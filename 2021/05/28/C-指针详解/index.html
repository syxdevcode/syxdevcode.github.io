<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一，常见指针&amp; 是取地址运算符，* 是间接运算符。 1，int p;整型变量，32位CPU的话，占有32个bite。 2，int *p;整型指针变量，用于存放一个整型变量的地址。 解析： 从 p 处开始，先与 * 结合，所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。 3，int p[3];整型数据组成的数组。 解析： 首先从 p 处开始，先">
<meta property="og:type" content="article">
<meta property="og:title" content="C-指针详解">
<meta property="og:url" content="https://syxdevcode.github.com/2021/05/28/C-%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:description" content="一，常见指针&amp; 是取地址运算符，* 是间接运算符。 1，int p;整型变量，32位CPU的话，占有32个bite。 2，int *p;整型指针变量，用于存放一个整型变量的地址。 解析： 从 p 处开始，先与 * 结合，所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。 3，int p[3];整型数据组成的数组。 解析： 首先从 p 处开始，先">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210528161733.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210528162431.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210528165552.png">
<meta property="article:published_time" content="2021-05-28T15:32:02.000Z">
<meta property="article:modified_time" content="2022-11-03T10:25:30.337Z">
<meta property="article:author" content="syxdevcode">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="VSCode">
<meta property="article:tag" content="MingGW64">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210528161733.png">

<link rel="canonical" href="https://syxdevcode.github.com/2021/05/28/C-%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C-指针详解 | syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/05/28/C-%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="syxdevcode的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C-指针详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-28 15:32:02" itemprop="dateCreated datePublished" datetime="2021-05-28T15:32:02+00:00">2021-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-03 10:25:30" itemprop="dateModified" datetime="2022-11-03T10:25:30+00:00">2022-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一，常见指针"><a href="#一，常见指针" class="headerlink" title="一，常见指针"></a>一，常见指针</h2><p><code>&amp;</code> 是取地址运算符，<code>*</code> 是间接运算符。</p>
<h3 id="1，int-p"><a href="#1，int-p" class="headerlink" title="1，int p;"></a>1，int p;</h3><p>整型变量，32位CPU的话，占有32个bite。</p>
<h3 id="2，int-p"><a href="#2，int-p" class="headerlink" title="2，int *p;"></a>2，int *p;</h3><p>整型指针变量，用于存放一个整型变量的地址。</p>
<p>解析：</p>
<p>从 p 处开始，先与 <code>*</code> 结合，所以说明 p 是一个指针, 然后再与 <code>int</code> 结合, 说明指针所指向的内容的类型为 <code>int</code> 型。</p>
<h3 id="3，int-p-3"><a href="#3，int-p-3" class="headerlink" title="3，int p[3];"></a>3，int p[3];</h3><p>整型数据组成的数组。</p>
<p>解析：</p>
<p>首先从 p 处开始，先与 <code>[]</code> 结合，说明 p 是一个数组, 然后与 <code>int</code> 结合, 说明数组里的元素是整型的, 所以 p 是一个由整型数据组成的数组。</p>
<h3 id="4，int-p-3"><a href="#4，int-p-3" class="headerlink" title="4，int *p[3];"></a>4，int *p[3];</h3><p>这是一个数组，该数组里面的成员是整型的指针，分别指向 <code>int</code> 型的内存。</p>
<p>解析：</p>
<p>首先从 p 处开始, 先与 <code>[]</code> 结合，因为其优先级比 <code>*</code> 高，所以 p 是一个数组, 然后再与 <code>*</code> 结合, 说明数组里的元素是指针类型, 然后再与 <code>int</code> 结合, 说明指针所指向的内容的类型是整型。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210528161733.png" alt="微信截图_20210528161733.png"></p>
<h3 id="5，int-p-3"><a href="#5，int-p-3" class="headerlink" title="5，int (*p)[3];"></a>5，int (*p)[3];</h3><p>这是一个指针，指向一个 <code>int</code> 型数组，地址类型是<code>int [3]</code>型。</p>
<p>解析：</p>
<p>首先从 p 处开始, 先与 <code>*</code> 结合,说明 p 是一个指针然后，再与 <code>[]</code> 结合(与 <code>()</code> 这步可以忽略,只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与 <code>int</code> 结合, 说明数组里的元素是整型的。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210528162431.png" alt="微信截图_20210528162431.png"></p>
<h3 id="6，int-p"><a href="#6，int-p" class="headerlink" title="6，int **p;"></a>6，int **p;</h3><p>这是一个整型指针变量，用于存放一个整型变量的地址，</p>
<p>解析：</p>
<p>首先从 p 开始, 先与 <code>*</code> 结合, 说是 p 是一个指针, 然后再与 <code>*</code> 结合, 说明指针所指向的元素是指针, 然后再与 <code>int</code> 结合, 说明该指针所指向的元素是整型数据。</p>
<h3 id="7，int-p-int"><a href="#7，int-p-int" class="headerlink" title="7，int p(int);"></a>7，int p(int);</h3><p>这是一个函数，函数的返回值是一个整型数据。</p>
<p>解析：</p>
<p>从 p 处起,先与 <code>()</code> 结合, 说明 p 是一个函数, 然后进入 <code>()</code> 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 <code>int</code> 结合, 说明函数的返回值是一个整型数据。</p>
<h3 id="8，void-p-int"><a href="#8，void-p-int" class="headerlink" title="8，void *p(int);"></a>8，void *p(int);</h3><p>这是一个函数，函数的参数是 <code>int</code>，返回值是 <code>void *</code>。</p>
<h3 id="9，int-p-int"><a href="#9，int-p-int" class="headerlink" title="9，int (*p)(int);"></a>9，int (*p)(int);</h3><p>这是一个指针，指向一个函数，该函数形参是 <code>int</code>，返回值是 <code>int</code>。</p>
<p>解析：</p>
<p>从 p 处开始, 先与指针结合, 说明 p 是一个指针, 然后与 <code>()</code> 结合, 说明指针指向的是一个函数, 然后再与 <code>()</code> 里的 <code>int</code> 结合, 说明函数有一个 <code>int</code> 型的参数, 再与最外层的 <code>int</code> 结合, 说明函数的返回类型是整型。</p>
<h3 id="10，int-p-3-int"><a href="#10，int-p-3-int" class="headerlink" title="10，int (*p[3])(int);"></a>10，int (*p[3])(int);</h3><p>解析：</p>
<ul>
<li>p 先和<code>[3]</code>结合，说明 p 是一个数组；</li>
<li><code>p[3]</code> 外面 <code>*</code> 结合，所以数组元素是一个指针；</li>
<li>假定 <code>（*p[3]）</code> 是 <code>X</code>,外面是 <code>int （X）（int）</code>，所以指针是指向函数，函数的形参是 <code>int</code> 型，返回值是 <code>int</code> 型。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210528165552.png" alt="微信截图_20210528165552.png"></p>
<h3 id="11，int-p-int-3"><a href="#11，int-p-int-3" class="headerlink" title="11，int *(*p(int))[3];"></a>11，<code>int *(*p(int))[3]</code>;</h3><p>解析：</p>
<p>从 p 开始，先与 <code>()</code> 结合, 说明 p 是一个函数, 然后进入 <code>()</code> 里面，与 <code>int</code> 结合, 说明函数有一个整型变量参数, 然后再与外面的 <code>*</code> 结合, 说明函数返回的是一个指针, 然后到最外面一层, 先与 <code>[]</code> 结合, 说明返回的指针指向的是一个数组, 然后再与 <code>*</code> 结合, 说明数组里的元素是指针, 然后再与 <code>int</code> 结合, 说明指针指向的内容是整型数据。</p>
<p>所以 p 是一个参数为一个整数，且返回一个指向由整型指针变量组成的数组的指针变量的函数。</p>
<span id="more"></span>
<h2 id="二，指针详解"><a href="#二，指针详解" class="headerlink" title="二，指针详解"></a>二，指针详解</h2><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。</p>
<p>要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。</p>
<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line"><span class="type">int</span> **ptr;</span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> *(*ptr)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h3 id="1，指针的类型"><a href="#1，指针的类型" class="headerlink" title="1，指针的类型"></a>1，指针的类型</h3><p><font color=#ff0000 size=4 face="黑体">从语法上看，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。</font>这是指针本身所具有的类型。</p>
<ul>
<li>1、<code>int *ptr;</code> : 指针的类型是 <code>int*</code></li>
<li>2、<code>char *ptr; </code>: 指针的类型是 <code>char*</code></li>
<li>3、<code>int **ptr;</code> : 指针的类型是 <code>int**</code></li>
<li>4、<code>int (*ptr)[3]; </code>: 指针的类型是 <code>int(*)[3]</code></li>
<li>5、<code>int *(*ptr)[4];</code> : 指针的类型是 <code>int*(*)[4]</code></li>
</ul>
<h3 id="2，指针所指向的类型"><a href="#2，指针所指向的类型" class="headerlink" title="2，指针所指向的类型"></a>2，指针所指向的类型</h3><p>通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p>
<p><font color=#ff0000 size=4 face="黑体">从语法上看，只须把指针声明语句中的 指针名字和名字左边的指针声明符 <code>*</code> 去掉，剩下的就是指针所指向的类型。</font></p>
<ul>
<li>1、<code>int*ptr;</code> : 指针所指向的类型是 <code>int</code></li>
<li>2、<code>char*ptr;</code> : 指针所指向的的类型是 <code>char</code></li>
<li>3、<code>int**ptr;</code> : 指针所指向的的类型是 <code>int*</code></li>
<li>4、<code>int(*ptr)[3];</code> : 指针所指向的的类型是 <code>int()[3]</code></li>
<li>5、<code>int*(*ptr)[4];</code> : 指针所指向的的类型是 <code>int*()[4]</code></li>
</ul>
<p>在指针的算术运算中，指针所指向的类型有很大的作用。</p>
<p>指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。</p>
<h3 id="3，指针的值—-或者叫指针所指向的内存区或地址"><a href="#3，指针的值—-或者叫指针所指向的内存区或地址" class="headerlink" title="3，指针的值—-或者叫指针所指向的内存区或地址"></a>3，指针的值—-或者叫指针所指向的内存区或地址</h3><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为32 位程序里内存地址全都是32位的长度。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 <code>sizeof(指针所指向的类型)</code> 的一片内存区。</p>
<p>一个指针的值是 <code>XX</code>，就相当于说该指针指向了以 <code>XX</code> 为首地址的一片内存区域；一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。</p>
<p>指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。</p>
<p>每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？（重点注意）</p>
<h3 id="4，指针本身所占据的内存区"><a href="#4，指针本身所占据的内存区" class="headerlink" title="4，指针本身所占据的内存区"></a>4，指针本身所占据的内存区</h3><p>指针本身占了多大的内存？只要用函数 <code>sizeof(指针的类型)</code> 测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。</p>
<h2 id="三，指针的算术运算"><a href="#三，指针的算术运算" class="headerlink" title="三，指针的算术运算"></a>三，指针的算术运算</h2><p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：</p>
<p><strong>实例1：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> *ptr=(<span class="type">int</span> *)a; <span class="comment">//强制类型转换并不会改变 a 的类型</span></span><br><span class="line">ptr++;</span><br></pre></td></tr></table></figure>

<p>解析：指针 <code>ptr</code> 的类型是 <code>int*</code>，它指向的类型是 <code>int</code>，它被初始化为指向整型变量 <code>a</code>。<br>接下来的第 3 句中，指针 <code>ptr</code> 被加了 1，编译器是这样处理的：它把指针 <code>ptr</code> 的值加上了 <code>sizeof(int)</code>，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。<br>由于地址是用字节做单位的，故 <code>ptr</code> 所指向的地址由原来的变量 <code>a</code> 的地址向高地址方向增加了 4 个字节。<br>由于 <code>char</code> 类型的长度是一个字节，所以，原来 <code>ptr</code> 是指向数组 <code>a</code> 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。</p>
<p><strong>实例2：</strong></p>
<p>将整型数组中各个单元的值加 1。由于每次循环都将指针 ptr 加 1 个单元，所以每次循环都能访问数组的下一个单元。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = (*ptr)++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p: %d\n&quot;</span>, (*ptr));</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实例2：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">20</span>]=<span class="string">&quot;You_are_a_girl&quot;</span>;</span><br><span class="line"><span class="type">int</span> *ptr=(<span class="type">int</span> *)a;</span><br><span class="line">ptr+=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><code>ptr</code> 被加上了 5，编译器是这样处理的：将指针 <code>ptr</code> 的值加上 5 乘 <code>sizeof(int)</code>，在 32 位程序中就是加上了 5 乘 <code>4=20</code>。由于地址的单位是字节，故现在的 <code>ptr</code> 所指向的地址比起加 5 后的 <code>ptr</code> 所指向的地址来说，向高地址方向移动了 <code>20</code> 个字节。</p>
<p>没加 5 前的 <code>ptr</code> 指向数组 a 的第 0 号单元开始的四个字节，加 5 后，<code>ptr</code> 已经指向了数组 a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。</p>
<p>如果 <code>ptr</code> 是被减去 5，那么处理过程大同小异，只不过 <code>ptr</code> 的值是被减去 5 乘 <code>sizeof(int)</code>，新的 <code>ptr</code> 指向的地址将比原来的 <code>ptr</code> 所指向的地址向低地址方向移动了 20 个字节。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个指针 <code>ptrold</code> 加(减)一个整数 <code>n</code> 后，结果是一个新的指针 <code>ptrnew</code>，<code>ptrnew</code> 的类型和 <code>ptrold</code> 的类型相同，<code>ptrnew</code> 所指向的类型和 <code>ptrold</code> 所指向的类型也相同。<code>ptrnew</code> 的值将比 <code>ptrold</code> 的值增加(减少)了 <code>n</code> 乘 <code>sizeof(ptrold 所指向的类型)</code> 个字节。就是说，<code>ptrnew</code> 所指向的内存区将比 <code>ptrold</code> 所指向的内存区向高(低)地址方向移动了 <code>n</code> 乘 <code>sizeof(ptrold所指向的类型)</code> 个字节。</p>
<p>指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组。</p>
<h2 id="四，指针表达式"><a href="#四，指针表达式" class="headerlink" title="四，指针表达式"></a>四，指针表达式</h2><p>一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *pa;</span><br><span class="line">pa=&amp;a; <span class="comment">//&amp;a 是一个指针表达式。</span></span><br><span class="line">Int **ptr=&amp;pa; <span class="comment">//&amp;pa 也是一个指针表达式。</span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr 和&amp;b 都是指针表达式。</span></span><br><span class="line">pa=<span class="built_in">array</span>;</span><br><span class="line">pa++; <span class="comment">//这也是指针表达式。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *arr[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> **parr=arr; <span class="comment">//如果把arr 看作指针的话，arr 也是指针表达式</span></span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line">str=*parr; <span class="comment">//*parr 是指针表达式</span></span><br><span class="line">str=*(parr+<span class="number">1</span>); <span class="comment">//*(parr+1)是指针表达式</span></span><br><span class="line">str=*(parr+<span class="number">2</span>); <span class="comment">//*(parr+2)是指针表达式</span></span><br></pre></td></tr></table></figure>

<p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p>
<p>当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在实例中，<code>&amp;a</code> 不是一个左值，因为它还没有占据明确的内存。<code>*ptr</code> 是一个左值，因为 <code>*ptr</code> 这个指针已经占据了内存，其实 <code>*ptr</code> 就是指针 <code>pa</code>，既然 <code>pa</code> 已经在内存中有了自己的位置，那么 <code>*ptr</code> 当然也有了自己的位置。</p>
<h2 id="五，数组和指针的关系"><a href="#五，数组和指针的关系" class="headerlink" title="五，数组和指针的关系"></a>五，数组和指针的关系</h2><p>数组的数组名其实可以看作一个指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,value;</span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">0</span>]; <span class="comment">//也可写成：value=*array;</span></span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">3</span>]; <span class="comment">//也可写成：value=*(array+3);</span></span><br><span class="line">value=<span class="built_in">array</span>[<span class="number">4</span>]; <span class="comment">//也可写成：value=*(array+4);</span></span><br></pre></td></tr></table></figure>

<p>一般而言数组名 <code>array</code> 代表数组本身，类型是 <code>int[10]</code>，但如果把 <code>array</code> 看做指针的话，它指向数组的第 0 个单元，类型是 <code>int *</code>，所指向的类型是数组单元的类型即 <code>int</code>。同理，<code>array+3</code> 是一个指向数组第 3 个单元的指针，所以 <code>*(array+3)</code> 等于 3。</p>
<p><strong>实例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str[<span class="number">3</span>]=&#123;</span><br><span class="line">    <span class="string">&quot;Hello,thisisasample!&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Hi,goodmorning.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Helloworld&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> s[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">0</span>]); <span class="comment">//也可写成strcpy(s,*str);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s=%s\n&quot;</span>, s);</span><br><span class="line"><span class="comment">// 输出 ：Hello,thisisasample!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">1</span>]); <span class="comment">//也可写成strcpy(s,*(str+1));</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s=%s\n&quot;</span>, s);</span><br><span class="line"><span class="comment">// 输出 ：Hi,goodmorning.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(s,str[<span class="number">2</span>]); <span class="comment">//也可写成strcpy(s,*(str+2));</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s=%s\n&quot;</span>, s);</span><br><span class="line"><span class="comment">// 输出 ：Helloworld</span></span><br></pre></td></tr></table></figure>

<p>C 库函数 <code>char *strcpy(char *dest, const char *src)</code> 把 <code>src</code> 所指向的字符串复制到 <code>dest</code>。<br>需要注意的是如果目标数组 <code>dest</code> 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。</p>
<p><code>str</code> 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 <code>str</code> 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 <code>char **</code>，它指向的类型是 <code>char *</code>。</p>
<p><code>*str</code> 也是一个指针，它的类型是 <code>char *</code>，它所指向的类型是 <code>char</code>，它指向的地址是字符串 <code>Hello,thisisasample!</code> 的第一个字符的地址，即 <code>H</code> 的地址。</p>
<p>注意:字符串相当于是一个数组, 在内存中以数组的形式储存, 只不过字符串是一个数组常量, 内容不可改变,且只能是右值，如果看成指针的话, 他即是常量指针, 也是指针常量。</p>
<p><code>str+1</code> 也是一个指针，它指向数组的第 1 号单元，它的类型是 <code>char**</code>，它指向的类型是 <code>char*</code>。<br><code>*(str+1)</code> 也是一个指针，它的类型是 <code>char*</code>，它所指向的类型是 <code>char</code>，它指向 <code>Hi,goodmorning.</code> 的第一个字符 <code>H</code>。</p>
<p><strong>数组</strong></p>
<p>声明了一个数组 <code>TYPE array[n]</code>，则数组名称 <code>array</code> 就有了两重含义：</p>
<ul>
<li>第一，它代表整个数组，它的类型是 <code>TYPE[n]</code>；</li>
<li>第二，它是一个常量指针，该指针的类型是 <code>TYPE*</code>，该指针指向的类型是 <code>TYPE</code>，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 <code>array++</code> 的表达式是错误的。</li>
</ul>
<p>在不同的表达式中数组名 <code>array</code> 可以扮演不同的角色。在表达式 <code>sizeof(array)</code> 中，数组名 <code>array</code> 代表数组本身，故这时 <code>sizeof</code> 函数测出的是整个数组的大小。</p>
<p>在表达式 <code>*array</code> 中，<code>array</code> 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。<code>sizeof(*array)</code> 测出的是数组单元的大小。</p>
<p>表达式 <code>array+n</code>（其中n=0，1，2，…..）中，<code>array</code> 扮演的是指针，故 <code>array+n</code> 的结果是一个指针，它的类型是 <code>TYPE *</code>，它指向的类型是 <code>TYPE</code>，它指向数组第 n 号单元。故 <code>sizeof(array+n)</code>测出的是指针类型的大小。在 32 位程序中结果是 4。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int array[10];</span><br><span class="line">int (*ptr)[10];</span><br><span class="line">ptr=&amp;array;：</span><br></pre></td></tr></table></figure>

<p><code>ptr</code> 是一个指针，它的类型是 <code>int(*)[10]</code>，他指向的类型是 <code>int[10]</code> ，我们用整个数组的首地址来初始化它。在语句 <code>ptr=&amp;array</code>中，<code>array</code> 代表数组本身。</p>
<p>函数 <code>sizeof(指针名称)</code> 测出的是指针自身类型的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*ptr)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>则在 32 位程序中，有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>(*)[<span class="number">10</span>])==<span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>[<span class="number">10</span>])==<span class="number">40</span></span><br><span class="line"><span class="keyword">sizeof</span>(ptr)==<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>实际上，<code>sizeof(对象)</code> 测出的都是对象自身的类型的大小，而不是别的什么类型的大小。</p>
<h2 id="六，指针和结构类型的关系"><a href="#六，指针和结构类型的关系" class="headerlink" title="六，指针和结构类型的关系"></a>六，指针和结构类型的关系</h2><p>实例：</p>
<p>声明一个指向结构类型对象的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">ss</span>=</span>&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> *<span class="title">ptr</span>=</span>&amp;ss;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明了一个指向结构对象ss 的指针。它的类型是</span></span><br><span class="line"><span class="comment">//MyStruct *,它指向的类型是MyStruct。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *pstr=(<span class="type">int</span>*)&amp;ss;</span><br><span class="line"><span class="comment">//声明了一个指向结构对象ss 的指针。但是pstr 和</span></span><br><span class="line"><span class="comment">//它被指向的类型ptr 是不同的。</span></span><br></pre></td></tr></table></figure>

<p>通过指针 <code>ptr</code> 来访问 <code>ss</code> 的三个成员变量：（推荐）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;a; <span class="comment">//指向运算符，或者 (*ptr).a ,建议使用前者</span></span><br><span class="line">ptr-&gt;b;</span><br><span class="line">ptr-&gt;c;</span><br></pre></td></tr></table></figure>

<p>通过指针 <code>pstr</code> 来访问 <code>ss</code> 的三个成员变量：（不推荐）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*pstr； <span class="comment">//访问了ss 的成员a。</span></span><br><span class="line">*(pstr+<span class="number">1</span>); <span class="comment">//访问了ss 的成员b。</span></span><br><span class="line">*(pstr+<span class="number">2</span>) <span class="comment">//访问了ss 的成员c。</span></span><br></pre></td></tr></table></figure>

<p><strong>使用pstr来访问结构成员是不正规的</strong></p>
<p>验证不正规</p>
<p>将结构体换成数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>]=&#123;<span class="number">35</span>,<span class="number">56</span>,<span class="number">37</span>&#125;;</span><br><span class="line"><span class="type">int</span> *pa=<span class="built_in">array</span>;</span><br><span class="line"><span class="comment">//通过指针pa 访问数组array 的三个单元的方法是：</span></span><br><span class="line">*pa; <span class="comment">//访问了第0 号单元</span></span><br><span class="line">*(pa+<span class="number">1</span>); <span class="comment">//访问了第1 号单元</span></span><br><span class="line">*(pa+<span class="number">2</span>); <span class="comment">//访问了第2 号单元</span></span><br></pre></td></tr></table></figure>

<p>所有的 <code>C/C++</code> 编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个 <code>填充字节</code>，这就导致各个成员之间可能会有若干个字节的空隙。</p>
<p>所以，即使 <code>*pstr</code> 访问到了结构对象 <code>ss</code> 的第一个成员变量 <code>a</code>，也不能保证 <code>*(pstr+1)</code> 就一定能访问到结构成员 <code>b</code>。因为成员 <code>a</code> 和成员 <code>b</code> 之间可能会有若干填充字节，可能 <code>*(pstr+1)</code> 就正好访问到了这些填充字节。</p>
<h2 id="七，指针和函数的关系"><a href="#七，指针和函数的关系" class="headerlink" title="七，指针和函数的关系"></a>七，指针和函数的关系</h2><p>可以把一个指针声明成为一个指向函数的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">char</span> *,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*pfun1)(<span class="type">char</span> *,<span class="type">int</span>);</span><br><span class="line">pfun1=fun1;</span><br><span class="line"><span class="type">int</span> a=(*pfun1)(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">7</span>); <span class="comment">//通过函数指针调用函数。</span></span><br></pre></td></tr></table></figure>

<p>可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line">inta;</span><br><span class="line"><span class="type">char</span> str[]=<span class="string">&quot;abcdefghijklmn&quot;</span>;</span><br><span class="line">a=fun(str);</span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;;)</span><br><span class="line">    &#123;</span><br><span class="line">        num+=*s;s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中的函数 <code>fun</code> 统计一个字符串中各个字符的 <code>ASCII</code> 码值之和。数组的名字也是一个指针。在函数调用中，当把 <code>str</code> 作为实参传递给形参 s 后，实际是把 <code>str</code> 的值传递给了 s，s 所指向的地址就和 <code>str</code> 所指向的地址一致，但是 <code>str</code> 和 s 各自占用各自的存储空间。在函数体内对 s 进行自加 1 运算，并不意味着同时对 <code>str</code> 进行了自加 1 运算。</p>
<h2 id="八，指针类型转换"><a href="#八，指针类型转换" class="headerlink" title="八，指针类型转换"></a>八，指针类型转换</h2><p>当初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f=<span class="number">12.3</span>;</span><br><span class="line"><span class="type">float</span> *fptr=&amp;f;</span><br><span class="line"><span class="type">int</span> *p;</span><br></pre></td></tr></table></figure>

<p><strong>指针p指向实数f</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line">p=(<span class="type">int</span>*)&amp;f;</span><br></pre></td></tr></table></figure>

<p>如果有一个指针 <code>p</code>，我们需要把它的类型和所指向的类型改为 <code>TYPE *TYPE</code>， 那么语法格式是：<code>(TYPE *)p</code></p>
<p>这样强制类型转换的结果是一个新指针，该新指针的类型是 <code>TYPE *</code>，它指向的类型是 <code>TYPE</code>，它指向的地址就是原指针指向的地址。 而原来的指针 <code>p</code> 的一切属性都没有被修改。（切记）</p>
<p>一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换:</p>
<p>函数 <code>fun</code> 的作用是把一个整数的四个字节的顺序来个颠倒:<br>注意这是一个 32 位程序，故 <code>int</code> 类型占了四个字节，<code>char</code> 类型占一个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">125</span>,b;</span><br><span class="line">fun((<span class="type">char</span>*)&amp;a);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span>*s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    c=*(s+<span class="number">3</span>);*(s+<span class="number">3</span>)=*(s+<span class="number">0</span>);*(s+<span class="number">0</span>)=c;</span><br><span class="line">    c=*(s+<span class="number">2</span>);*(s+<span class="number">2</span>)=*(s+<span class="number">1</span>);*(s+<span class="number">1</span>)=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数调用语句中，实参 <code>&amp;a</code> 的结果是一个指针，它的类型是 <code>int *</code>，它指向的类型是 <code>int</code>。形参这个指针的类型是 <code>char *</code>，它指向的类型是 <code>char</code>。这样，在实参和形参的结合过程中，必须进行一次从 <code>int *</code> 类型到 <code>char *</code> 类型的转换。</p>
<p>想象编译器进行转换的过程：编译器先构造一个临时指针 <code>char *temp</code>，然后执行 <code>temp=(char *)&amp;a</code>，最后再把 <code>temp</code> 的值传递给 s。所以最后的结果是：<code>s</code> 的类型是 <code>char *</code>,它指向的类型是 <code>char</code>，它指向的地址就是 <code>a</code> 的首地址。</p>
<h3 id="把一个整数当作指针的值直接赋给指针"><a href="#把一个整数当作指针的值直接赋给指针" class="headerlink" title="把一个整数当作指针的值直接赋给指针"></a>把一个整数当作指针的值直接赋给指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;</span><br><span class="line">TYPE *ptr; <span class="comment">//TYPE 是int，char 或结构类型等等类型。</span></span><br><span class="line">a=N <span class="comment">//N 必须代表一个合法的地址；</span></span><br><span class="line">ptr=(TYPE*)a;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, *p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure>

<p>在以上代码输出a的地址值之后，譬如：6422044<br>以上程序可以改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>,*p;</span><br><span class="line">p = (<span class="type">int</span> *)<span class="number">6422044</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>

<p>严格说来这里的 (<code>TYPE *</code>) 和指针类型转换中的 (<code>TYPE *</code>) 还不一样。这里的 (<code>TYPE *</code>) 的意思是把无符号整数 a 的值当作一个地址来看待。必须强调 a 的值必须代表一个合法的地址，否则的话，在你使用 <code>ptr</code> 的时候，就会出现非法操作错误。</p>
<p>想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">123</span>, b;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ptr:%d\n&quot;</span>, ptr);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line">b = (<span class="type">int</span>)ptr; <span class="comment">//把指针ptr 的值当作一个整数取出来。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b:%d\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">str = (<span class="type">char</span> *)b; <span class="comment">//把这个整数的值当作一个地址赋给指针str。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str:%d\n&quot;</span>, str);</span><br></pre></td></tr></table></figure>

<h2 id="九，指针的安全问题"><a href="#九，指针的安全问题" class="headerlink" title="九，指针的安全问题"></a>九，指针的安全问题</h2><p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line">ptr=(<span class="type">int</span> *)&amp;s;</span><br><span class="line">*ptr=<span class="number">1298</span>;</span><br></pre></td></tr></table></figure>

<p>指针 <code>ptr</code> 是一个 <code>int *</code> 类型的指针，它指向的类型是 <code>int</code>。它指向的地址就是 <code>s</code> 的首地址。在 32 位程序中，<code>s</code> 占一个字节，<code>int</code> 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 <code>s</code> 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。</p>
<p>再来看一例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="type">int</span> *ptr=&amp;a;</span><br><span class="line">ptr++;</span><br><span class="line">*ptr=<span class="number">115</span>;</span><br></pre></td></tr></table></figure>

<p>该例子完全可以通过编译，并能执行。但是，第 3 句对指针 <code>ptr</code> 进行自加1 运算后，<code>ptr</code> 指向了和整形变量 <code>a</code> 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。</p>
<p>而第 4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。</p>
<p>在指针的强制类型转换：<code>ptr1=(TYPE *)ptr2</code> 中，如果 <code>sizeof(ptr2的类型)</code> 大于 <code>sizeof(ptr1的类型)</code>，那么在使用指针 <code>ptr1</code> 来访问 <code>ptr2</code> 所指向的存储区时是安全的。如果 <code>sizeof(ptr2的类型)</code> 小于 <code>sizeof(ptr1 的类型)</code>，那么在使用指针 <code>ptr1</code> 来访问 <code>ptr2</code> 所指向的存储区时是不安全的。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/c-pointer-detail.html">C 指针详解</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"><i class="fa fa-tag"></i> C语言</a>
              <a href="/tags/VSCode/" rel="tag"><i class="fa fa-tag"></i> VSCode</a>
              <a href="/tags/MingGW64/" rel="tag"><i class="fa fa-tag"></i> MingGW64</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/27/C-%E6%8C%87%E9%92%88/" rel="prev" title="C-指针">
      <i class="fa fa-chevron-left"></i> C-指针
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/02/C-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" rel="next" title="C-函数指针与回调函数">
      C-函数指针与回调函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%EF%BC%8C%E5%B8%B8%E8%A7%81%E6%8C%87%E9%92%88"><span class="nav-number">1.</span> <span class="nav-text">一，常见指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%8Cint-p"><span class="nav-number">1.1.</span> <span class="nav-text">1，int p;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8Cint-p"><span class="nav-number">1.2.</span> <span class="nav-text">2，int *p;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%8Cint-p-3"><span class="nav-number">1.3.</span> <span class="nav-text">3，int p[3];</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%8Cint-p-3"><span class="nav-number">1.4.</span> <span class="nav-text">4，int *p[3];</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%8Cint-p-3"><span class="nav-number">1.5.</span> <span class="nav-text">5，int (*p)[3];</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%8Cint-p"><span class="nav-number">1.6.</span> <span class="nav-text">6，int **p;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%EF%BC%8Cint-p-int"><span class="nav-number">1.7.</span> <span class="nav-text">7，int p(int);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%EF%BC%8Cvoid-p-int"><span class="nav-number">1.8.</span> <span class="nav-text">8，void *p(int);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%EF%BC%8Cint-p-int"><span class="nav-number">1.9.</span> <span class="nav-text">9，int (*p)(int);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%EF%BC%8Cint-p-3-int"><span class="nav-number">1.10.</span> <span class="nav-text">10，int (*p[3])(int);</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%EF%BC%8Cint-p-int-3"><span class="nav-number">1.11.</span> <span class="nav-text">11，int *(*p(int))[3];</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%EF%BC%8C%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">二，指针详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.</span> <span class="nav-text">1，指针的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8C%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">2，指针所指向的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%80%BC%E2%80%94-%E6%88%96%E8%80%85%E5%8F%AB%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E6%88%96%E5%9C%B0%E5%9D%80"><span class="nav-number">2.3.</span> <span class="nav-text">3，指针的值—-或者叫指针所指向的内存区或地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%8C%E6%8C%87%E9%92%88%E6%9C%AC%E8%BA%AB%E6%89%80%E5%8D%A0%E6%8D%AE%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-number">2.4.</span> <span class="nav-text">4，指针本身所占据的内存区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%EF%BC%8C%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="nav-number">3.</span> <span class="nav-text">三，指针的算术运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%EF%BC%8C%E6%8C%87%E9%92%88%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">四，指针表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%EF%BC%8C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.</span> <span class="nav-text">五，数组和指针的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%EF%BC%8C%E6%8C%87%E9%92%88%E5%92%8C%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.</span> <span class="nav-text">六，指针和结构类型的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83%EF%BC%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.</span> <span class="nav-text">七，指针和函数的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%EF%BC%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.</span> <span class="nav-text">八，指针类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%BD%93%E4%BD%9C%E6%8C%87%E9%92%88%E7%9A%84%E5%80%BC%E7%9B%B4%E6%8E%A5%E8%B5%8B%E7%BB%99%E6%8C%87%E9%92%88"><span class="nav-number">8.1.</span> <span class="nav-text">把一个整数当作指针的值直接赋给指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%EF%BC%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">九，指针的安全问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="syxdevcode"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description">syxdevcode的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">584</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">144</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">218</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">28:15</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
