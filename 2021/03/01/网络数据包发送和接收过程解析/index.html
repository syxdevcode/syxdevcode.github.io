<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机网络体系结构分层 数据包名称简介 包：可以说是全能性术语； 帧：用于表示数据链路层中包的单位； 数据包：是 IP 和 UDP 等网络层以上的分层中包的单位； 段：则表示 TCP 数据流中的信息； 消息：是指应用协议中数据的单位。  &amp;emsp;&amp;emsp;每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包">
<meta property="og:type" content="article">
<meta property="og:title" content="网络数据包发送和接收过程解析">
<meta property="og:url" content="https://syxdevcode.github.com/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:description" content="计算机网络体系结构分层 数据包名称简介 包：可以说是全能性术语； 帧：用于表示数据链路层中包的单位； 数据包：是 IP 和 UDP 等网络层以上的分层中包的单位； 段：则表示 TCP 数据流中的信息； 消息：是指应用协议中数据的单位。  &amp;emsp;&amp;emsp;每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://syxdevcode.github.com/img/651016-20190403213253371-112748496.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/651016-20190403213115559-1163198356.jpg">
<meta property="og:image" content="https://syxdevcode.github.com/img/1c7ddca5e0e0415c8b4c69047e680fc7.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090819.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/3f35fe4b91bb4a27b4ab30f84639d32a.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/65b24665096545c089a7a18300218c6d.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/3148139034514574a74a055e2a35b6fd.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/3e49dad546ba48eca6777783a8456a97.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/4c5ab6ed942c431bbed30009959783c0.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/8c6eab31573940a5bc369ea648d45591.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/0f015679fbef46deb30d6669d5e28ddf.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/f665dba5def44bb8a9ae13848602442c.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/1a1667fade0340998a1879a9f06d8511.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090750.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/902f8a4e03a242ecb6e16e3f718371e6.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090934.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091419.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091204.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091531.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091724.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091808.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091932.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092058.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092208.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092307.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093819.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093945.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/71e3a03024f04d32954f591d6e1edb43.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/bb3cd3458dc94871a4a68f3fdd4897eb.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/050f0e2d38554dd89fdc4427226cc688.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330094830.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095148.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095237.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095312.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095612.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095637.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101202.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101335.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101457.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101607.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101639.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102027.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102240.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102302.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/97e1e1332e5445c5b3da354f7cf407f9.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102721.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104125.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104310.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104705.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104813.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104927.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/be1bff3dd05c4f999c7836ca26598c7d.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/478cf4cd8c2b43339b80d7b667a6520a.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/d9e6580e7ce245aa9116004055f69b8b.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/8efd0df062b049978546f10dc3895af5.jpeg">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105123.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105217.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105326.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105401.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105435.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105523.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105548.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105612.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105634.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105656.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105715.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105737.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110049.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110618.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110640.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110700.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110752.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/e11421fc61d14423adab54661884f497.jpeg">
<meta property="article:published_time" content="2021-03-01T10:34:08.000Z">
<meta property="article:modified_time" content="2021-03-30T09:16:26.064Z">
<meta property="article:author" content="syxdevcode">
<meta property="article:tag" content="计算机基础">
<meta property="article:tag" content="TCP协议">
<meta property="article:tag" content="网络基础">
<meta property="article:tag" content="子网掩码">
<meta property="article:tag" content="IP网络">
<meta property="article:tag" content="Ethernet">
<meta property="article:tag" content="广播地址">
<meta property="article:tag" content="ARP">
<meta property="article:tag" content="ICMP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://syxdevcode.github.com/img/651016-20190403213253371-112748496.png">

<link rel="canonical" href="https://syxdevcode.github.com/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>网络数据包发送和接收过程解析 | syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网络数据包发送和接收过程解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 10:34:08" itemprop="dateCreated datePublished" datetime="2021-03-01T10:34:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-30 09:16:26" itemprop="dateModified" datetime="2021-03-30T09:16:26+00:00">2021-03-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h2><p><img src="/img/651016-20190403213253371-112748496.png" alt="651016-20190403213253371-112748496.png"></p>
<h2 id="数据包名称简介"><a href="#数据包名称简介" class="headerlink" title="数据包名称简介"></a>数据包名称简介</h2><ul>
<li>包：可以说是全能性术语；</li>
<li>帧：用于表示数据链路层中包的单位；</li>
<li>数据包：是 IP 和 UDP 等网络层以上的分层中包的单位；</li>
<li>段：则表示 TCP 数据流中的信息；</li>
<li>消息：是指应用协议中数据的单位。</li>
</ul>
<p>&emsp;&emsp;每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="/img/651016-20190403213115559-1163198356.jpg" alt="651016-20190403213115559-1163198356.jpg"></p>
<h2 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h2><p>用户 a 向用户 b 发送邮件为例子：</p>
<p><img src="/img/1c7ddca5e0e0415c8b4c69047e680fc7.jpeg" alt="1c7ddca5e0e0415c8b4c69047e680fc7.jpeg"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090819.png" alt="微信截图_20210330090819.png"></p>
<p><strong>1，应用程序处理</strong></p>
<p>&emsp;&emsp;首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>
<p><strong>2，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>
<p><strong>3，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>
<p><strong>4，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<p><strong>5，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>
<p><strong>6，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>
<p><strong>7，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<p><strong>8，应用程序的处理</strong></p>
<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
<h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>
<p><strong>(1) TCP</strong> 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p>
<p><strong>(2) UDP</strong> 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
<p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>&emsp;&emsp;数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>
<p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p><img src="/img/3f35fe4b91bb4a27b4ab30f84639d32a.jpeg" alt="3f35fe4b91bb4a27b4ab30f84639d32a.jpeg"><br><img src="/img/65b24665096545c089a7a18300218c6d.jpeg" alt="65b24665096545c089a7a18300218c6d.jpeg"></p>
<ul>
<li>(1) 和 (2) 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</li>
<li>(3) 和 (1) 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li>
<li>当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li>
</ul>
<h4 id="端口号的确定"><a href="#端口号的确定" class="headerlink" title="端口号的确定"></a>端口号的确定</h4><ul>
<li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 <code>0~1023</code> 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 <code>1024~49151</code> 之间，不过这些端口号可用于任何通信用途。</li>
<li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 <code>49152~65535</code> 之间。</li>
</ul>
<h4 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h4><p>&emsp;&emsp;端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li>
<li>UDP 将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>
<li>传输途中出现丢包，UDP 也不负责重发。</li>
<li>当包的到达顺序出现乱序时也没有纠正的功能。</li>
<li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li>
</ul>
<p>UDP 常用于一下几个方面：</p>
<ul>
<li>1.包总量较少的通信（DNS、SNMP等）；</li>
<li>2.视频、音频等多媒体通信（即时通信）；</li>
<li>3.限定于 LAN 等特定网络中的应用通信；</li>
<li>4.广播通信（广播、多播）。</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>&emsp;&emsp;TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
<p>&emsp;&emsp;根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>&emsp;&emsp;TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。三次握手是指建立一个 TCP 连接时,需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p>
<p><img src="/img/3148139034514574a74a055e2a35b6fd.jpeg" alt="3148139034514574a74a055e2a35b6fd.jpeg"></p>
<ul>
<li><strong>第一次握手</strong>：客户端将标志位 <code>SYN</code> 置为1，随机产生一个值 <code>seq=J</code>，并将该数据包发送给服务器端，客户端进入 <code>SYN_SENT</code> 状态，等待服务器端确认。</li>
<li><strong>第二次握手</strong>：服务器端收到数据包后由标志位 <code>SYN=1</code>,知道客户端请求建立连接，服务器端将标志位 <code>SYN</code> 和 <code>ACK</code> 都置为1，<code>ack=J+1</code>，随机产生一个值 <code>seq=K</code> ，并将该数据包发送给客户端以确认连接请求，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
<li><strong>第三次握手</strong>：客户端收到确认后，检查 <code>ack</code> 是否为 <code>J+1</code>，<code>ACK</code> 是否为1，如果正确,则将标志位 <code>ACK</code>置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查 <code>ack</code> 是否为 <code>K+1</code>， <code>ACK</code> 是否为1，如果正确则连接建立成功，客户端和服务器端进入 <code>ESTABLISHED</code> 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>&emsp;&emsp;四次挥手即终止 TCP 连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在 <code>socket</code> 编程中，这一过程由 客户端 或 服务端 任一方执行 <code>close</code> 来触发。</p>
<p>&emsp;&emsp;由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 <code>FIN</code> 来终止这一方向的连接，收到一个 <code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了 <code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><img src="/img/3e49dad546ba48eca6777783a8456a97.jpeg" alt="3e49dad546ba48eca6777783a8456a97.jpeg"></p>
<p>中断连接端可以是客户端，也可以是服务器端。</p>
<ul>
<li><strong>第一次挥手</strong>：客户端发送一个 <code>FIN=M</code>，用来关闭客户端到服务器端的数据传送，客户端进入 <code>FIN_WAIT_1</code> 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li><strong>第二次挥手</strong>：服务器端收到 <code>FIN</code> 后，先发送 <code>ack=M+1</code>，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 <code>FIN_WAIT_2</code> 状态，继续等待服务器端的 <code>FIN</code> 报文。</li>
<li><em>第三次挥手*</em>：当服务器端确定数据已发送完成，则向客户端发送 <code>FIN=N</code> 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 <code>LAST_ACK</code> 状态。</li>
<li><em>第四次挥手*</em>：客户端收到 <code>FIN=N</code> 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 <code>ack=N+1</code> 后进入 <code>TIME_WAIT</code> 状态，如果 <code>Server</code> 端没有收到 <code>ACK</code> 则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了 <code>2MSL</code> 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，</p>
<p><img src="/img/4c5ab6ed942c431bbed30009959783c0.jpeg" alt="4c5ab6ed942c431bbed30009959783c0.jpeg"></p>
<h4 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h4><p>&emsp;&emsp;在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。 反之，则数据丢失的可能性很大。</p>
<p>&emsp;&emsp;在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>
<p>&emsp;&emsp;未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>
<p>&emsp;&emsp;此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>
<p>&emsp;&emsp;对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此引入了序列号。</p>
<p>&emsp;&emsp;序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p>
<h4 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h4><p>&emsp;&emsp;重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证 “确认应答一定能在这个时间内返回”。</p>
<p>&emsp;&emsp;TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</p>
<p>&emsp;&emsp;在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>
<p>&emsp;&emsp;此外， 数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>
<h4 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h4><p>&emsp;&emsp;在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，<font color=#ff0000 size=4 face="黑体">最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</font></p>
<p>&emsp;&emsp;TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</p>
<p>&emsp;&emsp;MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</p>
<h4 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h4><p>&emsp;&emsp;TCP 以 1 个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长,通信性能就越低。</p>
<p>&emsp;&emsp;为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p>
<p><img src="/img/8c6eab31573940a5bc369ea648d45591.jpeg" alt="8c6eab31573940a5bc369ea648d45591.jpeg"></p>
<p>&emsp;&emsp;窗口大小就是指：无需等待确认应答，而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段，同时进行确认应答的功能。</p>
<h4 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h4><p><img src="/img/0f015679fbef46deb30d6669d5e28ddf.jpeg" alt="0f015679fbef46deb30d6669d5e28ddf.jpeg"></p>
<p>&emsp;&emsp;上图中的窗口内的数据，即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>
<p>&emsp;&emsp;在滑动窗口以外的部分，包括未发送的数据，以及已经确认对端已收到的数据。当数据发出后，若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>
<p>&emsp;&emsp;收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为 <code>滑动窗口控制</code>。</p>
<h4 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h4><p>&emsp;&emsp;在使用窗口控制中， 出现丢包一般分为两种情况：</p>
<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>
<p><img src="/img/f665dba5def44bb8a9ae13848602442c.jpeg" alt="f665dba5def44bb8a9ae13848602442c.jpeg"></p>
<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为 <code>高速重发控制</code>。</p>
<p><img src="/img/1a1667fade0340998a1879a9f06d8511.jpeg" alt="1a1667fade0340998a1879a9f06d8511.jpeg"></p>
<h2 id="网络层中的-IP-协议"><a href="#网络层中的-IP-协议" class="headerlink" title="网络层中的 IP 协议"></a>网络层中的 IP 协议</h2><p>&emsp;&emsp;IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是 “实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点通信”。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090750.png" alt="微信截图_20210330090750.png"></p>
<ul>
<li>主机：配置有 IP 地址，不进行路由控制的设备。</li>
<li>路由器：既有 IP 地址又具有路由控制功能的设备。</li>
<li>节点：主机和路由器的统称。</li>
</ul>
<p>&emsp;&emsp;网络的下一层—数据链路层 的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上，也能实现两端节点之间的数据包传输。</p>
<p>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）、IP 分包与组包。</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>&emsp;&emsp;在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</p>
<p>&emsp;&emsp;作为网络层的 IP,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在 “连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</p>
<p>&emsp;&emsp;不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</p>
<p>&emsp;&emsp;IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</p>
<p><img src="/img/902f8a4e03a242ecb6e16e3f718371e6.jpeg" alt="902f8a4e03a242ecb6e16e3f718371e6.jpeg"></p>
<p>将 IP 地址的32位二进制进行计算，得出约 43 亿个 IP 地址。</p>
<p>实际上，网络的发展超乎想象，互联网上的设备远超 43 亿， 2019 年 11 月 25 日全球的 IPv4 地址已经彻底耗尽，但是直到现在大家仍然还在用 IPv4 ，并没有因为地址没了而无法上网。是因为除了 IPv6 之外，我们使用 NAT 技术缓解了地址不足的问题。</p>
<h4 id="IP-地址组成"><a href="#IP-地址组成" class="headerlink" title="IP 地址组成"></a>IP 地址组成</h4><p>IP 地址由网络号（网段地址）和主机号（主机地址）两部分组成。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090934.png" alt="微信截图_20210330090934.png"></p>
<p><strong>IP地址的主机标识</strong></p>
<p>&emsp;&emsp;如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的 “主机标识” 则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠，即 IP 地址具有了唯一性。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091419.png" alt="微信截图_20210330091419.png"></p>
<p><strong>IP地址的网络标识</strong></p>
<p>&emsp;&emsp;如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091204.png" alt="微信截图_20210330091204.png"></p>
<h4 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h4><p>&emsp;&emsp;IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091531.png" alt="微信截图_20210330091531.png"></p>
<ul>
<li>A 类 IP 地址是首位以 <code>0</code> 开头的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 8 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>0.0.0.0~127.0.0.0</code> 是 A 类的网络地址。<font color=#ff0000 size=4 face="黑体">A 类地址的后 24 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为 <code>16,777,214</code>(2的24次方-2) 个。其中 0 和 127 属于保留地址，减去两个保留地址，因此有 126 个可用的 A 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091724.png" alt="微信截图_20210330091724.png"><br><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091808.png" alt="微信截图_20210330091808.png"></p>
<ul>
<li>B 类 IP 地址是前两位 <code>10</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 16 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>128.0.0.0~191.255.0.0</code> 是 B 类的网络地址。<font color=#ff0000 size=4 face="黑体">B 类地址的后 16 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为<code>65,534</code> (2的16次方-2)个。其中 <code>128.0</code> 和 <code>191.255</code> 属于保留地址，减去两个保留地址，因此有 16382 个可用的 B 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091932.png" alt="微信截图_20210330091932.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092058.png" alt="微信截图_20210330092058.png"></p>
<ul>
<li>C 类 IP 地址是前三位为 <code>110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 24 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>192.0.0.0~223.255.255.0</code> 是 C 类的网络地址。<font color=#ff0000 size=4 face="黑体">C 类地址的后 8 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为 <code>254</code> (2的8次方-2)个。其中 <code>192.0.0</code> 和 <code>223.255.255</code> 属于保留地址，减去两个保留地址，因此有 <code>2097150</code> 个可用的 C 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092208.png" alt="微信截图_20210330092208.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092307.png" alt="微信截图_20210330092307.png"></p>
<ul>
<li>D 类 IP 地址是前四位为 <code>1110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 32 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>224.0.0.0~239.255.255.255</code> 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li>
</ul>
<p><code>127.x.x.x</code> 段地址空间是被保留的回环地址。</p>
<p>&emsp;&emsp;在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 2的8次方- 2 = 254）个主机地址的原因。</p>
<h4 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h4><p>&emsp;&emsp;广播地址(<code>Broadcast Address</code>) 是专门用于同时向网络中所有工作站进行发送的一个地址。在使用 <code>TCP/IP</code> 协议的网络中，主机标识段 <code>host ID</code>为全1 (11111111，即十进制的255) 的IP 地址为广播地址，广播的分组传送给<code>host ID</code>段所涉及的所有计算机。例如，对于 <code>10.1.1.0</code> （255.0.0.0 ）网段，其直播广播地址为 <code>10.255.255.255</code> （255 即为 2 进制的11111111），当发出一个目的地址为 <code>10.255.255.255</code> 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<p>广播地址应用于网络内的所有主机,广播分为受限广播(本地广播)和直接广播两种。在本网络内的广播叫做受限广播(本地广播)；在不同网络之间的广播叫做直接广播。</p>
<ul>
<li>（1）受限广播(本地广播)<br>它不被路由发送，但会被送到相同物理网络段上的所有主机<br>IP地址的网络字段和主机字段全为1就是地址 <code>255.255.255.255</code></li>
<li>（2）直接广播<br>网络广播会被路由，并会发送到专门网络上的每台主机<br>IP地址的网络字段定义这个网络，主机字段通常全为1，如 <code>192.168.10.255</code></li>
</ul>
<h5 id="受限地址"><a href="#受限地址" class="headerlink" title="受限地址"></a>受限地址</h5><p>&emsp;&emsp;受限的广播地址是 <code>255.255.255.255</code>。该地址用于主机配置过程中IP数据包的目的地址，此时，主机可能还不知道它所在网络的网络掩码，甚至连它的IP地址也不知道。在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出本地网络中。</p>
<h5 id="指向网络"><a href="#指向网络" class="headerlink" title="指向网络"></a>指向网络</h5><p>&emsp;&emsp;指向网络的广播地址是主机号为全1(11111111)的地址。A类网络广播地址为 netid.255.255.255，其中netid为A类网络的网络号。一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p>
<h5 id="指向子网"><a href="#指向子网" class="headerlink" title="指向子网"></a>指向子网</h5><p>&emsp;&emsp;指向子网的广播地址为主机号为全1(11111111)且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。例如，如果路由器收到发往 <code>128.1.2.255</code> 的数据报，当B类网络 <code>128.1</code> 的子网掩码为 <code>255.255.255.0</code>时，该地址就是指向子网的广播地址；但如果该子网的掩码为 <code>255.255.254.0</code>，该地址就不是指向子网的广播地址。</p>
<h5 id="指向所有子网"><a href="#指向所有子网" class="headerlink" title="指向所有子网"></a>指向所有子网</h5><p>&emsp;&emsp;指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。指向所有子网的广播地址的子网号及主机号为全1。例如，如果目的子网掩码为 <code>255.255.255.0</code> ，那么IP地址 <code>128.1.255.255</code> 是一个指向所有子网的广播地址。然而，如果网络没有划分子网，这就是一个指向网络的广播。</p>
<h4 id="IP多播-组播"><a href="#IP多播-组播" class="headerlink" title="IP多播(组播)"></a>IP多播(组播)</h4><p>&emsp;&emsp;<code>IP多播</code>（也称 <code>多址广播</code> 或 <code>组播</code>）技术，是一种允许一台或多台主机（多播源）发送单一数据包到多台主机（一次的，同时的）的TCP/IP网络技术。多播作为一点对多点的通信，是节省网络带宽的有效方法之一。在网络音频/视频广播的应用中，当需要将一个节点的信号传送到多个节点时，无论是采用重复点对点通信方式，还是采用广播方式，都会严重浪费网络带宽，只有多播才是最好的选择。多播能使一个或多个多播源只把数据包发送给特定的多播组，而只有加入该多播组的主机才能接收到数据包。目前，IP多播技术被广泛应用在 网络音频/视频广播、AOD/VOD、网络视频会议、多媒体远程教育、”push”技术（如股票行情等）和虚拟现实游戏等方面。</p>
<p>&emsp;&emsp;有些应用会有这样的要求：一些分布在各处的进程需要以组的方式协同工作，组中的进程通常要给其他所有的成员发送消息。即有这样的一种方法能够给一些明确定义的组发送消息，这些组的成员数量虽然很多，但是与整个网络规模相比却很小。给这样一个组发送消息称为多点点播送，简称多播。需要注意的是多播数据包的目的ip地址实际上不可能对应某一台真实存在的主机的ip地址，也就是说该目的ip地址永远不可能作为源地址，即多播ip地址只能用于目的ip地址，不能用于源ip地址。</p>
<p>组播使用 D 类地址。因此 IP 地址前四位是 “1110” 开头的，就是组播地址。剩下的 28 位就是组播的组编号。组播的地址范围是 <code>224.0.0.0 ~ 239.255.255.255</code> ，其中 <code>224.0.0.0 ~ 224.0.0.255</code> 既可以在同一个网段内实现组播，又可以跨网段给全网所有组员发送组播包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093819.png" alt="微信截图_20210330093819.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093945.png" alt="微信截图_20210330093945.png"></p>
<h5 id="1．多播地址和多播组"><a href="#1．多播地址和多播组" class="headerlink" title="1．多播地址和多播组"></a>1．多播地址和多播组</h5><p>&emsp;&emsp;IP多播通信必须依赖于IP多播地址，在 IPv4 中它是一个D类IP地址，并且ip首部中的协议字段为2，表明采用的是IGMP网际组管理协议。范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类。因此，如果从首位开始到第 4 位是 <code>1110</code> ，就可以认为是多播地址，而剩下的 28 位可以成为多播的组编号。所有的主机（路由器以外的主机和终端主机）必须属于 <code>224.0.0.1</code> 的组，所有的路由器必须属于 <code>224.0.0.2</code> 的组。</p>
<ul>
<li>局部链接多播地址范围在 <code>224.0.0.0~224.0.0.255</code>，这是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包；</li>
<li>预留多播地址为 <code>224.0.1.0~238.255.255.255</code>，可用于全球范围（如Internet）或网络协议；</li>
<li>管理权限多播地址为 <code>239.0.0.0~239.255.255.255</code>，可供组织内部使用，类似于私有IP地址，不能用于 Internet，可限制多播范围。</li>
</ul>
<p>&emsp;&emsp;使用同一个IP多播地址接收多播数据包的所有主机构成了一个主机组，也称为多播组。一个多播组的成员是随时变动的，一台主机可以随时加入或离开多播组，多播组成员的数目和所在的地理位置也不受限制，一台主机也可以属于几个多播组。此外，不属于某一个多播组的主机也可以向该多播组发送数据包。</p>
<h5 id="2-多播技术硬件支持"><a href="#2-多播技术硬件支持" class="headerlink" title="2. 多播技术硬件支持"></a>2. 多播技术硬件支持</h5><p>要实现IP多播通信，要求介于多播源和接收者之间的路由器、集线器、交换机以及主机均需支持IP多播。目前，IP多播技术已得到硬件、软件厂商的广泛支持。</p>
<ul>
<li>（1）主机<br>支持IP多播通信的平台包括 Windows CE 2.1、Windows 95、Windows 98、Windows NT 4 和 Windows 2000 等，运行这些操作系统的主机都可以进行IP多播通信。此外，新生产的网卡也几乎都提供了对IP多播的支持。</li>
<li>（2）集线器和交换机<br>目前大多数集线器、交换机只是简单地把多播数据当成广播来发送接收，但一些中、高档交换机提供了对IP多播的支持。例如，在 3COM SuperStack 3 Swith 3300 交换机上可启用 802.1p 或 IGMP 多播过滤功能，只为已侦测到IGMP 数据包的端口转发多播数据包。</li>
<li>（3）路由器<br>多播通信要求多播源节点和目的节点之间的所有路由器必须提供对 Internet组管理协议（IGMP）、多播路由协议（如PIM、DVMRP等）的支持。</li>
</ul>
<p>&emsp;&emsp;多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p>
<p><img src="/img/71e3a03024f04d32954f591d6e1edb43.jpeg" alt="71e3a03024f04d32954f591d6e1edb43.jpeg"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>&emsp;&emsp;子网掩码是在IPv4地址资源紧缺的背景下为了解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面。如果是都是使用的IPV6的话是没有子网掩码的概念。IPV6是端到端的连接通信，不需要子网了。</p>
<p>&emsp;&emsp;子网掩码用 32 位的二进制表示， IP 地址的网段地址部分设置为 1 ， IP 地址的主机地址部分设置为 0 。换句话说， IP 地址有多少位网段地址，子网掩码就有多少位取 1 ，其余都取 0 。为了方便记录，每 8 位为一组，以 <code>.</code> 隔开，再转换为十进制数。</p>
<p>将子网掩码和 IP 地址进行与（ AND ）运算，可得到这个 IP 地址的网段地址。</p>
<p>详情参考：<a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" title="IP4-子网掩码">IP4-子网掩码</a></p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">特征</th>
<th align="left">网络范围</th>
<th align="left">默认掩码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类地址</td>
<td align="left">第1个8位中的第1位始终为0</td>
<td align="left">0-127.x.x.x</td>
<td align="left">255.0.0.0/8</td>
</tr>
<tr>
<td align="left">B类地址</td>
<td align="left">第1个8位中的第1、2位始终为10</td>
<td align="left">128-191.x.x.x</td>
<td align="left">255.255.0.0/16</td>
</tr>
<tr>
<td align="left">C类地址</td>
<td align="left">第1个8位中的第1、2、3位始终为110</td>
<td align="left">192-y.x.x.x</td>
<td align="left">255.255.255.0/24</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</p>
<p><img src="/img/bb3cd3458dc94871a4a68f3fdd4897eb.jpeg" alt="bb3cd3458dc94871a4a68f3fdd4897eb.jpeg"></p>
<p>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用  <code>/</code> 隔开，如下：</p>
<p><img src="/img/050f0e2d38554dd89fdc4427226cc688.jpeg" alt="050f0e2d38554dd89fdc4427226cc688.jpeg"></p>
<h5 id="CIDR-与-VLSM"><a href="#CIDR-与-VLSM" class="headerlink" title="CIDR 与 VLSM"></a>CIDR 与 VLSM</h5><p>解决 IP 地址浪费问题，除了使用子网掩码，还使用了 CIDR 和 VLSM 技术。</p>
<p><strong>CIDR</strong> ，即无类域间路由，采用任意长度分割 IP 地址的网络号和主机号。它有两个作用：</p>
<ul>
<li>把多个网段聚合到一起，生成一个更大的网段；</li>
<li>汇总路由表 IP 地址，分担路由表压力。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330094830.png" alt="微信截图_20210330094830.png"></p>
<p><strong>VLSM</strong> ，即可变长子网掩码，它可以对 A 、 B 、 C 类地址再进行子网划分，以达到充分利用 IP 地址的目的。</p>
<p>假如一家企业有 100 台电脑，按以前的办法，只能分配一个 C 类地址 <code>222.222.222.0</code> 。但是 VLSM 可以在一个 C 类地址上划分出多个子网地址，再分配其中一个容纳主机数量与稍大于企业需求数量的子网地址给企业，这样就可以实现 IP 地址的合理使用。</p>
<p>计算容纳 100 台电脑的子网：使用主机号的位数计算出子网的主机地址数量。当主机号有 7 位时，有 126 个可用主机地址，可容纳 100 台电脑。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095148.png" alt="微信截图_20210330095148.png"></p>
<p>计算子网地址：当主机号有 7 位时，网络号有 32 - 7 = 25 位，也就是 <code>222.222.222.0/24</code> 向主机位借了一位作为子网位，那么子网掩码也就是 <code>255.255.255.128</code>。可分配 <code>222.222.222.0/25</code> 使用。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095237.png" alt="微信截图_20210330095237.png"></p>
<p>222.222.222.0/25子网详情：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095312.png" alt="微信截图_20210330095312.png"></p>
<p><strong>CIDR 和 VLSM 的区别</strong></p>
<p>CIDR 是主机号向网络号借位，目的是把几个网络汇总成一个大的网络，增加子网主机数量；</p>
<p>VLSM 是网络号向主机号借位，目的是把一个标准的网络划分成几个子网，减少子网主机数量。</p>
<h4 id="公网地址与私有地址"><a href="#公网地址与私有地址" class="headerlink" title="公网地址与私有地址"></a>公网地址与私有地址</h4><p>IP 地址分为公网地址和私有地址。公网地址是在互联网上使用的，私有地址是在局域网中使用的。</p>
<p>公网地址由 Internet NIC 负责分配，通过它直接访问互联网。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095612.png" alt="微信截图_20210330095612.png"></p>
<p>私有地址是一段保留的 IP 地址。只在局域网中使用，无法在互联网上使用。但是私有地址可以通过 NAT 技术，将私有地址转换为公网地址接入互联网。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095637.png" alt="微信截图_20210330095637.png"></p>
<p>公网 IP 地址在互联网范围内是唯一的，私有 IP 地址只要在同一个局域网内唯一即可。在不同局域网内出现相同的私有 IP 不会影响使用。</p>
<h3 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h3><p>&emsp;&emsp;发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于 <code>指明路由器或主机</code> 的信息，以便真正发往目标地址。保存这种信息的就是 <code>路由控制表</code>。</p>
<p>&emsp;&emsp;IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做 <code>路由协议</code> 的协议制作而成。</p>
<p>当一个数据包到达路由器时，路由器根据数据包的目的地址查询路由表，根据查询结果将数据包转发出去，这个过程就是 IP路由。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101202.png" alt="微信截图_20210330101202.png"></p>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>&emsp;&emsp;为了将数据包发给目的节点，所有节点都维护着一张路由表。路由表记录 IP 数据在下一跳应该发给哪个路由器。IP 包将根据这个路由表在各个数据链路上传输。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101335.png" alt="微信截图_20210330101335.png"></p>
<p>&emsp;&emsp;路由控制表的形成方式有两种：一种是管理员手动设置，也叫做 <strong>静态路由控制</strong>；另一种是路由器与其他路由器相互交换信息时自动刷新，叫做 <strong>动态路由控制</strong>。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101457.png" alt="微信截图_20210330101457.png"></p>
<h4 id="下一跳"><a href="#下一跳" class="headerlink" title="下一跳"></a>下一跳</h4><p>Hop ，中文叫 “跳”。它是指网络中的一个区间。IP 包就是在网络中一跳一跳的转发，在每一个区间内决定 IP 包下一跳的路径。</p>
<p>一跳是指数据链路中广播域的区间，也就是说不经过路由器而能直接到达的相连主机或路由器网卡的一个区间。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101607.png" alt="微信截图_20210330101607.png"></p>
<p>IP 数据包就像包裹，而送货车就像数据链路。包裹不可能自己移动，必须有送货车承载转运。而一辆送货车只能将包裹送到某个区间范围内。每个不同区间的包裹将由对应的送货车承载、运输。IP 的工作原理也是如此。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101639.png" alt="微信截图_20210330101639.png"></p>
<h4 id="路由条目类型"><a href="#路由条目类型" class="headerlink" title="路由条目类型"></a>路由条目类型</h4><h5 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h5><p>默认路由是指路由表中任何一个地址都能与之匹配的条目。所有数据包都可以使用默认路由进行数据转发。默认路由为 <code>0.0.0.0/0</code> 或 <code>default</code> 。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102027.png" alt="微信截图_20210330102027.png"></p>
<h5 id="主机路由"><a href="#主机路由" class="headerlink" title="主机路由"></a>主机路由</h5><p><code>IP地址/32</code> 被称为主机路由，它是路由表中指向单个 IP 地址或主机名的路由条目。例如：<code>192.168.153.15/32</code> 就是一条主机路由，表示整个 IP 地址的所有位都将参与路由。</p>
<h5 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h5><p>以 127 开头的 IP 地址都是环回地址，其所在的回环接口可以理解为虚拟网卡。使用回环地址时，数据包会直接被主机的 IP 层获取，而不经过链路层，也不会流向网络。一般用来检查主机上运行的网络服务是否正常。</p>
<h4 id="路由汇总"><a href="#路由汇总" class="headerlink" title="路由汇总"></a>路由汇总</h4><p>路由汇总主要是为了减少路由条目，把可以聚合的路由汇聚为一个大网络。</p>
<p>路由表越大，查找路由表所需的内存和 CPU 也就越多，时间也会越长，导致转发 IP 数据包的性能下降。如果想要搭建大规模、高性能的网络，就需要尽可能的路由表的大小。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102240.png" alt="微信截图_20210330102240.png"><br><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102302.png" alt="微信截图_20210330102302.png"></p>
<h4 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h4><p>IP 地址的网络地址部分用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</p>
<p>&emsp;&emsp;在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p>
<p><img src="/img/97e1e1332e5445c5b3da354f7cf407f9.jpeg" alt="97e1e1332e5445c5b3da354f7cf407f9.jpeg"></p>
<h3 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h3><h4 id="数据链路与MTU"><a href="#数据链路与MTU" class="headerlink" title="数据链路与MTU"></a>数据链路与MTU</h4><p>数据链路不同， MTU 则不同。</p>
<p>&emsp;&emsp;每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同，网络层的 IP 是数据链路的上一层， IP 通过分片屏蔽数据链路的差异，实现不同数据链路互通。从 IP 的上一层看，它完全可以忽略各个数据链路上的 MTU ，只需要按照源 IP 地址发送的长度接收数据包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102721.png" alt="微信截图_20210330102721.png"></p>
<h4 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h4><p>&emsp;&emsp;任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104125.png" alt="微信截图_20210330104125.png"></p>
<h4 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h4><p>分片机制有两点不足：</p>
<ul>
<li>加重路由器的处理性能；</li>
<li>在分片传输中，一旦某个分片丢失，会造成整个 IP 数据包作废。</li>
</ul>
<p>因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</p>
<p>为了应对分片机制的不足，<code>路径MTU发现</code>(Path MTU Discovery) 技术应运而生。</p>
<p>&emsp;&emsp;路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的值。即路径中存在的所有数据链路中最小的 MTU 。进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104310.png" alt="微信截图_20210330104310.png"></p>
<p>路径 MTU 发现的工作原理如下：</p>
<ul>
<li><p>1，发送端主机发送 IP 数据包时将其头部的分片禁止标志位设置为 1 。根据这个标志位，途中的路由器即使收到需要分片的大包，也不会分片，而是直接将包丢弃。之后通过一个 ICMP 不可达消息将数据链路上 MTU 值给发送端主机。</p>
</li>
<li><p>2，发送端主机根据收到的 MTU 值对数据包进行分片处理，再把 IP 数据包发送给相同的目的主机。如此重复，直到数据包被发送到目标主机为止没有再收到任何 ICMP ，就认为最后一次 ICMP 所通知的 MTU 即是一个合适的 MTU 值。MTU 值至少可以缓存约 10 分钟，在这 10 分钟内使用刚得到的 MTU ，过了 10 分钟后就重新做一次路径 MTU 发现。</p>
</li>
</ul>
<p>上面的例子是 UDP ，如果是在 TCP 的情况下，根据路径 MTU 的大小计算出最大段长度（ MSS ），然后再根据这些信息进行数据包的发送。因此，在 TCP 中如果使用路径 MTU 发现， IP 层则不会再分片。</p>
<h3 id="路由器三层转发原理"><a href="#路由器三层转发原理" class="headerlink" title="路由器三层转发原理"></a>路由器三层转发原理</h3><p>&emsp;&emsp;路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的网络号，再根据路由表进行转发，路由表中有匹配的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。</p>
<h4 id="路由器如何进行三层转发"><a href="#路由器如何进行三层转发" class="headerlink" title="路由器如何进行三层转发"></a>路由器如何进行三层转发</h4><p>当一台路由器收到一个数据包时，会执行如下步骤：</p>
<p>1，对数据包进行解封装。<br>    通过解封装，查看网络层头部信息的 目的 IP 地址。</p>
<p>2，在路由表中查找匹配的路由条目。</p>
<p>查找匹配的路由条目，就需要将数据包的目的 IP 地址与各个路由条目的网段地址先进行二进制与（ AND ）运算，再将运算结果与路由条目的网段地址进行比较，若一致则该条目与目的 IP 地址相匹配。最后，与所有路由条目完成运算和比较，可得到一条或多条相匹配的路由条目。也可能没有匹配的路由条目，那么丢弃数据包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104705.png" alt="微信截图_20210330104705.png"></p>
<p>3，从多个匹配项中选择掩码最长的路由条目。</p>
<p>如果路由表中有多条路由条目都匹配数据包的目的 IP 地址，则路由器会选择掩码长度最长的路由条目，这种匹配方式称为最长匹配原则。</p>
<p>例如：<code>10.1.3.10</code> 的网络地址与 <code>10.1.3.0/16</code> 和 <code>10.1.3.0/24</code> 两项都匹配，这时应该选择匹配度最长的 <code>10.1.3.0/24</code>。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104813.png" alt="微信截图_20210330104813.png"></p>
<p>4，将数据包按照相应路由条目进行转发。</p>
<p>路由条目中包含下一跳和出接口。当路由器找到相应的路由条目后，它就会根据对应的下一跳和出接口，将数据包从出接口发送数据给下一跳设备。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104927.png" alt="微信截图_20210330104927.png"></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>&emsp;&emsp;IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节</p>
<h4 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h4><ul>
<li>IP 地址的扩大与路由控制表的聚合。</li>
<li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li>
<li>支持即插即用功能。即使没有 <code>DHCP服务器</code> 也可以实现自动分配 IP 地址。</li>
<li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li>
<li>多播、Mobile IP 成为扩展功能。</li>
</ul>
<h4 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h4><p>&emsp;&emsp;一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（ <code>:</code> ）隔开进行标记。而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（<code>::</code>）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
<h4 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h4><p>&emsp;&emsp;IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</p>
<p><img src="/img/be1bff3dd05c4f999c7836ca26598c7d.jpeg" alt="be1bff3dd05c4f999c7836ca26598c7d.jpeg"></p>
<h4 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h4><p>&emsp;&emsp;全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</p>
<p>&emsp;&emsp;格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</p>
<p><img src="/img/478cf4cd8c2b43339b80d7b667a6520a.jpeg" alt="478cf4cd8c2b43339b80d7b667a6520a.jpeg"></p>
<h4 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h4><p>&emsp;&emsp;链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p>
<p><img src="/img/d9e6580e7ce245aa9116004055f69b8b.jpeg" alt="d9e6580e7ce245aa9116004055f69b8b.jpeg"></p>
<h4 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h4><p>&emsp;&emsp;唯一本地地址是不进行互联网通信时所用的地址。唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</p>
<ul>
<li>L 通常被置为 1</li>
<li>全局 ID 的值随机决定</li>
<li>子网 ID 是指该域子网地址</li>
<li>接口 ID 即为接口的 ID</li>
</ul>
<p><img src="/img/8efd0df062b049978546f10dc3895af5.jpeg" alt="8efd0df062b049978546f10dc3895af5.jpeg"></p>
<h4 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h4><p>&emsp;&emsp;IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</p>
<p>&emsp;&emsp;IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行 <code>路径MTU发现</code>，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</p>
<h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><p>&emsp;&emsp;IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>&emsp;&emsp;我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</p>
<p>&emsp;&emsp;这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>&emsp;&emsp;地址解析协议，即 <code>ARP（Address Resolution Protocol）</code>，是根据IP地址获取物理地址的一个 <code>TCP/IP</code> 协议。主机发送信息时将包含目标IP地址的 <code>ARP</code> 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机 <code>ARP缓存</code> 中，并保留一定时间，下次请求时直接查询 <code>ARP缓存</code> 以节约资源。</p>
<p>&emsp;&emsp;地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送 <code>ARP</code> 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 <code>ARP缓存</code>；由此攻击者就可以向某一主机发送伪 <code>ARP</code> 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 <code>ARP欺骗</code>。ARP命令可用于查询本机 <code>ARP缓存</code> 中 IP 地址和 MAC 地址的对应关系、添加或删除静态对应关系等。相关协议有 <code>RARP</code>、<code>代理ARP</code>。NDP用于在IPv6中代替地址解析协议。</p>
<p>&emsp;&emsp;只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时，还要知道每个 IP 地址所对应的 MAC 地址。</p>
<p>&emsp;&emsp;ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</p>
<p>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</p>
<h5 id="ARP-的工作原理"><a href="#ARP-的工作原理" class="headerlink" title="ARP 的工作原理"></a>ARP 的工作原理</h5><p><strong>当主机 A 向同一个网段内的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。</strong></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105123.png" alt="微信截图_20210330105123.png"></p>
<p>1，ARP 请求：主机 A 以主机 C 的 IP 地址为目的 IP 地址，以广播 MAC 地址为目的 MAC 地址，在同网段内发送这个广播报文，这个报文就叫 ARP 请求报文。</p>
<p>二层交换机不查看 IP 地址，根据目的 MAC 地址将报文除接收端口外的所有端口发送。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105217.png" alt="微信截图_20210330105217.png"></p>
<p>2，ARP 响应：主机 C 发现目的 IP 地址是自己的 IP 地址，于是主机 C 以自己 MAC 地址和 IP 地址作为源 MAC 地址和源 IP 地址，以主机 A 的 MAC 地址和 IP 地址作为目的 MAC 地址和目的 IP 地址，发送响应报文给主机 A ，这个报文就叫 ARP 响应报文。其它主机收到主机 A 的 ARP 请求报文，因为目的 IP 地址不是自己的 IP 地址，因此不会进行响应。</p>
<p>当主机 A 在发送 ARP 广播请求报文时，二层交换机已经有主机 A 的 MAC 地址表条目。当收到主机 C 发送的单播 ARP 响应报文时，二层交换机将报文从相应端口发送出去。并将主机 C 的 MAC 地址和对应端口记录到 MAC 地址表中。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105326.png" alt="微信截图_20210330105326.png"></p>
<p>3，更新 ARP 缓存表：主机 A 收到 ARP 响应报文后，将主机 C 的 IP 地址和 MAC 地址记录到 ARP 缓存表中。下次再向主机 C 发送数据时，直接将缓存的目的 MAC 地址进行封装。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105401.png" alt="微信截图_20210330105401.png"></p>
<p><strong>当主机 A 向不同网段的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。</strong></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105435.png" alt="微信截图_20210330105435.png"></p>
<p>1，主机 A 使用主机 C 的 IP 地址查询 ARP ，ARP 发现主机 C 不在同一个网段，需要通过默认网关（即默认路由的下一跳地址），但是没有网关 MAC 地址；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105523.png" alt="微信截图_20210330105523.png"></p>
<p>2，主机 A 先将发送给主机 C 的数据放入缓存中，然后发送 ARP 请求报文，主机 A 以网关 IP 地址为目的 IP 地址发送 ARP 广播请求报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105548.png" alt="微信截图_20210330105548.png"></p>
<p>3，路由器收到 ARP 广播请求报文后，将主机 A 的 MAC 地址和对应端口添加到自己的 MAC 表中，然后查看目的 IP 地址发现是请求自己的 MAC 地址，于是单播发送 ARP 响应报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105612.png" alt="微信截图_20210330105612.png"></p>
<p>4，主机 A 收到 ARP 响应报文后，将发送给主机 C 的数据封装网关 MAC 地址为目的 MAC 地址进行发送；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105634.png" alt="微信截图_20210330105634.png"></p>
<p>5，路由器收到报文后，查看目的 IP 地址，是发送给主机 C 的，于是查询路由表从相应端口发送数据。由于没有主机 C 的 MAC 地址，路由器发送 ARP 请求报文，源 MAC 地址和源 IP 地址替换为发送端口的MAC 地址和 IP 地址；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105656.png" alt="微信截图_20210330105656.png"></p>
<p>6，主机 C 收到 ARP 请求报文后，添加路由器的端口和 MAC 地址到 MAC 地址表，单播发送 ARP 响应报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105715.png" alt="微信截图_20210330105715.png"></p>
<p>7，路由器收到主机 C 的 MAC 地址后，将其添加到 MAC 地址表中。将主机 A 发送给主机 C 的报文重新封装，以自己的 MAC 地址为源 MAC 地址，以主机 C 的 MAC 地址为目的 MAC 地址，发送给主机 C ；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105737.png" alt="微信截图_20210330105737.png"></p>
<p>8，主机 C 收到主机 A 发送的数据，发送过程结束。</p>
<p>当主机 C 向主机 A 发送回复报文时，同主机 A 向主机 C 发送数据的步骤一致。</p>
<h5 id="ARP-代理"><a href="#ARP-代理" class="headerlink" title="ARP 代理"></a>ARP 代理</h5><p>如果 ARP 请求是从一个网络的主机发往同一网段却不在同一物理网络上的另一台主机，那么连接它们的具有代理 ARP 功能的设备就可以回答该请求，这个过程称作 代理ARP 。</p>
<p>代理 ARP 功能屏蔽了分离的物理网络，让用户使用起来，跟在同一个物理网络上一样。</p>
<h5 id="免费-ARP"><a href="#免费-ARP" class="headerlink" title="免费 ARP"></a>免费 ARP</h5><p>免费 ARP 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。</p>
<p>与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，目标 IP 地址是自己的 IP 地址。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110049.png" alt="微信截图_20210330110049.png"></p>
<p>免费 ARP 的作用：</p>
<ul>
<li>起到一个宣告作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。</li>
<li>可用于检测 IP 地址冲突。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</li>
<li>可用于更新其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。</li>
</ul>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>IP 提供尽力而为的服务，指为了把数据包发送到目的地址尽最大努力。它并不做对端目的主机是否收到数据包的验证，无法保证服务质量。</p>
<p>&emsp;&emsp;<code>ICMP（Internet Control Message Protocol）</code> Internet控制报文协议。它是 <code>TCP/IP</code> 协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>&emsp;&emsp;<code>ICMP</code> 使用 IP 的基本支持，就像它是一个更高级别的协议，但是，<code>ICMP</code> 实际上是IP的一个组成部分，必须由每个IP模块实现。</p>
<p>&emsp;&emsp;<code>ICMP</code> 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>
<p>&emsp;&emsp;IPv4 中 <code>ICMP</code> 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 <code>ICMP</code>，仍然可以实现 IP 通信。然而，在 IPv6 中，<code>ICMP</code> 的作用被扩大，如果没有 <code>ICMPv6</code>，IPv6 就无法进行正常通信。</p>
<p>ICMP 报文像 TCP/UDP 一样通过 IP 进行传输，但是 ICMP 的功能不是传输层的补充，应该把它当做网络层协议。’</p>
<p>ICMP 头部封装字段如:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110618.png" alt="微信截图_20210330110618.png"></p>
<p>通过类型字段和编码字段的取值判断这个 ICMP 消息的类型。常见的 ICMP 消息所对应的类型和编码值如下图。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110640.png" alt="微信截图_20210330110640.png"></p>
<p>从功能上，ICMP 的消息分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110700.png" alt="微信截图_20210330110700.png"></p>
<h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>我们常用的 ping 工具就是通过 ICMP 消息测试网络层连通性的。源主机发出 Echo request 消息，目的主机回应 Echo reply 消息，则两台主机间的网络层通信正常。也可以通过 ping 命令来判断目标主机是否启用。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110752.png" alt="微信截图_20210330110752.png"></p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>&emsp;&emsp;如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</p>
<p>&emsp;&emsp;于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</p>
<p>&emsp;&emsp;<code>DHCP</code> (Dynamic Host Configuration Protocol，动态主机配置协议) 是一个局域网的网络协议，使用UDP协议工作，指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为 <code>Windows Server</code> 的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。</p>
<p>&emsp;&emsp;主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<p>&emsp;&emsp;在RFC 2131中有详细的描述，DHCP有3个端口，其中 <code>UDP67</code> 和 <code>UDP68</code> 为正常的 <code>DHCP</code> 服务端口，分别作为 <code>DHCP Server</code> 和 <code>DHCP Client</code> 的服务端口；546号端口用于 <code>DHCPv6 Client</code>，而不用于 <code>DHCPv4</code> ，是为 <code>DHCP failover</code> 服务，这是需要特别开启的服务，<code>DHCP failover</code> 是用来做双机热备的。</p>
<p>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>&emsp;&emsp;<code>NAT</code>（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</p>
<p>&emsp;&emsp;除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 <code>NAPT</code>（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</p>
<p>&emsp;&emsp;<code>NAT（NAPT）</code>实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 <code>NAT-PT</code>。</p>
<h4 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h4><p><img src="/img/e11421fc61d14423adab54661884f497.jpeg" alt="e11421fc61d14423adab54661884f497.jpeg"></p>
<p>夹着 IPv4 网络的两个 IPv6 网络</p>
<p>&emsp;&emsp;如上图的网络环境中，网络A 网络B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</p>
<p>&emsp;&emsp;IP 隧道可以将那网络A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发网络C。</p>
<p>&emsp;&emsp;一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中 “IP首部的后面还是 IP首部” 或者 “IP首部 的后面是 IPv6的首部” 等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做 “IP隧道”。</p>
<h2 id="扩展：运行在传输层中的-TCP-和-UDP-的协议"><a href="#扩展：运行在传输层中的-TCP-和-UDP-的协议" class="headerlink" title="扩展：运行在传输层中的 TCP 和 UDP 的协议"></a>扩展：运行在传输层中的 TCP 和 UDP 的协议</h2><p>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</p>
<p><strong>运行在 TCP协议上的协议：</strong></p>
<ul>
<li>HTTP（HypertextTransferProtocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）, HTTP协议的安全版本。</li>
<li>FTP（FileTransferProtocol，文件传输协议），用于文件传输。</li>
<li>POP3（PostOfficeProtocol,version3，邮局协议），收邮件用。</li>
<li>SMTP（SimpleMailTransferProtocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletypeover theNetwork，网络电传），通过一个 终端（terminal）登陆到网络。</li>
<li>SSH（SecureShell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p><strong>运行在 UDP协议上的协议：</strong></p>
<ul>
<li>BOOTP（BootProtocol，启动协议），应用于无盘设备。</li>
<li>NTP（NetworkTimeProtocol，网络时间协议），用于网络同步。</li>
<li>DHCP（DynamicHostConfigurationProtocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p><strong>运行在 TCP和 UDP协议上：</strong></p>
<ul>
<li>DNS（DomainNameService，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/339068354_774177">https://www.sohu.com/a/339068354_774177</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jbjrR-7EGQ1vMgAdTT450A">71张图详解IP 地址、IP 路由、分片和重组、三层转发、ARP、ICMP</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44630560/article/details/108100907">https://blog.csdn.net/weixin_44630560/article/details/108100907</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 计算机基础</a>
              <a href="/tags/TCP%E5%8D%8F%E8%AE%AE/" rel="tag"><i class="fa fa-tag"></i> TCP协议</a>
              <a href="/tags/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> 网络基础</a>
              <a href="/tags/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" rel="tag"><i class="fa fa-tag"></i> 子网掩码</a>
              <a href="/tags/IP%E7%BD%91%E7%BB%9C/" rel="tag"><i class="fa fa-tag"></i> IP网络</a>
              <a href="/tags/Ethernet/" rel="tag"><i class="fa fa-tag"></i> Ethernet</a>
              <a href="/tags/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80/" rel="tag"><i class="fa fa-tag"></i> 广播地址</a>
              <a href="/tags/ARP/" rel="tag"><i class="fa fa-tag"></i> ARP</a>
              <a href="/tags/ICMP/" rel="tag"><i class="fa fa-tag"></i> ICMP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" rel="prev" title="IP4-子网掩码">
      <i class="fa fa-chevron-left"></i> IP4-子网掩码
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/01/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/" rel="next" title="Linux下网络丢包故障定位">
      Linux下网络丢包故障定位 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E5%B1%82"><span class="nav-number">1.</span> <span class="nav-text">计算机网络体系结构分层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E5%90%8D%E7%A7%B0%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">数据包名称简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">数据处理流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%AD%E7%9A%84-TCP-%E5%92%8C-UDP"><span class="nav-number">4.</span> <span class="nav-text">传输层中的 TCP 和 UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">4.1.</span> <span class="nav-text">端口号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="nav-number">4.1.1.</span> <span class="nav-text">端口号的确定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.2.</span> <span class="nav-text">端口号与协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP"><span class="nav-number">4.2.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">4.3.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">4.3.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%BA%8F%E5%88%97%E5%8F%B7%E4%B8%8E%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%8F%90%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">4.3.3.</span> <span class="nav-text">通过序列号与确认应答提高可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%8F%91%E8%B6%85%E6%97%B6%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="nav-number">4.3.4.</span> <span class="nav-text">重发超时的确定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E6%AE%B5%E4%B8%BA%E5%8D%95%E4%BD%8D%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="nav-number">4.3.5.</span> <span class="nav-text">以段为单位发送数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6"><span class="nav-number">4.3.6.</span> <span class="nav-text">利用窗口控制提高速度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.7.</span> <span class="nav-text">滑动窗口控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6%E4%B8%AD%E7%9A%84%E9%87%8D%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.8.</span> <span class="nav-text">窗口控制中的重发控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E4%B8%AD%E7%9A%84-IP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.</span> <span class="nav-text">网络层中的 IP 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">5.1.</span> <span class="nav-text">IP 地址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-%E5%9C%B0%E5%9D%80%E7%BB%84%E6%88%90"><span class="nav-number">5.1.1.</span> <span class="nav-text">IP 地址组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">5.1.2.</span> <span class="nav-text">IP 地址的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="nav-number">5.1.3.</span> <span class="nav-text">广播地址</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%97%E9%99%90%E5%9C%B0%E5%9D%80"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">受限地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E7%BD%91%E7%BB%9C"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">指向网络</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%AD%90%E7%BD%91"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">指向子网</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E6%89%80%E6%9C%89%E5%AD%90%E7%BD%91"><span class="nav-number">5.1.3.4.</span> <span class="nav-text">指向所有子网</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E5%A4%9A%E6%92%AD-%E7%BB%84%E6%92%AD"><span class="nav-number">5.1.4.</span> <span class="nav-text">IP多播(组播)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%8E%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80%E5%92%8C%E5%A4%9A%E6%92%AD%E7%BB%84"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">1．多播地址和多播组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%A4%9A%E6%92%AD%E6%8A%80%E6%9C%AF%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">2. 多播技术硬件支持</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="nav-number">5.1.5.</span> <span class="nav-text">子网掩码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CIDR-%E4%B8%8E-VLSM"><span class="nav-number">5.1.5.1.</span> <span class="nav-text">CIDR 与 VLSM</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E7%BD%91%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A7%81%E6%9C%89%E5%9C%B0%E5%9D%80"><span class="nav-number">5.1.6.</span> <span class="nav-text">公网地址与私有地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E8%B7%AF%E7%94%B1"><span class="nav-number">5.2.</span> <span class="nav-text">IP路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="nav-number">5.2.1.</span> <span class="nav-text">路由表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E8%B7%B3"><span class="nav-number">5.2.2.</span> <span class="nav-text">下一跳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.3.</span> <span class="nav-text">路由条目类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">默认路由</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E8%B7%AF%E7%94%B1"><span class="nav-number">5.2.3.2.</span> <span class="nav-text">主机路由</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80"><span class="nav-number">5.2.3.3.</span> <span class="nav-text">回环地址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB"><span class="nav-number">5.2.4.</span> <span class="nav-text">路由汇总</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP-%E5%9C%B0%E5%9D%80%E4%B8%8E%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6"><span class="nav-number">5.2.5.</span> <span class="nav-text">IP 地址与路由控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-%E5%88%86%E5%8C%85%E4%B8%8E%E7%BB%84%E5%8C%85"><span class="nav-number">5.3.</span> <span class="nav-text">IP 分包与组包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E4%B8%8EMTU"><span class="nav-number">5.3.1.</span> <span class="nav-text">数据链路与MTU</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E6%8A%A5%E6%96%87%E7%9A%84%E5%88%86%E7%89%87%E4%B8%8E%E9%87%8D%E7%BB%84"><span class="nav-number">5.3.2.</span> <span class="nav-text">IP报文的分片与重组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84-MTU-%E5%8F%91%E7%8E%B0"><span class="nav-number">5.3.3.</span> <span class="nav-text">路径 MTU 发现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%89%E5%B1%82%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86"><span class="nav-number">5.4.</span> <span class="nav-text">路由器三层转发原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%B8%89%E5%B1%82%E8%BD%AC%E5%8F%91"><span class="nav-number">5.4.1.</span> <span class="nav-text">路由器如何进行三层转发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv6"><span class="nav-number">5.5.</span> <span class="nav-text">IPv6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">5.5.1.</span> <span class="nav-text">IPv6 的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-%E4%B8%AD-IP-%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A0%87%E8%AE%B0%E6%96%B9%E6%B3%95"><span class="nav-number">5.5.2.</span> <span class="nav-text">IPv6 中 IP 地址的标记方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">5.5.3.</span> <span class="nav-text">IPv6 地址的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="nav-number">5.5.4.</span> <span class="nav-text">全局单播地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E6%9C%AC%E5%9C%B0%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="nav-number">5.5.5.</span> <span class="nav-text">链路本地单播地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80"><span class="nav-number">5.5.6.</span> <span class="nav-text">唯一本地地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv6-%E5%88%86%E6%AE%B5%E5%A4%84%E7%90%86"><span class="nav-number">5.5.7.</span> <span class="nav-text">IPv6 分段处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP-%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF"><span class="nav-number">5.6.</span> <span class="nav-text">IP 协议相关技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-number">5.6.1.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARP"><span class="nav-number">5.6.2.</span> <span class="nav-text">ARP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ARP-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.6.2.1.</span> <span class="nav-text">ARP 的工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARP-%E4%BB%A3%E7%90%86"><span class="nav-number">5.6.2.2.</span> <span class="nav-text">ARP 代理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%8D%E8%B4%B9-ARP"><span class="nav-number">5.6.2.3.</span> <span class="nav-text">免费 ARP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ICMP"><span class="nav-number">5.6.3.</span> <span class="nav-text">ICMP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ping"><span class="nav-number">5.6.3.1.</span> <span class="nav-text">ping</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DHCP"><span class="nav-number">5.6.4.</span> <span class="nav-text">DHCP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NAT"><span class="nav-number">5.6.5.</span> <span class="nav-text">NAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E9%9A%A7%E9%81%93"><span class="nav-number">5.6.6.</span> <span class="nav-text">IP隧道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E8%BF%90%E8%A1%8C%E5%9C%A8%E4%BC%A0%E8%BE%93%E5%B1%82%E4%B8%AD%E7%9A%84-TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.</span> <span class="nav-text">扩展：运行在传输层中的 TCP 和 UDP 的协议</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">373</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">118</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">168</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
