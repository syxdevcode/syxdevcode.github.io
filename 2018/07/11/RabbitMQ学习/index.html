<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="RabbitMQ学习RabbitMQ 简介RabbitMQ——Rabbit Message Queue的简写，是一个由erlang开发，基于AMQP（Advanced Message Queue Protocol）协议的开源实现。RabbitMQ提供了可靠的消息机制、跟踪机制和灵活的消息路由，支持消息集群和分布式部署，适用于排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、CQRS等">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ学习">
<meta property="og:url" content="https://syxdevcode.github.com/2018/07/11/RabbitMQ%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:description" content="RabbitMQ学习RabbitMQ 简介RabbitMQ——Rabbit Message Queue的简写，是一个由erlang开发，基于AMQP（Advanced Message Queue Protocol）协议的开源实现。RabbitMQ提供了可靠的消息机制、跟踪机制和灵活的消息路由，支持消息集群和分布式部署，适用于排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、CQRS等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://syxdevcode.github.com/img/435188-20180605151314266-1010797270.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/2799767-a5e45f97bec36c8a.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/2799767-283ced13913a0aac.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/QQ%E6%88%AA%E5%9B%BE20180712135714.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/2799767-d2bb1f2ac63fdb15.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/2799767-0b4fba202e525745.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/2799767-6c78ab57fe06c6ce.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/2799767-3afd7b874221a9a2.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/2799767-3196a1c3880b3466.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/python-six.png">
<meta property="og:image" content="https://syxdevcode.github.com/img/45366c44f775abfd0ac3b43bccc1abc3_hd.jpg">
<meta property="article:published_time" content="2018-07-11T16:24:34.000Z">
<meta property="article:modified_time" content="2021-10-09T07:41:56.704Z">
<meta property="article:author" content="syxdevcode">
<meta property="article:tag" content="DotNet">
<meta property="article:tag" content="CSharp">
<meta property="article:tag" content="DotNetCore">
<meta property="article:tag" content="消息队列">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://syxdevcode.github.com/img/435188-20180605151314266-1010797270.png">

<link rel="canonical" href="https://syxdevcode.github.com/2018/07/11/RabbitMQ%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RabbitMQ学习 | syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/07/11/RabbitMQ%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="syxdevcode的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-11 16:24:34" itemprop="dateCreated datePublished" datetime="2018-07-11T16:24:34+00:00">2018-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-10-09 07:41:56" itemprop="dateModified" datetime="2021-10-09T07:41:56+00:00">2021-10-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="RabbitMQ学习"><a href="#RabbitMQ学习" class="headerlink" title="RabbitMQ学习"></a>RabbitMQ学习</h1><h2 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h2><p>RabbitMQ——Rabbit Message Queue的简写，是一个由erlang开发，基于AMQP（Advanced Message Queue Protocol）协议的开源实现。RabbitMQ提供了可靠的消息机制、跟踪机制和灵活的消息路由，支持消息集群和分布式部署，适用于排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、CQRS等应用场景。是当前最主流的消息中间件之一。</p>
<p>RabbitMQ的官网：<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/">http://www.rabbitmq.com</a></p>
<p><img src="/img/435188-20180605151314266-1010797270.png" alt="435188-20180605151314266-1010797270.png"></p>
<p>RabbitMQ 投递过程:</p>
<ul>
<li>1.客户端连接到消息队列服务器，打开一个 channel。</li>
<li>2.客户端声明一个 exchange，并设置相关属性。</li>
<li>3.客户端声明一个 queue，并设置相关属性。</li>
<li>4.客户端使用 routing key，在 exchange 和 queue 之间建立好绑定关系。</li>
<li>5.客户端Producer投递消息到 exchange。</li>
<li>6.客户端Consumer从指定的 queue 中消费信息。</li>
</ul>
<h2 id="AMQP-简介"><a href="#AMQP-简介" class="headerlink" title="AMQP 简介"></a>AMQP 简介</h2><p>AMQP，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，同样，消息使用者也不用知道发送者的存在。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
<h2 id="RabbitMQ-概念"><a href="#RabbitMQ-概念" class="headerlink" title="RabbitMQ 概念"></a>RabbitMQ 概念</h2><ul>
<li><strong>Exchange</strong> : 消息交换机，它指定消息按什么规则，路由到哪个队列</li>
<li><strong>Queue</strong> : 消息队列，每个消息都会被投入到一个或多个队列</li>
<li><strong>Routing Key</strong> : 路由关键字，exchange根据这个关键字进行消息投递。</li>
<li><strong>Binding Key</strong> : 绑定，它的作用就是把 exchange 和 queue 按照路由规则绑定起来</li>
<li><strong>Vhost</strong> : 虚拟主机，可以开设多个 vhost，用作不同用户的权限分离</li>
<li><strong>Producer</strong> : 消息生产者，投递消息的程序，简写 ：P</li>
<li><strong>Consumer</strong> : 消息消费者，接受消息的程序，简写 : C</li>
<li><strong>Broker</strong> ：消息队列的服务器实体。</li>
<li><strong>Channel</strong> : 消息通道，在客户端的每个连接里，可建立多个 channel，每个 channel 代表一个会话任务</li>
</ul>
<h2 id="消息发送原理"><a href="#消息发送原理" class="headerlink" title="消息发送原理"></a>消息发送原理</h2><p>应用程序和Rabbit Server之间会创建一个TCP连接，一旦TCP打开，并通过了认证，认证就是你试图连接Rabbit之前发送的Rabbit服务器连接信息和用户名和密码，有点像程序连接数据库，一旦认证通过你的应用程序和Rabbit就创建了一条AMQP信道（Channel）。</p>
<p>信道是创建在“真实”TCP上的虚拟连接，AMQP命令都是通过信道发送出去的，每个信道都会有一个唯一的ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。</p>
<p>为什么不通过TCP直接发送命令？对于操作系统来说创建和销毁TCP会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条TCP会话，这就造成了TCP连接的巨大浪费，而且操作系统每秒能创建的TCP也是有限的，因此很快就会遇到系统瓶颈。</p>
<p>如果我们每个请求都使用一条TCP连接，既满足了性能的需要，又能确保每个连接的私密性，这就是引入信道概念的原因。</p>
<h2 id="使用-RabbitMQ"><a href="#使用-RabbitMQ" class="headerlink" title="使用 RabbitMQ"></a>使用 RabbitMQ</h2><p>在.NET中使用RabbitMQ需要下载RabbitMQ的客户端程序集.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package RabbitMQ.Client -Version 5.1.0</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/RabbitMQ.Client/">https://www.nuget.org/packages/RabbitMQ.Client/</a></p>
<h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>工作队列（work queues, 又称任务队列Task Queues）的主要思想是为了避免立即执行并等待一些占用大量资源、时间的操作完成。而是把任务（Task）当作消息发送到队列中，稍后处理。一个运行在后台的工作者（worker）进程就会取出任务然后处理。当运行多个工作者（workers）时，任务会在它们之间共享。</p>
<p>这个在网络应用中非常有用，它可以在短暂的HTTP请求中处理一些复杂的任务。在一些实时性要求不太高的地方，我们可以处理完主要操作之后，以消息的方式来处理其他的不紧要的操作，比如写日志等等。</p>
<h4 id="发送-接收消息"><a href="#发送-接收消息" class="headerlink" title="发送/接收消息"></a>发送/接收消息</h4><p>分别创建两个控制台项目Send、Receive。</p>
<p>安装 <code>RabbitMQ.Client</code></p>
<p>注意：消息接收端和发送端的队列名称（queue）必须保持一致</p>
<p><img src="/img/2799767-a5e45f97bec36c8a.png" alt="2799767-a5e45f97bec36c8a.png"></p>
<p>源代码：<a target="_blank" rel="noopener" href="https://github.com/syxdevcode/RabbitMqDemo">https://github.com/syxdevcode/RabbitMqDemo</a></p>
<p>Send逻辑代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMqDemo.Send</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) =&gt; true;</span></span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">                Ssl = <span class="keyword">new</span> SslOption()</span><br><span class="line">                &#123;</span><br><span class="line">                    CertPath = <span class="string">@&quot;E:\git\RabbitMqDemo\RabbitMqDemo.Send\server.pfx&quot;</span>,</span><br><span class="line">                    CertPassphrase = <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">                    AcceptablePolicyErrors = SslPolicyErrors.RemoteCertificateNameMismatch |</span><br><span class="line">                                                SslPolicyErrors.RemoteCertificateChainErrors,</span><br><span class="line">                    Enabled = <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//AuthMechanisms = new AuthMechanismFactory[] &#123; new ExternalMechanismFactory() &#125;,</span></span><br><span class="line">                RequestedHeartbeat = <span class="number">60</span>,</span><br><span class="line">                Port = <span class="number">5673</span>,</span><br><span class="line">                TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第一步：创建connection </span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//第二步：创建一个channel信道</span></span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//第三步：申明队列 durable:是否持久化</span></span><br><span class="line">                    <span class="keyword">var</span> result = channel.QueueDeclare(queue: <span class="string">&quot;test1&quot;</span>, durable: <span class="literal">true</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>.MaxValue; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//构建byte消息数据包</span></span><br><span class="line">                        <span class="keyword">var</span> body = Encoding.UTF8.GetBytes(i.ToString() + <span class="string">&quot;test&quot;</span>);</span><br><span class="line">                        channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: <span class="string">&quot;test1&quot;</span>, basicProperties: <span class="literal">null</span>, body: body);</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;&#123;0&#125; 推送成功&quot;</span>, i);</span><br><span class="line">                        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Receive逻辑代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.实例化连接工厂</span></span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">                Ssl = <span class="keyword">new</span> SslOption()</span><br><span class="line">                &#123;</span><br><span class="line">                    CertPath = <span class="string">@&quot;E:\git\RabbitMqDemo\RabbitMqDemo.Receive\server.pfx&quot;</span>,</span><br><span class="line">                    CertPassphrase = <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">                    AcceptablePolicyErrors = SslPolicyErrors.RemoteCertificateNameMismatch |</span><br><span class="line">                                                SslPolicyErrors.RemoteCertificateChainErrors,</span><br><span class="line">                    Enabled = <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//AuthMechanisms = new AuthMechanismFactory[] &#123; new ExternalMechanismFactory() &#125;,</span></span><br><span class="line">                RequestedHeartbeat = <span class="number">60</span>,</span><br><span class="line">                Port = <span class="number">5673</span>,</span><br><span class="line">                TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 建立连接</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//3. 创建信道</span></span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//4. 申明队列</span></span><br><span class="line">                    channel.QueueDeclare(queue: <span class="string">&quot;test1&quot;</span>, durable: <span class="literal">true</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//5. 构造消费者实例</span></span><br><span class="line">                    <span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line">                    <span class="comment">//6. 绑定消息接收后的事件委托</span></span><br><span class="line">                    consumer.Received += (model, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> message = Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class="line">                        Thread.Sleep(<span class="number">500</span>);<span class="comment">//模拟耗时</span></span><br><span class="line">                        Console.WriteLine(<span class="string">&quot; [x] Done&quot;</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">//7. 启动消费者</span></span><br><span class="line">                    channel.BasicConsume(queue: <span class="string">&quot;test1&quot;</span>, autoAck: <span class="literal">true</span>, consumer: consumer);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="轮询分发"><a href="#轮询分发" class="headerlink" title="轮询分发"></a>轮询分发</h4><p><img src="/img/2799767-283ced13913a0aac.png" alt="2799767-283ced13913a0aac.png"></p>
<p>我们先启动两个接收端，等待消息接收，再启动一个发送端进行消息发送。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180712135714.png" alt="QQ截图20180712135714.png"></p>
<p>从图中可知，发送的信息，被两个消息接收端按顺序循环分配。<br>默认情况下，RabbitMQ将按顺序将每条消息发送给下一个消费者。平均每个消费者将获得相同数量的消息。这种分发消息的方式叫做<strong>循环（round-robin）</strong>。</p>
<h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>当处理一个比较耗时得任务的时候，也许想知道消费者（consumers）是否运行到一半就挂掉。在当前的代码中，当RabbitMQ将消息发送给消费者（consumers）之后，马上就会将该消息从队列中移除。此时，如果把处理这个消息的工作者（worker）停掉，正在处理的这条消息就会丢失。同时，所有发送到这个工作者的还没有处理的消息都会丢失。</p>
<p>我们不想丢失任何任务消息。如果一个工作者（worker）挂掉了，我们希望该消息会重新发送给其他的工作者（worker）。</p>
<p>为了防止消息丢失，RabbitMQ提供了** 消息响应（message acknowledgments）**机制。消费者会通过一个ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ才会释放并删除这条消息。</p>
<p>如果消费者（consumer）挂掉了，没有发送响应，RabbitMQ就会认为消息没有被完全处理，然后重新发送给其他消费者（consumer）。这样，即使工作者（workers）偶尔的挂掉，也不会丢失消息。</p>
<p>消息是没有超时这个概念的；当工作者与它断开连的时候，RabbitMQ会重新发送消息。这样在处理一个耗时非常长的消息任务的时候就不会出问题了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMqDemo.Receive</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.实例化连接工厂</span></span><br><span class="line">            <span class="comment">// 加证书</span></span><br><span class="line">            <span class="comment">//ConnectionFactory factory = new ConnectionFactory()</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">            <span class="comment">//    UserName = &quot;admin&quot;,</span></span><br><span class="line">            <span class="comment">//    Password = &quot;admin&quot;,</span></span><br><span class="line">            <span class="comment">//    Ssl = new SslOption()</span></span><br><span class="line">            <span class="comment">//    &#123;</span></span><br><span class="line">            <span class="comment">//        CertPath = @&quot;E:\git\RabbitMqDemo\RabbitMqDemo.Receive\server.pfx&quot;,</span></span><br><span class="line">            <span class="comment">//        CertPassphrase = &quot;123123&quot;,</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//        AcceptablePolicyErrors = SslPolicyErrors.RemoteCertificateNameMismatch |</span></span><br><span class="line">            <span class="comment">//                                    SslPolicyErrors.RemoteCertificateChainErrors,</span></span><br><span class="line">            <span class="comment">//        Enabled = true</span></span><br><span class="line">            <span class="comment">//    &#125;,</span></span><br><span class="line">            <span class="comment">//    //AuthMechanisms = new AuthMechanismFactory[] &#123; new ExternalMechanismFactory() &#125;,</span></span><br><span class="line">            <span class="comment">//    RequestedHeartbeat = 60,</span></span><br><span class="line">            <span class="comment">//    Port = 5673</span></span><br><span class="line">            <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">                Port = <span class="number">5672</span>,</span><br><span class="line">                TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 建立连接</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//3. 创建信道</span></span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//4. 申明队列</span></span><br><span class="line">                    channel.QueueDeclare(queue: <span class="string">&quot;test1&quot;</span>, durable: <span class="literal">true</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line">                    channel.BasicQos(prefetchSize: <span class="number">0</span>, prefetchCount: <span class="number">1</span>, <span class="keyword">global</span>: <span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//5. 构造消费者实例</span></span><br><span class="line">                    <span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line">                    <span class="comment">//6. 绑定消息接收后的事件委托</span></span><br><span class="line">                    consumer.Received += (model, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> message = Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class="line">                        <span class="comment">// TODO 注：耗时过长（测试使用5000）,，使用证书模式手动确认会报错，原因不明</span></span><br><span class="line">                        Thread.Sleep(<span class="number">2000</span>);<span class="comment">//模拟耗时 </span></span><br><span class="line">                        Console.WriteLine(<span class="string">&quot; [x] Done &#123;0&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 发送消息确认信号（手动消息确认）</span></span><br><span class="line">                        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: <span class="literal">false</span>);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">//7. 启动消费者</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     autoAck:true；自动进行消息确认</span></span><br><span class="line"><span class="comment">                     autoAck:false；关闭自动消息确认，通过调用BasicAck方法手动进行消息确认</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//channel.BasicConsume(queue: &quot;test1&quot;, autoAck: true, consumer: consumer);</span></span><br><span class="line">                    channel.BasicConsume(queue: <span class="string">&quot;test1&quot;</span>, autoAck: <span class="literal">false</span>, consumer: consumer);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>消息确认确保了即使消费端异常，消息也不会丢失能够被重新分发处理。但是如果RabbitMQ服务端异常，消息依然会丢失。除非我们指定durable:true，否则当RabbitMQ退出或奔溃时，消息将依然会丢失。通过指定durable:true，并指定Persistent=true，来告知RabbitMQ将消息持久化。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMqDemo.Send</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) =&gt; <span class="literal">true</span>;</span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">                Ssl = <span class="keyword">new</span> SslOption()</span><br><span class="line">                &#123;</span><br><span class="line">                    CertPath = <span class="string">@&quot;E:\git\RabbitMqDemo\RabbitMqDemo.Send\server.pfx&quot;</span>,</span><br><span class="line">                    CertPassphrase = <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">                    AcceptablePolicyErrors = SslPolicyErrors.RemoteCertificateNameMismatch |</span><br><span class="line">                                                SslPolicyErrors.RemoteCertificateChainErrors,</span><br><span class="line">                    Enabled = <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//AuthMechanisms = new AuthMechanismFactory[] &#123; new ExternalMechanismFactory() &#125;,</span></span><br><span class="line">                RequestedHeartbeat = <span class="number">60</span>,</span><br><span class="line">                Port = <span class="number">5673</span>,</span><br><span class="line">                TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建connection</span></span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 创建一个channel信道</span></span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//将消息标记为持久性 - 将IBasicProperties.SetPersistent设置为true</span></span><br><span class="line">                    <span class="keyword">var</span> properties = channel.CreateBasicProperties();</span><br><span class="line">                    properties.Persistent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 申明队列 durable:是否持久化</span></span><br><span class="line">                    <span class="keyword">var</span> result = channel.QueueDeclare(queue: <span class="string">&quot;test1&quot;</span>, durable: <span class="literal">true</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;<span class="number">21</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//构建byte消息数据包</span></span><br><span class="line">                        <span class="keyword">var</span> body = Encoding.UTF8.GetBytes(i.ToString() + <span class="string">&quot;test&quot;</span>);</span><br><span class="line">                        channel.BasicPublish(exchange: <span class="string">&quot;&quot;</span>, routingKey: <span class="string">&quot;test1&quot;</span>, basicProperties: properties, body: body);</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;&#123;0&#125; 推送成功&quot;</span>, i);</span><br><span class="line">                        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，将消息设置为持久化并不能完全保证消息不丢失。虽然他告诉RabbitMQ将消息保存到磁盘上，但是在RabbitMQ接收到消息和将其保存到磁盘上这之间仍然有一个小的时间窗口。 RabbitMQ 可能只是将消息保存到了缓存中，并没有将其写入到磁盘上。持久化是不能够一定保证的，但是对于一个简单任务队列来说已经足够。如果需要消息队列持久化的强保证，可以使用<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/confirms.html">publisher confirms</a></p>
<h3 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h3><p>RabbitMQ的消息分发默认按照消费端的数量，按顺序循环分发。这样仅是确保了消费端被平均分发消息的数量，但却忽略了消费端的闲忙情况。这就可能出现某个消费端一直处理耗时任务处于阻塞状态，某个消费端一直处理一般任务处于空置状态，而只是它们分配的任务数量一样。</p>
<p><img src="/img/2799767-d2bb1f2ac63fdb15.png" alt="2799767-d2bb1f2ac63fdb15.png"></p>
<p>但我们可以通过<code>channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);</code><br>设置<code>prefetchCount : 1</code>来告知RabbitMQ，在未收到消费端的消息确认时，不再分发消息，也就确保了当消费端处于忙碌状态时，不再分配任务。</p>
<p>消费者Receive代码:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明队列</span></span><br><span class="line">channel.QueueDeclare(queue: <span class="string">&quot;test1&quot;</span>, durable: <span class="literal">true</span>, exclusive: <span class="literal">false</span>, autoDelete: <span class="literal">false</span>, arguments: <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置prefetchCount : 1来告知RabbitMQ，在未收到消费端的消息确认时，不再分发消息，也就确保了当消费端处于忙碌状态时</span></span><br><span class="line">channel.BasicQos(prefetchSize: <span class="number">0</span>, prefetchCount: <span class="number">1</span>, <span class="keyword">global</span>: <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>这时你需要注意的是如果所有的消费端都处于忙碌状态，你的队列可能会被塞满。你需要注意这一点，要么添加更多的消费端，要么采取其他策略。</p>
<h2 id="几种-Exchange-模式"><a href="#几种-Exchange-模式" class="headerlink" title="几种 Exchange 模式"></a>几种 Exchange 模式</h2><p>AMQP协议中的核心思想就是生产者和消费者隔离，生产者从不直接将消息发送给队列。生产者通常不知道是否一个消息会被发送到队列中，只是将消息发送到一个交换机。先由Exchange来接收，然后Exchange按照特定的策略转发到Queue进行存储。同理，消费者也是如此。Exchange 就类似于一个交换机，转发各个消息分发到相应的队列中。</p>
<p>RabbitMQ提供了Exchange，它类似于路由器的功能，它用于对消息进行路由，将消息发送到多个队列上。Exchange一方面从生产者接收消息，另一方面将消息推送到队列。但exchange必须知道如何处理接收到的消息，是将其附加到特定队列还是附加到多个队列，还是直接忽略。而这些规则由exchange type定义，exchange的原理如下图所示。</p>
<p><img src="/img/2799767-0b4fba202e525745.png" alt="2799767-0b4fba202e525745.png"></p>
<h3 id="Exchange分类"><a href="#Exchange分类" class="headerlink" title="Exchange分类"></a>Exchange分类</h3><p>RabbitMQ的Exchange（交换器）分为四类：</p>
<ul>
<li><strong>direct</strong>：默认；明确的路由规则：消费端绑定的队列名称必须和消息发布时指定的路由名称一致</li>
<li><strong>fanout</strong>： 消息广播，将消息分发到exchange上绑定的所有队列上</li>
<li><strong>topic</strong>：模式匹配的路由规则：支持通配符</li>
<li><strong>headers</strong>：不常用，允许你匹配AMQP消息的header而非路由键，除此之外headers交换器和direct交换器完全一致，但性能却很差，几乎用不到</li>
</ul>
<p><strong>注意：</strong> fanout、topic交换器是没有历史数据的，也就是说对于中途创建的队列，获取不到之前的消息。</p>
<h4 id="1，direct"><a href="#1，direct" class="headerlink" title="1，direct"></a>1，direct</h4><p>路由机制如下图，即队列名称和消息发送时指定的路由完全匹配时，消息才会发送到指定队列上。</p>
<p>routingKey =&gt; direct exchange =&gt; queue</p>
<p><img src="/img/2799767-6c78ab57fe06c6ce.png" alt="2799767-6c78ab57fe06c6ce.png"></p>
<p>生产者Send代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">&#123;</span><br><span class="line">    UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">    Ssl = <span class="keyword">new</span> SslOption()</span><br><span class="line">    &#123;</span><br><span class="line">        CertPath = <span class="string">@&quot;E:\git\RabbitMqDemo\RabbitMqDemo.Send\server.pfx&quot;</span>,</span><br><span class="line">        CertPassphrase = <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">        AcceptablePolicyErrors = SslPolicyErrors.RemoteCertificateNameMismatch |</span><br><span class="line">                                    SslPolicyErrors.RemoteCertificateChainErrors,</span><br><span class="line">        Enabled = <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//AuthMechanisms = new AuthMechanismFactory[] &#123; new ExternalMechanismFactory() &#125;,</span></span><br><span class="line">    RequestedHeartbeat = <span class="number">60</span>,</span><br><span class="line">    Port = <span class="number">5673</span>,</span><br><span class="line">    TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建connection </span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个channel信道</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        channel.ExchangeDeclare(exchange: <span class="string">&quot;directEC&quot;</span>, type: <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将消息标记为持久性 - 将IBasicProperties.SetPersistent设置为true</span></span><br><span class="line">        <span class="keyword">var</span> properties = channel.CreateBasicProperties();</span><br><span class="line">        properties.Persistent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建byte消息数据包</span></span><br><span class="line">            <span class="keyword">var</span> body = Encoding.UTF8.GetBytes(i.ToString() + <span class="string">&quot;test&quot;</span>);</span><br><span class="line">            channel.BasicPublish(exchange: <span class="string">&quot;directEC&quot;</span>, routingKey: <span class="string">&quot;direct-key&quot;</span>, basicProperties: <span class="literal">null</span>, body: body);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; 推送成功&quot;</span>, i);</span><br><span class="line">            <span class="comment">//Thread.Sleep(2000);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者Receive代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">&#123;</span><br><span class="line">    UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">    Port = <span class="number">5672</span>,</span><br><span class="line">    TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  建立连接</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  创建信道</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//申明direct类型exchange</span></span><br><span class="line">        channel.ExchangeDeclare(exchange: <span class="string">&quot;directEC&quot;</span>, type: <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> queueName = channel.QueueDeclare().QueueName;</span><br><span class="line">        channel.QueueBind(queue: queueName, exchange: <span class="string">&quot;directEC&quot;</span>, routingKey: <span class="string">&quot;direct-key&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  绑定消息接收后的事件委托</span></span><br><span class="line">        consumer.Received += (model, ea) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// var body = ea.Body;涉及到闭包，必须赋予变量</span></span><br><span class="line">            <span class="keyword">var</span> body = ea.Body;</span><br><span class="line">            <span class="keyword">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot; [x] Done1 &#123;0&#125;&quot;</span>, message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.BasicConsume(queue: queueName,</span><br><span class="line">                             autoAck: <span class="literal">true</span>,</span><br><span class="line">                             consumer: consumer);</span><br><span class="line">        <span class="comment">//channel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer);</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.ReadLine(); <span class="comment">// 必须存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，fanout"><a href="#2，fanout" class="headerlink" title="2，fanout"></a>2，fanout</h4><p>发布/订阅模式</p>
<p>fanout的路由机制如下图，即发送到 fanout 类型exchange的消息都会分发到所有绑定该exchange的队列上去。</p>
<p><img src="/img/2799767-3afd7b874221a9a2.png" alt="2799767-3afd7b874221a9a2.png"></p>
<p>生产者Send代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建connection </span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个channel信道</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        channel.ExchangeDeclare(exchange: <span class="string">&quot;fanoutEC&quot;</span>, type: <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将消息标记为持久性 - 将IBasicProperties.SetPersistent设置为true</span></span><br><span class="line">        <span class="keyword">var</span> properties = channel.CreateBasicProperties();</span><br><span class="line">        properties.Persistent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建byte消息数据包</span></span><br><span class="line">            <span class="keyword">var</span> body = Encoding.UTF8.GetBytes(i.ToString() + <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发布到指定exchange，fanout类型无需指定routingKey</span></span><br><span class="line">            channel.BasicPublish(exchange: <span class="string">&quot;fanoutEC&quot;</span>, routingKey: <span class="string">&quot;&quot;</span>, basicProperties: properties, body: body);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; 推送成功&quot;</span>, i);</span><br><span class="line">            <span class="comment">//Thread.Sleep(2000);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者Receive代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  建立连接</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  创建信道</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> channel = connection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//申明direct类型exchange</span></span><br><span class="line">        channel.ExchangeDeclare(exchange: <span class="string">&quot;fanoutEC&quot;</span>, type: <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> queueName = channel.QueueDeclare().QueueName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到指定fanout类型exchange，无需指定路由键</span></span><br><span class="line">        channel.QueueBind(queue: queueName, exchange: <span class="string">&quot;fanoutEC&quot;</span>, routingKey: <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> consumer = <span class="keyword">new</span> EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  绑定消息接收后的事件委托</span></span><br><span class="line">        consumer.Received += (model, ea) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// var body = ea.Body;涉及到闭包，必须赋予变量</span></span><br><span class="line">            <span class="keyword">var</span> body = ea.Body;</span><br><span class="line">            <span class="keyword">var</span> message = Encoding.UTF8.GetString(body);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot; [x] Received &#123;0&#125;&quot;</span>, message);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot; [x] Done1 &#123;0&#125;&quot;</span>, message);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.BasicConsume(queue: queueName,</span><br><span class="line">                             autoAck: <span class="literal">true</span>,</span><br><span class="line">                             consumer: consumer);</span><br><span class="line">        <span class="comment">//channel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer);</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot; Press [enter] to exit.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Console.ReadLine(); <span class="comment">// 必须存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3，topic"><a href="#3，topic" class="headerlink" title="3，topic"></a>3，topic</h4><p>匹配订阅模式</p>
<p>topic是direct的升级版，是一种模式匹配的路由机制。它支持使用两种通配符来进行模式匹配：符号<code>#</code>和符号<code>*</code>。其中<code>*</code>匹配一个单词， <code>#</code>则表示匹配0个或多个单词，单词之间用<code>.</code>分割。如下图所示。</p>
<p><img src="/img/2799767-3196a1c3880b3466.png" alt="2799767-3196a1c3880b3466.png"></p>
<p>生产者Send代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成随机队列名称</span></span><br><span class="line"><span class="keyword">var</span> queueName = channel.QueueDeclare().QueueName;</span><br><span class="line"><span class="comment">//使用topic exchange type，指定exchange名称</span></span><br><span class="line">channel.ExchangeDeclare(exchange: <span class="string">&quot;topicEC&quot;</span>, type: <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello Rabbit!&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"><span class="comment">//发布到topic类型exchange，必须指定routingKey</span></span><br><span class="line">channel.BasicPublish(exchange: <span class="string">&quot;topicEC&quot;</span>, routingKey: <span class="string">&quot;first.green.fast&quot;</span>, basicProperties: <span class="literal">null</span>, body: body);</span><br></pre></td></tr></table></figure>

<p>消费者Receive代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申明topic类型exchange</span></span><br><span class="line">channel.ExchangeDeclare (exchange: <span class="string">&quot;topicEC&quot;</span>, type: <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//申明随机队列名称</span></span><br><span class="line"><span class="keyword">var</span> queuename = channel.QueueDeclare ().QueueName;</span><br><span class="line"><span class="comment">//绑定队列到topic类型exchange，需指定路由键routingKey</span></span><br><span class="line">channel.QueueBind (queue : queuename, exchange: <span class="string">&quot;topicEC&quot;</span>, routingKey: <span class="string">&quot;#.*.fast&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<p><img src="/img/python-six.png" alt="python-six.png"></p>
<p><img src="/img/45366c44f775abfd0ac3b43bccc1abc3_hd.jpg" alt="45366c44f775abfd0ac3b43bccc1abc3_hd.jpg"></p>
<p>项目：<a target="_blank" rel="noopener" href="https://github.com/syxdevcode/RabbitMqDemo.git">https://github.com/syxdevcode/RabbitMqDemo.git</a></p>
<p>参考官网：</p>
<p><a target="_blank" rel="noopener" href="http://www.rabbitmq.com/tutorials/tutorial-six-dotnet.html">http://www.rabbitmq.com/tutorials/tutorial-six-dotnet.html</a></p>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。</p>
<p>死信，在官网中对应的单词为 <code>Dead Letter</code>，死信 是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况，该消息将成为死信：</p>
<ul>
<li>消息被否定确认，使用 <code>channel.basicNack</code> 或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>。</li>
<li>消息在队列的存活时间超过设置的TTL时间。</li>
<li>消息队列的消息数量已经超过最大队列长度。</li>
</ul>
<p>死信消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p>
<h3 id="配置死信队列"><a href="#配置死信队列" class="headerlink" title="配置死信队列"></a>配置死信队列</h3><p>步骤：</p>
<ul>
<li>1，配置业务队列，绑定到业务交换机上</li>
<li>2，为业务队列配置死信交换机和路由key</li>
<li>3，为死信交换机配置死信队列</li>
</ul>
<p>注意，并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。</p>
<p>有了死信交换机和路由key后，接下来，就像配置业务队列一样，配置死信队列，然后绑定在死信交换机上。也就是说，死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。</p>
<p>死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。</p>
<p>一般来说，会为每个业务队列分配一个独有的路由key，并对应的配置一个死信队列进行监听，也就是说，一般会为每个重要的业务队列配置一个死信队列。</p>
<h3 id="死信消息的变化"><a href="#死信消息的变化" class="headerlink" title="死信消息的变化"></a>死信消息的变化</h3><p>那么死信被丢到死信队列中后，会发生什么变化呢？</p>
<p>如果队列配置了参数 <code>x-dead-letter-routing-key</code> 的话，死信的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。</p>
<p>举个栗子：</p>
<p>如果原有消息的路由key是testA，被发送到业务Exchage中，然后被投递到业务队列QueueA中，如果该队列没有配置参数<code>x-dead-letter-routing-key</code>，则该消息成为死信后，将保留原有的路由keytestA，如果配置了该参数，并且值设置为testB，那么该消息成为死信后，路由key将会被替换为testB，然后被抛到死信交换机中。</p>
<p>另外，由于被抛到了死信交换机，所以消息的Exchange Name也会被替换为死信交换机的名称。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>死信队列其实并没有什么神秘的地方，不过是绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。</p>
<p>总结一下死信消息的生命周期：</p>
<ul>
<li>业务消息被投入业务队列</li>
<li>消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作</li>
<li>被nck或reject的消息由RabbitMQ投递到死信交换机中</li>
<li>死信交换机将消息投入相应的死信队列</li>
<li>死信队列的消费者消费死信消息</li>
</ul>
<p>死信消息是RabbitMQ为我们做的一层保证，其实我们也可以不使用死信队列，而是在消息消费异常时，将消息主动投递到另一个交换机中，当你明白了这些之后，这些Exchange和Queue想怎样配合就能怎么配合。比如从死信队列拉取消息，然后发送邮件、短信、钉钉通知来通知开发人员关注。或者将消息重新投递到一个队列然后设置过期时间，来进行延时消费。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.rabbitmq.com/getstarted.html">RabbitMQ Tutorials</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhangweizhong/p/5687457.html">RabbitMQ学习系列（一）: 介绍</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhangweizhong/p/5713874.html">RabbitMQ学习系列（四）: 几种Exchange 模式</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/sheng-jie/p/7192690.html">RabbitMQ知多少</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vipstone/p/9275256.html">深入解读RabbitMQ工作原理及简单使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vipstone/p/9295625.html">RabbitMQ交换器Exchange介绍与实践</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1463065">【RabbitMQ】一文带你搞定RabbitMQ死信队列</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/DotNet/" rel="tag"><i class="fa fa-tag"></i> DotNet</a>
              <a href="/tags/CSharp/" rel="tag"><i class="fa fa-tag"></i> CSharp</a>
              <a href="/tags/DotNetCore/" rel="tag"><i class="fa fa-tag"></i> DotNetCore</a>
              <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag"><i class="fa fa-tag"></i> 消息队列</a>
              <a href="/tags/RabbitMQ/" rel="tag"><i class="fa fa-tag"></i> RabbitMQ</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/07/09/SSL-TLS%E5%8D%8F%E8%AE%AE/" rel="prev" title="SSL/TLS协议">
      <i class="fa fa-chevron-left"></i> SSL/TLS协议
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/07/17/Moq%E6%B5%8B%E8%AF%95-Net-Core%E5%BA%94%E7%94%A8/" rel="next" title="Moq测试.Net Core应用">
      Moq测试.Net Core应用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RabbitMQ%E5%AD%A6%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">RabbitMQ学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">RabbitMQ 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMQP-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.</span> <span class="nav-text">AMQP 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.</span> <span class="nav-text">RabbitMQ 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">消息发送原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-RabbitMQ"><span class="nav-number">1.5.</span> <span class="nav-text">使用 RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-number">1.5.1.</span> <span class="nav-text">工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">发送&#x2F;接收消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E5%88%86%E5%8F%91"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">轮询分发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4"><span class="nav-number">1.5.2.</span> <span class="nav-text">消息确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">1.5.3.</span> <span class="nav-text">消息持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91"><span class="nav-number">1.5.4.</span> <span class="nav-text">公平分发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D-Exchange-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">几种 Exchange 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchange%E5%88%86%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">Exchange分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%8Cdirect"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">1，direct</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%BC%8Cfanout"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">2，fanout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%EF%BC%8Ctopic"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">3，topic</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC"><span class="nav-number">1.6.2.</span> <span class="nav-text">RPC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">1.7.</span> <span class="nav-text">死信队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">1.7.1.</span> <span class="nav-text">配置死信队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.7.2.</span> <span class="nav-text">死信消息的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="syxdevcode"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description">syxdevcode的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">539</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">136</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">203</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:12</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
