
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Redis内存模型 | syxdevcode博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="syxdevcode">
    
    <meta name="description" content="本文转载深入学习Redis（1）：Redis内存模型
这篇文章主要介绍Redis的内存模型（以3.0为例），包括Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器(jemalloc)、简单动态字符串(SDS)、RedisObject等；然后在此基础上介绍几个Redis内">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="syxdevcode博客" title="syxdevcode博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="syxdevcode博客">syxdevcode博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/tags">tags</a></li>
					
						<li><a href="/categories">categories</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:syxdevcode.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/11/Redis内存模型/" title="Redis内存模型" itemprop="url">Redis内存模型</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://syxdevcode.github.com" title="syxdevcode">syxdevcode</a>
    </p>
  <p class="article-time">
    <time datetime="2018-06-11T14:02:41.000Z" itemprop="datePublished">2018-06-11</time>
    更新日期:<time datetime="2020-08-04T09:53:04.357Z" itemprop="dateModified">2020-08-04</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Redis内存统计"><span class="toc-number">1.</span> <span class="toc-text">一、Redis内存统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Redis内存划分"><span class="toc-number">2.</span> <span class="toc-text">二、Redis内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、数据"><span class="toc-number">2.1.</span> <span class="toc-text">1、数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、进程本身运行需要的内存"><span class="toc-number">2.2.</span> <span class="toc-text">2、进程本身运行需要的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、缓冲内存"><span class="toc-number">2.3.</span> <span class="toc-text">3、缓冲内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、内存碎片"><span class="toc-number">2.4.</span> <span class="toc-text">4、内存碎片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Redis数据存储的细节"><span class="toc-number">3.</span> <span class="toc-text">三、Redis数据存储的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、概述"><span class="toc-number">3.1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、jemalloc"><span class="toc-number">3.2.</span> <span class="toc-text">2、jemalloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、redisObject"><span class="toc-number">3.3.</span> <span class="toc-text">3、redisObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）type"><span class="toc-number">3.3.1.</span> <span class="toc-text">（1）type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）encoding"><span class="toc-number">3.3.2.</span> <span class="toc-text">（2）encoding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）lru"><span class="toc-number">3.3.3.</span> <span class="toc-text">（3）lru</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（4）refcount"><span class="toc-number">3.3.4.</span> <span class="toc-text">（4）refcount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（5）ptr"><span class="toc-number">3.3.5.</span> <span class="toc-text">（5）ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（6）总结"><span class="toc-number">3.3.6.</span> <span class="toc-text">（6）总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、SDS"><span class="toc-number">3.4.</span> <span class="toc-text">4、SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）SDS结构"><span class="toc-number">3.4.1.</span> <span class="toc-text">（1）SDS结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SDS与C字符串的应用"><span class="toc-number">3.4.2.</span> <span class="toc-text">(2)SDS与C字符串的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Redis的对象类型与内部编码"><span class="toc-number">4.</span> <span class="toc-text">四、Redis的对象类型与内部编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、字符串"><span class="toc-number">4.1.</span> <span class="toc-text">1、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况"><span class="toc-number">4.1.1.</span> <span class="toc-text">（1）概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）内部编码"><span class="toc-number">4.1.2.</span> <span class="toc-text">（2）内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）编码转换"><span class="toc-number">4.1.3.</span> <span class="toc-text">（3）编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、列表"><span class="toc-number">4.2.</span> <span class="toc-text">2、列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）列表概况"><span class="toc-number">4.2.1.</span> <span class="toc-text">（1）列表概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）列表内部编码"><span class="toc-number">4.2.2.</span> <span class="toc-text">（2）列表内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）列表编码转换"><span class="toc-number">4.2.3.</span> <span class="toc-text">（3）列表编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、哈希"><span class="toc-number">4.3.</span> <span class="toc-text">3、哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">（1）概况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（3）编码转换-1"><span class="toc-number">4.4.</span> <span class="toc-text">（3）编码转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、集合"><span class="toc-number">4.5.</span> <span class="toc-text">4、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况-2"><span class="toc-number">4.5.1.</span> <span class="toc-text">（1）概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）内部编码-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">（2）内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）编码转换-2"><span class="toc-number">4.5.3.</span> <span class="toc-text">（3）编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、有序集合"><span class="toc-number">4.6.</span> <span class="toc-text">5、有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况-3"><span class="toc-number">4.6.1.</span> <span class="toc-text">（1）概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）内部编码-2"><span class="toc-number">4.6.2.</span> <span class="toc-text">（2）内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）编码转换-3"><span class="toc-number">4.6.3.</span> <span class="toc-text">（3）编码转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、应用举例"><span class="toc-number">5.</span> <span class="toc-text">五、应用举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、估算Redis内存使用量"><span class="toc-number">5.1.</span> <span class="toc-text">1、估算Redis内存使用量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、优化内存占用"><span class="toc-number">5.2.</span> <span class="toc-text">2、优化内存占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、关注内存碎片率"><span class="toc-number">5.3.</span> <span class="toc-text">3、关注内存碎片率</span></a></li></ol></li></ol>
		</div>
		
		<p>本文转载<a href="http://www.cnblogs.com/kismetv/p/8654978.html" target="_blank" rel="noopener">深入学习Redis（1）：Redis内存模型</a></p>
<p>这篇文章主要介绍Redis的内存模型（以3.0为例），包括Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器(jemalloc)、简单动态字符串(SDS)、RedisObject等；然后在此基础上介绍几个Redis内存模型的应用。</p>
<h2 id="一、Redis内存统计"><a href="#一、Redis内存统计" class="headerlink" title="一、Redis内存统计"></a>一、Redis内存统计</h2><p>在客户端通过redis-cli连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过info命令可以查看内存使用情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; info memory</span><br><span class="line"># Memory</span><br><span class="line">used_memory:848344</span><br><span class="line">used_memory_human:828.46K</span><br><span class="line">used_memory_rss:7520256</span><br><span class="line">used_memory_rss_human:7.17M</span><br><span class="line">used_memory_peak:848344</span><br><span class="line">used_memory_peak_human:828.46K</span><br><span class="line">used_memory_peak_perc:100.01%</span><br><span class="line">used_memory_overhead:836086</span><br><span class="line">used_memory_startup:786456</span><br><span class="line">used_memory_dataset:12258</span><br><span class="line">used_memory_dataset_perc:19.81%</span><br><span class="line">total_system_memory:1910714368</span><br><span class="line">total_system_memory_human:1.78G</span><br></pre></td></tr></table></figure>

<p>其中，info命令可以显示redis服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；memory是参数，表示只显示内存相关的信息。</p>
<p>返回结果中比较重要的几个说明如下：</p>
<p>（1）** used_memory**：Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。</p>
<p>（2）** used_memory_rss**：Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。</p>
<p>因此，used_memory和used_memory_rss，前者是从Redis角度得到的量，后者是从操作系统角度得到的量。二者之所以有所不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。</p>
<p>由于在实际应用中，Redis的数据量会比较大，此时进程运行占用的内存与Redis数据量和内存碎片相比，都会小得多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片率的参数；这个参数就是mem_fragmentation_ratio。</p>
<p>（3）** mem_fragmentation_ratio**：内存碎片比率，该值是used_memory_rss / used_memory的比值。</p>
<p>mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。mem_fragmentation_ratio&lt;1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。</p>
<p>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；</p>
<p>（4）** mem_allocator**：Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。</p>
<h2 id="二、Redis内存划分"><a href="#二、Redis内存划分" class="headerlink" title="二、Redis内存划分"></a>二、Redis内存划分</h2><p>Redis的内存占用主要可以划分为以下几个部分：</p>
<h3 id="1、数据"><a href="#1、数据" class="headerlink" title="1、数据"></a>1、数据</h3><p>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。</p>
<p>Redis使用键值对存储数据，其中的值（对象）包括5种类型，即字符串、哈希、列表、集合、有序集合。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；这篇文章后面将重点介绍Redis中数据存储的细节。</p>
<h3 id="2、进程本身运行需要的内存"><a href="#2、进程本身运行需要的内存" class="headerlink" title="2、进程本身运行需要的内存"></a>2、进程本身运行需要的内存</h3><p>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。</p>
<p>补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。</p>
<h3 id="3、缓冲内存"><a href="#3、缓冲内存" class="headerlink" title="3、缓冲内存"></a>3、缓冲内存</h3><p>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。</p>
<h3 id="4、内存碎片"><a href="#4、内存碎片" class="headerlink" title="4、内存碎片"></a>4、内存碎片</h3><p>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。</p>
<p>内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。</p>
<p>如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。</p>
<h2 id="三、Redis数据存储的细节"><a href="#三、Redis数据存储的细节" class="headerlink" title="三、Redis数据存储的细节"></a>三、Redis数据存储的细节</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。</p>
<p>下图是执行set hello world时，所涉及到的数据模型。</p>
<p><img src="/img/1174710-20180327001055927-1896197804.png" alt="1174710-20180327001055927-1896197804.png"></p>
<p>图片来源：<a href="https://searchdatabase.techtarget.com.cn/7-20218/" target="_blank" rel="noopener">https://searchdatabase.techtarget.com.cn/7-20218/</a></p>
<p>（1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。</p>
<p>（2）Key：图中右上角可见，Key（”hello”）并不是直接以字符串存储，而是存储在SDS结构中。</p>
<p>（3）redisObject：Value(“world”)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。</p>
<p>实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。</p>
<p>（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。</p>
<p>下面来分别介绍jemalloc、redisObject、SDS、对象类型及内部编码。</p>
<h3 id="2、jemalloc"><a href="#2、jemalloc" class="headerlink" title="2、jemalloc"></a>2、jemalloc</h3><p>Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。</p>
<p>jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p>
<p>jemalloc划分的内存单元如下图所示：</p>
<p><img src="/img/1174710-20180327001126509-2023165562.png" alt="1174710-20180327001126509-2023165562.png"></p>
<p>图片来源：<a href="http://blog.csdn.net/zhengpeitao/article/details/76573053" target="_blank" rel="noopener">http://blog.csdn.net/zhengpeitao/article/details/76573053</a></p>
<p>例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。</p>
<h3 id="3、redisObject"><a href="#3、redisObject" class="headerlink" title="3、redisObject"></a>3、redisObject</h3><p>前面说到，Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。</p>
<p>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，下面将通过redisObject的结构来说明它是如何起作用的。</p>
<p>redisObject的定义如下（不同版本的Redis可能稍稍有所不同）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">　　unsigned type:4;</span><br><span class="line">　　unsigned encoding:4;</span><br><span class="line">　　unsigned lru:REDIS_LRU_BITS; &#x2F;* lru time (relative to server.lruclock) *&#x2F;</span><br><span class="line">　　int refcount;</span><br><span class="line">　　void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>redisObject的每个字段的含义和作用如下：</p>
<h4 id="（1）type"><a href="#（1）type" class="headerlink" title="（1）type"></a>（1）type</h4><p>type字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。</p>
<p>当我们执行type命令时，便是通过读取RedisObject的type字段获得对象的类型；如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set mystring helloredis</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; type mystring</span><br><span class="line">string</span><br><span class="line">172.19.0.2:6380&gt; sadd myset member1 member2 member3</span><br><span class="line">(integer) 3</span><br><span class="line">172.19.0.2:6380&gt; type myset</span><br><span class="line">set</span><br></pre></td></tr></table></figure>

<h4 id="（2）encoding"><a href="#（2）encoding" class="headerlink" title="（2）encoding"></a>（2）encoding</h4><p>encoding表示对象的内部编码，占4个比特。</p>
<p>对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。以列表对象为例，有压缩列表和双端链表两种编码方式；如果列表中的元素较少，Redis倾向于使用压缩列表进行存储，因为压缩列表占用内存更少，而且比双端链表可以更快载入；当列表对象元素较多时，压缩列表就会转化为更适合存储大量元素的双端链表。</p>
<p>通过object encoding命令，可以查看对象采用的编码方式，如所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set key1 33</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;int&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key2 helloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<h4 id="（3）lru"><a href="#（3）lru" class="headerlink" title="（3）lru"></a>（3）lru</h4><p>lru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。</p>
<p>通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 540</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 541</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 547</span><br><span class="line">172.19.0.2:6380&gt; get mystring</span><br><span class="line">&quot;helloredis&quot;</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br></pre></td></tr></table></figure>

<p>lru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。</p>
<h4 id="（4）refcount"><a href="#（4）refcount" class="headerlink" title="（4）refcount"></a>（4）refcount</h4><p>** refcount与共享对象**</p>
<p>refcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。</p>
<p>Redis中被多次使用的对象(refcount&gt;1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。</p>
<p>** 共享对象的具体实现 **</p>
<p>Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。</p>
<p>虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。</p>
<p>就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0<del>9999的整数值；当Redis需要使用值为0</del>9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。</p>
<h4 id="（5）ptr"><a href="#（5）ptr" class="headerlink" title="（5）ptr"></a>（5）ptr</h4><p>ptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>综上所述，redisObject的结构与对象类型、编码、内存回收、共享对象都有关系；一个redisObject对象的大小为16字节：</p>
<p>4bit+4bit+24bit+4Byte+8Byte=16Byte。</p>
<h3 id="4、SDS"><a href="#4、SDS" class="headerlink" title="4、SDS"></a>4、SDS</h3><p>Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。</p>
<h4 id="（1）SDS结构"><a href="#（1）SDS结构" class="headerlink" title="（1）SDS结构"></a>（1）SDS结构</h4><p>sds的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度。下面是两个例子。</p>
<p>通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。</p>
<h4 id="2-SDS与C字符串的应用"><a href="#2-SDS与C字符串的应用" class="headerlink" title="(2)SDS与C字符串的应用"></a>(2)SDS与C字符串的应用</h4><p>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（”myset”），还是集合中的元素（”member1”、 ”member2”和”member3”），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。</p>
<p>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。</p>
<h2 id="四、Redis的对象类型与内部编码"><a href="#四、Redis的对象类型与内部编码" class="headerlink" title="四、Redis的对象类型与内部编码"></a>四、Redis的对象类型与内部编码</h2><p>前面已经说过，Redis支持5种对象类型，而每种结构都有至少两种编码；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。</p>
<p>关于Redis内部编码的转换，都符合以下规律：编码转换在Redis写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。</p>
<h3 id="1、字符串"><a href="#1、字符串" class="headerlink" title="1、字符串"></a>1、字符串</h3><h4 id="（1）概况"><a href="#（1）概况" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。</p>
<p>字符串长度不能超过512MB。</p>
<h4 id="（2）内部编码"><a href="#（2）内部编码" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>字符串类型的内部编码有3种，它们的应用场景如下：</p>
<p>** int**：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。</p>
<p>** embstr**：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</p>
<p>** raw**：大于39个字节的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;int&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key2 helloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key3 helloworldhelloworldhelloworldhelloworldhelloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; strlen key3</span><br><span class="line">(integer) 50</span><br><span class="line">172.19.0.2:6380&gt; object encoding key3</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">172.19.0.2:6380&gt;</span><br></pre></td></tr></table></figure>

<p>embstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。</p>
<h4 id="（3）编码转换"><a href="#（3）编码转换" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。</p>
<p>而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set key1 hello</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">172.19.0.2:6380&gt; append key1 ,world</span><br><span class="line">(integer) 11</span><br><span class="line">172.19.0.2:6380&gt; get key1</span><br><span class="line">&quot;hello,world&quot;</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2、列表"><a href="#2、列表" class="headerlink" title="2、列表"></a>2、列表</h3><h4 id="（1）列表概况"><a href="#（1）列表概况" class="headerlink" title="（1）列表概况"></a>（1）列表概况</h4><p>列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。</p>
<h4 id="（2）列表内部编码"><a href="#（2）列表内部编码" class="headerlink" title="（2）列表内部编码"></a>（2）列表内部编码</h4><p>列表的内部编码可以是压缩列表（ziplist）或双端链表（linkedlist）。</p>
<p>双端链表：由一个list结构和多个listNode结构组成；典型结构如下图所示：</p>
<p><img src="/img/1174710-20180327001435577-242733744.png" alt="1174710-20180327001435577-242733744.png"></p>
<p>图片来源：《Redis设计与实现》</p>
<p>通过图中可以看出，双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。</p>
<p>压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。</p>
<p>压缩列表不仅用于实现列表，也用于实现哈希、有序列表；使用非常广泛。</p>
<h4 id="（3）列表编码转换"><a href="#（3）列表编码转换" class="headerlink" title="（3）列表编码转换"></a>（3）列表编码转换</h4><p>只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。</p>
<p>其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。</p>
<h3 id="3、哈希"><a href="#3、哈希" class="headerlink" title="3、哈希"></a>3、哈希</h3><h4 id="（1）概况-1"><a href="#（1）概况-1" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。为了说明的方便，在本文后面当使用“内层的哈希”时，代表的是redis对外提供的5种对象类型的一种；使用“外层的哈希”代指Redis作为Key-Value数据库所使用的数据结构。</p>
<p>#####（2）内部编码</p>
<p>内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。</p>
<p>压缩列表前面已介绍。与哈希表相比，压缩列表用于元素个数少、元素长度小的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。</p>
<p>hashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成。</p>
<p>正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：</p>
<p><img src="/img/1174710-20180327001627028-325473621.png" alt="1174710-20180327001627028-325473621.png"></p>
<p>图片改编自：《Redis设计与实现》</p>
<p>下面从底层向上依次介绍各个部分：</p>
<p>** dictEntry **</p>
<p>dictEntry结构用于保存键值对，结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">    void *key;</span><br><span class="line">    union&#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<p>其中，各个属性的功能如下：</p>
<p>key：键值对中的键；<br>val：键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型；<br>next：指向下一个dictEntry，用于解决哈希冲突问题<br>在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。</p>
<p>** bucket**</p>
<p>bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。</p>
<p>** dictht**</p>
<p>dictht结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    unsigned long size;</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<p>其中，各个属性的功能说明如下：</p>
<p>table属性是一个指针，指向bucket；<br>size属性记录了哈希表的大小，即bucket的大小；<br>used记录了已使用的dictEntry的数量；<br>sizemask属性的值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置。</p>
<p>** dict**</p>
<p>一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。</p>
<p>dict结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pedef struct dict&#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    void *privdata;</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    int trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>其中，type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。</p>
<p>ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。</p>
<p>因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。</p>
<h3 id="（3）编码转换-1"><a href="#（3）编码转换-1" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h3><p>如前所述，Redis中内层的哈希既可能使用哈希表，也可能使用压缩列表。</p>
<p>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。</p>
<p>下图展示了Redis内层的哈希编码转换的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; hset myhash k1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; hset myhash k2 v2</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">172.19.0.2:6380&gt; hset myhash k4 vvsdfsddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">172.19.0.2:6380&gt; hdel myhash k4</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">172.19.0.2:6380&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4、集合"><a href="#4、集合" class="headerlink" title="4、集合"></a>4、集合</h3><h4 id="（1）概况-2"><a href="#（1）概况-2" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。</p>
<p>一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取交集、并集、差集。</p>
<h4 id="（2）内部编码-1"><a href="#（2）内部编码-1" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。</p>
<p>哈希表前面已经讲过，这里略过不提；需要注意的是，集合在使用哈希表时，值全部被置为null。</p>
<p>整数集合的结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>其中，encoding代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的；length表示元素个数。</p>
<p>整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于集合数量较少，因此操作的时间并没有明显劣势。</p>
<h4 id="（3）编码转换-2"><a href="#（3）编码转换-2" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。</p>
<h3 id="5、有序集合"><a href="#5、有序集合" class="headerlink" title="5、有序集合"></a>5、有序集合</h3><h4 id="（1）概况-3"><a href="#（1）概况-3" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p>
<h4 id="（2）内部编码-2"><a href="#（2）内部编码-2" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。ziplist在列表和哈希中都有使用，前面已经讲过，这里略过不提。</p>
<p>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。</p>
<h4 id="（3）编码转换-3"><a href="#（3）编码转换-3" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。</p>
<h2 id="五、应用举例"><a href="#五、应用举例" class="headerlink" title="五、应用举例"></a>五、应用举例</h2><h3 id="1、估算Redis内存使用量"><a href="#1、估算Redis内存使用量" class="headerlink" title="1、估算Redis内存使用量"></a>1、估算Redis内存使用量</h3><p>要估算redis中的数据占据的内存大小，需要对redis的内存模型有比较全面的了解，包括前面介绍的hashtable、sds、redisobject、各种对象类型的编码方式等。</p>
<p>下面以最简单的字符串类型来进行说明。</p>
<p>假设有90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。在估算占据空间之前，首先可以判定字符串类型使用的编码方式：embstr。</p>
<p>90000个键值对占据的内存空间主要可以分为两部分：一部分是90000个dictEntry占据的空间；一部分是键值对所需要的bucket空间。</p>
<p>每个dictEntry占据的空间包括：</p>
<p>1) 一个dictEntry，24字节，jemalloc会分配32字节的内存块</p>
<p>2) 一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节的内存块</p>
<p>3) 一个redisObject，16字节，jemalloc会分配16字节的内存块</p>
<p>4) 一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块</p>
<p>5) 综上，一个dictEntry需要32+16+16+16=80个字节。</p>
<p>bucket空间：bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。</p>
<p>因此，可以估算出这90000个键值对占据的内存大小为：90000<em>80 + 131072</em>8 = 8248576。</p>
<h3 id="2、优化内存占用"><a href="#2、优化内存占用" class="headerlink" title="2、优化内存占用"></a>2、优化内存占用</h3><p>了解redis的内存模型，对优化redis内存占用有很大帮助。下面介绍几种优化场景。</p>
<p>（1）利用jemalloc特性进行优化</p>
<p>上一小节所讲述的90000个键值便是一个例子。由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。</p>
<p>例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p>
<p>（2）使用整型/长整型</p>
<p>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。</p>
<p>（3）共享对象</p>
<p>利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。</p>
<p>考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。</p>
<p>（4）避免过度设计</p>
<p>然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。</p>
<p>如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。</p>
<h3 id="3、关注内存碎片率"><a href="#3、关注内存碎片率" class="headerlink" title="3、关注内存碎片率"></a>3、关注内存碎片率</h3><p>内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。</p>
<p>如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p>
<p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p>
<p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Redis/">Redis</a><a href="/tags/分布式/">分布式</a><a href="/tags/缓存/">缓存</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Redis/">Redis</a>
</div>



<div class="article-share" id="share">

  <div data-url="https://syxdevcode.github.com/2018/06/11/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-title="Redis内存模型 | syxdevcode博客" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/06/12/缓存在分布式系统中的应用/" title="缓存在分布式系统中的应用">
  <strong>PREVIOUS:</strong><br/>
  <span>
  缓存在分布式系统中的应用</span>
</a>
</div>


<div class="next">
<a href="/2018/06/08/分布式之数据库和缓存双写一致性方案/"  title="分布式之数据库和缓存双写一致性方案">
 <strong>NEXT:</strong><br/> 
 <span>分布式之数据库和缓存双写一致性方案
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Redis内存统计"><span class="toc-number">1.</span> <span class="toc-text">一、Redis内存统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Redis内存划分"><span class="toc-number">2.</span> <span class="toc-text">二、Redis内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、数据"><span class="toc-number">2.1.</span> <span class="toc-text">1、数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、进程本身运行需要的内存"><span class="toc-number">2.2.</span> <span class="toc-text">2、进程本身运行需要的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、缓冲内存"><span class="toc-number">2.3.</span> <span class="toc-text">3、缓冲内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、内存碎片"><span class="toc-number">2.4.</span> <span class="toc-text">4、内存碎片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Redis数据存储的细节"><span class="toc-number">3.</span> <span class="toc-text">三、Redis数据存储的细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、概述"><span class="toc-number">3.1.</span> <span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、jemalloc"><span class="toc-number">3.2.</span> <span class="toc-text">2、jemalloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、redisObject"><span class="toc-number">3.3.</span> <span class="toc-text">3、redisObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）type"><span class="toc-number">3.3.1.</span> <span class="toc-text">（1）type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）encoding"><span class="toc-number">3.3.2.</span> <span class="toc-text">（2）encoding</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）lru"><span class="toc-number">3.3.3.</span> <span class="toc-text">（3）lru</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（4）refcount"><span class="toc-number">3.3.4.</span> <span class="toc-text">（4）refcount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（5）ptr"><span class="toc-number">3.3.5.</span> <span class="toc-text">（5）ptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（6）总结"><span class="toc-number">3.3.6.</span> <span class="toc-text">（6）总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、SDS"><span class="toc-number">3.4.</span> <span class="toc-text">4、SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）SDS结构"><span class="toc-number">3.4.1.</span> <span class="toc-text">（1）SDS结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SDS与C字符串的应用"><span class="toc-number">3.4.2.</span> <span class="toc-text">(2)SDS与C字符串的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Redis的对象类型与内部编码"><span class="toc-number">4.</span> <span class="toc-text">四、Redis的对象类型与内部编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、字符串"><span class="toc-number">4.1.</span> <span class="toc-text">1、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况"><span class="toc-number">4.1.1.</span> <span class="toc-text">（1）概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）内部编码"><span class="toc-number">4.1.2.</span> <span class="toc-text">（2）内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）编码转换"><span class="toc-number">4.1.3.</span> <span class="toc-text">（3）编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、列表"><span class="toc-number">4.2.</span> <span class="toc-text">2、列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）列表概况"><span class="toc-number">4.2.1.</span> <span class="toc-text">（1）列表概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）列表内部编码"><span class="toc-number">4.2.2.</span> <span class="toc-text">（2）列表内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）列表编码转换"><span class="toc-number">4.2.3.</span> <span class="toc-text">（3）列表编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、哈希"><span class="toc-number">4.3.</span> <span class="toc-text">3、哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">（1）概况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#（3）编码转换-1"><span class="toc-number">4.4.</span> <span class="toc-text">（3）编码转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、集合"><span class="toc-number">4.5.</span> <span class="toc-text">4、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况-2"><span class="toc-number">4.5.1.</span> <span class="toc-text">（1）概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）内部编码-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">（2）内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）编码转换-2"><span class="toc-number">4.5.3.</span> <span class="toc-text">（3）编码转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、有序集合"><span class="toc-number">4.6.</span> <span class="toc-text">5、有序集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）概况-3"><span class="toc-number">4.6.1.</span> <span class="toc-text">（1）概况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）内部编码-2"><span class="toc-number">4.6.2.</span> <span class="toc-text">（2）内部编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（3）编码转换-3"><span class="toc-number">4.6.3.</span> <span class="toc-text">（3）编码转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、应用举例"><span class="toc-number">5.</span> <span class="toc-text">五、应用举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、估算Redis内存使用量"><span class="toc-number">5.1.</span> <span class="toc-text">1、估算Redis内存使用量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、优化内存占用"><span class="toc-number">5.2.</span> <span class="toc-text">2、优化内存占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、关注内存碎片率"><span class="toc-number">5.3.</span> <span class="toc-text">3、关注内存碎片率</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Net-Standard/" title=".Net Standard">.Net Standard<sup>2</sup></a></li>
		
			<li><a href="/categories/net异步与并行/" title=".net异步与并行">.net异步与并行<sup>10</sup></a></li>
		
			<li><a href="/categories/ABP/" title="ABP">ABP<sup>27</sup></a></li>
		
			<li><a href="/categories/ASP-NET-IIS请求处理管道/" title="ASP.NET/IIS请求处理管道">ASP.NET/IIS请求处理管道<sup>2</sup></a></li>
		
			<li><a href="/categories/ApplicationPoolIdentify/" title="ApplicationPoolIdentify">ApplicationPoolIdentify<sup>1</sup></a></li>
		
			<li><a href="/categories/CSharp基础/" title="CSharp基础">CSharp基础<sup>11</sup></a></li>
		
			<li><a href="/categories/CentOS7/" title="CentOS7">CentOS7<sup>11</sup></a></li>
		
			<li><a href="/categories/Chrome/" title="Chrome">Chrome<sup>1</sup></a></li>
		
			<li><a href="/categories/CodeDOM/" title="CodeDOM">CodeDOM<sup>3</sup></a></li>
		
			<li><a href="/categories/Consul/" title="Consul">Consul<sup>3</sup></a></li>
		
			<li><a href="/categories/Docker/" title="Docker">Docker<sup>7</sup></a></li>
		
			<li><a href="/categories/Docker-Compose/" title="Docker Compose">Docker Compose<sup>3</sup></a></li>
		
			<li><a href="/categories/DotNetCore/" title="DotNetCore">DotNetCore<sup>3</sup></a></li>
		
			<li><a href="/categories/DotNet面试题解析/" title="DotNet面试题解析">DotNet面试题解析<sup>8</sup></a></li>
		
			<li><a href="/categories/EasyNetQ/" title="EasyNetQ">EasyNetQ<sup>1</sup></a></li>
		
			<li><a href="/categories/Elasticsearch/" title="Elasticsearch">Elasticsearch<sup>1</sup></a></li>
		
			<li><a href="/categories/Emit-反射发出/" title="Emit(反射发出)">Emit(反射发出)<sup>6</sup></a></li>
		
			<li><a href="/categories/Expression-Tree/" title="Expression Tree">Expression Tree<sup>2</sup></a></li>
		
			<li><a href="/categories/Git/" title="Git">Git<sup>2</sup></a></li>
		
			<li><a href="/categories/HostService/" title="HostService">HostService<sup>1</sup></a></li>
		
			<li><a href="/categories/JavaScript-JQuery/" title="JavaScript/JQuery">JavaScript/JQuery<sup>1</sup></a></li>
		
			<li><a href="/categories/Jenkins/" title="Jenkins">Jenkins<sup>2</sup></a></li>
		
			<li><a href="/categories/Jexus/" title="Jexus">Jexus<sup>1</sup></a></li>
		
			<li><a href="/categories/Json-Net/" title="Json.Net">Json.Net<sup>1</sup></a></li>
		
			<li><a href="/categories/LINQ/" title="LINQ">LINQ<sup>3</sup></a></li>
		
			<li><a href="/categories/Let’s-Encrypt/" title="Let’s Encrypt">Let’s Encrypt<sup>1</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>3</sup></a></li>
		
			<li><a href="/categories/Linux基础命令/" title="Linux基础命令">Linux基础命令<sup>8</sup></a></li>
		
			<li><a href="/categories/MSIL指令/" title="MSIL指令">MSIL指令<sup>2</sup></a></li>
		
			<li><a href="/categories/MVC-Web-API/" title="MVC/Web API">MVC/Web API<sup>2</sup></a></li>
		
			<li><a href="/categories/MariaDB/" title="MariaDB">MariaDB<sup>1</sup></a></li>
		
			<li><a href="/categories/MarkDown/" title="MarkDown">MarkDown<sup>1</sup></a></li>
		
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		
			<li><a href="/categories/Moq/" title="Moq">Moq<sup>1</sup></a></li>
		
			<li><a href="/categories/MySql/" title="MySql">MySql<sup>5</sup></a></li>
		
			<li><a href="/categories/Naudio/" title="Naudio">Naudio<sup>2</sup></a></li>
		
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>2</sup></a></li>
		
			<li><a href="/categories/Nodejs/" title="Nodejs">Nodejs<sup>3</sup></a></li>
		
			<li><a href="/categories/OAuth2-0/" title="OAuth2.0">OAuth2.0<sup>2</sup></a></li>
		
			<li><a href="/categories/Ocelot/" title="Ocelot">Ocelot<sup>1</sup></a></li>
		
			<li><a href="/categories/Openssl/" title="Openssl">Openssl<sup>2</sup></a></li>
		
			<li><a href="/categories/PAM/" title="PAM">PAM<sup>1</sup></a></li>
		
			<li><a href="/categories/Polly/" title="Polly">Polly<sup>2</sup></a></li>
		
			<li><a href="/categories/PostGresqlSql/" title="PostGresqlSql">PostGresqlSql<sup>1</sup></a></li>
		
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		
			<li><a href="/categories/RESTful/" title="RESTful">RESTful<sup>2</sup></a></li>
		
			<li><a href="/categories/RabbitMQ/" title="RabbitMQ">RabbitMQ<sup>2</sup></a></li>
		
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>7</sup></a></li>
		
			<li><a href="/categories/Resharper/" title="Resharper">Resharper<sup>1</sup></a></li>
		
			<li><a href="/categories/SSH/" title="SSH">SSH<sup>1</sup></a></li>
		
			<li><a href="/categories/SSL-TLS/" title="SSL/TLS">SSL/TLS<sup>2</sup></a></li>
		
			<li><a href="/categories/Skywalking/" title="Skywalking">Skywalking<sup>1</sup></a></li>
		
			<li><a href="/categories/Sql/" title="Sql">Sql<sup>5</sup></a></li>
		
			<li><a href="/categories/TDD/" title="TDD">TDD<sup>1</sup></a></li>
		
			<li><a href="/categories/TPL-DataFlow/" title="TPL DataFlow">TPL DataFlow<sup>2</sup></a></li>
		
			<li><a href="/categories/WCF时间类型序列化/" title="WCF时间类型序列化">WCF时间类型序列化<sup>1</sup></a></li>
		
			<li><a href="/categories/WebForm/" title="WebForm">WebForm<sup>2</sup></a></li>
		
			<li><a href="/categories/WinDbg/" title="WinDbg">WinDbg<sup>1</sup></a></li>
		
			<li><a href="/categories/WinSCP/" title="WinSCP">WinSCP<sup>1</sup></a></li>
		
			<li><a href="/categories/Windows子系统/" title="Windows子系统">Windows子系统<sup>1</sup></a></li>
		
			<li><a href="/categories/Windows系统/" title="Windows系统">Windows系统<sup>1</sup></a></li>
		
			<li><a href="/categories/ab/" title="ab">ab<sup>1</sup></a></li>
		
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>2</sup></a></li>
		
			<li><a href="/categories/idea/" title="idea">idea<sup>2</sup></a></li>
		
			<li><a href="/categories/java/" title="java">java<sup>4</sup></a></li>
		
			<li><a href="/categories/shadowsocks/" title="shadowsocks">shadowsocks<sup>1</sup></a></li>
		
			<li><a href="/categories/supervisor/" title="supervisor">supervisor<sup>2</sup></a></li>
		
			<li><a href="/categories/zookeeper/" title="zookeeper">zookeeper<sup>1</sup></a></li>
		
			<li><a href="/categories/内存泄漏/" title="内存泄漏">内存泄漏<sup>1</sup></a></li>
		
			<li><a href="/categories/分布式/" title="分布式">分布式<sup>1</sup></a></li>
		
			<li><a href="/categories/分布式事务/" title="分布式事务">分布式事务<sup>1</sup></a></li>
		
			<li><a href="/categories/单词收录/" title="单词收录">单词收录<sup>14</sup></a></li>
		
			<li><a href="/categories/反射/" title="反射">反射<sup>4</sup></a></li>
		
			<li><a href="/categories/委托与事件/" title="委托与事件">委托与事件<sup>4</sup></a></li>
		
			<li><a href="/categories/工具/" title="工具">工具<sup>1</sup></a></li>
		
			<li><a href="/categories/并发模型/" title="并发模型">并发模型<sup>1</sup></a></li>
		
			<li><a href="/categories/插件/" title="插件">插件<sup>1</sup></a></li>
		
			<li><a href="/categories/时间-时间戳转换/" title="时间/时间戳转换">时间/时间戳转换<sup>1</sup></a></li>
		
			<li><a href="/categories/消息队列/" title="消息队列">消息队列<sup>1</sup></a></li>
		
			<li><a href="/categories/程序集/" title="程序集">程序集<sup>2</sup></a></li>
		
			<li><a href="/categories/算法/" title="算法">算法<sup>3</sup></a></li>
		
			<li><a href="/categories/线性表/" title="线性表">线性表<sup>1</sup></a></li>
		
			<li><a href="/categories/线程池/" title="线程池">线程池<sup>1</sup></a></li>
		
			<li><a href="/categories/缓存/" title="缓存">缓存<sup>3</sup></a></li>
		
			<li><a href="/categories/计算机基础/" title="计算机基础">计算机基础<sup>3</sup></a></li>
		
			<li><a href="/categories/认证与授权/" title="认证与授权">认证与授权<sup>1</sup></a></li>
		
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		
			<li><a href="/categories/链表/" title="链表">链表<sup>2</sup></a></li>
		
			<li><a href="/categories/集合与泛型/" title="集合与泛型">集合与泛型<sup>4</sup></a></li>
		
			<li><a href="/categories/音频-视频/" title="音频/视频">音频/视频<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist" style="clear:both;">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Net-Standard/" title=".Net Standard">.Net Standard<sup>2</sup></a></li>
		
			<li><a href="/tags/net异步与并行/" title=".net异步与并行">.net异步与并行<sup>12</sup></a></li>
		
			<li><a href="/tags/ABP/" title="ABP">ABP<sup>27</sup></a></li>
		
			<li><a href="/tags/ASP-NET-IIS请求处理管道/" title="ASP.NET/IIS请求处理管道">ASP.NET/IIS请求处理管道<sup>7</sup></a></li>
		
			<li><a href="/tags/AWS/" title="AWS">AWS<sup>7</sup></a></li>
		
			<li><a href="/tags/ApplicationPoolIdentify/" title="ApplicationPoolIdentify">ApplicationPoolIdentify<sup>1</sup></a></li>
		
			<li><a href="/tags/CSharp/" title="CSharp">CSharp<sup>101</sup></a></li>
		
			<li><a href="/tags/CSharp基础/" title="CSharp基础">CSharp基础<sup>45</sup></a></li>
		
			<li><a href="/tags/CentOS7/" title="CentOS7">CentOS7<sup>46</sup></a></li>
		
			<li><a href="/tags/Chrome/" title="Chrome">Chrome<sup>1</sup></a></li>
		
			<li><a href="/tags/CodeDOM/" title="CodeDOM">CodeDOM<sup>3</sup></a></li>
		
			<li><a href="/tags/Consul/" title="Consul">Consul<sup>4</sup></a></li>
		
			<li><a href="/tags/Docker/" title="Docker">Docker<sup>23</sup></a></li>
		
			<li><a href="/tags/Docker-Compose/" title="Docker Compose">Docker Compose<sup>5</sup></a></li>
		
			<li><a href="/tags/DotNet/" title="DotNet">DotNet<sup>106</sup></a></li>
		
			<li><a href="/tags/DotNetCore/" title="DotNetCore">DotNetCore<sup>16</sup></a></li>
		
			<li><a href="/tags/DotNet面试题解析/" title="DotNet面试题解析">DotNet面试题解析<sup>10</sup></a></li>
		
			<li><a href="/tags/Elasticsearch/" title="Elasticsearch">Elasticsearch<sup>2</sup></a></li>
		
			<li><a href="/tags/Emit-反射发出/" title="Emit(反射发出)">Emit(反射发出)<sup>8</sup></a></li>
		
			<li><a href="/tags/Expression-Tree/" title="Expression Tree">Expression Tree<sup>3</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
<div style="display: none;" id="rocket-to-top">
  <div style="opacity: 0; display: block;" class="level-2"></div>
  <div class="level-3"></div>
</div>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		<a href="https://github.com/syxdevcode" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/syxdevcode/pacman" target="_blank" title="Pacman">Pacman</a> © 2020 
		
		<a href="https://syxdevcode.github.com" target="_blank" title="syxdevcode">syxdevcode</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>

<script type="text/javascript">
  $(document).ready(function () {
    $('.navbar').click(function () {
      $('header nav').toggleClass('shownav');
    });
    var myWidth = 0;
    function getSize() {
      if (typeof (window.innerWidth) == 'number') {
        myWidth = window.innerWidth;
      } else if (document.documentElement && document.documentElement.clientWidth) {
        myWidth = document.documentElement.clientWidth;
      };
    };
    var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
    $(window).resize(function () {
      getSize();
      if (myWidth >= 1024) {
        $('header nav').removeClass('shownav');
      } else {
        m.removeClass('moveMain');
        a.css('display', 'block').removeClass('fadeOut');
        o.css('display', 'none');
      
          $('#toc.toc-aside').css('display', 'none');
        
    }
    });
    c.click(function () {
      a.addClass('fadeOut').css('display', 'none');
      o.css('display', 'block').addClass('fadeIn');
      m.addClass('moveMain');
    });
    o.click(function () {
      o.css('display', 'none').removeClass('beforeFadeIn');
      a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
      m.removeClass('moveMain');
    });
    $(window).scroll(function () {
      o.css("top", Math.max(80, 260 - $(this).scrollTop()));
    });
  });
  //判断访问终端
  var browser = {
    versions: function () {
      var u = navigator.userAgent,
        app = navigator.appVersion;
      return {
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1,//火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Adr') > -1, //android终端
        iPhone: u.indexOf('iPhone') > -1, //是否为iPhone或者QQHD浏览器
        iPad: u.indexOf('iPad') > -1, //是否iPad
        webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') > -1, //是否微信 （2015-01-22新增）
        qq: u.match(/\sQQ/i) == " qq" //是否QQ
      };
    }(),
    language: (navigator.browserLanguage || navigator.language).toLowerCase()
  }
</script>

<script type="text/javascript">
  $(document).ready(function () {
    var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t = $('#toc'),
      h = $('article h2')
    ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o = $('.openaside'),
      c = $('.closeaside');
    if (ai.length > 0) {
      ai.wrap('<div class="video-container" />');
    };
    if (ae.length > 0) {
      ae.wrap('<div class="video-container" />');
    };
    if (ah.length == 0) {
      t.css('display', 'none');
    } else {
      c.click(function () {
        ta.css('display', 'block').addClass('fadeIn');
      });
      o.click(function () {
        ta.css('display', 'none');
      });
      $(window).scroll(function () {
        ta.css("top", Math.max(140, 320 - $(this).scrollTop()));
      });
    };
  });
</script>


<script type="text/javascript">
  $(document).ready(function () {
    var $this = $('.share'),
      //url = $this.attr('data-url'),
      url = window.location.href,
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
    var html = [
      '<a href="#" class="overlay" id="qrcode"></a>',
      '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://mobile.qq.com/qrcode?url=' + encodedUrl + '"/></div>',
      '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
      '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
      '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
      '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
      '<a href="http://service.weibo.com/share/share.php?title=' + title + '&url=' + encodedUrl + '&ralateUid=' + tsina + '&searchPic=true&style=number' + '" class="article-share-weibo" target="_blank" title="Weibo"></a>',
      '<span title="Share to"></span>'
    ].join('');
    $this.append(html);
    viewqrCode();
    $('.article-share-qrcode').click(viewqrCode()
    );

  });
  function viewqrCode() {
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function () {
      $('.qrcode strong').text(' ');
    });
  }
</script>
<script type="text/javascript">  
  //判断是否移动端 
  if (!browser.versions.mobile) {
    $(function () {
      var c, a = $("#rocket-to-top"), e = ($(document).scrollTop(), !0);
      $(window).scroll(function () {
        var b = $(document).scrollTop(); 0 == b ? "0px 0px" == a.css("background-position") ? a.fadeOut("slow") : e && (e = !1, $(".level-2").css("opacity", 1), a.delay(100).animate({ marginTop: "-1000px" }, "normal", function () { a.css({ "margin-top": "-125px", display: "none" }), e = !0 })) : a.fadeIn("slow")
      }), a.hover(function () { $(".level-2").stop(!0).animate({ opacity: 1 }) }, function () { $(".level-2").stop(!0).animate({ opacity: 0 }) }), $(".level-3").click(function () { function b() { var b = a.css("background-position"); if ("none" == a.css("display") || 0 == e) return clearInterval(c), a.css("background-position", "0px 0px"), void 0; switch (b) { case "0px 0px": a.css("background-position", "-298px 0px"); break; case "-298px 0px": a.css("background-position", "-447px 0px"); break; case "-447px 0px": a.css("background-position", "-596px 0px"); break; case "-596px 0px": a.css("background-position", "-745px 0px"); break; case "-745px 0px": a.css("background-position", "-298px 0px") } } e && (c = setInterval(b, 50), $("html,body").animate({ scrollTop: 0 }, "slow")) })
    });
  }
</script>





  </body>
</html>
