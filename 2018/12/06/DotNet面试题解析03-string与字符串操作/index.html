
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>DotNet面试题解析03-string与字符串操作 | syxdevcode博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="syxdevcode">
    
    <meta name="description" content="字符串操作认识stringstring是一个特殊的引用类型,其对象值存储在托管堆中。string的内部是一个char集合，他的长度Length就是字符char数组的字符个数。string不允许使用new string()的方式创建实例，而是另一种更简单的语法，直接赋值（string aa= “000">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="syxdevcode博客" title="syxdevcode博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="syxdevcode博客">syxdevcode博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/tags">tags</a></li>
					
						<li><a href="/categories">categories</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:syxdevcode.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/12/06/DotNet面试题解析03-string与字符串操作/" title="DotNet面试题解析03-string与字符串操作" itemprop="url">DotNet面试题解析03-string与字符串操作</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://syxdevcode.github.com" title="syxdevcode">syxdevcode</a>
    </p>
  <p class="article-time">
    <time datetime="2018-12-06T14:20:09.000Z" itemprop="datePublished">2018-12-06</time>
    更新日期:<time datetime="2020-09-09T08:48:00.364Z" itemprop="dateModified">2020-09-09</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串操作"><span class="toc-number">1.</span> <span class="toc-text">字符串操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识string"><span class="toc-number">1.1.</span> <span class="toc-text">认识string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String的恒定性（不变性）"><span class="toc-number">1.2.</span> <span class="toc-text">String的恒定性（不变性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String的驻留性"><span class="toc-number">1.3.</span> <span class="toc-text">String的驻留性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#认识StringBuilder"><span class="toc-number">1.4.</span> <span class="toc-text">认识StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高效的使用字符串"><span class="toc-number">1.5.</span> <span class="toc-text">高效的使用字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目答案解析"><span class="toc-number">2.</span> <span class="toc-text">题目答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-字符串是引用类型类型还是值类型？"><span class="toc-number">2.1.</span> <span class="toc-text">1.字符串是引用类型类型还是值类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-在字符串连加处理中，最好采用什么方式，理由是什么？"><span class="toc-number">2.2.</span> <span class="toc-text">2.在字符串连加处理中，最好采用什么方式，理由是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-使用-StringBuilder时，需要注意些什么问题？"><span class="toc-number">2.3.</span> <span class="toc-text">3.使用 StringBuilder时，需要注意些什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><span class="toc-number">2.4.</span> <span class="toc-text">4.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><span class="toc-number">2.5.</span> <span class="toc-text">5.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-使用C-实现字符串反转算法，例如：输入”12345”-输出”54321”"><span class="toc-number">2.6.</span> <span class="toc-text">6.使用C#实现字符串反转算法，例如：输入”12345”, 输出”54321”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-下面的代码输出结果？为什么？"><span class="toc-number">2.7.</span> <span class="toc-text">7.下面的代码输出结果？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-C-中string-Empty、””和null-之间的区别"><span class="toc-number">2.8.</span> <span class="toc-text">8.C#中string.Empty、””和null 之间的区别</span></a></li></ol></li></ol>
		</div>
		
		<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="认识string"><a href="#认识string" class="headerlink" title="认识string"></a>认识string</h3><p>string是一个特殊的引用类型,其对象值存储在托管堆中。string的内部是一个char集合，他的长度Length就是字符char数组的字符个数。string不允许使用new string()的方式创建实例，而是另一种更简单的语法，直接赋值（string aa= “000”这一点也类似值类型）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoStringTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aa = <span class="string">"000"</span>;</span><br><span class="line">    SetStringValue(aa);</span><br><span class="line">    Console.WriteLine(aa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStringValue</span>(<span class="params"><span class="keyword">string</span> aa</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aa += <span class="string">"111"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">上面的输出结果为“000”。</font></p>
<p>通过前面的值类型与引用类型的文章，我们知道string是一个引用类型，既然是一个引用类型，参数传递的是引用地址，那为什么不是输出“000111”呢？是不是很有值类型的特点呢！这一切的原因源于string类型的两个重要的特性：恒定性与驻留性</p>
<h3 id="String的恒定性（不变性）"><a href="#String的恒定性（不变性）" class="headerlink" title="String的恒定性（不变性）"></a>String的恒定性（不变性）</h3><p><font color=#0099ff size=4 face="黑体">字符串是不可变的，字符串一经创建，就不会改变，任何改变都会产生新的字符串。</font></p>
<p><img src="/img/151257-20160303222417112-1147871973.png" alt="151257-20160303222417112-1147871973.png"></p>
<p>上文中的”任何改变都会产生新的字符串“，包括字符串的一些操作函数，如str1.ToLower，Trim()，Remove(int startIndex, int count)，ToUpper()等，都会产生新的字符串，因此在很多编程实践中，对于字符串忽略大小的比较：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（str1.ToLower()==str2.ToLower()） <span class="comment">//这种方式会产生新的字符串，不推荐</span></span><br><span class="line"><span class="keyword">if</span>（<span class="keyword">string</span>. Compare(str1,str2,<span class="literal">true</span>)） <span class="comment">//这种方式性能更好</span></span><br></pre></td></tr></table></figure>

<h3 id="String的驻留性"><a href="#String的驻留性" class="headerlink" title="String的驻留性"></a>String的驻留性</h3><p>由于字符串的不变性，在大量使用字符串操作时，会导致创建大量的字符串对象，带来极大的性能损失。因此CLR又给string提供另外一个法宝，就是字符串驻留，先看看下面的代码，字符串s1、s2竟然是同一个对象！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"123"</span>;</span><br><span class="line">Console.WriteLine(System.Object.Equals(s1, s2));  <span class="comment">//输出 True</span></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(s1, s2));  <span class="comment">//输出 True</span></span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">相同的字符串在内存（堆）中只分配一次，第二次申请字符串时，发现已经有该字符串是，直接返回已有字符串的地址，这就是驻留的基本过程。</font></p>
<p>字符串驻留的基本原理：</p>
<ul>
<li>CLR初始化时会在内存中创建一个驻留池，内部其实是一个哈希表，存储被驻留的字符串和其内存地址。</li>
<li>驻留池是进程级别的，多个AppDomain共享。同时她不受GC控制，生命周期随进程，意思就是不会被GC回收</li>
<li>当分配字符串时，首先会到驻留池中查找，如找到，则返回已有相同字符串的地址，不会创建新字符串对象。如果没有找到，则创建新的字符串，并把字符串添加到驻留池中。</li>
</ul>
<p>如果大量的字符串都驻留到内存里，而得不到释放，不是很容易造成内存爆炸吗，当然不会了？因为不是任何字符串都会驻留，只有通过IL指令ldstr创建的字符串才会留用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1 + <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">string</span>.Concat(s1, s2);</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="number">123.</span>ToString();</span><br><span class="line"><span class="keyword">var</span> s5 = s2.ToUpper();</span><br></pre></td></tr></table></figure>

<p>IL代码如下：<br><img src="/img/151257-20160303221217190-205612505.png" alt="151257-20160303221217190-205612505.png"></p>
<p>在上面的代码中，出现两个字符串常量，“123”和“abc”，这个两个常量字符串在IL代码中都是通过IL指令ldstr创建的，只有该指令创建的字符串才会被驻留，其他方式产生新的字符串都不会被驻留，也就不会共享字符串了，会被GC正常回收。</p>
<p>那该如何来验证字符串是否驻留呢，string类提供两个静态方法：</p>
<ul>
<li>string.Intern(string str) 可以主动驻留一个字符串；</li>
<li>string.IsInterned(string str);检测指定字符串是否驻留，如果驻留则返回字符串，否则返回NULL</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1 + <span class="string">"abc"</span>;</span><br><span class="line">Console.WriteLine(s2);   <span class="comment">//输出：123abc</span></span><br><span class="line">Console.WriteLine(<span class="keyword">string</span>.IsInterned(s2) ?? <span class="string">"NULL"</span>);   <span class="comment">//输出：NULL。因为“123abc”没有驻留</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>.Intern(s2);   <span class="comment">//主动驻留字符串</span></span><br><span class="line">Console.WriteLine(<span class="keyword">string</span>.IsInterned(s2) ?? <span class="string">"NULL"</span>);   <span class="comment">//输出：123abc</span></span><br></pre></td></tr></table></figure>

<h3 id="认识StringBuilder"><a href="#认识StringBuilder" class="headerlink" title="认识StringBuilder"></a>认识StringBuilder</h3><p>大量的编程实践和意见中，都说大量字符串连接操作，应该使用StringBuilder。相对于string的不可变，StringBuilder代表可变字符串，不会像字符串，在托管堆上频繁分配新对象。</p>
<p>首先StringBuilder内部同string一样，有一个char[]字符数组，负责维护字符串内容。因此，与char数组相关，就有两个很重要的属性：</p>
<ul>
<li>public int Capacity：StringBuilder的容量，其实就是字符数组的长度。</li>
<li>public int Length：StringBuilder中实际字符的长度，&gt;=0，&lt;=容量Capacity。</li>
</ul>
<p>StringBuilder之所以比string效率高，主要原因就是不会创建大量的新对象，StringBuilder在以下两种情况下会分配新对象：</p>
<ul>
<li>追加字符串时，当字符总长度超过了当前设置的容量Capacity，这个时候，会重新创建一个更大的字符数组，此时会涉及到分配新对象。</li>
<li>调用StringBuilder.ToString()，创建新的字符串。</li>
</ul>
<p>** 追加字符串的过程 **：</p>
<ul>
<li>StringBuilder的默认初始容量为16；</li>
<li>使用stringBuilder.Append()追加一个字符串时，当字符数大于16，StringBuilder会自动申请一个更大的字符数组，一般是倍增；</li>
<li>在新的字符数组分配完成后，将原字符数组中的字符复制到新字符数组中，原字符数组就被无情的抛弃了（会被GC回收）；</li>
<li>最后把需要追加的字符串追加到新字符数组中；</li>
</ul>
<p>简单来说，当StringBuilder的容量Capacity发生变化时，就会引起托管对象申请、内存复制等操作，带来不好的性能影响，因此设置合适的初始容量是非常必要的，尽量减少内存申请和对象创建。代码简单来验证一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=16; Length=0;   //初始容量为16 </span></span><br><span class="line">sb1.Append(<span class="string">'a'</span>, <span class="number">12</span>);    <span class="comment">//追加12个字符</span></span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=16; Length=12;  </span></span><br><span class="line">sb1.Append(<span class="string">'a'</span>, <span class="number">20</span>);    <span class="comment">//继续追加20个字符，容量倍增了</span></span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=32; Length=32;  </span></span><br><span class="line">sb1.Append(<span class="string">'a'</span>, <span class="number">41</span>);    <span class="comment">//追加41个字符，新容量=32+41=73</span></span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=73; Length=73;  </span></span><br><span class="line"></span><br><span class="line">StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="number">80</span>); <span class="comment">//设置一个合适的初始容量</span></span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=0;</span></span><br><span class="line">sb2.Append(<span class="string">'a'</span>, <span class="number">12</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=12;</span></span><br><span class="line">sb2.Append(<span class="string">'a'</span>, <span class="number">20</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=32;</span></span><br><span class="line">sb2.Append(<span class="string">'a'</span>, <span class="number">41</span>);</span><br><span class="line">Console.WriteLine(<span class="string">"Capacity=&#123;0&#125;; Length=&#123;1&#125;;"</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=73;</span></span><br></pre></td></tr></table></figure>

<p>为什么少量字符串不推荐使用StringBuilder呢？因为StringBuilder本身是有一定的开销的，少量字符串就不推荐使用了，使用String.Concat和String.Join更合适。</p>
<h3 id="高效的使用字符串"><a href="#高效的使用字符串" class="headerlink" title="高效的使用字符串"></a>高效的使用字符串</h3><ul>
<li>在使用线程锁的时候，不要锁定一个字符串对象，因为字符串的驻留性，可能会引发不可以预料的问题；</li>
<li>理解字符串的不变性，尽量避免产生额外字符串，如：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（str1.ToLower()==str2.ToLower()） <span class="comment">//这种方式会产生新的字符串，不推荐</span></span><br><span class="line"><span class="keyword">if</span>（<span class="keyword">string</span>. Compare(str1,str2,<span class="literal">true</span>)） <span class="comment">//这种方式性能更好</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在处理大量字符串连接的时候，尽量使用StringBuilder，在使用StringBuilder时，尽量设置一个合适的长度初始值；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder myStringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello World!"</span>, <span class="number">25</span>);</span><br><span class="line">或</span><br><span class="line">myStringBuilder.Capacity = <span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>少量字符串连接建议使用String.Concat和String.Join代替。</li>
</ul>
<h2 id="题目答案解析"><a href="#题目答案解析" class="headerlink" title="题目答案解析"></a>题目答案解析</h2><h3 id="1-字符串是引用类型类型还是值类型？"><a href="#1-字符串是引用类型类型还是值类型？" class="headerlink" title="1.字符串是引用类型类型还是值类型？"></a>1.字符串是引用类型类型还是值类型？</h3><p>引用类型。</p>
<h3 id="2-在字符串连加处理中，最好采用什么方式，理由是什么？"><a href="#2-在字符串连加处理中，最好采用什么方式，理由是什么？" class="headerlink" title="2.在字符串连加处理中，最好采用什么方式，理由是什么？"></a>2.在字符串连加处理中，最好采用什么方式，理由是什么？</h3><p>少量字符串连接，使用String.Concat，大量字符串使用StringBuilder，因为StringBuilder的性能更好，如果string的话会创建大量字符串对象。</p>
<h3 id="3-使用-StringBuilder时，需要注意些什么问题？"><a href="#3-使用-StringBuilder时，需要注意些什么问题？" class="headerlink" title="3.使用 StringBuilder时，需要注意些什么问题？"></a>3.使用 StringBuilder时，需要注意些什么问题？</h3><ul>
<li>少量字符串时，尽量不要用，StringBuilder本身是有一定性能开销的；</li>
<li>大量字符串连接使用StringBuilder时，应该设置一个合适的容量</li>
</ul>
<h3 id="4-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><a href="#4-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？" class="headerlink" title="4.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"></a>4.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> st1 = <span class="string">"123"</span> + <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">string</span> st2 = <span class="string">"123abc"</span>;</span><br><span class="line">Console.WriteLine(st1 == st2);</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(st1, st2));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>内存中的字符串只有一个“123abc”,第一行代码（string st1 = “123” + “abc”; ）常量字符串相加会被编译器优化。由于字符串驻留机制，两个变量st1、st2都指向同一个对象。IL代码如下：</p>
<p><img src="/img/151257-20160303221219330-60155453.png" alt="151257-20160303221219330-60155453.png"></p>
<h3 id="5-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><a href="#5-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？" class="headerlink" title="5.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"></a>5.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> s1 = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">string</span> s2 = s1 + <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">string</span> s3 = <span class="string">"123abc"</span>;</span><br><span class="line">Console.WriteLine(s2 == s3);</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(s2, s3));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>4个字符串。<br>分别是123，abc，123abc，123abc。</p>
<p>理由：<br>s1+abc时产生的不是可驻留的的字符串，而下句则是个驻留字符串。<br>字符串是不可变的，字符串一经创建，就不会改变，任何改变都会产生新的字符串。</p>
<h3 id="6-使用C-实现字符串反转算法，例如：输入”12345”-输出”54321”"><a href="#6-使用C-实现字符串反转算法，例如：输入”12345”-输出”54321”" class="headerlink" title="6.使用C#实现字符串反转算法，例如：输入”12345”, 输出”54321”"></a>6.使用C#实现字符串反转算法，例如：输入”12345”, 输出”54321”</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Reverse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"参数不合法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(str.Length);  <span class="comment">//注意：设置合适的初始长度，可以显著提高效率（避免了多次内存申请）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = str.Length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--)</span><br><span class="line">    &#123;</span><br><span class="line">        sb.Append(str[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Reverse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"参数不合法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.ToCharArray();</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = chars.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> tempChar;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        tempChar = chars[begin];</span><br><span class="line">        chars[begin] = chars[end];</span><br><span class="line">        chars[end] = tempChar;</span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">string</span> strResult = <span class="keyword">new</span> <span class="keyword">string</span>(chars);</span><br><span class="line">    <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Reverse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] arr = str.ToCharArray();</span><br><span class="line">    Array.Reverse(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-下面的代码输出结果？为什么？"><a href="#7-下面的代码输出结果？为什么？" class="headerlink" title="7.下面的代码输出结果？为什么？"></a>7.下面的代码输出结果？为什么？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> a = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">object</span> b = <span class="string">"123"</span>;</span><br><span class="line">Console.WriteLine(System.Object.Equals(a,b));</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(a,b));</span><br><span class="line"><span class="keyword">string</span> sa = <span class="string">"123"</span>;</span><br><span class="line">Console.WriteLine(System.Object.Equals(a, sa));</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(a, sa));</span><br></pre></td></tr></table></figure>

<p>输出结果全是True，因为他们都指向同一个字符串实例，使用object声明和string声明在这里并没有区别（string是引用类型）。</p>
<h3 id="8-C-中string-Empty、””和null-之间的区别"><a href="#8-C-中string-Empty、””和null-之间的区别" class="headerlink" title="8.C#中string.Empty、””和null 之间的区别"></a>8.C#中string.Empty、””和null 之间的区别</h3><p>实际上Empty是string类中的一个静态的只读字段，他的定义是这样的：</p>
<p>public static readonly String Empty = “”;</p>
<p>也就是说string.Empty的内部实现是等于””的。</p>
<p>引用类型是将对象是实际数据保存在堆上, 将对象在堆上的地址保存在栈上。因此string.Empty与””都会在栈上保存一个地址这个地址占4字节，指向内存堆中的某个长度为0的空间，这个空间保存的是string.Empty的实际值</p>
<p>“”是通过CLR进行优化的,CLR会维护一个字符串池,以防在堆中创建重复的字符串。<br>而string.Empty是一种c#语法级别的优化，是在C#编译器将代码编译为IL(即MSIL)时进行了优化，即所有对string类的静态字段Empty的访问都会被指向同一引用，以节省内存空间。也就是说，””与string.Empty在用法与性能上基本没区别。string.Empty是在语法级别对””的优化。</p>
<p>那就是string.Empty会在堆上占用一个长度为0的空间，而null不会。具体内容如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> str1=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">string</span> str2=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>如刚才所说str1会在栈上保存一个地址,这个地址占4字节，指向内存堆中的某个长度为0的空间，这个空间保存的是str1的实际值。</p>
<p>str2同样会在栈上保存一个地址,这个地址也占4字节，但是这个地址是没有明确指向的，它哪也不指，其内容为0x00000000</p>
<p>参考：</p>
<p><a href="http://www.cnblogs.com/anding/p/5240313.html" target="_blank" rel="noopener">.NET面试题解析(03)-string与字符串操作</a></p>
<p><a href="http://www.cnblogs.com/solan/archive/2012/08/06/CSharp09.html" target="_blank" rel="noopener">C#基础知识梳理系列九：StringBuilder</a></p>
<p><a href="http://www.cnblogs.com/artech/archive/2007/05/06/737130.html" target="_blank" rel="noopener">深入理解string和如何高效地使用string</a></p>
<p><a href="https://blog.csdn.net/henulwj/article/details/7830615" target="_blank" rel="noopener">C#中string.Empty、””和null 之间的区别</a></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/DotNet/">DotNet</a><a href="/tags/CSharp/">CSharp</a><a href="/tags/CSharp基础/">CSharp基础</a><a href="/tags/DotNet面试题解析/">DotNet面试题解析</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/">DotNet面试题解析</a>
</div>



<div class="article-share" id="share">

  <div data-url="https://syxdevcode.github.com/2018/12/06/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9003-string%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" data-title="DotNet面试题解析03-string与字符串操作 | syxdevcode博客" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/12/06/DotNet面试题解析04-类型、方法与继承/" title="DotNet面试题解析04-类型、方法与继承">
  <strong>PREVIOUS:</strong><br/>
  <span>
  DotNet面试题解析04-类型、方法与继承</span>
</a>
</div>


<div class="next">
<a href="/2018/12/05/DotNet面试题解析02-拆箱与装箱/"  title="DotNet面试题解析02-拆箱与装箱">
 <strong>NEXT:</strong><br/> 
 <span>DotNet面试题解析02-拆箱与装箱
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串操作"><span class="toc-number">1.</span> <span class="toc-text">字符串操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认识string"><span class="toc-number">1.1.</span> <span class="toc-text">认识string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String的恒定性（不变性）"><span class="toc-number">1.2.</span> <span class="toc-text">String的恒定性（不变性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String的驻留性"><span class="toc-number">1.3.</span> <span class="toc-text">String的驻留性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#认识StringBuilder"><span class="toc-number">1.4.</span> <span class="toc-text">认识StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高效的使用字符串"><span class="toc-number">1.5.</span> <span class="toc-text">高效的使用字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目答案解析"><span class="toc-number">2.</span> <span class="toc-text">题目答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-字符串是引用类型类型还是值类型？"><span class="toc-number">2.1.</span> <span class="toc-text">1.字符串是引用类型类型还是值类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-在字符串连加处理中，最好采用什么方式，理由是什么？"><span class="toc-number">2.2.</span> <span class="toc-text">2.在字符串连加处理中，最好采用什么方式，理由是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-使用-StringBuilder时，需要注意些什么问题？"><span class="toc-number">2.3.</span> <span class="toc-text">3.使用 StringBuilder时，需要注意些什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><span class="toc-number">2.4.</span> <span class="toc-text">4.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><span class="toc-number">2.5.</span> <span class="toc-text">5.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-使用C-实现字符串反转算法，例如：输入”12345”-输出”54321”"><span class="toc-number">2.6.</span> <span class="toc-text">6.使用C#实现字符串反转算法，例如：输入”12345”, 输出”54321”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-下面的代码输出结果？为什么？"><span class="toc-number">2.7.</span> <span class="toc-text">7.下面的代码输出结果？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-C-中string-Empty、””和null-之间的区别"><span class="toc-number">2.8.</span> <span class="toc-text">8.C#中string.Empty、””和null 之间的区别</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Net-Standard/" title=".Net Standard">.Net Standard<sup>2</sup></a></li>
		
			<li><a href="/categories/net异步与并行/" title=".net异步与并行">.net异步与并行<sup>10</sup></a></li>
		
			<li><a href="/categories/ABP/" title="ABP">ABP<sup>27</sup></a></li>
		
			<li><a href="/categories/ASP-NET-IIS请求处理管道/" title="ASP.NET/IIS请求处理管道">ASP.NET/IIS请求处理管道<sup>2</sup></a></li>
		
			<li><a href="/categories/ApplicationPoolIdentify/" title="ApplicationPoolIdentify">ApplicationPoolIdentify<sup>1</sup></a></li>
		
			<li><a href="/categories/CSharp基础/" title="CSharp基础">CSharp基础<sup>11</sup></a></li>
		
			<li><a href="/categories/CentOS7/" title="CentOS7">CentOS7<sup>11</sup></a></li>
		
			<li><a href="/categories/Chrome/" title="Chrome">Chrome<sup>1</sup></a></li>
		
			<li><a href="/categories/CodeDOM/" title="CodeDOM">CodeDOM<sup>3</sup></a></li>
		
			<li><a href="/categories/Consul/" title="Consul">Consul<sup>3</sup></a></li>
		
			<li><a href="/categories/Crontab/" title="Crontab">Crontab<sup>1</sup></a></li>
		
			<li><a href="/categories/Docker/" title="Docker">Docker<sup>7</sup></a></li>
		
			<li><a href="/categories/Docker-Compose/" title="Docker Compose">Docker Compose<sup>3</sup></a></li>
		
			<li><a href="/categories/DotNetCore/" title="DotNetCore">DotNetCore<sup>4</sup></a></li>
		
			<li><a href="/categories/DotNet面试题解析/" title="DotNet面试题解析">DotNet面试题解析<sup>8</sup></a></li>
		
			<li><a href="/categories/EasyNetQ/" title="EasyNetQ">EasyNetQ<sup>1</sup></a></li>
		
			<li><a href="/categories/Elasticsearch/" title="Elasticsearch">Elasticsearch<sup>1</sup></a></li>
		
			<li><a href="/categories/Emit-反射发出/" title="Emit(反射发出)">Emit(反射发出)<sup>6</sup></a></li>
		
			<li><a href="/categories/Expression-Tree/" title="Expression Tree">Expression Tree<sup>2</sup></a></li>
		
			<li><a href="/categories/Git/" title="Git">Git<sup>2</sup></a></li>
		
			<li><a href="/categories/HostService/" title="HostService">HostService<sup>1</sup></a></li>
		
			<li><a href="/categories/IDEA/" title="IDEA">IDEA<sup>2</sup></a></li>
		
			<li><a href="/categories/Java/" title="Java">Java<sup>5</sup></a></li>
		
			<li><a href="/categories/JavaScript-JQuery/" title="JavaScript/JQuery">JavaScript/JQuery<sup>1</sup></a></li>
		
			<li><a href="/categories/Jenkins/" title="Jenkins">Jenkins<sup>2</sup></a></li>
		
			<li><a href="/categories/Jexus/" title="Jexus">Jexus<sup>1</sup></a></li>
		
			<li><a href="/categories/Json-Net/" title="Json.Net">Json.Net<sup>1</sup></a></li>
		
			<li><a href="/categories/LINQ/" title="LINQ">LINQ<sup>3</sup></a></li>
		
			<li><a href="/categories/Let’s-Encrypt/" title="Let’s Encrypt">Let’s Encrypt<sup>1</sup></a></li>
		
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>5</sup></a></li>
		
			<li><a href="/categories/Linux-LVM/" title="Linux LVM">Linux LVM<sup>1</sup></a></li>
		
			<li><a href="/categories/Linux-磁盘/" title="Linux 磁盘">Linux 磁盘<sup>1</sup></a></li>
		
			<li><a href="/categories/Linux基础命令/" title="Linux基础命令">Linux基础命令<sup>22</sup></a></li>
		
			<li><a href="/categories/Linux服务/" title="Linux服务">Linux服务<sup>3</sup></a></li>
		
			<li><a href="/categories/MSIL指令/" title="MSIL指令">MSIL指令<sup>2</sup></a></li>
		
			<li><a href="/categories/MVC-Web-API/" title="MVC/Web API">MVC/Web API<sup>2</sup></a></li>
		
			<li><a href="/categories/MariaDB/" title="MariaDB">MariaDB<sup>1</sup></a></li>
		
			<li><a href="/categories/MarkDown/" title="MarkDown">MarkDown<sup>1</sup></a></li>
		
			<li><a href="/categories/MinIo/" title="MinIo">MinIo<sup>1</sup></a></li>
		
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		
			<li><a href="/categories/Moq/" title="Moq">Moq<sup>1</sup></a></li>
		
			<li><a href="/categories/MySql/" title="MySql">MySql<sup>9</sup></a></li>
		
			<li><a href="/categories/Naudio/" title="Naudio">Naudio<sup>2</sup></a></li>
		
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>2</sup></a></li>
		
			<li><a href="/categories/Nodejs/" title="Nodejs">Nodejs<sup>3</sup></a></li>
		
			<li><a href="/categories/OAuth2-0/" title="OAuth2.0">OAuth2.0<sup>2</sup></a></li>
		
			<li><a href="/categories/Ocelot/" title="Ocelot">Ocelot<sup>1</sup></a></li>
		
			<li><a href="/categories/Openssl/" title="Openssl">Openssl<sup>2</sup></a></li>
		
			<li><a href="/categories/PAM/" title="PAM">PAM<sup>1</sup></a></li>
		
			<li><a href="/categories/Polly/" title="Polly">Polly<sup>2</sup></a></li>
		
			<li><a href="/categories/PostGresqlSql/" title="PostGresqlSql">PostGresqlSql<sup>1</sup></a></li>
		
			<li><a href="/categories/Python/" title="Python">Python<sup>1</sup></a></li>
		
			<li><a href="/categories/RESTful/" title="RESTful">RESTful<sup>2</sup></a></li>
		
			<li><a href="/categories/RabbitMQ/" title="RabbitMQ">RabbitMQ<sup>2</sup></a></li>
		
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>8</sup></a></li>
		
			<li><a href="/categories/Resharper/" title="Resharper">Resharper<sup>1</sup></a></li>
		
			<li><a href="/categories/SSH/" title="SSH">SSH<sup>1</sup></a></li>
		
			<li><a href="/categories/SSL-TLS/" title="SSL/TLS">SSL/TLS<sup>2</sup></a></li>
		
			<li><a href="/categories/Shell脚本/" title="Shell脚本">Shell脚本<sup>1</sup></a></li>
		
			<li><a href="/categories/Skywalking/" title="Skywalking">Skywalking<sup>1</sup></a></li>
		
			<li><a href="/categories/Sql/" title="Sql">Sql<sup>5</sup></a></li>
		
			<li><a href="/categories/TDD/" title="TDD">TDD<sup>1</sup></a></li>
		
			<li><a href="/categories/TPL-DataFlow/" title="TPL DataFlow">TPL DataFlow<sup>2</sup></a></li>
		
			<li><a href="/categories/Tomcat/" title="Tomcat">Tomcat<sup>2</sup></a></li>
		
			<li><a href="/categories/WCF时间类型序列化/" title="WCF时间类型序列化">WCF时间类型序列化<sup>1</sup></a></li>
		
			<li><a href="/categories/WSL/" title="WSL">WSL<sup>1</sup></a></li>
		
			<li><a href="/categories/WebForm/" title="WebForm">WebForm<sup>2</sup></a></li>
		
			<li><a href="/categories/WinDbg/" title="WinDbg">WinDbg<sup>1</sup></a></li>
		
			<li><a href="/categories/WinSCP/" title="WinSCP">WinSCP<sup>1</sup></a></li>
		
			<li><a href="/categories/Windows系统/" title="Windows系统">Windows系统<sup>1</sup></a></li>
		
			<li><a href="/categories/ab/" title="ab">ab<sup>1</sup></a></li>
		
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>2</sup></a></li>
		
			<li><a href="/categories/shadowsocks/" title="shadowsocks">shadowsocks<sup>1</sup></a></li>
		
			<li><a href="/categories/supervisor/" title="supervisor">supervisor<sup>2</sup></a></li>
		
			<li><a href="/categories/zookeeper/" title="zookeeper">zookeeper<sup>1</sup></a></li>
		
			<li><a href="/categories/内存泄漏/" title="内存泄漏">内存泄漏<sup>1</sup></a></li>
		
			<li><a href="/categories/分布式/" title="分布式">分布式<sup>1</sup></a></li>
		
			<li><a href="/categories/分布式事务/" title="分布式事务">分布式事务<sup>1</sup></a></li>
		
			<li><a href="/categories/单词收录/" title="单词收录">单词收录<sup>14</sup></a></li>
		
			<li><a href="/categories/反射/" title="反射">反射<sup>4</sup></a></li>
		
			<li><a href="/categories/委托与事件/" title="委托与事件">委托与事件<sup>4</sup></a></li>
		
			<li><a href="/categories/工具/" title="工具">工具<sup>1</sup></a></li>
		
			<li><a href="/categories/并发模型/" title="并发模型">并发模型<sup>1</sup></a></li>
		
			<li><a href="/categories/插件/" title="插件">插件<sup>1</sup></a></li>
		
			<li><a href="/categories/时间-时间戳转换/" title="时间/时间戳转换">时间/时间戳转换<sup>1</sup></a></li>
		
			<li><a href="/categories/消息队列/" title="消息队列">消息队列<sup>1</sup></a></li>
		
			<li><a href="/categories/硬盘/" title="硬盘">硬盘<sup>1</sup></a></li>
		
			<li><a href="/categories/程序集/" title="程序集">程序集<sup>2</sup></a></li>
		
			<li><a href="/categories/算法/" title="算法">算法<sup>3</sup></a></li>
		
			<li><a href="/categories/线性表/" title="线性表">线性表<sup>1</sup></a></li>
		
			<li><a href="/categories/线程池/" title="线程池">线程池<sup>1</sup></a></li>
		
			<li><a href="/categories/缓存/" title="缓存">缓存<sup>3</sup></a></li>
		
			<li><a href="/categories/计算机基础/" title="计算机基础">计算机基础<sup>3</sup></a></li>
		
			<li><a href="/categories/认证与授权/" title="认证与授权">认证与授权<sup>1</sup></a></li>
		
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		
			<li><a href="/categories/链表/" title="链表">链表<sup>2</sup></a></li>
		
			<li><a href="/categories/集合与泛型/" title="集合与泛型">集合与泛型<sup>4</sup></a></li>
		
			<li><a href="/categories/音频-视频/" title="音频/视频">音频/视频<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist" style="clear:both;">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Net-Standard/" title=".Net Standard">.Net Standard<sup>2</sup></a></li>
		
			<li><a href="/tags/net异步与并行/" title=".net异步与并行">.net异步与并行<sup>12</sup></a></li>
		
			<li><a href="/tags/ABP/" title="ABP">ABP<sup>27</sup></a></li>
		
			<li><a href="/tags/ASP-NET-IIS请求处理管道/" title="ASP.NET/IIS请求处理管道">ASP.NET/IIS请求处理管道<sup>7</sup></a></li>
		
			<li><a href="/tags/AWS/" title="AWS">AWS<sup>7</sup></a></li>
		
			<li><a href="/tags/ApplicationPoolIdentify/" title="ApplicationPoolIdentify">ApplicationPoolIdentify<sup>1</sup></a></li>
		
			<li><a href="/tags/CSharp/" title="CSharp">CSharp<sup>102</sup></a></li>
		
			<li><a href="/tags/CSharp基础/" title="CSharp基础">CSharp基础<sup>45</sup></a></li>
		
			<li><a href="/tags/CentOS7/" title="CentOS7">CentOS7<sup>77</sup></a></li>
		
			<li><a href="/tags/Chrome/" title="Chrome">Chrome<sup>1</sup></a></li>
		
			<li><a href="/tags/CodeDOM/" title="CodeDOM">CodeDOM<sup>3</sup></a></li>
		
			<li><a href="/tags/Consul/" title="Consul">Consul<sup>4</sup></a></li>
		
			<li><a href="/tags/Crontab/" title="Crontab">Crontab<sup>1</sup></a></li>
		
			<li><a href="/tags/Docker/" title="Docker">Docker<sup>23</sup></a></li>
		
			<li><a href="/tags/Docker-Compose/" title="Docker Compose">Docker Compose<sup>5</sup></a></li>
		
			<li><a href="/tags/DotNet/" title="DotNet">DotNet<sup>106</sup></a></li>
		
			<li><a href="/tags/DotNetCore/" title="DotNetCore">DotNetCore<sup>17</sup></a></li>
		
			<li><a href="/tags/DotNet面试题解析/" title="DotNet面试题解析">DotNet面试题解析<sup>10</sup></a></li>
		
			<li><a href="/tags/Elasticsearch/" title="Elasticsearch">Elasticsearch<sup>2</sup></a></li>
		
			<li><a href="/tags/Emit-反射发出/" title="Emit(反射发出)">Emit(反射发出)<sup>8</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
<div style="display: none;" id="rocket-to-top">
  <div style="opacity: 0; display: block;" class="level-2"></div>
  <div class="level-3"></div>
</div>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		<a href="https://github.com/syxdevcode" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/syxdevcode/pacman" target="_blank" title="Pacman">Pacman</a> © 2020 
		
		<a href="https://syxdevcode.github.com" target="_blank" title="syxdevcode">syxdevcode</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>

<script type="text/javascript">
  $(document).ready(function () {
    $('.navbar').click(function () {
      $('header nav').toggleClass('shownav');
    });
    var myWidth = 0;
    function getSize() {
      if (typeof (window.innerWidth) == 'number') {
        myWidth = window.innerWidth;
      } else if (document.documentElement && document.documentElement.clientWidth) {
        myWidth = document.documentElement.clientWidth;
      };
    };
    var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
    $(window).resize(function () {
      getSize();
      if (myWidth >= 1024) {
        $('header nav').removeClass('shownav');
      } else {
        m.removeClass('moveMain');
        a.css('display', 'block').removeClass('fadeOut');
        o.css('display', 'none');
      
          $('#toc.toc-aside').css('display', 'none');
        
    }
    });
    c.click(function () {
      a.addClass('fadeOut').css('display', 'none');
      o.css('display', 'block').addClass('fadeIn');
      m.addClass('moveMain');
    });
    o.click(function () {
      o.css('display', 'none').removeClass('beforeFadeIn');
      a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
      m.removeClass('moveMain');
    });
    $(window).scroll(function () {
      o.css("top", Math.max(80, 260 - $(this).scrollTop()));
    });
  });
  //判断访问终端
  var browser = {
    versions: function () {
      var u = navigator.userAgent,
        app = navigator.appVersion;
      return {
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1,//火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Adr') > -1, //android终端
        iPhone: u.indexOf('iPhone') > -1, //是否为iPhone或者QQHD浏览器
        iPad: u.indexOf('iPad') > -1, //是否iPad
        webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') > -1, //是否微信 （2015-01-22新增）
        qq: u.match(/\sQQ/i) == " qq" //是否QQ
      };
    }(),
    language: (navigator.browserLanguage || navigator.language).toLowerCase()
  }
</script>

<script type="text/javascript">
  $(document).ready(function () {
    var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t = $('#toc'),
      h = $('article h2')
    ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o = $('.openaside'),
      c = $('.closeaside');
    if (ai.length > 0) {
      ai.wrap('<div class="video-container" />');
    };
    if (ae.length > 0) {
      ae.wrap('<div class="video-container" />');
    };
    if (ah.length == 0) {
      t.css('display', 'none');
    } else {
      c.click(function () {
        ta.css('display', 'block').addClass('fadeIn');
      });
      o.click(function () {
        ta.css('display', 'none');
      });
      $(window).scroll(function () {
        ta.css("top", Math.max(140, 320 - $(this).scrollTop()));
      });
    };
  });
</script>


<script type="text/javascript">
  $(document).ready(function () {
    var $this = $('.share'),
      //url = $this.attr('data-url'),
      url = window.location.href,
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
    var html = [
      '<a href="#" class="overlay" id="qrcode"></a>',
      '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://mobile.qq.com/qrcode?url=' + encodedUrl + '"/></div>',
      '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
      '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
      '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
      '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
      '<a href="http://service.weibo.com/share/share.php?title=' + title + '&url=' + encodedUrl + '&ralateUid=' + tsina + '&searchPic=true&style=number' + '" class="article-share-weibo" target="_blank" title="Weibo"></a>',
      '<span title="Share to"></span>'
    ].join('');
    $this.append(html);
    viewqrCode();
    $('.article-share-qrcode').click(viewqrCode()
    );

  });
  function viewqrCode() {
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function () {
      $('.qrcode strong').text(' ');
    });
  }
</script>
<script type="text/javascript">  
  //判断是否移动端 
  if (!browser.versions.mobile) {
    $(function () {
      var c, a = $("#rocket-to-top"), e = ($(document).scrollTop(), !0);
      $(window).scroll(function () {
        var b = $(document).scrollTop(); 0 == b ? "0px 0px" == a.css("background-position") ? a.fadeOut("slow") : e && (e = !1, $(".level-2").css("opacity", 1), a.delay(100).animate({ marginTop: "-1000px" }, "normal", function () { a.css({ "margin-top": "-125px", display: "none" }), e = !0 })) : a.fadeIn("slow")
      }), a.hover(function () { $(".level-2").stop(!0).animate({ opacity: 1 }) }, function () { $(".level-2").stop(!0).animate({ opacity: 0 }) }), $(".level-3").click(function () { function b() { var b = a.css("background-position"); if ("none" == a.css("display") || 0 == e) return clearInterval(c), a.css("background-position", "0px 0px"), void 0; switch (b) { case "0px 0px": a.css("background-position", "-298px 0px"); break; case "-298px 0px": a.css("background-position", "-447px 0px"); break; case "-447px 0px": a.css("background-position", "-596px 0px"); break; case "-596px 0px": a.css("background-position", "-745px 0px"); break; case "-745px 0px": a.css("background-position", "-298px 0px") } } e && (c = setInterval(b, 50), $("html,body").animate({ scrollTop: 0 }, "slow")) })
    });
  }
</script>





  </body>
</html>
