
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>DotNet面试题解析08-多线程与线程同步 | syxdevcode博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="syxdevcode">
    
    <meta name="description" content="线程基础进程与线程我们运行一个exe，就是一个进程实例，系统中有很多个进程。每一个进程都有自己的内存地址空间，每个进程相当于一个独立的边界，有自己的独占的资源，进程之间不能共享代码和数据空间。

每一个进程有一个或多个线程，进程内多个线程可以共享所属进程的资源和数据，线程是操作系统调度的基本单元。线">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="syxdevcode博客" title="syxdevcode博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="syxdevcode博客">syxdevcode博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/tags">tags</a></li>
					
						<li><a href="/categories">categories</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:syxdevcode.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/12/20/DotNet面试题解析08-多线程与线程同步/" title="DotNet面试题解析08-多线程与线程同步" itemprop="url">DotNet面试题解析08-多线程与线程同步</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://syxdevcode.github.com" title="syxdevcode">syxdevcode</a>
    </p>
  <p class="article-time">
    <time datetime="2018-12-20T16:29:55.000Z" itemprop="datePublished">2018-12-20</time>
    更新日期:<time datetime="2020-02-29T10:34:53.184Z" itemprop="dateModified">2020-02-29</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程基础"><span class="toc-number">1.</span> <span class="toc-text">线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程与线程"><span class="toc-number">1.1.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的开销及调度"><span class="toc-number">1.2.</span> <span class="toc-text">线程的开销及调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池-ThreadPool"><span class="toc-number">2.1.</span> <span class="toc-text">线程池(ThreadPool)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务Task与并行Parallel"><span class="toc-number">2.2.</span> <span class="toc-text">任务Task与并行Parallel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GUI线程处理模型"><span class="toc-number">2.3.</span> <span class="toc-text">GUI线程处理模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步构造"><span class="toc-number">3.</span> <span class="toc-text">线程同步构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户模式构造"><span class="toc-number">3.1.</span> <span class="toc-text">用户模式构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核模式构造"><span class="toc-number">3.2.</span> <span class="toc-text">内核模式构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合线程同步"><span class="toc-number">3.3.</span> <span class="toc-text">混合线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock关键字"><span class="toc-number">3.4.</span> <span class="toc-text">Lock关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程使用及线程同步总结"><span class="toc-number">3.5.</span> <span class="toc-text">多线程使用及线程同步总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目答案解析"><span class="toc-number">4.</span> <span class="toc-text">题目答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-描述线程与进程的区别？"><span class="toc-number">4.1.</span> <span class="toc-text">1. 描述线程与进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"><span class="toc-number">4.2.</span> <span class="toc-text">2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-简述后台线程和前台线程的区别？"><span class="toc-number">4.3.</span> <span class="toc-text">3. 简述后台线程和前台线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-说说常用的锁，lock是一种什么样的锁？"><span class="toc-number">4.4.</span> <span class="toc-text">4. 说说常用的锁，lock是一种什么样的锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"><span class="toc-number">4.5.</span> <span class="toc-text">5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-多线程和异步有什么关系和区别？"><span class="toc-number">4.6.</span> <span class="toc-text">6. 多线程和异步有什么关系和区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-线程池的优点有哪些？又有哪些不足？"><span class="toc-number">4.7.</span> <span class="toc-text">7. 线程池的优点有哪些？又有哪些不足？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？"><span class="toc-number">4.8.</span> <span class="toc-text">8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"><span class="toc-number">4.9.</span> <span class="toc-text">9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-用双检锁实现一个单例模式Singleton。"><span class="toc-number">4.10.</span> <span class="toc-text">10. 用双检锁实现一个单例模式Singleton。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-下面代码输出结果是什么？为什么？如何改进她？"><span class="toc-number">4.11.</span> <span class="toc-text">11.下面代码输出结果是什么？为什么？如何改进她？</span></a></li></ol></li></ol>
		</div>
		
		<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>我们运行一个exe，就是一个进程实例，系统中有很多个进程。每一个进程都有自己的内存地址空间，每个进程相当于一个独立的边界，有自己的独占的资源，进程之间不能共享代码和数据空间。</p>
<p><img src="/img/151257-20160321141549448-1325816759.png" alt="151257-20160321141549448-1325816759.png"></p>
<p>每一个进程有一个或多个线程，进程内多个线程可以共享所属进程的资源和数据，线程是操作系统调度的基本单元。线程是由操作系统来调度和执行的，她的基本状态如下图。</p>
<p><img src="/img/151257-20160321141550120-2131692214.png" alt="151257-20160321141550120-2131692214.png"></p>
<h3 id="线程的开销及调度"><a href="#线程的开销及调度" class="headerlink" title="线程的开销及调度"></a>线程的开销及调度</h3><p>创建一个线程,主要包括线程内核对象、线程环境块、1M大小的用户模式栈、内核模式栈。其中用户模式栈对于普通的系统线程那1M是预留的，在需要的时候才会分配，但是对于CLR线程，那1M是一开始就分类了内存空间的。</p>
<p><img src="/img/151257-20160321141550589-1339297361.png" alt="151257-20160321141550589-1339297361.png"></p>
<p>操作系统中那么多线程（一般都有上千个线程，大部分都处于休眠状态），对于单核CPU，一次只能有一个线程被调度执行，那么多线程怎么分配的呢？Windows系统采用时间轮询机制，CPU计算资源以时间片(大约30ms)的形式分配给执行线程。</p>
<p>计算机资源（CPU核心和CPU寄存器）一次只能调度一个线程，具体的调度流程：</p>
<ul>
<li>把CPU寄存器内的数据保存到当前线程内部（线程上下文等地方），给下一个线程腾地方；</li>
<li>线程调度：在线程集合里取出一个需要执行的线程；</li>
<li>加载新线程的上下文数据到CPU寄存器；</li>
<li>新线程执行，享受她自己的CPU时间片（大约30ms），完了之后继续回到第一步，继续轮回；</li>
</ul>
<p>上面线程调度的过程，就是一次线程切换，一次切换就涉及到线程上下文等数据的搬入搬出，性能开销是很大的。因此线程不可滥用，线程的创建和消费也是很昂贵的，这也是为什么建议尽量使用线程池的一个主要原因。</p>
<p>线程的主要几点性能影响：</p>
<ul>
<li>线程的创建、销毁都是很昂贵的；</li>
<li>线程上下文切换有极大的性能开销，当然假如需要调度的新线程与当前是同一线程的话，就不需要线程上下文切换了，效率要快很多；</li>
<li>GC执行回收时，首先要（安全的）挂起所有线程，遍历所有线程栈（根），GC回收后更新所有线程的根地址，再恢复线程调用，线程越多，GC要干的活就越多；</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池(ThreadPool)"></a>线程池(ThreadPool)</h3><p>将任务添加进线程池:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(方法名));</span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line">ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(方法名), 参数);</span><br></pre></td></tr></table></figure>

<p>因为ThreadPool是静态类 所以不需要实例化.</p>
<p>每个CLR都有一个线程池，线程池在CLR内可以多个AppDomain共享，线程池是CLR内部管理的一个线程集合，初始是没有线程的，在需要的时候才会创建。</p>
<p>基本流程如下：</p>
<ul>
<li>线程池内部维护一个请求列队，用于缓存用户请求需要执行的代码任务，就是ThreadPool.QueueUserWorkItem提交的请求；</li>
<li>有新任务后，线程池使用空闲线程或新线程来执行队列请求；</li>
<li>任务执行完后线程不会销毁，留着重复使用；</li>
<li>线程池自己负责维护线程的创建和销毁，当线程池中有大量闲置的线程时，线程池会自动结束一部分多余的线程来释放资源；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line">namespace 多线程池试验</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//新建ManualResetEvent对象并且初始化为无信号状态</span></span><br><span class="line">            ManualResetEvent eventX = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">            ThreadPool.SetMaxThreads(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">            thr t = <span class="keyword">new</span> thr(<span class="number">15</span>, eventX);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(t.ThreadProc), i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等待事件的完成，即线程调用ManualResetEvent.Set()方法</span></span><br><span class="line">            <span class="comment">//eventX.WaitOne  阻止当前线程，直到当前 WaitHandle 收到信号为止。 </span></span><br><span class="line">            eventX.WaitOne(Timeout.Infinite, <span class="literal">true</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"断点测试"</span>);</span><br><span class="line">            Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">"运行结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">thr</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">thr</span>(<span class="params"><span class="keyword">int</span> count,ManualResetEvent mre</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                iMaxCount = count;</span><br><span class="line">                eventX = mre;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> iCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> iMaxCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> ManualResetEvent eventX;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThreadProc</span>(<span class="params"><span class="keyword">object</span> i</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Thread["</span> + i.ToString() + <span class="string">"]"</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">//Interlocked.Increment()操作是一个原子操作，作用是:iCount++ 具体请看下面说明 </span></span><br><span class="line">                <span class="comment">//原子操作，就是不能被更高等级中断抢夺优先的操作。你既然提这个问题，我就说深一点。</span></span><br><span class="line">                <span class="comment">//由于操作系统大部分时间处于开中断状态，</span></span><br><span class="line">                <span class="comment">//所以，一个程序在执行的时候可能被优先级更高的线程中断。</span></span><br><span class="line">                <span class="comment">//而有些操作是不能被中断的，不然会出现无法还原的后果，这时候，这些操作就需要原子操作。</span></span><br><span class="line">                <span class="comment">//就是不能被中断的操作。</span></span><br><span class="line">                Interlocked.Increment(<span class="keyword">ref</span> iCount);</span><br><span class="line">                <span class="keyword">if</span> (iCount == iMaxCount)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">"发出结束信号!"</span>);</span><br><span class="line">                    <span class="comment">//将事件状态设置为终止状态，允许一个或多个等待线程继续。</span></span><br><span class="line">                    eventX.Set();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** AutoResetEvent和ManualResetEvent区别：**<br><font color=#0099ff size=4 face="黑体">AutoResetEvent的WaitOne()方法执行后会自动又将信号置为不发送状态也就是阻塞状态，当再次遇到WaitOne()方法是又会被阻塞，而ManualResetEvent则不会，只要线程处于非阻塞状态则无论遇到多少次WaitOne()方法都不会被阻塞，除非调用ReSet()方法来手动阻塞线程。</font></p>
<p>线程池是有一个容量的，可以设置线程池的最大活跃线程数，调用方法ThreadPool.SetMaxThreads可以设置相关参数。但很多编程实践里都不建议程序猿们自己去设置这些参数，其实微软为了提高线程池性能，做了大量的优化，线程池可以很智能的确定是否要创建或是消费线程，大多数情况都可以满足需求了。</p>
<p>线程池使得线程可以充分有效地被利用，减少了任务启动的延迟，也不用大量的去创建线程，避免了大量线程的创建和销毁对性能的极大影响。</p>
<p>线程池的不足：</p>
<ul>
<li>线程池内的线程不支持线程的挂起、取消等操作，如想要取消线程里的任务，.NET支持一种协作式方式取消，使用起来也不很方便，而且有些场景并不满足需求；</li>
<li>线程内的任务没有返回值，也不知道何时执行完成；</li>
<li>不支持设置线程的优先级，还包括其他类似需要对线程有更多的控制的需求都不支持；</li>
</ul>
<h3 id="任务Task与并行Parallel"><a href="#任务Task与并行Parallel" class="headerlink" title="任务Task与并行Parallel"></a>任务Task与并行Parallel</h3><p>任务Task与并行Parallel本质上内部都是使用的线程池，提供了更丰富的并行编程的方式。任务Task基于线程池，可支持返回值，支持比较强大的任务执行计划定制等功能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个任务</span></span><br><span class="line">Task&lt;<span class="keyword">int</span>&gt; t1 = <span class="keyword">new</span> Task&lt;<span class="keyword">int</span>&gt;(n =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    System.Threading.Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)n;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//定制一个延续任务计划</span></span><br><span class="line">t1.ContinueWith(task =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"end"</span> + t1.Result);</span><br><span class="line">&#125;, TaskContinuationOptions.AttachedToParent);</span><br><span class="line">t1.Start();</span><br><span class="line"><span class="comment">//使用Task.Factory创建并启动一个任务</span></span><br><span class="line"><span class="keyword">var</span> t2 = System.Threading.Tasks.Task.Factory.StartNew(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"t1:"</span> + t1.Status);</span><br><span class="line">&#125;);</span><br><span class="line">Task.WaitAll();</span><br><span class="line">Console.WriteLine(t1.Result);</span><br></pre></td></tr></table></figure>

<p>并行Parallel内部其实使用的是Task对象（TPL会在内部创建System.Threading.Tasks.Task的实例），所有并行任务完成后才会返回。少量短时间任务建议就不要使用并行Parallel了，并行Parallel本身也是有性能开销的，而且还要进行并行任务调度、创建调用方法的委托等等。</p>
<p><img src="/img/221025576742743.png" alt="221025576742743.png"></p>
<h3 id="GUI线程处理模型"><a href="#GUI线程处理模型" class="headerlink" title="GUI线程处理模型"></a>GUI线程处理模型</h3><p>这是很多开发C/S客户端应用程序会遇到的问题，GUI程序的界面控件不允许跨线程访问，如果在其他线程中访问了界面控件，运行时就会抛出一个异常，就像下面的图示，是不是很熟悉！这其中的罪魁祸首就是，就是“GUI的线程处理模型”。</p>
<p><img src="/img/151257-20160321141551714-1827445547.png" alt="151257-20160321141551714-1827445547.png"></p>
<p>.NET支持多种不同应用程序模型，大多数的线程都是可以做任何事情（他们可能没有引入线程模型），但GUI应用程序（主要是Winform、WPF）引入了一个特殊线程处理模型，<font color=#0099ff size=4 face="黑体">UI控件元素只能由创建它的线程访问或修改，微软这样处理是为了保证UI控件的线程安全。</font></p>
<p>为什么在UI线程中执行一个耗时的计算操作，会导致UI假死呢？这个问题要追溯到Windows的消息机制了。</p>
<p>因为Windows是基于消息机制的，我们在UI上所有的键盘、鼠标操作都是以消息的形式发送给各个应用程序的。GUI线程内部就有一个消息队列，GUI线程不断的循环处理这些消息，并根据消息更新UI的呈现。如果这个时候，你让GUI线程去处理一个耗时的操作（比如花10秒去下载一个文件），那GUI线程就没办法处理消息队列了，UI界面就处于假死的状态。</p>
<p><img src="/img/151257-20160321141552292-299214517.png" alt="151257-20160321141552292-299214517.png"></p>
<p>在线程里处理事件完成后，需要更新UI控件的状态:</p>
<p><font color=#0099ff size=4 face="黑体">（1）使用GUI控件提供的方法，Winform是控件的Invoke方法，WPF中是控件的Dispatcher.Invoke方法</font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Winform：Invoke方法和BeginInvoke</span></span><br><span class="line"> <span class="keyword">this</span>.label.Invoke(method, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.WPF：Dispatcher.Invoke</span></span><br><span class="line"><span class="keyword">this</span>.label.Dispatcher.Invoke(method, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">（2）使用.NET中提供的BackgroundWorker执行耗时计算操作，在其任务完成事件RunWorkerCompleted 中更新UI控件</font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (BackgroundWorker bw = <span class="keyword">new</span> BackgroundWorker())</span><br><span class="line">&#123;</span><br><span class="line">    bw.RunWorkerCompleted += <span class="keyword">new</span> RunWorkerCompletedEventHandler((ojb,arg) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.label.Text = <span class="string">"test"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    bw.RunWorkerAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">（3）使用GUI线程处理模型的同步上下文来送封UI控件修改操作，这样可以不需要调用UI控件元素</font></p>
<p>.NET中提供一个用于同步上下文的类SynchronizationContext，利用它可以把应用程序模型链接到他的线程处理模型，其实它的本质还是调用的第一步（1）中的方法。</p>
<p>实现代码分为三步，第一步定义一个静态类，用于GUI线程的UI元素访问封装：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GUIThreadHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> System.Threading.SynchronizationContext GUISyncContext</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _GUISyncContext; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _GUISyncContext = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> System.Threading.SynchronizationContext _GUISyncContext =</span><br><span class="line">        System.Threading.SynchronizationContext.Current;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 主要用于GUI线程的同步回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="callback"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SyncContextCallback</span>(<span class="params">Action callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (GUISyncContext == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            callback();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        GUISyncContext.Post(result =&gt; callback(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 支持APM异步编程模型的GUI线程的同步回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncCallback <span class="title">SyncContextCallback</span>(<span class="params">AsyncCallback callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="literal">null</span>) <span class="keyword">return</span> callback;</span><br><span class="line">        <span class="keyword">if</span> (GUISyncContext == <span class="literal">null</span>) <span class="keyword">return</span> callback;</span><br><span class="line">        <span class="keyword">return</span> asynresult =&gt; GUISyncContext.Post(result =&gt; callback(result <span class="keyword">as</span> IAsyncResult), asynresult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，在主窗口注册当前SynchronizationContext：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            CLRTest.ConsoleTest.GUIThreadHelper.GUISyncContext = System.Threading.SynchronizationContext.Current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第三步，就是使用了，可以在任何地方使用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GUIThreadHelper.SyncContextCallback(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.txtMessage.Text = res.ToString();</span><br><span class="line">    <span class="keyword">this</span>.btnTest.Content = <span class="string">"DoTest"</span>;</span><br><span class="line">    <span class="keyword">this</span>.btnTest.IsEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="线程同步构造"><a href="#线程同步构造" class="headerlink" title="线程同步构造"></a>线程同步构造</h2><p>基元线程同步构造分为：基元用户模式构造和基元内核模式构造，两种同步构造方式各有优缺点，而混合构造（如lock）就是综合两种构造模式的优点。</p>
<h3 id="用户模式构造"><a href="#用户模式构造" class="headerlink" title="用户模式构造"></a>用户模式构造</h3><p>基元用户模式比基元内核模式速度要快，她使用特殊的cpu指令来协调线程，在硬件中发生，速度很快。但也因此Windows操作系统永远检测不到一个线程在一个用户模式构造上阻塞了。举个例子来模拟一下用户模式构造的同步方式：</p>
<ul>
<li>线程1请求了临界资源，并在资源门口使用了用户模式构造的锁；</li>
<li>线程2请求临界资源时，发现有锁，因此就在门口等待，并不停的去询问资源是否可用；</li>
<li>线程1如果使用资源时间较长，则线程2会一直运行，并且占用CPU时间。占用CPU干什么呢？她会不停的轮询锁的状态，直到资源可用，这就是所谓的活锁；</li>
</ul>
<p>缺点：<font color=#0099ff size=4 face="黑体">线程2会一直使用CPU时间（假如当前系统只有这两个线程在运行），也就意味着不仅浪费了CPU时间，而且还会有频繁的线程上下文切换，对性能影响是很严重的。</font></p>
<p><font color=#0099ff size=4 face="黑体">当然她的优点是效率高，适合哪种对资源占用时间很短的线程同步。</font></p>
<p>.NET中为我们提供了两种原子性操作，利用原子操作可以实现一些简单的用户模式锁（如自旋锁）。</p>
<ul>
<li>System.Threading.Interlocked：易失构造，它在包含一个简单数据类型的变量上执行原子性的读或写操作。</li>
<li>Thread.VolatileRead 和 Thread.VolatileWrite：互锁构造，它在包含一个简单数据类型的变量上执行原子性的读和写操作。</li>
</ul>
<h3 id="内核模式构造"><a href="#内核模式构造" class="headerlink" title="内核模式构造"></a>内核模式构造</h3><p>这是针对用户模式的一个补充，先模拟一个内核模式构造的同步流程来理解她的工作方式：</p>
<ul>
<li>线程1请求了临界资源，并在资源门口使用了内核模式构造的锁；</li>
<li>线程2请求临界资源时，发现有锁，就会被系统要求睡眠（阻塞），线程2就不会被执行了，也就不会浪费CPU和线程上下文切换了；</li>
<li>等待线程1使用完资源后，解锁后会发送一个通知，然后操作系统会把线程2唤醒。假如有多个线程在临界资源门口等待，则会挑选一个唤醒；</li>
</ul>
<p>看上去是不是非常棒！彻底解决了用户模式构造的缺点，但内核模式也有缺点的：将线程从用户模式切换到内核模式（或相反）导致巨大性能损失。调用线程将从托管代码转换为内核代码，再转回来，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此尽量不要让线程从用户模式转到内核模式。</p>
<p><font color=#0099ff size=4 face="黑体">它的优点就是阻塞线程，不浪费CPU时间，适合那种需要长时间占用资源的线程同步。</font></p>
<p>内核模式构造的主要有两种方式，以及基于这两种方式的常见的锁：</p>
<ul>
<li>基于事件：如AutoResetEvent、ManualResetEvent</li>
<li>基于信号量：如Semaphore</li>
</ul>
<h3 id="混合线程同步"><a href="#混合线程同步" class="headerlink" title="混合线程同步"></a>混合线程同步</h3><p>Lock、SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim</p>
<p>lock的本质就是使用的Monitor，lock只是一种简化的语法形式，实质的语法形式如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Enter(obj, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockTaken) Monitor.Exit(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** Semaphore 信号量**</p>
<p>它可以控制对某一段代码或者对某个资源访问的线程的数量，超过这个数量之后，其它的线程就得等待，只有等现在有线程释放了之后，下面的线程才能访问。这个跟锁有相似的功能，只不过不是独占的，它允许一定数量的线程同时访问。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SemaphoreSlim _sem = <span class="keyword">new</span> SemaphoreSlim(<span class="number">3</span>);    <span class="comment">// 我们限制能同时访问的线程数量是3</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="keyword">new</span> Thread(Enter).Start(i);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Enter</span>(<span class="params"><span class="keyword">object</span> id</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(id + <span class="string">" 开始排队..."</span>);</span><br><span class="line">    _sem.Wait();</span><br><span class="line">    Console.WriteLine(id + <span class="string">" 开始执行！"</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span> * (<span class="keyword">int</span>)id);</span><br><span class="line">    Console.WriteLine(id + <span class="string">" 执行完毕，离开！"</span>);</span><br><span class="line">    _sem.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/222030017324376.png" alt="222030017324376.png"></p>
<p>同步索引块是.NET中解决对象同步问题的基本机制，该机制为每个堆内的对象（即引用类型对象实例）分配一个同步索引，她其实是一个地址指针，初始值为-1不指向任何地址。</p>
<ul>
<li>创建一个锁对象Object obj，obj的同步索引块（地址）为-1，不指向任何地址；</li>
<li>Monitor.Enter（obj），创建或使用一个空闲的同步索引块（如下图中的同步块1），这个才是真正的同步索引块，其内部结构就是一个混合锁的结构，包含线程ID、递归计数、等待线程统计、内核对象等，类似一个混合锁AnotherHybridLock。obj对象（同步索引块AsynBlockIndex）指向该同步块1；</li>
<li>Exit时，重置为-1，那个同步索引块1可以被重复利用；</li>
</ul>
<h3 id="Lock关键字"><a href="#Lock关键字" class="headerlink" title="Lock关键字"></a>Lock关键字</h3><p>lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p>
<p>通常，应避免锁定 public 类型，否则实例将超出代码的控制范围。常见的结构 lock (this)、lock (typeof (MyType)) 和 lock (“myLock”) 违反此准则：</p>
<ul>
<li>如果实例可以被公共访问，将出现 lock (this) 问题。</li>
<li>如果 MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题。</li>
<li>由于进程中使用同一字符串的任何其他代码将共享同一个锁，所以出现lock(“myLock”) 问题。</li>
</ul>
<p>最佳做法是定义 private 对象来锁定, 或 private static 对象变量来保护所有实例所共有的数据。</p>
<p><font color=#0099ff size=4 face="黑体">不要Lock值类型,不要Lock(this),不要Lock(null对象),推荐Lock只读静态对象。</font></p>
<p><img src="/img/151257-20160321141553854-448927161.jpg" alt="151257-20160321141553854-448927161.jpg"></p>
<p>因此，锁对象要求必须为一个引用对象（在堆上）。</p>
<h3 id="多线程使用及线程同步总结"><a href="#多线程使用及线程同步总结" class="headerlink" title="多线程使用及线程同步总结"></a>多线程使用及线程同步总结</h3><p>在使用Lock时，关键点就是锁对象了，需要注意以下几个方面：</p>
<ul>
<li>这个对象肯定要是引用类型，值类型可不可呢？值类型可以装箱啊！你觉得可不可以？但也不要用值类型，因为值类型多次装箱后的对象是不同的，会导致无法锁定；</li>
<li>不要锁定this，尽量使用一个没有意义的Object对象来锁；</li>
<li>不要锁定一个类型对象，因类型对象是全局的；</li>
<li>不要锁定一个字符串，因为字符串可能被驻留，不同字符对象可能指向同一个字符串；</li>
<li>不要使用[System.Runtime.CompilerServices.MethodImpl(MethodImplOptions.Synchronized)]，这个可以使用在方法上面，保证方法同一时刻只能被一个线程调用。她实质上是使用lock的，如果是实例方法，会锁定this，如果是静态方法，则会锁定类型对象</li>
</ul>
<h2 id="题目答案解析"><a href="#题目答案解析" class="headerlink" title="题目答案解析"></a>题目答案解析</h2><h3 id="1-描述线程与进程的区别？"><a href="#1-描述线程与进程的区别？" class="headerlink" title="1. 描述线程与进程的区别？"></a>1. 描述线程与进程的区别？</h3><ul>
<li>一个应用程序实例是一个进程，一个进程内包含一个或多个线程，线程是进程的一部分；</li>
<li>进程之间是相互独立的，他们有各自的私有内存空间和资源，进程内的线程可以共享其所属进程的所有资源；</li>
</ul>
<h3 id="2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"><a href="#2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？" class="headerlink" title="2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"></a>2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？</h3><p>因为GUI应用程序引入了一个特殊的线程处理模型，为了保证UI控件的线程安全，这个线程处理模型不允许其他子线程跨线程访问UI元素。解决方法还是比较多的，如：</p>
<ul>
<li>利用UI控件提供的方法，Winform是控件的Invoke方法，WPF中是控件的Dispatcher.Invoke方法；</li>
<li>使用BackgroundWorker；</li>
<li>使用GUI线程处理模型的同步上下文SynchronizationContext来提交UI更新操作</li>
</ul>
<p>上面几个方式在文中已详细给出。</p>
<h3 id="3-简述后台线程和前台线程的区别？"><a href="#3-简述后台线程和前台线程的区别？" class="headerlink" title="3. 简述后台线程和前台线程的区别？"></a>3. 简述后台线程和前台线程的区别？</h3><p>应用程序必须运行完所有的前台线程才可以退出，或者主动结束前台线程，不管后台线程是否还在运行，应用程序都会结束；而对于后台线程，应用程序则可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时都会自动结束。</p>
<p>通过将 Thread.IsBackground 设置为 true，就可以将线程指定为后台线程，主线程就是一个前台线程。</p>
<h3 id="4-说说常用的锁，lock是一种什么样的锁？"><a href="#4-说说常用的锁，lock是一种什么样的锁？" class="headerlink" title="4. 说说常用的锁，lock是一种什么样的锁？"></a>4. 说说常用的锁，lock是一种什么样的锁？</h3><p>常用的如如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock是一个混合锁，其实质是Monitor[‘mɒnɪtə]。</p>
<h3 id="5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"><a href="#5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？" class="headerlink" title="5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"></a>5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？</h3><p>lock的锁对象要求为一个引用类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。</p>
<p>对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向一个真正的锁（同步块），这个锁（同步块）会被复用。</p>
<h3 id="6-多线程和异步有什么关系和区别？"><a href="#6-多线程和异步有什么关系和区别？" class="headerlink" title="6. 多线程和异步有什么关系和区别？"></a>6. 多线程和异步有什么关系和区别？</h3><p>多线程是实现异步的主要方式之一，异步并不等同于多线程。实现异步的方式还有很多，比如利用硬件的特性、使用进程或纤程等。在.NET中就有很多的异步编程支持，比如很多地方都有Begin、End的方法，就是一种异步编程支持，她内部有些是利用多线程，有些是利用硬件的特性来实现的异步编程。</p>
<h3 id="7-线程池的优点有哪些？又有哪些不足？"><a href="#7-线程池的优点有哪些？又有哪些不足？" class="headerlink" title="7. 线程池的优点有哪些？又有哪些不足？"></a>7. 线程池的优点有哪些？又有哪些不足？</h3><p>优点：减小线程创建和销毁的开销，可以复用线程；也从而减少了线程上下文切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。</p>
<p>缺点：线程池无法对一个线程有更多的精确的控制，如了解其运行状态等；不能设置线程的优先级；加入到线程池的任务（方法）不能有返回值；对于需要长期运行的任务就不适合线程池。</p>
<h3 id="8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？"><a href="#8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？" class="headerlink" title="8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？"></a>8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？</h3><p>Mutex是一个基于内核模式的互斥锁，支持锁的递归调用，而Lock是一个混合锁，一般建议使用Lock更好，因为lock的性能更好。</p>
<h3 id="9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"><a href="#9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。" class="headerlink" title="9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"></a>9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeadLockTest</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (<span class="keyword">this</span>)   <span class="comment">//或者lock一个静态object变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i--);</span><br><span class="line">            DeadLockTest(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会的，因为lock是一个混合锁，支持锁的递归调用，如果你使用一个ManualResetEvent或AutoResetEvent可能就会发生死锁。</p>
<h3 id="10-用双检锁实现一个单例模式Singleton。"><a href="#10-用双检锁实现一个单例模式Singleton。" class="headerlink" title="10. 用双检锁实现一个单例模式Singleton。"></a>10. 用双检锁实现一个单例模式Singleton。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static class Singleton&lt;T&gt; where T : class,new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T _Instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> _lockObj = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取单例对象的实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Instance != <span class="literal">null</span>) <span class="keyword">return</span> _Instance;</span><br><span class="line">        <span class="keyword">lock</span> (_lockObj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_Instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = Activator.CreateInstance&lt;T&gt;();</span><br><span class="line">                System.Threading.Interlocked.Exchange(<span class="keyword">ref</span> _Instance, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-下面代码输出结果是什么？为什么？如何改进她？"><a href="#11-下面代码输出结果是什么？为什么？如何改进她？" class="headerlink" title="11.下面代码输出结果是什么？为什么？如何改进她？"></a>11.下面代码输出结果是什么？为什么？如何改进她？</h3><p>int a = 0;<br>System.Threading.Tasks.Parallel.For(0, 100000, (i) =&gt;<br>{<br>    a++;<br>});<br>Console.Write(a);</p>
<p>输出结果不稳定，小于等于100000。因为多线程访问，没有使用锁机制，会导致有更新丢失。</p>
<p>改进：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Threading.Interlocked.Add(<span class="keyword">ref</span> a, <span class="number">1</span>);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="http://www.cnblogs.com/anding/p/5301754.html" target="_blank" rel="noopener">.NET面试题解析(07)-多线程编程与线程同步</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=netframework-4.7.2" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=netframework-4.7.2</a></p>
<p><a href="https://www.cnblogs.com/yifengjianbai/p/5499493.html" target="_blank" rel="noopener">C#多线程–线程池（ThreadPool）</a></p>
<p><a href="http://www.cnblogs.com/henw/archive/2012/01/06/2314870.html" target="_blank" rel="noopener">C#多线程学习 之 线程池[ThreadPool]</a></p>
<p><a href="http://www.cnblogs.com/chengqscjh/archive/2010/12/12/1903784.html" target="_blank" rel="noopener">C#深入学习笔记—Lock</a></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/DotNet/">DotNet</a><a href="/tags/CSharp/">CSharp</a><a href="/tags/CSharp基础/">CSharp基础</a><a href="/tags/DotNet面试题解析/">DotNet面试题解析</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/">DotNet面试题解析</a>
</div>



<div class="article-share" id="share">

  <div data-url="https://syxdevcode.github.com/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9008-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" data-title="DotNet面试题解析08-多线程与线程同步 | syxdevcode博客" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/12/22/DotNet基础-并行编程之Task/" title="DotNet基础-并行编程之Task">
  <strong>PREVIOUS:</strong><br/>
  <span>
  DotNet基础-并行编程之Task</span>
</a>
</div>


<div class="next">
<a href="/2018/12/20/DotNet面试题解析07-GC与内存管理/"  title="DotNet面试题解析07-GC与内存管理">
 <strong>NEXT:</strong><br/> 
 <span>DotNet面试题解析07-GC与内存管理
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程基础"><span class="toc-number">1.</span> <span class="toc-text">线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程与线程"><span class="toc-number">1.1.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的开销及调度"><span class="toc-number">1.2.</span> <span class="toc-text">线程的开销及调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池-ThreadPool"><span class="toc-number">2.1.</span> <span class="toc-text">线程池(ThreadPool)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务Task与并行Parallel"><span class="toc-number">2.2.</span> <span class="toc-text">任务Task与并行Parallel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GUI线程处理模型"><span class="toc-number">2.3.</span> <span class="toc-text">GUI线程处理模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程同步构造"><span class="toc-number">3.</span> <span class="toc-text">线程同步构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用户模式构造"><span class="toc-number">3.1.</span> <span class="toc-text">用户模式构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内核模式构造"><span class="toc-number">3.2.</span> <span class="toc-text">内核模式构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合线程同步"><span class="toc-number">3.3.</span> <span class="toc-text">混合线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock关键字"><span class="toc-number">3.4.</span> <span class="toc-text">Lock关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程使用及线程同步总结"><span class="toc-number">3.5.</span> <span class="toc-text">多线程使用及线程同步总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目答案解析"><span class="toc-number">4.</span> <span class="toc-text">题目答案解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-描述线程与进程的区别？"><span class="toc-number">4.1.</span> <span class="toc-text">1. 描述线程与进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"><span class="toc-number">4.2.</span> <span class="toc-text">2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-简述后台线程和前台线程的区别？"><span class="toc-number">4.3.</span> <span class="toc-text">3. 简述后台线程和前台线程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-说说常用的锁，lock是一种什么样的锁？"><span class="toc-number">4.4.</span> <span class="toc-text">4. 说说常用的锁，lock是一种什么样的锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"><span class="toc-number">4.5.</span> <span class="toc-text">5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-多线程和异步有什么关系和区别？"><span class="toc-number">4.6.</span> <span class="toc-text">6. 多线程和异步有什么关系和区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-线程池的优点有哪些？又有哪些不足？"><span class="toc-number">4.7.</span> <span class="toc-text">7. 线程池的优点有哪些？又有哪些不足？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？"><span class="toc-number">4.8.</span> <span class="toc-text">8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"><span class="toc-number">4.9.</span> <span class="toc-text">9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-用双检锁实现一个单例模式Singleton。"><span class="toc-number">4.10.</span> <span class="toc-text">10. 用双检锁实现一个单例模式Singleton。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-下面代码输出结果是什么？为什么？如何改进她？"><span class="toc-number">4.11.</span> <span class="toc-text">11.下面代码输出结果是什么？为什么？如何改进她？</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Net-Standard/" title=".Net Standard">.Net Standard<sup>2</sup></a></li>
		
			<li><a href="/categories/net异步与并行/" title=".net异步与并行">.net异步与并行<sup>10</sup></a></li>
		
			<li><a href="/categories/ABP/" title="ABP">ABP<sup>27</sup></a></li>
		
			<li><a href="/categories/ASP-NET-IIS请求处理管道/" title="ASP.NET/IIS请求处理管道">ASP.NET/IIS请求处理管道<sup>2</sup></a></li>
		
			<li><a href="/categories/ApplicationPoolIdentify/" title="ApplicationPoolIdentify">ApplicationPoolIdentify<sup>1</sup></a></li>
		
			<li><a href="/categories/CSharp基础/" title="CSharp基础">CSharp基础<sup>11</sup></a></li>
		
			<li><a href="/categories/CentOS7/" title="CentOS7">CentOS7<sup>5</sup></a></li>
		
			<li><a href="/categories/Chrome/" title="Chrome">Chrome<sup>1</sup></a></li>
		
			<li><a href="/categories/CodeDOM/" title="CodeDOM">CodeDOM<sup>3</sup></a></li>
		
			<li><a href="/categories/Consul/" title="Consul">Consul<sup>3</sup></a></li>
		
			<li><a href="/categories/Docker/" title="Docker">Docker<sup>7</sup></a></li>
		
			<li><a href="/categories/Docker-Compose/" title="Docker Compose">Docker Compose<sup>3</sup></a></li>
		
			<li><a href="/categories/DotNetCore/" title="DotNetCore">DotNetCore<sup>3</sup></a></li>
		
			<li><a href="/categories/DotNet面试题解析/" title="DotNet面试题解析">DotNet面试题解析<sup>8</sup></a></li>
		
			<li><a href="/categories/EasyNetQ/" title="EasyNetQ">EasyNetQ<sup>1</sup></a></li>
		
			<li><a href="/categories/Elasticsearch/" title="Elasticsearch">Elasticsearch<sup>1</sup></a></li>
		
			<li><a href="/categories/Emit-反射发出/" title="Emit(反射发出)">Emit(反射发出)<sup>6</sup></a></li>
		
			<li><a href="/categories/Expression-Tree/" title="Expression Tree">Expression Tree<sup>2</sup></a></li>
		
			<li><a href="/categories/Git/" title="Git">Git<sup>2</sup></a></li>
		
			<li><a href="/categories/HostService/" title="HostService">HostService<sup>1</sup></a></li>
		
			<li><a href="/categories/JavaScript-JQuery/" title="JavaScript/JQuery">JavaScript/JQuery<sup>1</sup></a></li>
		
			<li><a href="/categories/Jenkins/" title="Jenkins">Jenkins<sup>2</sup></a></li>
		
			<li><a href="/categories/Jexus/" title="Jexus">Jexus<sup>1</sup></a></li>
		
			<li><a href="/categories/Json-Net/" title="Json.Net">Json.Net<sup>1</sup></a></li>
		
			<li><a href="/categories/LINQ/" title="LINQ">LINQ<sup>3</sup></a></li>
		
			<li><a href="/categories/Let’s-Encrypt/" title="Let’s Encrypt">Let’s Encrypt<sup>1</sup></a></li>
		
			<li><a href="/categories/Linux基础命令/" title="Linux基础命令">Linux基础命令<sup>6</sup></a></li>
		
			<li><a href="/categories/MSIL指令/" title="MSIL指令">MSIL指令<sup>2</sup></a></li>
		
			<li><a href="/categories/MVC-Web-API/" title="MVC/Web API">MVC/Web API<sup>2</sup></a></li>
		
			<li><a href="/categories/MariaDB/" title="MariaDB">MariaDB<sup>1</sup></a></li>
		
			<li><a href="/categories/MarkDown/" title="MarkDown">MarkDown<sup>1</sup></a></li>
		
			<li><a href="/categories/MongoDB/" title="MongoDB">MongoDB<sup>3</sup></a></li>
		
			<li><a href="/categories/Moq/" title="Moq">Moq<sup>1</sup></a></li>
		
			<li><a href="/categories/MySql/" title="MySql">MySql<sup>3</sup></a></li>
		
			<li><a href="/categories/Naudio/" title="Naudio">Naudio<sup>2</sup></a></li>
		
			<li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>2</sup></a></li>
		
			<li><a href="/categories/OAuth2-0/" title="OAuth2.0">OAuth2.0<sup>2</sup></a></li>
		
			<li><a href="/categories/Ocelot/" title="Ocelot">Ocelot<sup>1</sup></a></li>
		
			<li><a href="/categories/Openssl/" title="Openssl">Openssl<sup>2</sup></a></li>
		
			<li><a href="/categories/Polly/" title="Polly">Polly<sup>2</sup></a></li>
		
			<li><a href="/categories/PostGresqlSql/" title="PostGresqlSql">PostGresqlSql<sup>1</sup></a></li>
		
			<li><a href="/categories/RESTful/" title="RESTful">RESTful<sup>2</sup></a></li>
		
			<li><a href="/categories/RabbitMQ/" title="RabbitMQ">RabbitMQ<sup>2</sup></a></li>
		
			<li><a href="/categories/Redis/" title="Redis">Redis<sup>5</sup></a></li>
		
			<li><a href="/categories/Resharper/" title="Resharper">Resharper<sup>1</sup></a></li>
		
			<li><a href="/categories/SSH/" title="SSH">SSH<sup>1</sup></a></li>
		
			<li><a href="/categories/SSL-TLS/" title="SSL/TLS">SSL/TLS<sup>2</sup></a></li>
		
			<li><a href="/categories/Skywalking/" title="Skywalking">Skywalking<sup>1</sup></a></li>
		
			<li><a href="/categories/Sql/" title="Sql">Sql<sup>5</sup></a></li>
		
			<li><a href="/categories/TDD/" title="TDD">TDD<sup>1</sup></a></li>
		
			<li><a href="/categories/TPL-DataFlow/" title="TPL DataFlow">TPL DataFlow<sup>2</sup></a></li>
		
			<li><a href="/categories/WCF时间类型序列化/" title="WCF时间类型序列化">WCF时间类型序列化<sup>1</sup></a></li>
		
			<li><a href="/categories/WebForm/" title="WebForm">WebForm<sup>2</sup></a></li>
		
			<li><a href="/categories/WinDbg/" title="WinDbg">WinDbg<sup>1</sup></a></li>
		
			<li><a href="/categories/WinSCP/" title="WinSCP">WinSCP<sup>1</sup></a></li>
		
			<li><a href="/categories/Windows子系统/" title="Windows子系统">Windows子系统<sup>1</sup></a></li>
		
			<li><a href="/categories/Windows系统/" title="Windows系统">Windows系统<sup>1</sup></a></li>
		
			<li><a href="/categories/ab/" title="ab">ab<sup>1</sup></a></li>
		
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>2</sup></a></li>
		
			<li><a href="/categories/shadowsocks/" title="shadowsocks">shadowsocks<sup>1</sup></a></li>
		
			<li><a href="/categories/zookeeper/" title="zookeeper">zookeeper<sup>1</sup></a></li>
		
			<li><a href="/categories/内存泄漏/" title="内存泄漏">内存泄漏<sup>1</sup></a></li>
		
			<li><a href="/categories/分布式/" title="分布式">分布式<sup>1</sup></a></li>
		
			<li><a href="/categories/分布式事务/" title="分布式事务">分布式事务<sup>1</sup></a></li>
		
			<li><a href="/categories/单词收录/" title="单词收录">单词收录<sup>14</sup></a></li>
		
			<li><a href="/categories/反射/" title="反射">反射<sup>4</sup></a></li>
		
			<li><a href="/categories/委托与事件/" title="委托与事件">委托与事件<sup>4</sup></a></li>
		
			<li><a href="/categories/工具/" title="工具">工具<sup>1</sup></a></li>
		
			<li><a href="/categories/并发模型/" title="并发模型">并发模型<sup>1</sup></a></li>
		
			<li><a href="/categories/插件/" title="插件">插件<sup>1</sup></a></li>
		
			<li><a href="/categories/时间-时间戳转换/" title="时间/时间戳转换">时间/时间戳转换<sup>1</sup></a></li>
		
			<li><a href="/categories/消息队列/" title="消息队列">消息队列<sup>1</sup></a></li>
		
			<li><a href="/categories/程序集/" title="程序集">程序集<sup>2</sup></a></li>
		
			<li><a href="/categories/算法/" title="算法">算法<sup>3</sup></a></li>
		
			<li><a href="/categories/线性表/" title="线性表">线性表<sup>1</sup></a></li>
		
			<li><a href="/categories/线程池/" title="线程池">线程池<sup>1</sup></a></li>
		
			<li><a href="/categories/缓存/" title="缓存">缓存<sup>3</sup></a></li>
		
			<li><a href="/categories/计算机基础/" title="计算机基础">计算机基础<sup>2</sup></a></li>
		
			<li><a href="/categories/认证与授权/" title="认证与授权">认证与授权<sup>1</sup></a></li>
		
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		
			<li><a href="/categories/链表/" title="链表">链表<sup>2</sup></a></li>
		
			<li><a href="/categories/集合与泛型/" title="集合与泛型">集合与泛型<sup>3</sup></a></li>
		
			<li><a href="/categories/音频-视频/" title="音频/视频">音频/视频<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist" style="clear:both;">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Net-Standard/" title=".Net Standard">.Net Standard<sup>2</sup></a></li>
		
			<li><a href="/tags/net异步与并行/" title=".net异步与并行">.net异步与并行<sup>12</sup></a></li>
		
			<li><a href="/tags/ABP/" title="ABP">ABP<sup>27</sup></a></li>
		
			<li><a href="/tags/ASP-NET-IIS请求处理管道/" title="ASP.NET/IIS请求处理管道">ASP.NET/IIS请求处理管道<sup>7</sup></a></li>
		
			<li><a href="/tags/AWS/" title="AWS">AWS<sup>7</sup></a></li>
		
			<li><a href="/tags/ApplicationPoolIdentify/" title="ApplicationPoolIdentify">ApplicationPoolIdentify<sup>1</sup></a></li>
		
			<li><a href="/tags/CSharp/" title="CSharp">CSharp<sup>101</sup></a></li>
		
			<li><a href="/tags/CSharp基础/" title="CSharp基础">CSharp基础<sup>44</sup></a></li>
		
			<li><a href="/tags/CentOS7/" title="CentOS7">CentOS7<sup>24</sup></a></li>
		
			<li><a href="/tags/Chrome/" title="Chrome">Chrome<sup>1</sup></a></li>
		
			<li><a href="/tags/CodeDOM/" title="CodeDOM">CodeDOM<sup>3</sup></a></li>
		
			<li><a href="/tags/Consul/" title="Consul">Consul<sup>4</sup></a></li>
		
			<li><a href="/tags/Docker/" title="Docker">Docker<sup>23</sup></a></li>
		
			<li><a href="/tags/Docker-Compose/" title="Docker Compose">Docker Compose<sup>5</sup></a></li>
		
			<li><a href="/tags/DotNet/" title="DotNet">DotNet<sup>106</sup></a></li>
		
			<li><a href="/tags/DotNetCore/" title="DotNetCore">DotNetCore<sup>16</sup></a></li>
		
			<li><a href="/tags/DotNet面试题解析/" title="DotNet面试题解析">DotNet面试题解析<sup>10</sup></a></li>
		
			<li><a href="/tags/Elasticsearch/" title="Elasticsearch">Elasticsearch<sup>2</sup></a></li>
		
			<li><a href="/tags/Emit-反射发出/" title="Emit(反射发出)">Emit(反射发出)<sup>8</sup></a></li>
		
			<li><a href="/tags/Expression-Tree/" title="Expression Tree">Expression Tree<sup>3</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
<div style="display: none;" id="rocket-to-top">
  <div style="opacity: 0; display: block;" class="level-2"></div>
  <div class="level-3"></div>
</div>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		<a href="https://github.com/syxdevcode" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/syxdevcode/pacman" target="_blank" title="Pacman">Pacman</a> © 2020 
		
		<a href="https://syxdevcode.github.com" target="_blank" title="syxdevcode">syxdevcode</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>

<script type="text/javascript">
  $(document).ready(function () {
    $('.navbar').click(function () {
      $('header nav').toggleClass('shownav');
    });
    var myWidth = 0;
    function getSize() {
      if (typeof (window.innerWidth) == 'number') {
        myWidth = window.innerWidth;
      } else if (document.documentElement && document.documentElement.clientWidth) {
        myWidth = document.documentElement.clientWidth;
      };
    };
    var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
    $(window).resize(function () {
      getSize();
      if (myWidth >= 1024) {
        $('header nav').removeClass('shownav');
      } else {
        m.removeClass('moveMain');
        a.css('display', 'block').removeClass('fadeOut');
        o.css('display', 'none');
      
          $('#toc.toc-aside').css('display', 'none');
        
    }
    });
    c.click(function () {
      a.addClass('fadeOut').css('display', 'none');
      o.css('display', 'block').addClass('fadeIn');
      m.addClass('moveMain');
    });
    o.click(function () {
      o.css('display', 'none').removeClass('beforeFadeIn');
      a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
      m.removeClass('moveMain');
    });
    $(window).scroll(function () {
      o.css("top", Math.max(80, 260 - $(this).scrollTop()));
    });
  });
  //判断访问终端
  var browser = {
    versions: function () {
      var u = navigator.userAgent,
        app = navigator.appVersion;
      return {
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1,//火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Adr') > -1, //android终端
        iPhone: u.indexOf('iPhone') > -1, //是否为iPhone或者QQHD浏览器
        iPad: u.indexOf('iPad') > -1, //是否iPad
        webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') > -1, //是否微信 （2015-01-22新增）
        qq: u.match(/\sQQ/i) == " qq" //是否QQ
      };
    }(),
    language: (navigator.browserLanguage || navigator.language).toLowerCase()
  }
</script>

<script type="text/javascript">
  $(document).ready(function () {
    var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t = $('#toc'),
      h = $('article h2')
    ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o = $('.openaside'),
      c = $('.closeaside');
    if (ai.length > 0) {
      ai.wrap('<div class="video-container" />');
    };
    if (ae.length > 0) {
      ae.wrap('<div class="video-container" />');
    };
    if (ah.length == 0) {
      t.css('display', 'none');
    } else {
      c.click(function () {
        ta.css('display', 'block').addClass('fadeIn');
      });
      o.click(function () {
        ta.css('display', 'none');
      });
      $(window).scroll(function () {
        ta.css("top", Math.max(140, 320 - $(this).scrollTop()));
      });
    };
  });
</script>


<script type="text/javascript">
  $(document).ready(function () {
    var $this = $('.share'),
      //url = $this.attr('data-url'),
      url = window.location.href,
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
    var html = [
      '<a href="#" class="overlay" id="qrcode"></a>',
      '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://mobile.qq.com/qrcode?url=' + encodedUrl + '"/></div>',
      '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
      '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
      '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
      '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
      '<a href="http://service.weibo.com/share/share.php?title=' + title + '&url=' + encodedUrl + '&ralateUid=' + tsina + '&searchPic=true&style=number' + '" class="article-share-weibo" target="_blank" title="Weibo"></a>',
      '<span title="Share to"></span>'
    ].join('');
    $this.append(html);
    viewqrCode();
    $('.article-share-qrcode').click(viewqrCode()
    );

  });
  function viewqrCode() {
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function () {
      $('.qrcode strong').text(' ');
    });
  }
</script>
<script type="text/javascript">  
  //判断是否移动端 
  if (!browser.versions.mobile) {
    $(function () {
      var c, a = $("#rocket-to-top"), e = ($(document).scrollTop(), !0);
      $(window).scroll(function () {
        var b = $(document).scrollTop(); 0 == b ? "0px 0px" == a.css("background-position") ? a.fadeOut("slow") : e && (e = !1, $(".level-2").css("opacity", 1), a.delay(100).animate({ marginTop: "-1000px" }, "normal", function () { a.css({ "margin-top": "-125px", display: "none" }), e = !0 })) : a.fadeIn("slow")
      }), a.hover(function () { $(".level-2").stop(!0).animate({ opacity: 1 }) }, function () { $(".level-2").stop(!0).animate({ opacity: 0 }) }), $(".level-3").click(function () { function b() { var b = a.css("background-position"); if ("none" == a.css("display") || 0 == e) return clearInterval(c), a.css("background-position", "0px 0px"), void 0; switch (b) { case "0px 0px": a.css("background-position", "-298px 0px"); break; case "-298px 0px": a.css("background-position", "-447px 0px"); break; case "-447px 0px": a.css("background-position", "-596px 0px"); break; case "-596px 0px": a.css("background-position", "-745px 0px"); break; case "-745px 0px": a.css("background-position", "-298px 0px") } } e && (c = setInterval(b, 50), $("html,body").animate({ scrollTop: 0 }, "slow")) })
    });
  }
</script>





  </body>
</html>
