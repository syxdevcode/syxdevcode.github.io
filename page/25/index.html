<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/25/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/25/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/11/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/11/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Redis内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-11 14:02:41" itemprop="dateCreated datePublished" datetime="2018-06-11T14:02:41+00:00">2018-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转载<a target="_blank" rel="noopener" href="http://www.cnblogs.com/kismetv/p/8654978.html">深入学习Redis（1）：Redis内存模型</a></p>
<p>这篇文章主要介绍Redis的内存模型（以3.0为例），包括Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器(jemalloc)、简单动态字符串(SDS)、RedisObject等；然后在此基础上介绍几个Redis内存模型的应用。</p>
<h2 id="一、Redis内存统计"><a href="#一、Redis内存统计" class="headerlink" title="一、Redis内存统计"></a>一、Redis内存统计</h2><p>在客户端通过redis-cli连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过info命令可以查看内存使用情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; info memory</span><br><span class="line"># Memory</span><br><span class="line">used_memory:848344</span><br><span class="line">used_memory_human:828.46K</span><br><span class="line">used_memory_rss:7520256</span><br><span class="line">used_memory_rss_human:7.17M</span><br><span class="line">used_memory_peak:848344</span><br><span class="line">used_memory_peak_human:828.46K</span><br><span class="line">used_memory_peak_perc:100.01%</span><br><span class="line">used_memory_overhead:836086</span><br><span class="line">used_memory_startup:786456</span><br><span class="line">used_memory_dataset:12258</span><br><span class="line">used_memory_dataset_perc:19.81%</span><br><span class="line">total_system_memory:1910714368</span><br><span class="line">total_system_memory_human:1.78G</span><br></pre></td></tr></table></figure>

<p>其中，info命令可以显示redis服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；memory是参数，表示只显示内存相关的信息。</p>
<p>返回结果中比较重要的几个说明如下：</p>
<p>（1）** used_memory**：Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。</p>
<p>（2）** used_memory_rss**：Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。</p>
<p>因此，used_memory和used_memory_rss，前者是从Redis角度得到的量，后者是从操作系统角度得到的量。二者之所以有所不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。</p>
<p>由于在实际应用中，Redis的数据量会比较大，此时进程运行占用的内存与Redis数据量和内存碎片相比，都会小得多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片率的参数；这个参数就是mem_fragmentation_ratio。</p>
<p>（3）** mem_fragmentation_ratio**：内存碎片比率，该值是used_memory_rss / used_memory的比值。</p>
<p>mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。mem_fragmentation_ratio&lt;1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。</p>
<p>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；</p>
<p>（4）** mem_allocator**：Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。</p>
<h2 id="二、Redis内存划分"><a href="#二、Redis内存划分" class="headerlink" title="二、Redis内存划分"></a>二、Redis内存划分</h2><p>Redis的内存占用主要可以划分为以下几个部分：</p>
<h3 id="1、数据"><a href="#1、数据" class="headerlink" title="1、数据"></a>1、数据</h3><p>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。</p>
<p>Redis使用键值对存储数据，其中的值（对象）包括5种类型，即字符串、哈希、列表、集合、有序集合。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；这篇文章后面将重点介绍Redis中数据存储的细节。</p>
<h3 id="2、进程本身运行需要的内存"><a href="#2、进程本身运行需要的内存" class="headerlink" title="2、进程本身运行需要的内存"></a>2、进程本身运行需要的内存</h3><p>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。</p>
<p>补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。</p>
<h3 id="3、缓冲内存"><a href="#3、缓冲内存" class="headerlink" title="3、缓冲内存"></a>3、缓冲内存</h3><p>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。</p>
<h3 id="4、内存碎片"><a href="#4、内存碎片" class="headerlink" title="4、内存碎片"></a>4、内存碎片</h3><p>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。</p>
<p>内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。</p>
<p>如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。</p>
<h2 id="三、Redis数据存储的细节"><a href="#三、Redis数据存储的细节" class="headerlink" title="三、Redis数据存储的细节"></a>三、Redis数据存储的细节</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。</p>
<p>下图是执行set hello world时，所涉及到的数据模型。</p>
<p><img src="/img/1174710-20180327001055927-1896197804.png" alt="1174710-20180327001055927-1896197804.png"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://searchdatabase.techtarget.com.cn/7-20218/">https://searchdatabase.techtarget.com.cn/7-20218/</a></p>
<p>（1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。</p>
<p>（2）Key：图中右上角可见，Key（”hello”）并不是直接以字符串存储，而是存储在SDS结构中。</p>
<p>（3）redisObject：Value(“world”)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。</p>
<p>实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。</p>
<p>（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。</p>
<p>下面来分别介绍jemalloc、redisObject、SDS、对象类型及内部编码。</p>
<h3 id="2、jemalloc"><a href="#2、jemalloc" class="headerlink" title="2、jemalloc"></a>2、jemalloc</h3><p>Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。</p>
<p>jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p>
<p>jemalloc划分的内存单元如下图所示：</p>
<p><img src="/img/1174710-20180327001126509-2023165562.png" alt="1174710-20180327001126509-2023165562.png"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.csdn.net/zhengpeitao/article/details/76573053">http://blog.csdn.net/zhengpeitao/article/details/76573053</a></p>
<p>例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。</p>
<h3 id="3、redisObject"><a href="#3、redisObject" class="headerlink" title="3、redisObject"></a>3、redisObject</h3><p>前面说到，Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。</p>
<p>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，下面将通过redisObject的结构来说明它是如何起作用的。</p>
<p>redisObject的定义如下（不同版本的Redis可能稍稍有所不同）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">　　unsigned type:4;</span><br><span class="line">　　unsigned encoding:4;</span><br><span class="line">　　unsigned lru:REDIS_LRU_BITS; &#x2F;* lru time (relative to server.lruclock) *&#x2F;</span><br><span class="line">　　int refcount;</span><br><span class="line">　　void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>redisObject的每个字段的含义和作用如下：</p>
<h4 id="（1）type"><a href="#（1）type" class="headerlink" title="（1）type"></a>（1）type</h4><p>type字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。</p>
<p>当我们执行type命令时，便是通过读取RedisObject的type字段获得对象的类型；如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set mystring helloredis</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; type mystring</span><br><span class="line">string</span><br><span class="line">172.19.0.2:6380&gt; sadd myset member1 member2 member3</span><br><span class="line">(integer) 3</span><br><span class="line">172.19.0.2:6380&gt; type myset</span><br><span class="line">set</span><br></pre></td></tr></table></figure>

<h4 id="（2）encoding"><a href="#（2）encoding" class="headerlink" title="（2）encoding"></a>（2）encoding</h4><p>encoding表示对象的内部编码，占4个比特。</p>
<p>对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。以列表对象为例，有压缩列表和双端链表两种编码方式；如果列表中的元素较少，Redis倾向于使用压缩列表进行存储，因为压缩列表占用内存更少，而且比双端链表可以更快载入；当列表对象元素较多时，压缩列表就会转化为更适合存储大量元素的双端链表。</p>
<p>通过object encoding命令，可以查看对象采用的编码方式，如所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set key1 33</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;int&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key2 helloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<h4 id="（3）lru"><a href="#（3）lru" class="headerlink" title="（3）lru"></a>（3）lru</h4><p>lru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。</p>
<p>通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 540</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 541</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 547</span><br><span class="line">172.19.0.2:6380&gt; get mystring</span><br><span class="line">&quot;helloredis&quot;</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br></pre></td></tr></table></figure>

<p>lru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。</p>
<h4 id="（4）refcount"><a href="#（4）refcount" class="headerlink" title="（4）refcount"></a>（4）refcount</h4><p>** refcount与共享对象**</p>
<p>refcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。</p>
<p>Redis中被多次使用的对象(refcount&gt;1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。</p>
<p>** 共享对象的具体实现 **</p>
<p>Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。</p>
<p>虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。</p>
<p>就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0<del>9999的整数值；当Redis需要使用值为0</del>9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。</p>
<h4 id="（5）ptr"><a href="#（5）ptr" class="headerlink" title="（5）ptr"></a>（5）ptr</h4><p>ptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>综上所述，redisObject的结构与对象类型、编码、内存回收、共享对象都有关系；一个redisObject对象的大小为16字节：</p>
<p>4bit+4bit+24bit+4Byte+8Byte=16Byte。</p>
<h3 id="4、SDS"><a href="#4、SDS" class="headerlink" title="4、SDS"></a>4、SDS</h3><p>Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。</p>
<h4 id="（1）SDS结构"><a href="#（1）SDS结构" class="headerlink" title="（1）SDS结构"></a>（1）SDS结构</h4><p>sds的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度。下面是两个例子。</p>
<p>通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。</p>
<h4 id="2-SDS与C字符串的应用"><a href="#2-SDS与C字符串的应用" class="headerlink" title="(2)SDS与C字符串的应用"></a>(2)SDS与C字符串的应用</h4><p>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（”myset”），还是集合中的元素（”member1”、 ”member2”和”member3”），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。</p>
<p>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。</p>
<h2 id="四、Redis的对象类型与内部编码"><a href="#四、Redis的对象类型与内部编码" class="headerlink" title="四、Redis的对象类型与内部编码"></a>四、Redis的对象类型与内部编码</h2><p>前面已经说过，Redis支持5种对象类型，而每种结构都有至少两种编码；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。</p>
<p>关于Redis内部编码的转换，都符合以下规律：编码转换在Redis写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。</p>
<h3 id="1、字符串"><a href="#1、字符串" class="headerlink" title="1、字符串"></a>1、字符串</h3><h4 id="（1）概况"><a href="#（1）概况" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。</p>
<p>字符串长度不能超过512MB。</p>
<h4 id="（2）内部编码"><a href="#（2）内部编码" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>字符串类型的内部编码有3种，它们的应用场景如下：</p>
<p>** int**：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。</p>
<p>** embstr**：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</p>
<p>** raw**：大于39个字节的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;int&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key2 helloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key3 helloworldhelloworldhelloworldhelloworldhelloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; strlen key3</span><br><span class="line">(integer) 50</span><br><span class="line">172.19.0.2:6380&gt; object encoding key3</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">172.19.0.2:6380&gt;</span><br></pre></td></tr></table></figure>

<p>embstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。</p>
<h4 id="（3）编码转换"><a href="#（3）编码转换" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。</p>
<p>而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set key1 hello</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">172.19.0.2:6380&gt; append key1 ,world</span><br><span class="line">(integer) 11</span><br><span class="line">172.19.0.2:6380&gt; get key1</span><br><span class="line">&quot;hello,world&quot;</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2、列表"><a href="#2、列表" class="headerlink" title="2、列表"></a>2、列表</h3><h4 id="（1）列表概况"><a href="#（1）列表概况" class="headerlink" title="（1）列表概况"></a>（1）列表概况</h4><p>列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。</p>
<h4 id="（2）列表内部编码"><a href="#（2）列表内部编码" class="headerlink" title="（2）列表内部编码"></a>（2）列表内部编码</h4><p>列表的内部编码可以是压缩列表（ziplist）或双端链表（linkedlist）。</p>
<p>双端链表：由一个list结构和多个listNode结构组成；典型结构如下图所示：</p>
<p><img src="/img/1174710-20180327001435577-242733744.png" alt="1174710-20180327001435577-242733744.png"></p>
<p>图片来源：《Redis设计与实现》</p>
<p>通过图中可以看出，双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。</p>
<p>压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。</p>
<p>压缩列表不仅用于实现列表，也用于实现哈希、有序列表；使用非常广泛。</p>
<h4 id="（3）列表编码转换"><a href="#（3）列表编码转换" class="headerlink" title="（3）列表编码转换"></a>（3）列表编码转换</h4><p>只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。</p>
<p>其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。</p>
<h3 id="3、哈希"><a href="#3、哈希" class="headerlink" title="3、哈希"></a>3、哈希</h3><h4 id="（1）概况-1"><a href="#（1）概况-1" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。为了说明的方便，在本文后面当使用“内层的哈希”时，代表的是redis对外提供的5种对象类型的一种；使用“外层的哈希”代指Redis作为Key-Value数据库所使用的数据结构。</p>
<p>#####（2）内部编码</p>
<p>内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。</p>
<p>压缩列表前面已介绍。与哈希表相比，压缩列表用于元素个数少、元素长度小的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。</p>
<p>hashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成。</p>
<p>正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：</p>
<p><img src="/img/1174710-20180327001627028-325473621.png" alt="1174710-20180327001627028-325473621.png"></p>
<p>图片改编自：《Redis设计与实现》</p>
<p>下面从底层向上依次介绍各个部分：</p>
<p>** dictEntry **</p>
<p>dictEntry结构用于保存键值对，结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">    void *key;</span><br><span class="line">    union&#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<p>其中，各个属性的功能如下：</p>
<p>key：键值对中的键；<br>val：键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型；<br>next：指向下一个dictEntry，用于解决哈希冲突问题<br>在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。</p>
<p>** bucket**</p>
<p>bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。</p>
<p>** dictht**</p>
<p>dictht结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    unsigned long size;</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<p>其中，各个属性的功能说明如下：</p>
<p>table属性是一个指针，指向bucket；<br>size属性记录了哈希表的大小，即bucket的大小；<br>used记录了已使用的dictEntry的数量；<br>sizemask属性的值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置。</p>
<p>** dict**</p>
<p>一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。</p>
<p>dict结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pedef struct dict&#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    void *privdata;</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    int trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>其中，type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。</p>
<p>ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。</p>
<p>因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。</p>
<h3 id="（3）编码转换-1"><a href="#（3）编码转换-1" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h3><p>如前所述，Redis中内层的哈希既可能使用哈希表，也可能使用压缩列表。</p>
<p>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。</p>
<p>下图展示了Redis内层的哈希编码转换的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; hset myhash k1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; hset myhash k2 v2</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">172.19.0.2:6380&gt; hset myhash k4 vvsdfsddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">172.19.0.2:6380&gt; hdel myhash k4</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">172.19.0.2:6380&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4、集合"><a href="#4、集合" class="headerlink" title="4、集合"></a>4、集合</h3><h4 id="（1）概况-2"><a href="#（1）概况-2" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。</p>
<p>一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取交集、并集、差集。</p>
<h4 id="（2）内部编码-1"><a href="#（2）内部编码-1" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。</p>
<p>哈希表前面已经讲过，这里略过不提；需要注意的是，集合在使用哈希表时，值全部被置为null。</p>
<p>整数集合的结构定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>其中，encoding代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的；length表示元素个数。</p>
<p>整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于集合数量较少，因此操作的时间并没有明显劣势。</p>
<h4 id="（3）编码转换-2"><a href="#（3）编码转换-2" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。</p>
<h3 id="5、有序集合"><a href="#5、有序集合" class="headerlink" title="5、有序集合"></a>5、有序集合</h3><h4 id="（1）概况-3"><a href="#（1）概况-3" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p>
<h4 id="（2）内部编码-2"><a href="#（2）内部编码-2" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。ziplist在列表和哈希中都有使用，前面已经讲过，这里略过不提。</p>
<p>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。</p>
<h4 id="（3）编码转换-3"><a href="#（3）编码转换-3" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。</p>
<h2 id="五、应用举例"><a href="#五、应用举例" class="headerlink" title="五、应用举例"></a>五、应用举例</h2><h3 id="1、估算Redis内存使用量"><a href="#1、估算Redis内存使用量" class="headerlink" title="1、估算Redis内存使用量"></a>1、估算Redis内存使用量</h3><p>要估算redis中的数据占据的内存大小，需要对redis的内存模型有比较全面的了解，包括前面介绍的hashtable、sds、redisobject、各种对象类型的编码方式等。</p>
<p>下面以最简单的字符串类型来进行说明。</p>
<p>假设有90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。在估算占据空间之前，首先可以判定字符串类型使用的编码方式：embstr。</p>
<p>90000个键值对占据的内存空间主要可以分为两部分：一部分是90000个dictEntry占据的空间；一部分是键值对所需要的bucket空间。</p>
<p>每个dictEntry占据的空间包括：</p>
<p>1) 一个dictEntry，24字节，jemalloc会分配32字节的内存块</p>
<p>2) 一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节的内存块</p>
<p>3) 一个redisObject，16字节，jemalloc会分配16字节的内存块</p>
<p>4) 一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块</p>
<p>5) 综上，一个dictEntry需要32+16+16+16=80个字节。</p>
<p>bucket空间：bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。</p>
<p>因此，可以估算出这90000个键值对占据的内存大小为：90000<em>80 + 131072</em>8 = 8248576。</p>
<h3 id="2、优化内存占用"><a href="#2、优化内存占用" class="headerlink" title="2、优化内存占用"></a>2、优化内存占用</h3><p>了解redis的内存模型，对优化redis内存占用有很大帮助。下面介绍几种优化场景。</p>
<p>（1）利用jemalloc特性进行优化</p>
<p>上一小节所讲述的90000个键值便是一个例子。由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。</p>
<p>例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p>
<p>（2）使用整型/长整型</p>
<p>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。</p>
<p>（3）共享对象</p>
<p>利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。</p>
<p>考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。</p>
<p>（4）避免过度设计</p>
<p>然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。</p>
<p>如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。</p>
<h3 id="3、关注内存碎片率"><a href="#3、关注内存碎片率" class="headerlink" title="3、关注内存碎片率"></a>3、关注内存碎片率</h3><p>内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。</p>
<p>如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p>
<p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p>
<p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">分布式之数据库和缓存双写一致性方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-08 17:14:48" itemprop="dateCreated datePublished" datetime="2018-06-08T17:14:48+00:00">2018-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式之数据库和缓存双写一致性方案"><a href="#分布式之数据库和缓存双写一致性方案" class="headerlink" title="分布式之数据库和缓存双写一致性方案"></a>分布式之数据库和缓存双写一致性方案</h1><p>本文参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a>,做的进一步整理笔记。</p>
<p>三种更新策略：</p>
<p>1.先更新数据库，再更新缓存</p>
<p>2.先删除缓存，再更新数据库</p>
<p>3.先更新数据库，再删除缓存</p>
<h2 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="(1)先更新数据库，再更新缓存"></a>(1)先更新数据库，再更新缓存</h2><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。</p>
<p>** 原因一（线程安全角度）**</p>
<p>同时有请求A和请求B进行更新操作，那么会出现</p>
<p>（1）线程A更新了数据库</p>
<p>（2）线程B更新了数据库</p>
<p>（3）线程B更新了缓存</p>
<p>（4）线程A更新了缓存</p>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<p>** 原因二（业务场景角度）**</p>
<p>有如下两点：</p>
<p>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</p>
<p>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<h2 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="(2)先删缓存，再更新数据库"></a>(2)先删缓存，再更新数据库</h2><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求B查询发现缓存不存在</p>
<p>（3）请求B去数据库查询得到旧值</p>
<p>（4）请求B将旧值写入缓存</p>
<p>（5）请求A将新值写入数据库</p>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，如何解决呢？采用延时双删策略</p>
<p>伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void write(string key,object data)</span><br><span class="line">&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化为中文描述就是</p>
<p>（1）先淘汰缓存</p>
<p>（2）再写数据库（这两步和原来一样）</p>
<p>（3）休眠1秒，再次淘汰缓存</p>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p>
<p>** 那么，这个1秒怎么确定的，具体该休眠多久呢？**</p>
<p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>** 如果你用了mysql的读写分离架构怎么办？**</p>
<p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求A将数据写入数据库了</p>
<p>（3）请求B查询缓存发现，缓存没有值</p>
<p>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
<p>（5）请求B将旧值写入缓存</p>
<p>（6）数据库完成主从同步，从库变为新值</p>
<p>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<p>** 采用这种同步淘汰策略，吞吐量降低怎么办？**</p>
<p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
<p>** 第二次删除,如果删除失败怎么办？**</p>
<p>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求B查询发现缓存不存在</p>
<p>（3）请求B去数据库查询得到旧值</p>
<p>（4）请求B将旧值写入缓存</p>
<p>（5）请求A将新值写入数据库</p>
<p>（6）请求A试图去删除请求B写入对缓存值，结果失败了。</p>
<p>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。</p>
<p>如何解决呢？<br>具体解决方案，且看对第(3)种更新策略的解析。</p>
<h2 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="(3)先更新数据库，再删缓存"></a>(3)先更新数据库，再删缓存</h2><p>** Cache Aside Pattern **</p>
<p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<p>** 失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</p>
<p>** 命中**：应用程序从cache中取数据，取到后返回。</p>
<p>** 更新**：先把数据存到数据库中，成功后，再让缓存失效。</p>
<p>注意，我们的更新是先更新数据库，成功后，让缓存失效。</p>
<p>** 这种情况不存在并发问题么？**</p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>
<p>（1）缓存刚好失效</p>
<p>（2）请求A查询数据库，得一个旧值</p>
<p>（3）请求B将新值写入数据库</p>
<p>（4）请求B删除缓存</p>
<p>（5）请求A将查到的旧值写入缓存</p>
<p>ok，如果发生上述情况，确实是会发生脏数据。</p>
<p>** 然而，发生这种情况的概率又有多少呢？**</p>
<p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</p>
<p>** 如何解决上述并发问题？**</p>
<p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p>
<p>** 还有其他造成不一致的原因么？**</p>
<p>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p>
<p>** 如何解决？**</p>
<p>提供一个保障的重试机制即可，这里给出两套方案。</p>
<p>** 方案一：**</p>
<p>流程如下所示</p>
<p><img src="/img/o_update1.png" alt="o_update1.png"></p>
<p>（1）更新数据库数据；</p>
<p>（2）缓存因为种种问题删除失败</p>
<p>（3）将需要删除的key发送至消息队列</p>
<p>（4）自己消费消息，获得需要删除的key</p>
<p>（5）继续重试删除操作，直到成功</p>
<p>** 方案二：**</p>
<p>流程如下所示：</p>
<p><img src="/img/o_update2.png" alt="o_update2.png"></p>
<p>（1）更新数据库数据</p>
<p>（2）数据库会将操作信息写入binlog日志当中</p>
<p>（3）订阅程序提取出所需要的数据以及key</p>
<p>（4）另起一段非业务代码，获得该信息</p>
<p>（5）尝试删除缓存操作，发现删除失败</p>
<p>（6）将这些信息发送至消息队列</p>
<p>（7）重新从消息队列中获得该数据，重试操作。</p>
<p>备注说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。另外，重试机制，可以采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect">主从DB与cache一致性</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/08/Redis%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/08/Redis%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Redis详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-08 16:01:34" itemprop="dateCreated datePublished" datetime="2018-06-08T16:01:34+00:00">2018-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis详解"><a href="#Redis详解" class="headerlink" title="Redis详解"></a>Redis详解</h1><p>本文参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/rjzheng/p/9096228.html">【原创】分布式之redis复习精讲</a>,做的进一步整理笔记。</p>
<h2 id="1、为什么使用redis"><a href="#1、为什么使用redis" class="headerlink" title="1、为什么使用redis"></a>1、为什么使用redis</h2><p>Redis 的优势：</p>
<p>性能极高 – Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。</p>
<p>丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p>
<p>原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</p>
<p>丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p>
<h2 id="2、使用redis有什么缺点"><a href="#2、使用redis有什么缺点" class="headerlink" title="2、使用redis有什么缺点"></a>2、使用redis有什么缺点</h2><p>分析:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>
<p>回答:主要是四个问题</p>
<p>(一)缓存和数据库双写一致性问题</p>
<p>(二)缓存雪崩问题</p>
<p>(三)缓存击穿问题</p>
<p>(四)缓存的并发竞争问题</p>
<h2 id="3、单线程的redis为什么这么快"><a href="#3、单线程的redis为什么这么快" class="headerlink" title="3、单线程的redis为什么这么快"></a>3、单线程的redis为什么这么快</h2><p>分析:这个问题其实是对redis内部机制的一个考察。</p>
<p>回答:主要是以下三点</p>
<p>(一)纯内存操作</p>
<p>(二)单线程操作，避免了频繁的上下文切换</p>
<p>(三)采用了非阻塞I/O多路复用机制</p>
<h2 id="4、redis的数据类型，以及每种数据类型的使用场景"><a href="#4、redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="4、redis的数据类型，以及每种数据类型的使用场景"></a>4、redis的数据类型，以及每种数据类型的使用场景</h2><p>** 一共五种 **</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。</p>
<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作</p>
<h2 id="5、redis的过期策略以及内存淘汰机制"><a href="#5、redis的过期策略以及内存淘汰机制" class="headerlink" title="5、redis的过期策略以及内存淘汰机制"></a>5、redis的过期策略以及内存淘汰机制</h2><p>分析:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>
<p>回答:<br>redis采用的是定期删除+惰性删除策略。</p>
<h3 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" class="headerlink" title="为什么不用定时删除策略"></a>为什么不用定时删除策略</h3><p>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>
<h3 id="定期删除-惰性删除是如何工作的呢"><a href="#定期删除-惰性删除是如何工作的呢" class="headerlink" title="定期删除+惰性删除是如何工作的呢"></a>定期删除+惰性删除是如何工作的呢</h3><p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<h3 id="采用定期删除-惰性删除就没其他问题了么"><a href="#采用定期删除-惰性删除就没其他问题了么" class="headerlink" title="采用定期删除+惰性删除就没其他问题了么"></a>采用定期删除+惰性删除就没其他问题了么</h3><p>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在redis.conf中有一行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<p>该配置就是配内存淘汰策略的</p>
<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。** 不推荐**</p>
<p>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。** 推荐使用。**</p>
<p>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。** 不推荐。**</p>
<p>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。** 不推荐 **</p>
<p>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。** 不推荐**</p>
<p>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。** 不推荐**</p>
<p>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<h2 id="6、redis和数据库双写一致性问题"><a href="#6、redis和数据库双写一致性问题" class="headerlink" title="6、redis和数据库双写一致性问题"></a>6、redis和数据库双写一致性问题</h2><p>分析:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>
<p>回答: 参考 《<a target="_blank" rel="noopener" href="https://syxdevcode.github.io/2018/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/">分布式之数据库和缓存双写一致性方案解析</a>》首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>
<h2 id="7、如何应对缓存穿透和缓存雪崩问题"><a href="#7、如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="7、如何应对缓存穿透和缓存雪崩问题"></a>7、如何应对缓存穿透和缓存雪崩问题</h2><p>分析:一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>
<p>回答:如下所示</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p>** 解决方案:**</p>
<p>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</p>
<p>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</p>
<p>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p>解决方案:</p>
<p>(一)给缓存的失效时间，加上一个随机值，避免集体失效。</p>
<p>(二)使用互斥锁，但是该方案吞吐量明显下降了。</p>
<p>(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点</p>
<p>I 从缓存A读数据库，有则直接返回</p>
<p>II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</p>
<p>III 更新线程同时更新缓存A和缓存B。</p>
<h2 id="8、如何解决redis的并发竞争问题"><a href="#8、如何解决redis的并发竞争问题" class="headerlink" title="8、如何解决redis的并发竞争问题"></a>8、如何解决redis的并发竞争问题</h2><p>分析:同时有多个子系统去set一个key。s不推荐使用redis的事务机制。因为生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p>
<p>回答:如下所示</p>
<p>(1)如果对这个key操作，不要求顺序</p>
<p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</p>
<p>(2)如果对这个key操作，要求顺序</p>
<p>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.</p>
<p>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure>

<p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/rjzheng/p/9096228.html">【原创】分布式之redis复习精讲</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/28/Redis%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/28/Redis%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-28 08:46:39" itemprop="dateCreated datePublished" datetime="2018-05-28T08:46:39+00:00">2018-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h1><p>Redis虽然是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题Redis提供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。</p>
<h2 id="AOF与RDB对比"><a href="#AOF与RDB对比" class="headerlink" title="AOF与RDB对比"></a>AOF与RDB对比</h2><p>** AOF **更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢， 也更完整。</p>
<p>** RDB **持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小，恢复数度较快。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>redis提供了RDB持久化的功能，这个功能可以将redis在内存中的的状态保存到硬盘中，它可以手动执行，也可以再redis.conf中配置，定期执行。</p>
<p>RDB持久化产生的RDB文件是一个经过压缩的二进制文件，这个文件被保存在硬盘中，redis可以通过这个文件还原数据库当时的状态。</p>
<h3 id="RDB的创建与载入"><a href="#RDB的创建与载入" class="headerlink" title="RDB的创建与载入"></a>RDB的创建与载入</h3><p>RDB文件可以通过两个命令来生成：</p>
<p><code>SAVE</code>：阻塞redis的服务器进程，直到RDB文件被创建完毕。<br><code>BGSAVE</code>：派生(fork)一个子进程来创建新的RDB文件，记录接收到BGSAVE当时的数据库状态，父进程继续处理接收到的命令，子进程完成文件的创建之后，会发送信号给父进程，而与此同时，父进程处理命令的同时，通过轮询来接收子进程的信号。<br>而RDB文件的载入一般情况是自动的，redis服务器启动的时候，redis服务器再启动的时候如果检测到RDB文件的存在，那么redis会自动载入这个文件。</p>
<p>如果服务器开启了AOF持久化，那么服务器会优先使用AOF文件来还原数据库状态。</p>
<p>RDB是通过保存键值对来记录数据库状态的，采用copy on write的模式，每次都是全量的备份。</p>
<h3 id="自动保存间隔"><a href="#自动保存间隔" class="headerlink" title="自动保存间隔"></a>自动保存间隔</h3><p><code>BGSAVE</code>可以在不阻塞主进程的情况下完成数据的备份。可以通过redis.conf中设置多个自动保存条件，只要有一个条件被满足，服务器就会执行BGSAVE命令。</p>
<p>相关配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 以下配置表示的条件：</span><br><span class="line"># 服务器在900秒之内被修改了1次</span><br><span class="line">save 900 1</span><br><span class="line"># 服务器在300秒之内被修改了10次</span><br><span class="line">save 300 10</span><br><span class="line"># 服务器在60秒之内被修改了10000次</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>AOF持久化（Append-Only-File），与RDB持久化不同，AOF持久化是通过保存Redis服务器锁执行的写状态来记录数据库的</p>
<p>具体来说，RDB持久化相当于备份数据库状态，而AOF持久化是备份数据库接收到的命令，所有被写入AOF的命令都是以redis的协议格式来保存的。</p>
<p>在AOF持久化的文件中，数据库会记录下所有变更数据库状态的命令，除了指定数据库的select命令，其他的命令都是来自client的，这些命令会以追加(append)的形式保存到文件中。</p>
<p>** appendfsync** 影响服务器多久完成一次命令的记录</p>
<p><code>always</code>：将缓存区的内容总是即时写到AOF文件中。</p>
<p><code>everysec</code>：将缓存区的内容每隔一秒写入AOF文件中。</p>
<p><code>no</code> ：写入AOF文件中的操作由操作系统决定，一般而言为了提高效率，操作系统会等待缓存区被填满，才会开始同步数据到磁盘</p>
<p>redis默认<code>everysec</code></p>
<p>redis在载入AOF文件的时候，会创建一个虚拟的client，把AOF中每一条命令都执行一遍，最终还原回数据库的状态，它的载入也是自动的。在RDB和AOF备份文件都有的情况下，redis会优先载入AOF备份文件</p>
<p>AOF文件可能会随着服务器运行的时间越来越大，可以利用AOF重写的功能，来控制AOF文件的大小。AOF重写功能会首先读取数据库中现有的键值对状态，然后根据类型使用一条命令来替代前的键值对多条命令。</p>
<p>AOF重写功能有大量写入操作，所以redis才用子进程来处理AOF重写。这里带来一个新的问题，由于处理重新的是子进程，这样意味着如果主线程的数据在此时被修改，备份的数据和主库的数据将会有不一致的情况发生。因此redis还设置了一个AOF重写缓冲区，这个缓冲区在子进程被创建开始之后开始使用，这个期间，所有的命令会被存两份，一份在AOF缓存空间，一份在AOF重写缓冲区，当AOF重写完成之后，子进程发送信号给主进程，通知主进程将AOF重写缓冲区的内容添加到AOF文件中。</p>
<p>相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#AOF 和 RDB 持久化方式可以同时启动并且无冲突。</span><br><span class="line">#如果AOF开启，启动redis时会加载aof文件，这些文件能够提供更好的保证。</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 只增文件的文件名称。（默认是appendonly.aof）</span><br><span class="line"># appendfilename appendonly.aof </span><br><span class="line">#redis支持三种不同的写入方式：</span><br><span class="line">#</span><br><span class="line"># no:不调用，之等待操作系统来清空缓冲区当操作系统要输出数据时。很快。</span><br><span class="line"># always: 每次更新数据都写入仅增日志文件。慢，但是最安全。</span><br><span class="line"># everysec: 每秒调用一次。折中。</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入.官方文档建议如果你有特殊的情况可以配置为&#39;yes&#39;。但是配置为&#39;no&#39;是最为安全的选择。</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 自动重写只增文件。</span><br><span class="line"># redis可以自动盲从的调用‘BGREWRITEAOF’来重写日志文件，如果日志文件增长了指定的百分比。</span><br><span class="line"># 当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># 当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line"> |--data</span><br><span class="line"> |--docker-compose.yml</span><br><span class="line"> |--Dockerfile</span><br><span class="line"> |--redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="新建redis-conf"><a href="#新建redis-conf" class="headerlink" title="新建redis.conf"></a>新建redis.conf</h3><p>具体配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用守护进程模式</span></span><br><span class="line"><span class="attribute">daemonize</span> <span class="literal">no</span></span><br><span class="line"><span class="comment"># 非保护模式，可以外网访问</span></span><br><span class="line">protected-mode <span class="literal">no</span></span><br><span class="line">timeout <span class="number">300</span></span><br><span class="line">databases <span class="number">16</span></span><br><span class="line">rdbcompression <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 学习开发，使用最大日志级别，能够看到最多的日志信息</span></span><br><span class="line">loglevel <span class="literal">debug</span></span><br><span class="line">port <span class="number">6380</span></span><br><span class="line"><span class="comment">##授权密码，各个配置保持一致</span></span><br><span class="line"><span class="comment">##暂且禁用指令重命名</span></span><br><span class="line"><span class="comment">##rename-command</span></span><br><span class="line"><span class="comment">##开启AOF，禁用snapshot</span></span><br><span class="line">slave-read-only <span class="literal">yes</span></span><br><span class="line">maxclients <span class="number">10000</span></span><br><span class="line">maxmemory 1000mb</span><br><span class="line"></span><br><span class="line"><span class="comment">#AOF 和 RDB 持久化方式可以同时启动并且无冲突。</span></span><br><span class="line"><span class="comment">#如果AOF开启，启动redis时会加载aof文件，这些文件能够提供更好的保证。</span></span><br><span class="line">appendonly <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只增文件的文件名称。（默认是appendonly.aof）</span></span><br><span class="line"><span class="comment"># appendfilename appendonly.aof</span></span><br><span class="line"><span class="comment">#redis支持三种不同的写入方式：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># no:不调用，之等待操作系统来清空缓冲区当操作系统要输出数据时。很快。</span></span><br><span class="line"><span class="comment"># always: 每次更新数据都写入仅增日志文件。慢，但是最安全。</span></span><br><span class="line"><span class="comment"># everysec: 每秒调用一次。折中。</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入.官方文档建议如果你有特殊的情况可以配置为&#x27;yes&#x27;。但是配置为&#x27;no&#x27;是最为安全的选择。</span></span><br><span class="line"><span class="literal">no</span>-appendfsync-<span class="literal">on</span>-rewrite <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动重写只增文件。</span></span><br><span class="line"><span class="comment"># redis可以自动盲从的调用‘BGREWRITEAOF’来重写日志文件，如果日志文件增长了指定的百分比。</span></span><br><span class="line"><span class="comment"># 当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="comment"># 当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<h3 id="新建Dockerfile"><a href="#新建Dockerfile" class="headerlink" title="新建Dockerfile"></a>新建Dockerfile</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> redis:<span class="number">4</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --update tzdata</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> redis.conf /conf/redis.conf</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chown redis:redis /conf/*</span></span><br></pre></td></tr></table></figure>

<p>** 生成镜像**</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t redis:v2 .</span><br></pre></td></tr></table></figure>

<h3 id="新建docker-compose-yml"><a href="#新建docker-compose-yml" class="headerlink" title="新建docker-compose.yml"></a>新建docker-compose.yml</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis-master:</span><br><span class="line">    container_name: redis_server</span><br><span class="line">    volumes:</span><br><span class="line">      - $PWD/data:/data</span><br><span class="line">    image: redis:v2</span><br><span class="line">    command: [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;/conf/redis.conf&quot;</span>]</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;6380:6380&quot;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;6380&quot;</span></span><br></pre></td></tr></table></figure>

<p>** 执行**</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在data目录查看是否有.aof文件生成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redistest1]# cd data</span><br><span class="line">[root@localhost data]# ls</span><br><span class="line">appendonly.aof</span><br></pre></td></tr></table></figure>

<h4 id="获取容器IP"><a href="#获取容器IP" class="headerlink" title="获取容器IP"></a>获取容器IP</h4><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> redis_server</span><br><span class="line"><span class="number">172.19</span>.<span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<h4 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h4><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis_server redis-cli -h <span class="number">172.19</span>.<span class="number">0.2</span> -p <span class="number">6380</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bedec93e5a7b">Redis 持久化</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/9137897.html">深入学习Redis（2）：持久化</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/25/Docker%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/25/Docker%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA/" class="post-title-link" itemprop="url">Docker修改时区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-25 09:31:59" itemprop="dateCreated datePublished" datetime="2018-05-25T09:31:59+00:00">2018-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker修改时区"><a href="#Docker修改时区" class="headerlink" title="Docker修改时区"></a>Docker修改时区</h1><h2 id="修改Dockerfile"><a href="#修改Dockerfile" class="headerlink" title="修改Dockerfile"></a>修改Dockerfile</h2><p>** CentOS7**</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --update tzdata</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#update system timezone</span></span><br><span class="line"><span class="comment">#RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#update application timezone</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt;&gt; /etc/timezone</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/21/Docker%E5%AE%89%E8%A3%85Redis%20Sentinel(%E9%AB%98%E5%8F%AF%E7%94%A8)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/21/Docker%E5%AE%89%E8%A3%85Redis%20Sentinel(%E9%AB%98%E5%8F%AF%E7%94%A8)/" class="post-title-link" itemprop="url">Docker安装Redis Sentinel(高可用)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-21 08:51:08" itemprop="dateCreated datePublished" datetime="2018-05-21T08:51:08+00:00">2018-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker安装redis-Sentinel-高可用"><a href="#Docker安装redis-Sentinel-高可用" class="headerlink" title="Docker安装redis Sentinel(高可用)"></a>Docker安装redis Sentinel(高可用)</h1><h2 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h2><p>redis集群有两种，一种是redis sentinel(哨兵)，高可用集群，同时只有一个master，各实例数据保持一致；一种是redis cluster，分布式集群，同时有多个master，数据分片部署在各个master上。 哨兵模式简单说就是在后台有一个监控，监控当前的主机并巡逻主机下面的从机，如果某一时刻主机挂掉了，那么他会通过一种投票的机制从从机之中选举一台作为新的主机，并且其余的从机将会连接到这个新的主机上面，完成故障转移,主从模式就是一个中心化的结构,通过哨兵完成去中心化；本次要搭建的是redis sentinel。</p>
<p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p>
<ul>
<li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redis</span><br><span class="line"> |--master</span><br><span class="line"> |--slave1</span><br><span class="line"> |--slave2</span><br><span class="line"> |--Dockerfile</span><br><span class="line"> |--redis.conf</span><br><span class="line"> |--docker-compose.yml</span><br><span class="line"> |--sentinel.conf</span><br><span class="line"> |--start.sh</span><br></pre></td></tr></table></figure>

<h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><p>整个集群可以分为一个master，N个slave，M个sentinel，本次以2个slave和3个sentinel为例</p>
<h3 id="增加redis-conf"><a href="#增加redis-conf" class="headerlink" title="增加redis.conf"></a>增加redis.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 使用守护进程模式</span><br><span class="line">daemonize no</span><br><span class="line"># 非保护模式，可以外网访问</span><br><span class="line">protected-mode no</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 学习开发，使用最大日志级别，能够看到最多的日志信息</span><br><span class="line">loglevel debug</span><br><span class="line">port $redis_port</span><br><span class="line">##授权密码，各个配置保持一致</span><br><span class="line">##暂且禁用指令重命名</span><br><span class="line">##rename-command</span><br><span class="line">##开启AOF，禁用snapshot</span><br><span class="line">appendonly yes</span><br><span class="line">#slaveof redis-master $master_port</span><br><span class="line">slave-read-only yes</span><br><span class="line">maxclients 10000</span><br><span class="line">maxmemory 1000mb</span><br></pre></td></tr></table></figure>

<h3 id="增加sentinel-conf"><a href="#增加sentinel-conf" class="headerlink" title="增加sentinel.conf"></a>增加sentinel.conf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port $sentinel_port</span><br><span class="line">dir &quot;&#x2F;tmp&quot;</span><br><span class="line">sentinel monitor mymaster redis-master $master_port 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line">sentinel failover-timeout manager1 180000</span><br><span class="line">sentinel parallel-syncs manager1 2</span><br></pre></td></tr></table></figure>

<p>这四行配置为一组，因为我们只有一个 master 节点，所以只配置了一个 master，可以配置多个 master，不用配置 slave 的信息，因为 slave 能够被自动检测到（master 节点会有关于 slave 的消息）</p>
<p>其他选项的基本格式如下：</p>
<p>sentinel &lt;选项的名字&gt; &lt;主服务器的名字&gt; &lt;选项的值&gt;</p>
<ul>
<li><code>auth-pass</code>：选项指定了 master 的连接密码。</li>
<li><code>down-after-milliseconds</code>：选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。</li>
<li><code>failover-timeout</code>：如果在该时间（ms）内未能完成 failover 操作，则认为该 failover 失败。</li>
<li><code>parallel-syncs</code>：选项指定了在执行故障转移时，最多可以有多少个从服务器同时对新的主服务器进行同步，这个数字越小，完成故障转移所需的时间就越长。</li>
</ul>
<h3 id="添加start-sh"><a href="#添加start-sh" class="headerlink" title="添加start.sh"></a>添加start.sh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;conf</span><br><span class="line">redis_role&#x3D;$1</span><br><span class="line">echo $redis_role</span><br><span class="line">if [ $redis_role &#x3D; &quot;master&quot; ] ; then</span><br><span class="line">    echo &quot;master&quot;</span><br><span class="line">    sed -i &quot;s&#x2F;\$redis_port&#x2F;$redis_port&#x2F;g&quot; redis.conf</span><br><span class="line">    redis-server &#x2F;conf&#x2F;redis.conf</span><br><span class="line">elif [ $redis_role &#x3D; &quot;slave&quot; ] ; then</span><br><span class="line">    echo &quot;slave&quot;</span><br><span class="line">    sed -i &quot;s&#x2F;\$redis_port&#x2F;$redis_port&#x2F;g&quot; redis.conf</span><br><span class="line">    sed -i &quot;s&#x2F;#slaveof&#x2F;slaveof&#x2F;g&quot; redis.conf</span><br><span class="line">    sed -i &quot;s&#x2F;\$master_port&#x2F;$master_port&#x2F;g&quot; redis.conf</span><br><span class="line">    redis-server &#x2F;conf&#x2F;redis.conf</span><br><span class="line">elif [ $redis_role &#x3D; &quot;sentinel&quot; ] ; then</span><br><span class="line">    echo &quot;sentinel&quot;</span><br><span class="line">    sed -i &quot;s&#x2F;\$sentinel_port&#x2F;$sentinel_port&#x2F;g&quot; sentinel.conf</span><br><span class="line">    sed -i &quot;s&#x2F;\$master_port&#x2F;$master_port&#x2F;g&quot; sentinel.conf</span><br><span class="line">    redis-sentinel &#x2F;conf&#x2F;sentinel.conf</span><br><span class="line">else</span><br><span class="line">    echo &quot;unknow role!&quot;</span><br><span class="line">fi     #ifend</span><br></pre></td></tr></table></figure>

<h3 id="添加Dockerfile"><a href="#添加Dockerfile" class="headerlink" title="添加Dockerfile"></a>添加Dockerfile</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> redis:<span class="number">4</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --update tzdata</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> redis.conf /conf/redis.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> sentinel.conf /conf/sentinel.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> start.sh /conf/start.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x /conf/start.sh &amp;&amp; chown redis:redis /conf/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;/conf/start.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;master&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="build镜像"><a href="#build镜像" class="headerlink" title="build镜像"></a>build镜像</h3><p>在当前目录执行以下命令，创建redis:v1镜像。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t redis:v1 .</span><br></pre></td></tr></table></figure>

<h2 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h2><p>在根目录创建<code>master</code>,<code>slave1</code>,<code>slave2</code>目录。</p>
<p>创建<code>docker-compose.yml</code></p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis-master:</span><br><span class="line">    container_name: redis-master</span><br><span class="line">    build:</span><br><span class="line">      context: ./master</span><br><span class="line">    volumes:</span><br><span class="line">      - /master/data:/data</span><br><span class="line">    environment:</span><br><span class="line">      redis_port: <span class="string">&#x27;16379&#x27;</span></span><br><span class="line">    image: redis:v1</span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;16379&quot;</span></span><br><span class="line">  redis-slave1:</span><br><span class="line">    container_name: redis-slave1</span><br><span class="line">    build:</span><br><span class="line">      context:./slave1</span><br><span class="line">    volumes:</span><br><span class="line">      - /slave1/data:/data</span><br><span class="line">    environment:</span><br><span class="line">      master_port: <span class="string">&#x27;16379&#x27;</span></span><br><span class="line">      redis_port: <span class="string">&#x27;16380&#x27;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;16380&quot;</span></span><br><span class="line">    command:</span><br><span class="line">      - slave</span><br><span class="line">    image: redis:v1</span><br><span class="line">  redis-slave2:</span><br><span class="line">    container_name: redis-slave2</span><br><span class="line">    build:</span><br><span class="line">      context:./slave2</span><br><span class="line">    volumes:</span><br><span class="line">      - /slave2/data:/data</span><br><span class="line">    environment:</span><br><span class="line">      master_port: <span class="string">&#x27;16379&#x27;</span></span><br><span class="line">      redis_port: <span class="string">&#x27;16380&#x27;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;16380&quot;</span></span><br><span class="line">    command:</span><br><span class="line">      - slave</span><br><span class="line">    image: redis:v1</span><br><span class="line">  redis-sentinel-<span class="number">1</span>:</span><br><span class="line">    container_name: redis-sentinel-<span class="number">1</span></span><br><span class="line">    environment:</span><br><span class="line">      master_port: <span class="string">&#x27;16379&#x27;</span></span><br><span class="line">      sentinel_port: <span class="string">&#x27;16381&#x27;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;16381&quot;</span></span><br><span class="line">    command:</span><br><span class="line">      - sentinel</span><br><span class="line">    depends_on:</span><br><span class="line">      - <span class="string">&quot;redis-master&quot;</span></span><br><span class="line">      - <span class="string">&quot;redis-slave1&quot;</span></span><br><span class="line">      - <span class="string">&quot;redis-slave2&quot;</span></span><br><span class="line">    image: redis:v1</span><br><span class="line">  redis-sentinel-<span class="number">2</span>:</span><br><span class="line">    container_name: redis-sentinel-<span class="number">2</span></span><br><span class="line">    environment:</span><br><span class="line">      master_port: <span class="string">&#x27;16379&#x27;</span></span><br><span class="line">      sentinel_port: <span class="string">&#x27;16381&#x27;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;16381&quot;</span></span><br><span class="line">    command:</span><br><span class="line">      - sentinel</span><br><span class="line">    depends_on:</span><br><span class="line">      - <span class="string">&quot;redis-master&quot;</span></span><br><span class="line">      - <span class="string">&quot;redis-slave1&quot;</span></span><br><span class="line">      - <span class="string">&quot;redis-slave2&quot;</span></span><br><span class="line">    image: redis:v1</span><br><span class="line">  redis-sentinel-<span class="number">3</span>:</span><br><span class="line">    container_name: redis-sentinel-<span class="number">3</span></span><br><span class="line">    environment:</span><br><span class="line">      master_port: <span class="string">&#x27;16379&#x27;</span></span><br><span class="line">      sentinel_port: <span class="string">&#x27;16381&#x27;</span></span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;16381&quot;</span></span><br><span class="line">    command:</span><br><span class="line">      - sentinel</span><br><span class="line">    depends_on:</span><br><span class="line">      - <span class="string">&quot;redis-master&quot;</span></span><br><span class="line">      - <span class="string">&quot;redis-slave1&quot;</span></span><br><span class="line">      - <span class="string">&quot;redis-slave2&quot;</span></span><br><span class="line">    image: redis:v1</span><br></pre></td></tr></table></figure>

<p>运行以下命令以启动：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p>可以选择添加<code>-d</code>参数以守护进程启动。</p>
<h2 id="Redis-Sentinel-故障转移测试"><a href="#Redis-Sentinel-故障转移测试" class="headerlink" title="Redis Sentinel 故障转移测试"></a>Redis Sentinel 故障转移测试</h2><h3 id="查看redis-master服务IP"><a href="#查看redis-master服务IP" class="headerlink" title="查看redis-master服务IP"></a>查看redis-master服务IP</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> redis-master</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># docker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; redis-master</span></span><br><span class="line"><span class="number">172.18</span>.<span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<h3 id="查看mymaster节点IP"><a href="#查看mymaster节点IP" class="headerlink" title="查看mymaster节点IP"></a>查看mymaster节点IP</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec redis-sentinel-<span class="number">1</span> redis-cli -p <span class="number">16381</span> SENTINEL get-master-addr-by-name mymaster</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># docker exec redis-sentinel-1 redis-cli -p 16381 SENTINEL get-master-addr-by-name mymaster</span></span><br><span class="line"><span class="number">172.18</span>.<span class="number">0.2</span></span><br><span class="line"><span class="number">16379</span></span><br></pre></td></tr></table></figure>

<h3 id="连接client"><a href="#连接client" class="headerlink" title="连接client"></a>连接client</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-master redis-cli -h <span class="number">172.18</span>.<span class="number">0.2</span> -p <span class="number">16379</span></span><br></pre></td></tr></table></figure>

<h3 id="停止master节点"><a href="#停止master节点" class="headerlink" title="停止master节点"></a>停止master节点</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause redis-master</span><br></pre></td></tr></table></figure>

<h3 id="查询master主节点IP"><a href="#查询master主节点IP" class="headerlink" title="查询master主节点IP"></a>查询master主节点IP</h3><p>注意：中间有时间间隔。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec redis-sentinel-<span class="number">1</span> redis-cli -p <span class="number">16381</span> SENTINEL get-master-addr-by-name mymaster</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># docker exec redis-sentinel-1 redis-cli -p 16381 SENTINEL get-master-addr-by-name mymaster</span></span><br><span class="line"><span class="number">172.18</span>.<span class="number">0.4</span></span><br><span class="line"><span class="number">16380</span></span><br></pre></td></tr></table></figure>

<h3 id="恢复redis-master服务"><a href="#恢复redis-master服务" class="headerlink" title="恢复redis-master服务"></a>恢复redis-master服务</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause redis-master</span><br></pre></td></tr></table></figure>

<h3 id="分别查看slave1，slave2服务IP"><a href="#分别查看slave1，slave2服务IP" class="headerlink" title="分别查看slave1，slave2服务IP"></a>分别查看slave1，slave2服务IP</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]<span class="comment"># docker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; redis-slave1</span></span><br><span class="line"><span class="number">172.18</span>.<span class="number">0.4</span></span><br><span class="line">[root@localhost redis]<span class="comment"># docker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; redis-slave2</span></span><br><span class="line"><span class="number">172.18</span>.<span class="number">0.3</span></span><br></pre></td></tr></table></figure>

<h3 id="停止主节点"><a href="#停止主节点" class="headerlink" title="停止主节点"></a>停止主节点</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause redis-slave1</span><br></pre></td></tr></table></figure>

<h3 id="查询主节点"><a href="#查询主节点" class="headerlink" title="查询主节点"></a>查询主节点</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec redis-sentinel-<span class="number">1</span> redis-cli -p <span class="number">16381</span> SENTINEL get-master-addr-by-name mymaster</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localhost redis]<span class="comment"># docker exec redis-sentinel-1 redis-cli -p 16381 SENTINEL get-master-addr-by-name mymaster</span></span><br><span class="line"><span class="number">172.18</span>.<span class="number">0.2</span></span><br><span class="line"><span class="number">16379</span></span><br></pre></td></tr></table></figure>

<p>至此，故障转移测试完成。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuning/p/8464625.html">高可用Redis服务架构分析与搭建</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xishuai/p/redis-sentinel.html">Redis Sentinel 高可用服务架构搭建</a></p>
<p><a target="_blank" rel="noopener" href="http://redis.majunwei.com/topics/sentinel.html">Redis哨兵-实现Redis高可用</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000002680804">Redis Sentinel机制与用法（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://itbilu.com/database/redis/Ey_r7mWR.html">Redis设置认证密码 Redis使用认证密码登录 在Redis集群中使用认证密码</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/58003">Docker化高可用redis集群</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a63a98fa047d">Docker环境搭建redis集群(主从模式)</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/AliyunContainerService/redis-cluster/blob/master/test.sh">https://github.com/AliyunContainerService/redis-cluster/blob/master/test.sh</a></p>
<p><a target="_blank" rel="noopener" href="http://www.redis.cn/topics/sentinel.html?spm=a2c4e.11153940.blogcont58003.8.5e0d6772hFOEsg">Redis 的 Sentinel 文档</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/17/Docker-Docker-Compose-Nginx-%E9%83%A8%E7%BD%B2DotNetCore%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/17/Docker-Docker-Compose-Nginx-%E9%83%A8%E7%BD%B2DotNetCore%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">Docker & Docker Compose & Nginx 部署DotNetCore项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-17 08:51:19" itemprop="dateCreated datePublished" datetime="2018-05-17T08:51:19+00:00">2018-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker-Compose/" itemprop="url" rel="index"><span itemprop="name">Docker Compose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker-amp-Docker-Compose-amp-Nginx-部署DotNetCore项目"><a href="#Docker-amp-Docker-Compose-amp-Nginx-部署DotNetCore项目" class="headerlink" title="Docker &amp; Docker Compose &amp; Nginx 部署DotNetCore项目"></a>Docker &amp; Docker Compose &amp; Nginx 部署DotNetCore项目</h1><h2 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker Compose简介"></a>Docker Compose简介</h2><p>文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
<p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 <code>Docker</code> 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a target="_blank" rel="noopener" href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<p><code>服务 (service)</code>：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p>
<p><code>项目 (project)</code>：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</p>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p>
<h2 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker Compose安装"></a>Docker Compose安装</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/compose/install/#install-compose">https://docs.docker.com/compose/install/#install-compose</a></p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/<span class="number">1.21</span>.<span class="number">2</span>/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br><span class="line">docker-compose version <span class="number">1.21</span>.<span class="number">2</span>, build a133471</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="YAML配置命令"><a href="#YAML配置命令" class="headerlink" title="YAML配置命令"></a>YAML配置命令</h3><table>
<thead>
<tr>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>build</td>
<td>指定 Dockerfile 所在的目录地址，用于构建镜像，并使用此镜像创建容器，比如上面配置的 <code>build: .</code></td>
</tr>
<tr>
<td>command</td>
<td>容器的执行命令</td>
</tr>
<tr>
<td>dns</td>
<td>自定义 dns 服务器</td>
</tr>
<tr>
<td>expose</td>
<td>暴露端口配置，但不映射到宿主机，只被连接的服务访问</td>
</tr>
<tr>
<td>extends</td>
<td>对<code>docker-compose.yml</code>的扩展，配置在服务中</td>
</tr>
<tr>
<td>image</td>
<td>使用的镜像名称或镜像 ID</td>
</tr>
<tr>
<td>links</td>
<td>链接到其它服务中的容器（一般桥接网络模式使用）</td>
</tr>
<tr>
<td>net</td>
<td>设置容器的网络模式（四种：<code>bridge</code>, <code>none</code>, <code>container:[name or id]</code>和<code>host</code>）</td>
</tr>
<tr>
<td>ports</td>
<td>暴露端口信息，主机和容器的端口映射</td>
</tr>
<tr>
<td>volumes</td>
<td>数据卷所挂载路径设置</td>
</tr>
</tbody></table>
<h3 id="Docker-Compose-常用命令"><a href="#Docker-Compose-常用命令" class="headerlink" title="Docker Compose 常用命令"></a>Docker Compose 常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>docker-compose build</td>
<td>构建项目中的镜像，–force-rm：删除构建过程中的临时容器；–no-cache：不使用缓存构建；–pull：获取最新版本的镜像</td>
</tr>
<tr>
<td>docker-compose up -d</td>
<td>构建镜像、创建服务和启动项目，-d表示后台运行</td>
</tr>
<tr>
<td>docker-compose run ubuntu ls -d</td>
<td>指定服务上运行一个命令，-d表示后台运行</td>
</tr>
<tr>
<td>docker-compose logs</td>
<td>查看服务容器输出日志</td>
</tr>
<tr>
<td>docker-compose ps</td>
<td>列出项目中所有的容器</td>
</tr>
<tr>
<td>docker-compose pause [service_name]</td>
<td>暂停一个服务容器</td>
</tr>
<tr>
<td>docker-compose unpause [service_name]</td>
<td>恢复已暂停的一个服务容器</td>
</tr>
<tr>
<td>docker-compose restart</td>
<td>重启项目中的所有服务容器（也可以指定具体的服务）</td>
</tr>
<tr>
<td>docker-compose stop</td>
<td>停止运行项目中的所有服务容器（也可以指定具体的服务）</td>
</tr>
<tr>
<td>docker-compose start</td>
<td>启动已经停止项目中的所有服务容器（也可以指定具体的服务）</td>
</tr>
<tr>
<td>docker-compose rm</td>
<td>删除项目中的所有服务容器（也可以指定具体的服务），-f：强制删除（包含运行的）</td>
</tr>
<tr>
<td>docker-compose kill</td>
<td>强制停止项目中的所有服务容器（也可以指定具体的服务）</td>
</tr>
</tbody></table>
<h2 id="编写一个docker-compose-yml"><a href="#编写一个docker-compose-yml" class="headerlink" title="编写一个docker-compose.yml"></a>编写一个docker-compose.yml</h2><p><code>dockers-compose.yml</code>文件要定义在我们项目的文件夹下。</p>
<p>整体目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-- docker.web</span><br><span class="line">  |--Dockerfile</span><br><span class="line">|-- nginx</span><br><span class="line">  |--nginx.conf</span><br><span class="line">  |--Dockerfile</span><br><span class="line">|--docker-compose.yml</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  dockerwebapp:</span><br><span class="line">    container_name:dockerwebapp</span><br><span class="line">    build:</span><br><span class="line">      context: ./docker.web</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    <span class="keyword">expose</span>:</span><br><span class="line">      - <span class="string">&quot;5000&quot;</span></span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  reverse-proxy:</span><br><span class="line">    container_name: reverse-proxy-nginx</span><br><span class="line">    build:</span><br><span class="line">      context: ./nginx</span><br><span class="line">    volumes:</span><br><span class="line">        - /etc/letsencrypt:/etc/letsencrypt/</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">     - <span class="string">&quot;443:443&quot;</span></span><br></pre></td></tr></table></figure>

<p>** docker.web下Dockerfile:**</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/dotnet:latest</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dotnet restore</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">ENV</span> ASPNETCORE_URLS http://*:<span class="number">5000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>,<span class="string">&quot;run&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>** nginx下Dockerfile**</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>

<p>** nginx下nginx.conf配置**</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.shiyx.top;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://www.shiyx.top$request_uri;</span><br><span class="line">        <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">upstream</span> app_servers &#123;</span><br><span class="line">        <span class="attribute">server</span> dockerwebapp:<span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">        <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.shiyx.top;</span><br><span class="line">        <span class="comment">#$host该变量的值等于请求头中Host的值。如果Host无效时，那么就是处理该请求的server的名称。</span></span><br><span class="line">        <span class="comment">#permanent: 永久性重定向。请求日志中的状态码为301</span></span><br><span class="line">        <span class="comment">#nginx 对文档检测比较严格，所以if ( $host != &#x27;www.csdn.com&#x27; ) 这些代码之间需要有空格隔开，不然会</span></span><br><span class="line">        <span class="comment">#报错：unknown directive “if($host!=”</span></span><br><span class="line">        <span class="attribute">if</span> ($host != <span class="string">&#x27;www.shiyx.top&#x27;</span> )&#123;</span><br><span class="line">                <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://www.shiyx.top/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/shiyx.top/fullchain.pem;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/shiyx.top/privkey.pem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#禁止在header中出现服务器版本，防止黑客利用版本漏洞攻击</span></span><br><span class="line">        <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="comment"># 设置ssl/tls会话缓存的类型和大小。如果设置了这个参数一般是shared，buildin可能会参数内存碎片，默认是none，</span></span><br><span class="line">        <span class="comment">#和off差不多，停用缓存。如shared:SSL:10m表示我&gt;所有的nginx工作进程共享ssl会话缓存，</span></span><br><span class="line">        <span class="comment">#网介绍说1M可以存放约4000个sessions。</span></span><br><span class="line">        <span class="attribute">ssl_session_cache</span>    shared:SSL:<span class="number">1m</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 客户端可以重用会话缓存中ssl参数的过期时间，内网系统默认5分钟太短了，可以设成30m即30分钟甚至4h。</span></span><br><span class="line">        <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_protocols</span> SSLv3 TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择加密套件，不同的浏览器所支持的套件（和顺序）可能会不同。</span></span><br><span class="line">        <span class="comment"># 这里指定的是OpenSSL库能够识别的写法，你可以通过 openssl -v cipher &#x27;RC4:HIGH:!aNULL:!MD5&#x27;</span></span><br><span class="line">        <span class="comment">#（后面是你所指定的套件加密算法） 来看所支持算法。</span></span><br><span class="line">        <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。</span></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查看代理程序的ip</span></span><br><span class="line">        <span class="comment"># sudo docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; &lt;container-ID&gt;</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://app_servers;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Upgrade $http_upgrade;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Connection keep-alive;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Host $http_host;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   X-Real-IP $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   X-Forwarded-Host $server_name;</span><br><span class="line">            <span class="attribute">proxy_cache_bypass</span> $http_upgrade;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /.well-known</span>&#123;</span><br><span class="line">                <span class="attribute">allow</span> all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中要注意反向代理的配置：<code>server dockerwebapp:5000;</code>，其中ip部分直接指定的是docker-compose.yml中定义的第一个服务的名称dockerwebapp</p>
<h2 id="启动compose"><a href="#启动compose" class="headerlink" title="启动compose"></a>启动compose</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-16-20:~/dotnet$ docker-compose up -d --build</span><br><span class="line">Creating network <span class="string">&quot;dotnet_default&quot;</span> with the default driver</span><br><span class="line">Building dockerwebapp</span><br><span class="line">Step 1/7 : FROM microsoft/dotnet:latest</span><br><span class="line"> ---&gt; 2ac9a416f201</span><br><span class="line">Step 2/7 : WORKDIR /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9449738bc5a1</span><br><span class="line">Step 3/7 : COPY . /app</span><br><span class="line"> ---&gt; 63468e7420e1</span><br><span class="line">Step 4/7 : RUN dotnet restore</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 24ecd554e076</span><br><span class="line">  Restore completed <span class="keyword">in</span> 75.73 ms <span class="keyword">for</span> /app/docker.web.csproj.</span><br><span class="line">  Restoring packages <span class="keyword">for</span> /app/docker.web.csproj...</span><br><span class="line">  Restore completed <span class="keyword">in</span> 464.93 ms <span class="keyword">for</span> /app/docker.web.csproj.</span><br><span class="line">Removing intermediate container 24ecd554e076</span><br><span class="line"> ---&gt; cdc5f195aa36</span><br><span class="line">Step 5/7 : EXPOSE 5000</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> af5717cc39b8</span><br><span class="line">Removing intermediate container af5717cc39b8</span><br><span class="line"> ---&gt; afe466d24f6d</span><br><span class="line">Step 6/7 : ENV ASPNETCORE_URLS http://*:5000</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d151cad8058d</span><br><span class="line">Removing intermediate container d151cad8058d</span><br><span class="line"> ---&gt; d4e8dadfe89c</span><br><span class="line">Step 7/7 : ENTRYPOINT [<span class="string">&quot;dotnet&quot;</span>,<span class="string">&quot;run&quot;</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> de41a97d97a8</span><br><span class="line">Removing intermediate container de41a97d97a8</span><br><span class="line"> ---&gt; 05c1f1c48653</span><br><span class="line">Successfully built 05c1f1c48653</span><br><span class="line">Successfully tagged dotnet_dockerwebapp:latest</span><br><span class="line">Building reverse-proxy</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"> ---&gt; ae513a47849c</span><br><span class="line">Step 2/2 : COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line"> ---&gt; 458d9128600f</span><br><span class="line">Successfully built 458d9128600f</span><br><span class="line">Successfully tagged dotnet_reverse-proxy:latest</span><br><span class="line">Creating reverse-proxy-nginx ... <span class="keyword">done</span></span><br><span class="line">Creating dockerwebapp        ... <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>验证启动的服务：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose ps</span><br></pre></td></tr></table></figure>

<p>显示结果：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~/dotnet$ docker-compose ps</span><br><span class="line">       Name                 Command          State              Ports</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">dockerwebapp          dotnet <span class="keyword">run</span><span class="bash">             Up      5000/tcp</span></span><br><span class="line">reverse-proxy-nginx   nginx -g daemon off;   Up      <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">443</span>-&gt;<span class="number">443</span>/tcp,</span><br><span class="line">                                                     <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">80</span>-&gt;<span class="number">80</span>/tcp</span><br></pre></td></tr></table></figure>

<p>** remove-orphans**</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down --rmi local --remove-orphans</span><br></pre></td></tr></table></figure>

<h2 id="删除tag为none镜像"><a href="#删除tag为none镜像" class="headerlink" title="删除tag为none镜像"></a>删除tag为none镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images -a|grep none|awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>|xargs docker rmi</span><br><span class="line"><span class="comment">## 显示依赖关系</span></span><br><span class="line">docker image inspect --format=<span class="string">&#x27;&#123;&#123;.RepoTags&#125;&#125; &#123;&#123;.Id&#125;&#125; &#123;&#123;.Parent&#125;&#125;&#x27;</span> $(docker image ls -q --filter since=b64089162379)</span><br></pre></td></tr></table></figure>

<p>其中b64089162379为镜像ID。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/content/compose/introduction.html">https://yeasy.gitbooks.io/docker_practice/content/compose/introduction.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.sep.com/sep-blog/2017/02/27/nginx-reverse-proxy-to-asp-net-core-separate-docker-containers/">https://www.sep.com/sep-blog/2017/02/27/nginx-reverse-proxy-to-asp-net-core-separate-docker-containers/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sheng-jie/p/8116276.html">https://www.cnblogs.com/sheng-jie/p/8116276.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xishuai/p/docker-compose.html">http://www.cnblogs.com/xishuai/p/docker-compose.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/lsxqw2004/p/6709766.html">http://www.cnblogs.com/lsxqw2004/p/6709766.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/16/%E8%8E%B7%E5%8F%96docker%E5%AE%B9%E5%99%A8%EF%BC%88container%EF%BC%89ip%E5%9C%B0%E5%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/16/%E8%8E%B7%E5%8F%96docker%E5%AE%B9%E5%99%A8%EF%BC%88container%EF%BC%89ip%E5%9C%B0%E5%9D%80/" class="post-title-link" itemprop="url">获取docker容器（container）ip地址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-16 14:40:11" itemprop="dateCreated datePublished" datetime="2018-05-16T14:40:11+00:00">2018-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="获取docker容器（container）ip地址"><a href="#获取docker容器（container）ip地址" class="headerlink" title="获取docker容器（container）ip地址"></a>获取docker容器（container）ip地址</h1><h2 id="使用命令方式"><a href="#使用命令方式" class="headerlink" title="使用命令方式"></a>使用命令方式</h2><ul>
<li>命令</li>
</ul>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> &lt;container-ID&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>命令2</li>
</ul>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect &lt;container id&gt;</span><br><span class="line"></span><br><span class="line">sudo docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> &lt;container_name_or_id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="进入容器内"><a href="#进入容器内" class="headerlink" title="进入容器内"></a>进入容器内</h2><p>命令：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it mynginx /bin/bash</span><br><span class="line">cat /etc/hosts</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~/dotnet$ sudo docker exec -it mynginx /bin/bash</span><br><span class="line">root@<span class="number">70</span>e571d3bcab:/<span class="comment"># cat /etc/hosts</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>       localhost</span><br><span class="line">::<span class="number">1</span>     localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::<span class="number">0</span> ip6-localnet</span><br><span class="line">ff00::<span class="number">0</span> ip6-mcastprefix</span><br><span class="line">ff02::<span class="number">1</span> ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span> ip6-allrouters</span><br><span class="line"><span class="number">172.17</span>.<span class="number">0.4</span>      <span class="number">70</span>e571d3bcab</span><br></pre></td></tr></table></figure>

<h2 id="在-bashrc-中写一个-bash-函数"><a href="#在-bashrc-中写一个-bash-函数" class="headerlink" title="在 ~/.bashrc 中写一个 bash 函数"></a>在 ~/.bashrc 中写一个 bash 函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>添加如下内容：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function docker_ip() &#123;</span><br><span class="line">    sudo docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> $<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>最后调用函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker_ip mynginx</span><br></pre></td></tr></table></figure>

<h2 id="所有容器名称及其IP地址"><a href="#所有容器名称及其IP地址" class="headerlink" title="所有容器名称及其IP地址"></a>所有容器名称及其IP地址</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;&#x27;</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<p>如果使用docker-compose命令将是:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect --format=<span class="string">&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<p>可能遇到的问题：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~/dotnet$ sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;&#x27;</span> $(docker ps -aq)</span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/<span class="keyword">run</span><span class="bash">/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/containers/json?all=1: dial unix /var/run/docker.sock: connect: permission denied</span></span><br><span class="line"><span class="string">&quot;docker inspect&quot;</span> requires at least <span class="number">1</span> argument.</span><br><span class="line">See <span class="string">&#x27;docker inspect --help&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Usage:  docker inspect [OPTIONS] NAME|ID [NAME|ID...] [flags]</span><br><span class="line"></span><br><span class="line">Return low-level information on Docker objects</span><br></pre></td></tr></table></figure>

<p>执行以下命令,将当前用户添加 docker 组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G docker <span class="variable">$USER</span></span><br><span class="line">或</span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<p>注销，重新登录:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">logout</span></span><br></pre></td></tr></table></figure>

<p>注意：注销并重新登录是必需的，因为除非您的会话关闭，否则组更改不会生效。</p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sannerlittle/article/details/77063800">https://blog.csdn.net/sannerlittle/article/details/77063800</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/15/Nginx&Docker%E9%83%A8%E7%BD%B2NetCore%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/15/Nginx&Docker%E9%83%A8%E7%BD%B2NetCore%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">Nginx&Docker部署NetCore项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-15 13:48:24" itemprop="dateCreated datePublished" datetime="2018-05-15T13:48:24+00:00">2018-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNetCore/" itemprop="url" rel="index"><span itemprop="name">DotNetCore</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nginx-amp-Docker部署NetCore项目"><a href="#Nginx-amp-Docker部署NetCore项目" class="headerlink" title="Nginx&amp;Docker部署NetCore项目"></a>Nginx&amp;Docker部署NetCore项目</h1><h2 id="Nginx运行在Docker"><a href="#Nginx运行在Docker" class="headerlink" title="Nginx运行在Docker"></a>Nginx运行在Docker</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker container <span class="keyword">run</span><span class="bash"> \</span></span><br><span class="line"><span class="bash">  -d \</span></span><br><span class="line"><span class="bash">  -p 127.0.0.2:8080:80 \</span></span><br><span class="line"><span class="bash">  --rm \</span></span><br><span class="line"><span class="bash">  --name mynginx \</span></span><br><span class="line"><span class="bash">  nginx</span></span><br></pre></td></tr></table></figure>

<p>上面命令下载并运行官方的 Nginx image，默认是最新版本（latest）。如果本机安装过以前的版本，请删掉重新安装，因为只有 1.13.9 才开始支持 server push。</p>
<p>上面命令的各个参数含义如下:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-d：在后台运行</span><br><span class="line">-p ：容器的<span class="number">80</span>端口映射到<span class="number">127.0</span>.<span class="number">0.2</span>:<span class="number">8080</span></span><br><span class="line">--rm：容器停止运行后，自动删除容器文件</span><br><span class="line">--name：容器的名字为mynginx</span><br></pre></td></tr></table></figure>

<p>如果没有报错，就可以打开浏览器访问 127.0.0.2:8080 了。正常情况下，显示 Nginx 的欢迎页。</p>
<p>或者用curl显示：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~/dotnet/conf$ curl http://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        width: <span class="number">35</span>em;</span><br><span class="line">        margin: <span class="number">0</span> auto;</span><br><span class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~/dotnet/conf$</span><br></pre></td></tr></table></figure>

<p>然后，把这个容器终止，由于–rm参数的作用，容器文件会自动删除。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker container stop mynginx</span><br></pre></td></tr></table></figure>

<h2 id="拷贝配置"><a href="#拷贝配置" class="headerlink" title="拷贝配置"></a>拷贝配置</h2><p>首先，把容器里面的 Nginx 配置文件拷贝到本地。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker container cp mynginx:/etc/nginx .</span><br></pre></td></tr></table></figure>

<p>上面命令的含义是，把mynginx容器的/etc/nginx拷贝到当前目录。不要漏掉最后那个点。</p>
<p>执行完成后，当前目录应该多出一个nginx子目录。然后，把这个子目录改名为conf。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv nginx conf</span><br></pre></td></tr></table></figure>

<p>容器终止:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker container stop mynginx</span><br></pre></td></tr></table></figure>

<h2 id="映射配置目录"><a href="#映射配置目录" class="headerlink" title="映射配置目录"></a>映射配置目录</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> docker container run \</span><br><span class="line">  --name mynginx \</span><br><span class="line">  --rm \</span><br><span class="line">  --volume <span class="string">&quot;$PWD/conf&quot;</span>:/etc/nginx \</span><br><span class="line">  -p <span class="number">80</span>:<span class="number">80</span> \</span><br><span class="line">  -d \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>

<p>–volume “$PWD/conf”:/etc/nginx表示把容器的配置目录/etc/nginx，映射到本地的conf子目录。</p>
<p>查看docker 容器日志：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs mynginx</span><br></pre></td></tr></table></figure>

<h2 id="映射证书"><a href="#映射证书" class="headerlink" title="映射证书"></a>映射证书</h2><p>使用Let’s Encrypt生成的证书文件</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> docker container run \</span><br><span class="line">  --name mynginx \</span><br><span class="line">  --rm \</span><br><span class="line">  --volume <span class="string">&quot;$PWD/conf&quot;</span>:/etc/nginx \</span><br><span class="line">  -v /etc/letsencrypt:/etc/letsencrypt/ \</span><br><span class="line">  -d \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>

<p>-v : 映射本地/etc/letsencrypt到容器/etc/letsencrypt目录。</p>
<h2 id="HTTPS-配置"><a href="#HTTPS-配置" class="headerlink" title="HTTPS 配置"></a>HTTPS 配置</h2><p>配置<code>conf/conf.d/default.conf</code>文件，具体配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.shiyx.top;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://www.shiyx.top$request_uri;</span><br><span class="line">        <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">        <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.shiyx.top;</span><br><span class="line">        <span class="comment">#$host该变量的值等于请求头中Host的值。如果Host无效时，那么就是处理该请求的server的名称。</span></span><br><span class="line">        <span class="comment">#permanent: 永久性重定向。请求日志中的状态码为301</span></span><br><span class="line">        <span class="comment">#nginx 对文档检测比较严格，所以if ( $host != &#x27;www.csdn.com&#x27; ) 这些代码之间需要有空格隔开，不然会</span></span><br><span class="line">        <span class="comment">#报错：unknown directive “if($host!=”</span></span><br><span class="line">        <span class="attribute">if</span> ($host != <span class="string">&#x27;www.shiyx.top&#x27;</span> )&#123;</span><br><span class="line">                <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)$</span> https://www.shiyx.top/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/shiyx.top/fullchain.pem;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/shiyx.top/privkey.pem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#禁止在header中出现服务器版本，防止黑客利用版本漏洞攻击</span></span><br><span class="line">        <span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br><span class="line">        <span class="comment"># 设置ssl/tls会话缓存的类型和大小。如果设置了这个参数一般是shared，buildin可能会参数内存碎片，默认是none，</span></span><br><span class="line">        <span class="comment">#和off差不多，停用缓存。如shared:SSL:10m表示我&gt;所有的nginx工作进程共享ssl会话缓存，</span></span><br><span class="line">        <span class="comment">#网介绍说1M可以存放约4000个sessions。</span></span><br><span class="line">        <span class="attribute">ssl_session_cache</span>    shared:SSL:<span class="number">1m</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 客户端可以重用会话缓存中ssl参数的过期时间，内网系统默认5分钟太短了，可以设成30m即30分钟甚至4h。</span></span><br><span class="line">        <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_protocols</span> SSLv3 TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选择加密套件，不同的浏览器所支持的套件（和顺序）可能会不同。</span></span><br><span class="line">        <span class="comment"># 这里指定的是OpenSSL库能够识别的写法，你可以通过 openssl -v cipher &#x27;RC4:HIGH:!aNULL:!MD5&#x27;</span></span><br><span class="line">        <span class="comment">#（后面是你所指定的套件加密算法） 来看所支持算法。</span></span><br><span class="line">        <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。</span></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查看代理程序的ip</span></span><br><span class="line">        <span class="comment"># sudo docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; &lt;container-ID&gt;</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://172.17.0.3:5000;</span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Upgrade $http_upgrade;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Connection keep-alive;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>   Host $http_host;</span><br><span class="line">            <span class="attribute">proxy_cache_bypass</span> $http_upgrade;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ /.well-known</span>&#123;</span><br><span class="line">                <span class="attribute">allow</span> all;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看docker ip地址</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect --format <span class="string">&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27;</span> &lt;container-ID&gt;</span><br></pre></td></tr></table></figure>

<p>最后，启动一个新的Nginx容器。</p>
<p>** 注意运行目录**</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> docker container run \</span><br><span class="line">  --name mynginx \</span><br><span class="line">  --rm \</span><br><span class="line">  --volume <span class="string">&quot;$PWD/conf&quot;</span>:/etc/nginx \</span><br><span class="line">  -v /etc/letsencrypt:/etc/letsencrypt/ \</span><br><span class="line">  -p <span class="number">80</span>:<span class="number">80</span> \</span><br><span class="line">  -p <span class="number">443</span>:<span class="number">443</span> \</span><br><span class="line">  -d \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>

<p>参考：<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html">http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.0&tabs=aspnetcore2x">https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-2.0&amp;tabs=aspnetcore2x</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/savorboard/p/dotnet-core-publish-nginx.html">http://www.cnblogs.com/savorboard/p/dotnet-core-publish-nginx.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/14/DotNetCore%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/14/DotNetCore%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">DotNetCore使用Docker部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-14 17:34:11" itemprop="dateCreated datePublished" datetime="2018-05-14T17:34:11+00:00">2018-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNetCore/" itemprop="url" rel="index"><span itemprop="name">DotNetCore</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DotNetCore使用Docker部署"><a href="#DotNetCore使用Docker部署" class="headerlink" title="DotNetCore使用Docker部署"></a>DotNetCore使用Docker部署</h1><h2 id="docker安装（ubuntu16-04）"><a href="#docker安装（ubuntu16-04）" class="headerlink" title="docker安装（ubuntu16.04）"></a>docker安装（ubuntu16.04）</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>

<h2 id="拉取microsoft-dotnet镜像"><a href="#拉取microsoft-dotnet镜像" class="headerlink" title="拉取microsoft/dotnet镜像"></a>拉取microsoft/dotnet镜像</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~$ sudo docker pull microsoft/dotnet</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling <span class="keyword">from</span> microsoft/dotnet</span><br><span class="line">cc1a78bfd46b: Pull complete</span><br><span class="line"><span class="number">6861473222</span>a6: Pull complete</span><br><span class="line"><span class="number">7</span>e0b9c3b5ae0: Pull complete</span><br><span class="line"><span class="number">3</span>ec98735f56f: Pull complete</span><br><span class="line"><span class="number">8</span>b3d41e9a6c9: Pull complete</span><br><span class="line"><span class="number">92</span>c2ea8451ce: Pull complete</span><br><span class="line">e321ed356c13: Pull complete</span><br><span class="line">Digest: sha256:ec26f9d34e3e8a85eb3f0d269170e5502bdee7d1ed46ddc1356d9ba6d245e6fa</span><br><span class="line">Status: Downloaded newer image for microsoft/dotnet:latest</span><br></pre></td></tr></table></figure>

<h2 id="运行microsoft-dotnet镜像"><a href="#运行microsoft-dotnet镜像" class="headerlink" title="运行microsoft/dotnet镜像"></a>运行microsoft/dotnet镜像</h2><p>使用<code>docker run &lt;image&gt;</code>可以启动镜像，通过指定参数<code>-it</code>以交互模式（进入容器内部）启动<br><code>--rm</code> 退出时，删除容器。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//启动一个dotnet镜像</span><br><span class="line">$ docker <span class="keyword">run</span><span class="bash"> --rm -it microsoft/dotnet</span></span><br><span class="line"></span><br><span class="line">//创建项目名为docker.Web的.NET Core MVC项目</span><br><span class="line">dotnet new mvc -n docker.web</span><br><span class="line"></span><br><span class="line">//进入docker.web文件夹</span><br><span class="line">cd docker.web</span><br><span class="line"></span><br><span class="line">//启动.NET Core MVC项目</span><br><span class="line">dotnet <span class="keyword">run</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~$ sudo docker <span class="keyword">run</span><span class="bash"> --rm -it microsoft/dotnet</span></span><br><span class="line">root@b2ce07e9f5e5:/<span class="comment"># dotnet new mvc -n docker.web</span></span><br><span class="line">The template <span class="string">&quot;ASP.NET Core Web App (Model-View-Controller)&quot;</span> was created successfully.</span><br><span class="line">This template contains technologies <span class="keyword">from</span> parties other than Microsoft, see https://aka.ms/template-<span class="number">3</span>pn for details.</span><br><span class="line"></span><br><span class="line">Processing post-creation actions...</span><br><span class="line">Running <span class="string">&#x27;dotnet restore&#x27;</span> on docker.web/docker.web.csproj...</span><br><span class="line">  Restoring packages for /docker.web/docker.web.csproj...</span><br><span class="line">  Generating MSBuild file /docker.web/obj/docker.web.csproj.nuget.g.props.</span><br><span class="line">  Generating MSBuild file /docker.web/obj/docker.web.csproj.nuget.g.targets.</span><br><span class="line">  Restore completed in <span class="number">1.69</span> sec for /docker.web/docker.web.csproj.</span><br><span class="line">  Restoring packages for /docker.web/docker.web.csproj...</span><br><span class="line">  Restore completed in <span class="number">338.5</span> ms for /docker.web/docker.web.csproj.</span><br><span class="line"></span><br><span class="line">Restore succeeded.</span><br><span class="line"></span><br><span class="line">root@b2ce07e9f5e5:/<span class="comment"># cd docker.web</span></span><br><span class="line">root@b2ce07e9f5e5:/docker.web<span class="comment"># dotnet run</span></span><br><span class="line">warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[<span class="number">35</span>]</span><br><span class="line">      No XML encryptor configured. Key &#123;<span class="number">392</span>f49bb-<span class="number">6372</span>-<span class="number">47</span>a0-a34b-<span class="number">94</span>b82a079812&#125; may be persisted to storage in unencrypted form.</span><br><span class="line">warn: Microsoft.AspNetCore.Server.Kestrel[<span class="number">0</span>]</span><br><span class="line">      Unable to bind to http://localhost:<span class="number">5000</span> on the IPv6 loopback interface: <span class="string">&#x27;Error -99 EADDRNOTAVAIL address not available&#x27;</span>.</span><br><span class="line">Hosting environment: Production</span><br><span class="line">Content root path: /docker.web</span><br><span class="line">Now listening on: http://localhost:<span class="number">5000</span></span><br><span class="line">Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>

<h2 id="挂载源代码"><a href="#挂载源代码" class="headerlink" title="挂载源代码"></a>挂载源代码</h2><h3 id="宿主机安装-NET-Core-SDK"><a href="#宿主机安装-NET-Core-SDK" class="headerlink" title="宿主机安装.NET Core SDK"></a>宿主机安装.NET Core SDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -q packages-microsoft-prod.deb https:&#x2F;&#x2F;packages.microsoft.com&#x2F;config&#x2F;ubuntu&#x2F;16.04&#x2F;packages-microsoft-prod.deb</span><br><span class="line">sudo dpkg -i packages-microsoft-prod.deb</span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install dotnet-sdk-2.1.200</span><br></pre></td></tr></table></figure>

<p>安装完毕后，我们依次执行以下命令创建一个.NET Core MVC项目:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;回到根目录</span><br><span class="line">$ cd $HOME</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建demo文件夹</span><br><span class="line">$ mkdir demo</span><br><span class="line">$ cd demo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建项目名为docker.web的.NET Core MVC项目</span><br><span class="line">sudo dotnet new mvc -n docker.web</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进入docker.web文件夹</span><br><span class="line">cd docker.web</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动.NET Core MVC项目</span><br><span class="line">sudo dotnet run</span><br></pre></td></tr></table></figure>

<p><code>sudo lsof -i :5000</code>：查看5000端口信息</p>
<h3 id="挂载宿主机项目到容器中"><a href="#挂载宿主机项目到容器中" class="headerlink" title="挂载宿主机项目到容器中"></a>挂载宿主机项目到容器中</h3><p>在启动Docker镜像时，Docker允许我们通过使用<code>-v</code>参数挂载宿主机的文件到容器的指定目录下。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 命令中的`\`结合`Enter`键构成换行符，允许我们换行输入一个长命令。</span><br><span class="line">$ sudo docker <span class="keyword">run</span><span class="bash"> --rm -it \</span></span><br><span class="line"><span class="bash">-v <span class="variable">$HOME</span>/dotnet/docker.web:/app \</span></span><br><span class="line"><span class="bash">microsoft/dotnet:latest</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-16-20:~$ sudo docker run --rm -it \</span><br><span class="line">&gt; -v $HOME&#x2F;dotnet&#x2F;docker.web:&#x2F;app \</span><br><span class="line">&gt; microsoft&#x2F;dotnet:latest</span><br><span class="line">root@4e0ae54991c4:&#x2F;# ls</span><br><span class="line">app  boot  etc   lib    media  opt   root  sbin  sys  usr</span><br><span class="line">bin  dev   home  lib64  mnt    proc  run   srv   tmp  var</span><br><span class="line">root@4e0ae54991c4:&#x2F;# cd app</span><br><span class="line">root@4e0ae54991c4:&#x2F;app# ls</span><br><span class="line">Controllers  Startup.cs                    appsettings.json   docker.web.csproj</span><br><span class="line">Models       Views                         bin                obj</span><br><span class="line">Program.cs   appsettings.Development.json  bundleconfig.json  wwwroot</span><br><span class="line">root@4e0ae54991c4:&#x2F;app# dotnet run</span><br><span class="line">warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[35]</span><br><span class="line">      No XML encryptor configured. Key &#123;3600e0ea-f9cc-4c43-b75f-58665338c060&#125; may be persisted to storage in unencrypted form.</span><br><span class="line">warn: Microsoft.AspNetCore.Server.Kestrel[0]</span><br><span class="line">      Unable to bind to http:&#x2F;&#x2F;localhost:5000 on the IPv6 loopback interface: &#39;Error -99 EADDRNOTAVAIL address not available&#39;.</span><br><span class="line">Hosting environment: Production</span><br><span class="line">Content root path: &#x2F;app</span><br><span class="line">Now listening on: http:&#x2F;&#x2F;localhost:5000</span><br><span class="line">Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>

<p>上面说到是以共享的形式，而不是容器拥有一份宿主机目录的拷贝，意味着，在宿主机上对目录的更改，会即时反应到容器中。但反过来，容器中对共享目录的更改，不会反应到宿主机上，不然就打破了容器具有的隔离特性。</p>
<h3 id="使用Dockerfile部署"><a href="#使用Dockerfile部署" class="headerlink" title="使用Dockerfile部署"></a>使用Dockerfile部署</h3><p>Dockerfile用来定义你将要在容器中执行的系列操作。我们来创建一个Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;确保进入我们创建的MVC项目目录中去</span><br><span class="line">$ cd $HOME&#x2F;demo&#x2F;HelloDocker.Web</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用touch命令创建Dockerfile</span><br><span class="line">$ sudo touch Dockerfile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用vi命令编辑Dockerfile</span><br><span class="line">sudo vim Dockerfile</span><br></pre></td></tr></table></figure>

<p>填入以下内容：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/dotnet:latest</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dotnet restore</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">ENV</span> ASPNETCORE_URLS http://*:<span class="number">5000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>,<span class="string">&quot;run&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><code>wq</code>:保存退出</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>：指定容器使用的镜像</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">：指定工作目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash">：复制当前目录（其中.即代表当前目录）到容器中的/app目录下</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">：命令指定容器中执行的命令</span></span><br><span class="line"><span class="keyword">EXPOSE</span>：指定容器暴露的端口号</span><br><span class="line"><span class="keyword">ENV</span>：指定环境参数，上面用来告诉.NETCore项目在所有网络接口上监听<span class="number">5000</span>端口</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash">：制定容器的入口点</span></span><br></pre></td></tr></table></figure>

<p>使用<code>docker build -t &lt;name&gt; &lt;path&gt;</code>指令打包镜像:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t docker.web .</span><br></pre></td></tr></table></figure>

<p><code>.</code>：表示当前路径</p>
<p>运行结果：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-<span class="number">172</span>-<span class="number">31</span>-<span class="number">16</span>-<span class="number">20</span>:~/dotnet/docker.web$ sudo docker build -t docker.web .</span><br><span class="line">Sending build context to Docker daemon  <span class="number">4.937</span>MB</span><br><span class="line">Step <span class="number">1</span>/<span class="number">7</span> : <span class="keyword">FROM</span> microsoft/dotnet:latest</span><br><span class="line"> ---&gt; <span class="number">2</span>ac9a416f201</span><br><span class="line">Step <span class="number">2</span>/<span class="number">7</span> : <span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line">Removing intermediate container <span class="number">921079</span>b99047</span><br><span class="line"> ---&gt; <span class="number">9449738</span>bc5a1</span><br><span class="line">Step <span class="number">3</span>/<span class="number">7</span> : <span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"> ---&gt; b64089162379</span><br><span class="line">Step <span class="number">4</span>/<span class="number">7</span> : <span class="keyword">RUN</span><span class="bash"> dotnet restore</span></span><br><span class="line"> ---&gt; Running in <span class="number">0</span>f13fc033144</span><br><span class="line">  Restore completed in <span class="number">76.09</span> ms for /app/docker.web.csproj.</span><br><span class="line">  Restoring packages for /app/docker.web.csproj...</span><br><span class="line">  Restore completed in <span class="number">499.14</span> ms for /app/docker.web.csproj.</span><br><span class="line">Removing intermediate container <span class="number">0</span>f13fc033144</span><br><span class="line"> ---&gt; <span class="number">31</span>a054861344</span><br><span class="line">Step <span class="number">5</span>/<span class="number">7</span> : <span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"> ---&gt; Running in <span class="number">2</span>a87ea69cb01</span><br><span class="line">Removing intermediate container <span class="number">2</span>a87ea69cb01</span><br><span class="line"> ---&gt; <span class="number">83</span>e3c278ae44</span><br><span class="line">Step <span class="number">6</span>/<span class="number">7</span> : <span class="keyword">ENV</span> ASPNETCORE_URLS http://*:<span class="number">5000</span></span><br><span class="line"> ---&gt; Running in <span class="number">535</span>c7da1ced9</span><br><span class="line">Removing intermediate container <span class="number">535</span>c7da1ced9</span><br><span class="line"> ---&gt; <span class="number">4965</span>bd215b81</span><br><span class="line">Step <span class="number">7</span>/<span class="number">7</span> : <span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>,<span class="string">&quot;run&quot;</span>]</span></span><br><span class="line"> ---&gt; Running in d023e6d8160b</span><br><span class="line">Removing intermediate container d023e6d8160b</span><br><span class="line"> ---&gt; eb265d4f49cd</span><br><span class="line">Successfully built eb265d4f49cd</span><br><span class="line">Successfully tagged docker.web:latest</span><br></pre></td></tr></table></figure>

<p>运行新打包的镜像，并通过<code>-p</code>参数映射容器的5000到宿主机的80端口，其中<code>-d</code>参数告诉docker以后台任务形式运行镜像,<code>--rm</code>退出时删除容器,<code>--name</code>指定容器名称。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="keyword">run</span><span class="bash"> --name dockerweb -d --rm -p 80:5000 docker.web</span></span><br></pre></td></tr></table></figure>

<p>通过<code>curl -i http://localhost</code>验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-16-20:~$ curl -i http:&#x2F;&#x2F;localhost</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Tue, 15 May 2018 05:43:45 GMT</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Server: Kestrel</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Home Page - docker.web&lt;&#x2F;title&gt;</span><br></pre></td></tr></table></figure>

<p>至此，完成dotnetcore项目部署。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/sheng-jie/p/8107877.html#autoid-4-0-0">http://www.cnblogs.com/sheng-jie/p/8107877.html#autoid-4-0-0</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/savorboard/p/dotnetcore-docker.html">http://www.cnblogs.com/savorboard/p/dotnetcore-docker.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/11/Docker%20Compose%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/11/Docker%20Compose%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Docker Compose配置文件详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-11 14:38:31" itemprop="dateCreated datePublished" datetime="2018-05-11T14:38:31+00:00">2018-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker-Compose/" itemprop="url" rel="index"><span itemprop="name">Docker Compose</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker-Compose配置文件详解"><a href="#Docker-Compose配置文件详解" class="headerlink" title="Docker Compose配置文件详解"></a>Docker Compose配置文件详解</h1><p>参考官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/#service-configuration-reference">https://docs.docker.com/compose/compose-file/#service-configuration-reference</a></p>
<p>Compose文件是一个定义服务， 网络和 卷的YAML文件 。Compose文件的默认路径是。./docker-compose.yml</p>
<p>标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分。</p>
<p>提示：您可以对此文件使用a .yml或.yaml扩展名。他们都工作。</p>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  dotnetcoreapp1:</span><br><span class="line">    image: dotnetcoreapp</span><br></pre></td></tr></table></figure>

<p>在 services 标签下的第二级标签是 dotnetcoreapp1，这个名字是用户自己自定义，它就是服务名称。</p>
<p>image 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p>
<h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>在构建时应用的配置选项</p>
<p>build 可以指定为构建上下文的路径：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果同时指定build和image，那么会在./dir中生成名为webapp和标记的镜像tag。</p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>可以是包含Dockerfile的目录的路径，也可以是到git存储库的URL。</p>
<p>当提供的值是相对路径时，它被解释为相对于撰写文件的位置。 这个目录也是发送到Docker守护进程的构建上下文。</p>
<p>使用生成的名称构建并标记它，然后使用该镜像。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: ./dir</span><br></pre></td></tr></table></figure>

<h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><p>dockerfile作为备用，并且需要提供路径。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  dockerfile: Dockerfile-alternate</span><br></pre></td></tr></table></figure>

<h3 id="args"><a href="#args" class="headerlink" title="args"></a>args</h3><p>添加构建参数，这些参数是仅在构建过程中可访问的环境变量。</p>
<p>首先，指定Dockerfile：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> buildno</span><br><span class="line"><span class="keyword">ARG</span> gitcommithash</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Build number: <span class="variable">$buildno</span>&quot;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Based on commit: <span class="variable">$gitcommithash</span>&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>然后指定参数。 您可以传递一个映射或一个列表：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  args:</span><br><span class="line">    buildno: <span class="number">1</span></span><br><span class="line">    gitcommithash: cdc3b19</span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  args:</span><br><span class="line">    - buildno=<span class="number">1</span></span><br><span class="line">    - gitcommithash=cdc3b19</span><br></pre></td></tr></table></figure>

<p>指定构建参数时可以省略该值，在这种情况下，构建时的值是构成运行环境中的值。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args:</span><br><span class="line">  - buildno</span><br><span class="line">  - gitcommithash</span><br></pre></td></tr></table></figure>

<p>注意：YAML 的布尔值（true, false, yes, no, on, off）必须要使用引号引起来（单引号、双引号均可），否则会当成字符串解析。</p>
<h3 id="cache-from"><a href="#cache-from" class="headerlink" title="cache_from"></a>cache_from</h3><p>v3.2新添加</p>
<p>用于缓存解析的镜像列表</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  cache_from:</span><br><span class="line">    - alpine:latest</span><br><span class="line">    - corp/web_app:<span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<h3 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h3><p>v3.3新添加</p>
<p>使用Docker标签将元数据添加到生成的图像。 您可以使用数组或字典。</p>
<p>建议您使用反向DNS标记来防止您的标签与其他软件使用的标签冲突。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  labels:</span><br><span class="line">    com.example.description: <span class="string">&quot;Accounting webapp&quot;</span></span><br><span class="line">    com.example.department: <span class="string">&quot;Finance&quot;</span></span><br><span class="line">    com.example.label-with-empty-value: <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  labels:</span><br><span class="line">    - <span class="string">&quot;com.example.description=Accounting webapp&quot;</span></span><br><span class="line">    - <span class="string">&quot;com.example.department=Finance&quot;</span></span><br><span class="line">    - <span class="string">&quot;com.example.label-with-empty-value&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="shm-size"><a href="#shm-size" class="headerlink" title="shm_size"></a>shm_size</h3><p>v3.5新添加</p>
<p>为此版本的容器设置/dev/shm分区的大小。 指定为表示字节数的整数值或表示字节值的字符串。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  shm_size: <span class="string">&#x27;2gb&#x27;</span></span><br><span class="line"></span><br><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  shm_size: <span class="number">10000000</span></span><br></pre></td></tr></table></figure>

<h2 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h2><p>添加或删除容器功能</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - NET_ADMIN</span><br><span class="line">  - SYS_ADMIN</span><br></pre></td></tr></table></figure>

<h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><p>command 覆盖容器启动后默认执行的命令</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>该命令也可以是一个列表，方式类似于dockerfile：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: [<span class="string">&quot;bundle&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;thin&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="string">&quot;3000&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/swarm/configs/" title="configs命令">configs命令</a></p>
<p>Grant access to configs on a per-service basis using the per-service configs configuration.</p>
<p>为每个服务配置配置为每个服务授予对配置的访问权限。支持两种不同的语法变体。</p>
<p>注意：配置必须已经存在或在此堆栈文件的顶级配置配置中定义，否则堆栈部署失败。</p>
<h3 id="SHORT-SYNTAX"><a href="#SHORT-SYNTAX" class="headerlink" title="SHORT SYNTAX"></a>SHORT SYNTAX</h3><p>简短的语法变体只能指定配置​​名称</p>
<p>支持v3.3以上</p>
<p>以下示例使用简短语法将redis服务访问权限授予my_config和my_other_config配置。 my_config的值被设置为文件./my_config.txt的内容，my_other_config被定义为外部资源，这意味着它已经在Docker中定义，可以通过运行docker config create命令或通过另一个堆栈部署。如果外部配置不存在，堆栈部署将失败并显示配置未找到错误。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">1</span></span><br><span class="line">    configs:</span><br><span class="line">      - my_config</span><br><span class="line">      - my_other_config</span><br><span class="line">configs:</span><br><span class="line">  my_config:</span><br><span class="line">    file: ./my_config.txt</span><br><span class="line">  my_other_config:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<h3 id="LONG-SYNTAX"><a href="#LONG-SYNTAX" class="headerlink" title="LONG SYNTAX"></a>LONG SYNTAX</h3><p>长的语法提供了在服务的任务容器中如何创建配置的更细粒度。</p>
<p>source：Docker中配置的名称。</p>
<p>target：要在服务的任务容器中安装的文件的路径和名称。如果未指定，则默认为 <code>/&lt;source&gt;</code>。</p>
<p>uid和gid：在服务的任务容器中拥有安装的配置文件的数字UID或GID。如果未指定，则在Linux上均默认为0。 Windows不支持。</p>
<p>mode：安装在服务任务容器内的文件的权限，采用八进制表示法。例如，0444代表可读。缺省值为0444.由于Configs被挂载在临时文件系统中，因此它们不能写入，因此如果设置了可写位，它将被忽略。可执行位可以被设置。如果您不熟悉UNIX文件权限模式，则可能会发现此权限计算器很有用。</p>
<p>以下示例将容器中my_config的名称设置为redis_config，将模式设置为0440（可读组），并将用户和组设置为103. redis服务无法访问my_other_config配置</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">1</span></span><br><span class="line">    configs:</span><br><span class="line">      - source: my_config</span><br><span class="line">        target: /redis_config</span><br><span class="line">        uid: <span class="string">&#x27;103&#x27;</span></span><br><span class="line">        gid: <span class="string">&#x27;103&#x27;</span></span><br><span class="line">        mode: <span class="number">0440</span></span><br><span class="line">configs:</span><br><span class="line">  my_config:</span><br><span class="line">    file: ./my_config.txt</span><br><span class="line">  my_other_config:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<p>您可以授予多个配置的服务访问权限，您可以混合使用长短语法。定义配置并不意味着授予服务访问权限。</p>
<h2 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h2><p>指定自定义容器名称</p>
<p>由于Docker容器名称必须是唯一的，因此如果您指定了自定义名称，则无法将服务扩展到1个容器之外。 试图这样做会导致错误。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure>

<p>注意：当使用（版本3）Compose文件在群集模式下部署堆栈时，忽略此选项。</p>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><p>指定与部署和运行服务相关的配置。 这只在部署到使用docker stack部署的群集时才生效，并且被docker-compose up和docker-compose run忽略。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">6</span></span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: <span class="number">2</span></span><br><span class="line">        delay: <span class="number">10</span>s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br></pre></td></tr></table></figure>

<h3 id="ENDPOINT-MODE"><a href="#ENDPOINT-MODE" class="headerlink" title="ENDPOINT_MODE"></a>ENDPOINT_MODE</h3><p>指定连接到群组的外部客户端的服务发现方法。</p>
<p>v3.3独有</p>
<p><code>endpoint_mode：vip</code> - Docker为服务分配一个虚拟IP（VIP），作为客户端到达网络服务的“前端”。 Docker在客户端和可用的工作节点之间为服务路由请求，而客户端不知道有多少节点参与服务或其IP地址或端口。 （这是默认设置。）</p>
<p><code>endpoint_mode：dnsrr</code> - DNS轮询（DNSRR）服务发现不使用单个虚拟IP。 Docker为服务设置DNS条目，使得服务名称的DNS查询返回一个IP地址列表，并且客户端直接连接到其中的一个。 如果您想使用自己的负载平衡器，或者混合Windows和Linux应用程序，则DNS轮询功能非常有用。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - overlay</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: <span class="number">2</span></span><br><span class="line">      endpoint_mode: vip</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    volumes:</span><br><span class="line">       - db-data:/var/lib/mysql/data</span><br><span class="line">    networks:</span><br><span class="line">       - overlay</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: <span class="number">2</span></span><br><span class="line">      endpoint_mode: dnsrr</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  overlay:</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/commandline/service_create/">docker service create</a></p>
<h3 id="LABELS"><a href="#LABELS" class="headerlink" title="LABELS"></a>LABELS</h3><p>指定服务的标签。 这些标签仅在服务上设置，而不在服务的任何容器上设置。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: web</span><br><span class="line">    deploy:</span><br><span class="line">      labels:</span><br><span class="line">        com.example.description: <span class="string">&quot;This label will appear on the web service&quot;</span></span><br></pre></td></tr></table></figure>

<p>要在容器上设置标签，请在部署之外使用标签键：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: web</span><br><span class="line">    labels:</span><br><span class="line">      com.example.description: <span class="string">&quot;This label will appear on all containers for the web service&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="MODE"><a href="#MODE" class="headerlink" title="MODE"></a>MODE</h3><p>全局（每个群集节点只有一个容器）或复制（指定数量的容器）。 默认值被复制。 （要了解更多信息，请参阅swarm主题中的复制和全局服务。）</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    deploy:</span><br><span class="line">      mode: global</span><br></pre></td></tr></table></figure>

<h3 id="PLACEMENT"><a href="#PLACEMENT" class="headerlink" title="PLACEMENT"></a>PLACEMENT</h3><p>指定约束和偏好的位置。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line">          - engine.labels.operatingsystem == ubuntu <span class="number">14.04</span></span><br><span class="line">        preferences:</span><br><span class="line">          - spread: node.labels.zone</span><br></pre></td></tr></table></figure>

<h3 id="REPLICAS"><a href="#REPLICAS" class="headerlink" title="REPLICAS"></a>REPLICAS</h3><p>如果服务被复制（这是默认设置），请指定在任何给定时间应该运行的容器数量。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="RESOURCES"><a href="#RESOURCES" class="headerlink" title="RESOURCES"></a>RESOURCES</h3><p>配置资源限制。</p>
<p>注意：这会替换版本3之前的Compose文件（cpu_shares，cpu_quota，cpuset，mem_limit，memswap_limit，mem_swappiness）中的非群集模式的旧资源约束选项，如升级2.x版至3.x中所述。</p>
<p>在这个一般的例子中，Redis服务限制使用不超过50M的内存和0.50（50％）的可用处理时间（CPU），并且具有20M的内存和0.25个CPU时间保留（总是可用）。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: <span class="string">&#x27;0.50&#x27;</span></span><br><span class="line">          memory: <span class="number">50</span>M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: <span class="string">&#x27;0.25&#x27;</span></span><br><span class="line">          memory: <span class="number">20</span>M</span><br></pre></td></tr></table></figure>

<p>这里描述的选项特定于部署密钥和群集模式。 如果要为非群部署设置资源约束，请使用Compose文件格式版本2 CPU，内存和其他资源选项。</p>
<p>** 内存异常（OOME）**<br>如果您的服务或容器尝试使用比系统可用的内存更多的内存，则可能会遇到内存异常（OOME），并且容器或Docker守护程序可能会被内核OOM杀手所杀。 要防止发生这种情况，请确保您的应用程序在具有足够内存的主机上运行，并且请参阅了解耗尽内存的风险。</p>
<h3 id="RESTART-POLICY"><a href="#RESTART-POLICY" class="headerlink" title="RESTART_POLICY"></a>RESTART_POLICY</h3><p>配置是否以及如何在退出时重新启动容器。 取代重新启动。</p>
<p><code>condition</code>:无，失败或任何（默认：任何）。<br><code>delay</code>:在重启尝试之间等待多长时间，指定为持续时间（默认值：0）。<br><code>max_attempts</code>:放弃之前尝试重新启动容器的次数（默认值：永不放弃）。 如果重新启动在配置的窗口内没有成功，则此尝试不计入配置的max_attempts值。 例如，如果max_attempts设置为’2’，并且第一次尝试重新启动失败，则可能会尝试重新启动两次以上。<br><code>window</code>：在决定重新启动是否成功之前等待多久，指定为持续时间（默认值：立即决定）。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: <span class="number">5</span>s</span><br><span class="line">        max_attempts: <span class="number">3</span></span><br><span class="line">        window: <span class="number">120</span>s</span><br></pre></td></tr></table></figure>

<h3 id="UPDATE-CONFIG"><a href="#UPDATE-CONFIG" class="headerlink" title="UPDATE_CONFIG"></a>UPDATE_CONFIG</h3><p>配置如何更新服务。 用于配置滚动更新。</p>
<p><code>parallelism</code>：一次更新容器的数量。<br><code>delay</code>：更新一组容器之间的等待时间。<br><code>failure_action</code>：更新失败时该怎么做。 继续，回滚或暂停之一（默认：暂停）。<br><code>monitor</code>：每次任务更新后监视失败的时间（ns | us | ms | s | m | h）（默认为0）。<br><code>max_failure_ratio</code>：在更新期间容忍的失败率。<br><code>order</code>：更新期间的操作顺序。 停止优先（旧任务在开始新任务之前停止）或者先启动（首先启动新任务，并且正在运行的任务短暂重叠）（默认停止优先）注意：只支持v3.4及更高版本。</p>
<p>order支持v3.4或更高版本</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  vote:</span><br><span class="line">    image: dockersamples/examplevotingapp_vote:before</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">2</span></span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: <span class="number">2</span></span><br><span class="line">        delay: <span class="number">10</span>s</span><br><span class="line">        order: stop-first</span><br></pre></td></tr></table></figure>





<h2 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h2><p>设备映射列表。 使用与–device docker客户端创建选项相同的格式。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - <span class="string">&quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：当使用（版本3）Compose文件在群集模式下部署堆栈时，忽略此选项。</p>
<h2 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h2><p>服务之间的快速依赖关系，服务依赖关系导致以下行为：</p>
<p><code>docker-compose up</code> 以依赖顺序启动服务。 在以下示例中，db和redis在web之前启动。</p>
<p><code>docker-up up SERVICE</code> 自动包含SERVICE的依赖关系。 在下面的例子中，docker-compose up web也会创建并启动db和redis。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>

<p>使用depends_on时有几件事要注意：</p>
<p>在启动web之前，depends_on不会等待db和redis“准备就绪” - 只有在它们启动之前。 如果您需要等待服务准备就绪，请参阅控制启动顺序以了解有关此问题的更多信息以及解决此问题的策略。</p>
<p>版本3不再支持depends_on的条件形式。</p>
<p>使用版本3撰写文件在群集模式下部署堆栈时，将忽略depends_on选项。</p>
<h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><p>自定义DNS服务器。 可以是单个值或列表。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns: <span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">dns:</span><br><span class="line">  - <span class="number">8.8</span>.<span class="number">8.8</span></span><br><span class="line">  - <span class="number">9.9</span>.<span class="number">9.9</span></span><br></pre></td></tr></table></figure>

<h2 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h2><p>自定义DNS搜索域。 可以是单个值或列表。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure>

<h2 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h2><p>v2.0以上</p>
<p>在容器中装入一个临时文件系统。 可以是单个值或列表。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: /<span class="keyword">run</span></span><br><span class="line"><span class="bash">tmpfs:</span></span><br><span class="line">  - /<span class="keyword">run</span></span><br><span class="line"><span class="bash">  - /tmp</span></span><br></pre></td></tr></table></figure>

<p>注意：在使用（版本3-3.5）撰写文件的群集模式下部署堆栈时，忽略此选项。</p>
<p>v3.6以上</p>
<p>在容器中装入一个临时文件系统。 Size参数以字节为单位指定tmpfs安装的大小。 无限制默认。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- type: tmpfs</span><br><span class="line">     target: /app</span><br><span class="line">     tmpfs:</span><br><span class="line">       size: <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">entrypoint</span><span class="bash">: /code/entrypoint.sh</span></span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">entrypoint</span><span class="bash">:</span></span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-<span class="number">20100525</span>/xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit=-<span class="number">1</span></span><br><span class="line">    - vendor/bin/phpunit</span><br></pre></td></tr></table></figure>

<p>注意：设置入口点都会使用ENTRYPOINT Dockerfile指令覆盖服务映像上设置的任何默认入口点，并清除映像上的任何默认命令 - 这意味着如果Dockerfile中存在CMD指令，则它将被忽略。</p>
<h2 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h2><p>从文件添加环境变量。 可以是单个值或列表。</p>
<p>如果您已经使用<code>docker-compose -f FILE</code>指定了Compose文件，则env_file中的路径与该文件所在的目录相关。</p>
<p>环境部分中声明的环境变量会覆盖这些值 - 即使这些值为空或未定义，也是如此。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .<span class="keyword">env</span></span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.<span class="keyword">env</span></span><br><span class="line">  - ./apps/web.<span class="keyword">env</span></span><br><span class="line">  - /opt/secrets.<span class="keyword">env</span></span><br></pre></td></tr></table></figure>

<p>撰写Compose env文件中的每行都是VAR = VAL格式。 以＃开始的行被视为注释并被忽略。 空行也被忽略。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set Rails/Rack environment</span></span><br><span class="line">RACK_ENV=development</span><br></pre></td></tr></table></figure>

<p>注意：如果您的服务指定了构建选项，则在构建期间，环境文件中定义的变量不会自动显示。 使用build的args子选项来定义构建时环境变量。</p>
<p>定义的值并不会始终保持不变，列表中的值按照顺序执行，以最后值为准。</p>
<h2 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h2><p>添加环境变量。 您可以使用数组或字典。</p>
<p> 任何布尔值; true, false, yes no，需要用引号括起来以确保它们不被YML解析器转换为True或False。</p>
 <figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: <span class="string">&#x27;true&#x27;</span></span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=true</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure>

<p>注意：如果您的服务指定了构建选项，则在构建过程中定义的变量不会自动显示。 使用build的args子选项来定义构建时环境变量。</p>
<h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>公开端口而不将它们发布到主机 - 它们只能被链接服务访问。 只能指定内部端口。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">expose</span>:</span><br><span class="line"> - <span class="string">&quot;3000&quot;</span></span><br><span class="line"> - <span class="string">&quot;8000&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h2><p>链接到此Docker-compose.yml之外甚至Compose之外的容器，尤其是提供共享或公共服务的容器。 在指定容器名称和链接别名（CONTAINER：ALIAS）时，external_links遵循类似于旧版选项链接的语义。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">external_links:</span><br><span class="line"> - redis_1</span><br><span class="line"> - project_db_1:mysql</span><br><span class="line"> - project_db_1:postgresql</span><br></pre></td></tr></table></figure>

<h2 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h2><p>添加主机名映射。 使用与docker客户端–add-host参数相同的值。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - <span class="string">&quot;somehost:162.242.195.82&quot;</span></span><br><span class="line"> - <span class="string">&quot;otherhost:50.31.209.229&quot;</span></span><br></pre></td></tr></table></figure>

<p>具有ip地址和主机名的条目在容器内的<code>/etc/hosts</code>中为该服务创建，例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">162.242</span>.<span class="number">195.82</span>  somehost</span><br><span class="line"><span class="number">50.31</span>.<span class="number">209.229</span>   otherhost</span><br></pre></td></tr></table></figure>

<h2 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h2><p>v2.1以上</p>
<p>配置运行的检查以确定此服务的容器是否“健康”。 查看<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/#usage" title="HEALTHCHECK Dockerfile">HEALTHCHECK Dockerfile</a>指令的文档以获取有关健康检查如何工作的详细信息。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">healthcheck</span><span class="bash">:</span></span><br><span class="line">  test: [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  interval: <span class="number">1</span>m30s</span><br><span class="line">  timeout: <span class="number">10</span>s</span><br><span class="line">  retries: <span class="number">3</span></span><br><span class="line">  start_period: <span class="number">40</span>s</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hit the local web app</span></span><br><span class="line">test: [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># As above, but wrapped in /bin/sh. Both forms below are equivalent.</span></span><br><span class="line">test: [<span class="string">&quot;CMD-SHELL&quot;</span>, <span class="string">&quot;curl -f http://localhost || exit 1&quot;</span>]</span><br><span class="line">test: curl -f https://localhost || exit <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>要禁用图像设置的任何默认健康检查，您可以使用disable：true。 这相当于指定测试：[“NONE”]。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">healthcheck</span><span class="bash">:</span></span><br><span class="line">  disable: true</span><br></pre></td></tr></table></figure>

<h2 id="Specifying-durations"><a href="#Specifying-durations" class="headerlink" title="Specifying durations"></a>Specifying durations</h2><p>一些配置选项（如检查的间隔和超时子选项）以如下格式的字符串形式接受持续时间：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.5</span>s</span><br><span class="line"><span class="number">10</span>s</span><br><span class="line"><span class="number">1</span>m30s</span><br><span class="line"><span class="number">2</span>h32m</span><br><span class="line"><span class="number">5</span>h34m56s</span><br></pre></td></tr></table></figure>

<p>支持的单位是us，ms，s，m和h。</p>
<h2 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h2><p>指定容器的隔离技术。 在Linux上，唯一支持的值是默认值。 在Windows上，可接受的值是默认值，进程和hyperv。 有关详细信息，请参阅Docker Engine文档。</p>
<h2 id="labels-1"><a href="#labels-1" class="headerlink" title="labels"></a>labels</h2><p>使用Docker标签将元数据添加到容器。 您可以使用数组或字典。</p>
<p>建议您使用反向DNS标记来防止您的标签与其他软件使用的标签冲突。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.example.description: <span class="string">&quot;Accounting webapp&quot;</span></span><br><span class="line">  com.example.department: <span class="string">&quot;Finance&quot;</span></span><br><span class="line">  com.example.label-with-empty-value: <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">labels:</span><br><span class="line">  - <span class="string">&quot;com.example.description=Accounting webapp&quot;</span></span><br><span class="line">  - <span class="string">&quot;com.example.department=Finance&quot;</span></span><br><span class="line">  - <span class="string">&quot;com.example.label-with-empty-value&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>记录服务的配置。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: <span class="string">&quot;tcp://192.168.0.42:123&quot;</span></span><br></pre></td></tr></table></figure>

<p>驱动程序名称指定服务容器的日志记录驱动程序，与docker run的–log-driver选项（此处记录）一样。</p>
<p>默认值是json-file。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: <span class="string">&quot;json-file&quot;</span></span><br><span class="line">driver: <span class="string">&quot;syslog&quot;</span></span><br><span class="line">driver: <span class="string">&quot;none&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：只有<code>json-file</code>和<code>journald</code>驱动程序才能使日志直接从<code>docker-compose up</code>和<code>docker-compose logs</code>。 使用任何其他驱动程序不会打印任何日志。</p>
<p>使用选项键指定日志记录驱动程序的日志记录选项，就像<code>docker run</code>的–log-opt选项一样。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: <span class="string">&quot;syslog&quot;</span></span><br><span class="line">options:</span><br><span class="line">  syslog-address: <span class="string">&quot;tcp://192.168.0.42:123&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认驱动程序json-file具有限制存储日志量的选项。 为此，请使用键值对来获得最大存储大小和最大文件数量：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: <span class="string">&quot;200k&quot;</span></span><br><span class="line">  max-file: <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面显示的示例将存储日志文件，直到它们达到200kB的最大大小，然后旋转它们。 存储的单个日志文件的数量由最大文件值指定。 随着日志增长超出最大限制，旧日志文件将被删除以允许存储新日志。</p>
<p>以下是限制日志存储的示例docker-compose.yml文件：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    image: some-service</span><br><span class="line">    logging:</span><br><span class="line">      driver: <span class="string">&quot;json-file&quot;</span></span><br><span class="line">      options:</span><br><span class="line">        max-size: <span class="string">&quot;200k&quot;</span></span><br><span class="line">        max-file: <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h2><p>网络模式。 使用与docker客户端相同的值–net参数，以及特殊的表单服务：[服务名称]。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: <span class="string">&quot;bridge&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;host&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;none&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;service:[service name]&quot;</span></span><br><span class="line">network_mode: <span class="string">&quot;container:[container name/id]&quot;</span></span><br></pre></td></tr></table></figure>

<p>network_mode：“host”不能与链接混合使用。</p>
<h2 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h2><p>加入网络，引用顶级网络密钥下的条目。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br></pre></td></tr></table></figure>

<h3 id="ALIASES"><a href="#ALIASES" class="headerlink" title="ALIASES"></a>ALIASES</h3><p>网络上此服务的别名（备用主机名）。 同一网络上的其他容器可以使用服务名称或别名来连接到某个服务的容器。</p>
<p>由于别名是网络范围的，相同的服务可以在不同的网络上具有不同的别名。</p>
<p>注意：网络范围的别名可以由多个容器共享，甚至可以由多个服务共享。 如果是，那么名称解析的确切容器的名称就不能保证。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">         - alias3</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: ./web</span><br><span class="line">    networks:</span><br><span class="line">      - new</span><br><span class="line"></span><br><span class="line">  worker:</span><br><span class="line">    build: ./worker</span><br><span class="line">    networks:</span><br><span class="line">      - legacy</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br><span class="line">    networks:</span><br><span class="line">      new:</span><br><span class="line">        aliases:</span><br><span class="line">          - database</span><br><span class="line">      legacy:</span><br><span class="line">        aliases:</span><br><span class="line">          - mysql</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  new:</span><br><span class="line">  legacy:</span><br></pre></td></tr></table></figure>

<h3 id="IPV4-ADDRESS-IPV6-ADDRESS"><a href="#IPV4-ADDRESS-IPV6-ADDRESS" class="headerlink" title="IPV4_ADDRESS, IPV6_ADDRESS"></a>IPV4_ADDRESS, IPV6_ADDRESS</h3><p>加入网络时，为此服务的容器指定一个静态IP地址。</p>
<p>顶级网络部分中的相应网络配置必须具有覆盖每个静态地址的具有子网配置的ipam块。 如果需要IPv6寻址，则必须设置enable_ipv6选项，并且必须使用版本2.x Compose文件，如下所示。</p>
<p>注意：这些选项目前不在群集模式下工作。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.1&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: busybox</span><br><span class="line">    command: ifconfig</span><br><span class="line">    networks:</span><br><span class="line">      app_net:</span><br><span class="line">        ipv4_address: <span class="number">172.16</span>.<span class="number">238.10</span></span><br><span class="line">        ipv6_address: <span class="number">2001</span>:<span class="number">3984</span>:<span class="number">3989</span>::<span class="number">10</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    driver: bridge</span><br><span class="line">    enable_ipv6: true</span><br><span class="line">    ipam:</span><br><span class="line">      driver: default</span><br><span class="line">      config:</span><br><span class="line">      -</span><br><span class="line">        subnet: <span class="number">172.16</span>.<span class="number">238.0</span>/<span class="number">24</span></span><br><span class="line">      -</span><br><span class="line">        subnet: <span class="number">2001</span>:<span class="number">3984</span>:<span class="number">3989</span>::/<span class="number">64</span></span><br></pre></td></tr></table></figure>

<h2 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid: <span class="string">&quot;host&quot;</span></span><br></pre></td></tr></table></figure>

<p>将PID模式设置为主机PID模式。 这将打开容器与主机操作系统之间的共享PID地址空间。 使用此标志启动的容器可以访问和操作裸机的名称空间中的其他容器，反之亦然。</p>
<h2 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h2><p>公开端口</p>
<p>注意：端口映射与network_mode：host不兼容</p>
<h3 id="SHORT-SYNTAX-1"><a href="#SHORT-SYNTAX-1" class="headerlink" title="SHORT SYNTAX"></a>SHORT SYNTAX</h3><p>既可以指定两个端口（HOST：CONTAINER），也可以指定容器端口（选择临时主机端口）。</p>
<p>注意：以HOST：CONTAINER格式映射端口时，使用低于60的容器端口时可能会遇到错误结果，因为YAML会将格式为xx：yy的数字解析为基数为60的值。 出于这个原因，我们建议始终明确指定您的端口映射为字符串。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - <span class="string">&quot;3000&quot;</span></span><br><span class="line"> - <span class="string">&quot;3000-3005&quot;</span></span><br><span class="line"> - <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> - <span class="string">&quot;9090-9091:8080-8081&quot;</span></span><br><span class="line"> - <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> - <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br><span class="line"> - <span class="string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span></span><br><span class="line"> - <span class="string">&quot;6060:6060/udp&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="LONG-SYNTAX-1"><a href="#LONG-SYNTAX-1" class="headerlink" title="LONG SYNTAX"></a>LONG SYNTAX</h3><p>长格式语法允许配置不能以简短形式表示的附加字段。</p>
<p>target：容器内的端口<br>published：公开曝光的港口<br>protocol：端口协议（tcp或udp）<br>mode：用于在每个节点上发布主机端口的主机，或用于群集模式端口的入口以进行负载平衡。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">  - target: <span class="number">80</span></span><br><span class="line">    published: <span class="number">8080</span></span><br><span class="line">    protocol: tcp</span><br><span class="line">    mode: host</span><br></pre></td></tr></table></figure>

<p>注意：长语法在v3.2中是新的</p>
<h2 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.1&quot;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">1</span></span><br><span class="line">    secrets:</span><br><span class="line">      - my_secret</span><br><span class="line">      - my_other_secret</span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">  my_other_secret:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.1&quot;</span></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: <span class="number">1</span></span><br><span class="line">    secrets:</span><br><span class="line">      - source: my_secret</span><br><span class="line">        target: redis_secret</span><br><span class="line">        uid: <span class="string">&#x27;103&#x27;</span></span><br><span class="line">        gid: <span class="string">&#x27;103&#x27;</span></span><br><span class="line">        mode: <span class="number">0440</span></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">  my_other_secret:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<h2 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h2><p>覆盖每个容器的默认标签方案。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">security_opt:</span><br><span class="line">  - <span class="keyword">label</span><span class="bash">:user:USER</span></span><br><span class="line">  - <span class="keyword">label</span><span class="bash">:role:ROLE</span></span><br></pre></td></tr></table></figure>

<h2 id="stop-grace-period"><a href="#stop-grace-period" class="headerlink" title="stop_grace_period"></a>stop_grace_period</h2><p>指定在发送SIGKILL之前，如果试图停止一个容器（如果它没有处理SIGTERM）（或者使用stop_signal指定了任何停止信号），请等待多久。 指定为持续时间。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop_grace_period: <span class="number">1</span>s</span><br><span class="line">stop_grace_period: <span class="number">1</span>m30s</span><br></pre></td></tr></table></figure>

<p>默认情况下，停止在发送SIGKILL之前等待10秒钟容器退出。</p>
<h2 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h2><p>设置一个替代信号来停止容器。 默认停止使用SIGTERM。 使用stop_signal设置替代信号会导致停止发送该信号。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure>

<h2 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h2><p>在容器中设置的内核参数。 您可以使用数组或字典。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: <span class="number">1024</span></span><br><span class="line">  net.ipv4.tcp_syncookies: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=<span class="number">1024</span></span><br><span class="line">  - net.ipv4.tcp_syncookies=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h2><p>覆盖容器的默认限制。 您可以将单个限制指定为整数，也可以将软限制/硬限制指定为映射。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: <span class="number">65535</span></span><br><span class="line">  nofile:</span><br><span class="line">    soft: <span class="number">20000</span></span><br><span class="line">    hard: <span class="number">40000</span></span><br></pre></td></tr></table></figure>

<h2 id="userns-mode"><a href="#userns-mode" class="headerlink" title="userns_mode"></a>userns_mode</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userns_mode: <span class="string">&quot;host&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果Docker守护程序配置了用户命名空间，则禁用此服务的用户命名空间。</p>
<h2 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h2><p>装载主机路径或命名卷，将其指定为服务的子选项。</p>
<p>您可以将主机路径作为单个服务的定义的一部分进行安装，并且无需在顶级卷密钥中定义它。</p>
<p>但是，如果要跨多个服务重用卷，请在顶级卷密钥中定义一个命名卷。 将命名卷与服务，群集和堆栈文件一起使用。</p>
<p>注意：顶级卷密钥定义了一个命名卷，并从每个服务的卷列表中引用它。 这会替换早期版本的Compose文件格式中的volumes_from。 有关卷的一般信息，请参阅使用卷和卷插件。</p>
<p>此示例显示Web服务正在使用的命名卷（mydata），以及为单个服务（数据库服务卷下的第一个路径）定义的绑定挂载。 数据库服务还使用名为dbdata的命名卷（数据库服务卷下的第二个路径），但使用旧的字符串格式定义它以装载命名卷。 如图所示，命名卷必须列在顶级卷密钥下。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.2&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    volumes:</span><br><span class="line">      - type: <span class="keyword">volume</span></span><br><span class="line"><span class="bash">        <span class="built_in">source</span>: mydata</span></span><br><span class="line">        target: /data</span><br><span class="line">        <span class="keyword">volume</span><span class="bash">:</span></span><br><span class="line">          nocopy: true</span><br><span class="line">      - type: bind</span><br><span class="line">        source: ./static</span><br><span class="line">        target: /opt/app/static</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;</span></span><br><span class="line">      - <span class="string">&quot;dbdata:/var/lib/postgresql/data&quot;</span></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mydata:</span><br><span class="line">  dbdata:</span><br></pre></td></tr></table></figure>

<h3 id="SHORT-SYNTAX-2"><a href="#SHORT-SYNTAX-2" class="headerlink" title="SHORT SYNTAX"></a>SHORT SYNTAX</h3><p>可以选择在主机上（HOST：CONTAINER）或访问模式（HOST：CONTAINER：ro）指定路径。</p>
<p>您可以在主机上挂载相对路径，该路径相对于正在使用的Compose配置文件的目录进行扩展。 相对路径应始终以</p>
<p><code>.</code>或<code>..</code>。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  <span class="comment"># Just specify a path and let the Engine create a volume</span></span><br><span class="line">  - /var/lib/mysql</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Specify an absolute path mapping</span></span><br><span class="line">  - /opt/data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Path on the host, relative to the Compose file</span></span><br><span class="line">  - ./cache:/tmp/cache</span><br><span class="line"></span><br><span class="line">  <span class="comment"># User-relative path</span></span><br><span class="line">  - ~/configs:/etc/configs/:ro</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Named volume</span></span><br><span class="line">  - datavolume:/var/lib/mysql</span><br></pre></td></tr></table></figure>

<h3 id="LONG-SYNTAX-2"><a href="#LONG-SYNTAX-2" class="headerlink" title="LONG SYNTAX"></a>LONG SYNTAX</h3><p><code>type</code>：装载类型卷，绑定或tmpfs<br><code>source</code>：装入源，主机上用于绑定装入的路径或顶级卷密钥中定义的卷的名称。 不适用于tmpfs安装。<br><code>target</code>：卷所在的容器中的路径<br><code>read_only</code>：标志将卷设置为只读<br><code>bind</code>：配置额外的绑定选项<br>  <code>propagation</code>：用于绑定的传播模式<br><code>volume</code>：配置额外的volume选项<br>  <code>nocopy</code>：标志，用于在卷创建时禁止从容器复制数据<br><code>tmpfs</code>：配置附加的tmpfs选项<br>  <code>size</code>：tmpfs的大小，以字节为单位</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3.2&quot;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - type: <span class="keyword">volume</span></span><br><span class="line"><span class="bash">        <span class="built_in">source</span>: mydata</span></span><br><span class="line">        target: /data</span><br><span class="line">        <span class="keyword">volume</span><span class="bash">:</span></span><br><span class="line">          nocopy: true</span><br><span class="line">      - type: bind</span><br><span class="line">        source: ./static</span><br><span class="line">        target: /opt/app/static</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mydata:</span><br></pre></td></tr></table></figure>

<p>Note: The long syntax is new in v3.2</p>
<p>** 服务，群集和堆栈文件的卷**</p>
<p>在使用服务，群集和docker-stack.yml文件时，请记住支持服务的任务（容器）可以部署在群集中的任何节点上，并且每次更新服务时都可能是不同的节点。</p>
<p>在缺少指定源的命名卷的情况下，Docker为支持服务的每个任务创建一个匿名卷。关联的容器被移除后，匿名卷不会保留。</p>
<p>如果您希望数据持久存在，请使用可识别多主机的命名卷和卷驱动程序，以便可以从任何节点访问数据。或者，对该服务设置约束，以便将其任务部署在具有该卷的节点上。</p>
<p>作为一个例子，Docker Labs中votingapp示例的docker-stack.yml文件 定义了一个称为运行数据库的服务。它被配置为一个命名卷来保存群体上的数据， 并且仅限于在节点上运行。这是来自该文件的相关剪辑：db postgres manager</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:<span class="number">9.4</span></span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br></pre></td></tr></table></figure>

<h2 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h2><p>no是默认的重启策略，在任何情况下都不会重启容器。 总是指定时，容器总是重新启动。 如果退出代码指示出现故障错误，则故障中策略会重新启动容器。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: <span class="string">&quot;no&quot;</span></span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure>

<h2 id="domainname-hostname-ipc-mac-address-privileged-read-only-shm-size-stdin-open-tty-user-working-dir"><a href="#domainname-hostname-ipc-mac-address-privileged-read-only-shm-size-stdin-open-tty-user-working-dir" class="headerlink" title="domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, tty, user, working_dir"></a>domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, tty, user, working_dir</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span>: postgresql</span><br><span class="line">working_dir: /code</span><br><span class="line"></span><br><span class="line">domainname: foo.com</span><br><span class="line">hostname: foo</span><br><span class="line">ipc: host</span><br><span class="line">mac_address: <span class="number">02</span>:<span class="number">42</span>:ac:<span class="number">11</span>:<span class="number">65</span>:<span class="number">43</span></span><br><span class="line"></span><br><span class="line">privileged: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read_only: true</span><br><span class="line">shm_size: <span class="number">64</span>M</span><br><span class="line">stdin_open: true</span><br><span class="line">tty: true</span><br></pre></td></tr></table></figure>

<h2 id="Specifying-durations-1"><a href="#Specifying-durations-1" class="headerlink" title="Specifying durations"></a>Specifying durations</h2><p>一些配置选项（如interval和timeout ）以如下格式的字符串形式接受持续时间：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.5</span>s</span><br><span class="line"><span class="number">10</span>s</span><br><span class="line"><span class="number">1</span>m30s</span><br><span class="line"><span class="number">2</span>h32m</span><br><span class="line"><span class="number">5</span>h34m56s</span><br></pre></td></tr></table></figure>

<h2 id="Volume-configuration-reference"><a href="#Volume-configuration-reference" class="headerlink" title="Volume configuration reference"></a>Volume configuration reference</h2><p>虽然可以将文件中的卷声明为服务声明的一部分，但本节允许您创建可在多个服务中重复使用的命名卷（不依赖于volumes_from），并且可以使用docker命令行轻松检索和检查 或API。 有关更多信息，请参阅docker卷子命令文档。</p>
<p>有关卷的一般信息，请参阅使用卷和卷插件。</p>
<p>以下是一个双服务设置的示例，其中数据库的数据目录与另一个服务共享为一个卷，以便可以定期进行备份：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: db</span><br><span class="line">    volumes:</span><br><span class="line">      - data-<span class="keyword">volume</span><span class="bash">:/var/lib/db</span></span><br><span class="line">  backup:</span><br><span class="line">    image: backup-service</span><br><span class="line">    volumes:</span><br><span class="line">      - data-<span class="keyword">volume</span><span class="bash">:/var/lib/backup/data</span></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  data-<span class="keyword">volume</span><span class="bash">:</span></span><br></pre></td></tr></table></figure>

<p>顶级卷密钥下的条目可以为空，在这种情况下，它使用由引擎配置的默认驱动程序（在大多数情况下，这是本地驱动程序）。 或者，您可以使用以下键配置它：</p>
<h3 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h3><p>指定应该为此卷使用哪个卷驱动程序。 默认为Docker引擎已经配置使用的驱动程序，在大多数情况下它是本地的。 如果驱动程序不可用，则当docker-compose up尝试创建卷时，引擎会返回错误。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver: foobar</span><br></pre></td></tr></table></figure>

<h3 id="driver-opts"><a href="#driver-opts" class="headerlink" title="driver_opts"></a>driver_opts</h3><p>指定一个选项列表作为传递给该卷的驱动程序的键值对。 这些选项是依赖于驱动程序的 - 请查阅驱动程序的文档以获取更多信息。 可选的。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver_opts:</span><br><span class="line">  foo: <span class="string">&quot;bar&quot;</span></span><br><span class="line">  baz: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="external"><a href="#external" class="headerlink" title="external"></a>external</h3><p>如果设置为true，则指定该卷已在Compose之外创建。 docker-compose up不会尝试创建它，并在它不存在时引发错误。</p>
<p>外部不能与其他卷配置键（驱动程序，driver_opts）一起使用。</p>
<p>在下面的示例中，Compose不是试图创建一个名为[projectname] _data的卷，而是查找一个简单称为data的现有卷，并将其挂载到数据库服务的容器中。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    volumes:</span><br><span class="line">      - data:/var/lib/postgresql/data</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  data:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>

<p>external.name在版本3.4文件格式中被弃用，而使用name。</p>
<p>您还可以在Compose文件中单独指定用于引用它的名称来指定卷的名称：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  data:</span><br><span class="line">    external:</span><br><span class="line">      name: actual-name-of-<span class="keyword">volume</span></span><br></pre></td></tr></table></figure>

<p>** 外部卷始终使用Docker堆栈部署来创建**</p>
<p>如果您使用docker stack deploy以swarm模式启动应用程序（而不是docker组合），则创建不存在的外部卷。 在群集模式下，当服务定义时会自动创建一个卷。 由于服务任务在新节点上进行安排，因此swarmkit会在本地节点上创建卷</p>
<h3 id="labels-2"><a href="#labels-2" class="headerlink" title="labels"></a>labels</h3><p>使用Docker标签将元数据添加到容器。 您可以使用数组或字典。</p>
<p>建议您使用反向DNS标记来防止您的标签与其他软件使用的标签冲突。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.example.description: <span class="string">&quot;Database volume&quot;</span></span><br><span class="line">  com.example.department: <span class="string">&quot;IT/Ops&quot;</span></span><br><span class="line">  com.example.label-with-empty-value: <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">labels:</span><br><span class="line">  - <span class="string">&quot;com.example.description=Database volume&quot;</span></span><br><span class="line">  - <span class="string">&quot;com.example.department=IT/Ops&quot;</span></span><br><span class="line">  - <span class="string">&quot;com.example.label-with-empty-value&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>为此卷设置一个自定义名称。 名称字段可用于引用包含特殊字符的网络。 该名称按原样使用，不会与堆栈名称一起作用。</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line">volumes:</span><br><span class="line">  data:</span><br><span class="line">    name: my-app-data</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line">volumes:</span><br><span class="line">  data:</span><br><span class="line">    external: true</span><br><span class="line">    name: my-app-data</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/11/Power-Shell%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/11/Power-Shell%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Power Shell命令学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-11 08:58:10" itemprop="dateCreated datePublished" datetime="2018-05-11T08:58:10+00:00">2018-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/11/linux-chmod%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/11/linux-chmod%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">linux chmod命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-11 08:56:22" itemprop="dateCreated datePublished" datetime="2018-05-11T08:56:22+00:00">2018-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。<br>该命令有两种用法:</p>
<p>** 一种是包含字母和操作符表达式的文字设定法；**<br>** 一种是包含数字的数字设定法。**</p>
<p>Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。</p>
<p>文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。</p>
<p>有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。</p>
<p>每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[toor@localhost cmdtest]$ ls -al</span><br><span class="line">总用量 4</span><br><span class="line">drwxrwxr-x.  2 toor toor   24 5月  11 09:19 .</span><br><span class="line">drwx------. 15 toor toor 4096 5月  11 09:19 ..</span><br><span class="line">-rw-rw-r--.  1 toor toor    0 5月  11 09:19 2018511.log</span><br></pre></td></tr></table></figure>

<p>以2018511.log为例：</p>
<p><code>-rw-rw-r--.  1 toor toor    0 5月  11 09:19 2018511.log</code></p>
<p>第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。</p>
<p>例如：<br><code>-rw-rw-r--</code><br>　　表示2018511.log是一个普通文件；2018511.log的属主有读写权限；与log2012.log属主同组的用户有读写权限；其他用户也只有读权限。</p>
<p>确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。</p>
<p>chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [-cfvR] [--<span class="built_in">help</span>] [--version] mode file</span><br></pre></td></tr></table></figure>

<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。</p>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p>** 必要参数：**</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c 当发生改变时，报告处理信息</span><br><span class="line">-f 错误信息不输出</span><br><span class="line">-R 处理指定目录以及其子目录下的所有文件</span><br><span class="line">-v 运行时显示详细处理信息</span><br></pre></td></tr></table></figure>

<p>** 选择参数 **</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限</span><br><span class="line">--version 显示版本信息</span><br><span class="line">&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限</span><br><span class="line">&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限</span><br><span class="line">&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值</span><br></pre></td></tr></table></figure>

<p>** 权限范围 **</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u ：目录或者文件的当前的用户</span><br><span class="line">g ：目录或者文件的当前的群组</span><br><span class="line">o ：除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class="line">a ：所有的用户及群组</span><br></pre></td></tr></table></figure>

<p>** 权限代号**</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r ：读权限，用数字4表示</span><br><span class="line">w ：写权限，用数字2表示</span><br><span class="line">x ：执行权限，用数字1表示</span><br><span class="line">- ：删除权限，用数字0表示</span><br><span class="line">s ：特殊权限</span><br></pre></td></tr></table></figure>

<p>该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p>
<p><strong>* 文字设定法 *</strong></p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ［who］ ［+ | - | =］ ［mode］ 文件名</span><br></pre></td></tr></table></figure>

<p><strong>* 数字设定法 *</strong></p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ［mode］ 文件名</span><br></pre></td></tr></table></figure>

<p>0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。</p>
<p>例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。</p>
<p>数字与字符对应关系如下：</p>
<p>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>** 增加文件所有用户组可执行权限 **</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x 2018511.log</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">-rw-rw-r--. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ chmod a+x 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">-rwxrwxr-x. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$</span><br></pre></td></tr></table></figure>

<p>说明：<br>即设定文件2018511.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。</p>
<p>** 同时修改不同用户权限**</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-x 2018511.log</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">-r-xr-xr-x. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ chmod ug+w,o-x 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">-rwxrwxr--. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$</span><br></pre></td></tr></table></figure>

<p>说明：<br>即设定文件text的属性为：文件属主（u） 增加写权限;与文件属主同组用户（g） 增加写权限;其他用户（o） 删除执行权限</p>
<p>** 删除文件权限 **</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a-x 2018511.log</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">-rwxrwxr--. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ chmod a-x 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">-rw-rw-r--. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$</span><br></pre></td></tr></table></figure>

<p>说明：<br>删除所有用户的可执行权限</p>
<p>** 使用“=”设置权限**</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=x 2018511.log</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">-rw-rw-r--. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ chmod u=x 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$ ls -al 2018511.log</span><br><span class="line">---xrw-r--. 1 toor toor 0 5月  11 09:19 2018511.log</span><br><span class="line">[toor@localhost cmdtest]$</span><br></pre></td></tr></table></figure>

<p>说明：<br>文件属主（u）等于执行权限;其它权限不变</p>
<p>** 对一个目录及其子目录所有文件添加权限**</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R u+x test1</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[toor@localhost test1]$ ls -al</span><br><span class="line">总用量 0</span><br><span class="line">drwxrwxr-x. 2 toor toor 36 5月  11 10:46 .</span><br><span class="line">drwxrwxr-x. 3 toor toor 36 5月  11 10:46 ..</span><br><span class="line">-rw-rw-r--. 1 toor toor  0 5月  11 10:46 log1.log</span><br><span class="line">-rw-rw-r--. 1 toor toor  0 5月  11 10:46 log2.log</span><br><span class="line">[toor@localhost test1]$ <span class="built_in">cd</span> ..</span><br><span class="line">[toor@localhost cmdtest]$ chmod -R u+x test1</span><br><span class="line">[toor@localhost cmdtest]$ <span class="built_in">cd</span> test1</span><br><span class="line">[toor@localhost test1]$ ls -al</span><br><span class="line">总用量 0</span><br><span class="line">drwxrwxr-x. 2 toor toor 36 5月  11 10:46 .</span><br><span class="line">drwxrwxr-x. 3 toor toor 36 5月  11 10:46 ..</span><br><span class="line">-rwxrw-r--. 1 toor toor  0 5月  11 10:46 log1.log</span><br><span class="line">-rwxrw-r--. 1 toor toor  0 5月  11 10:46 log2.log</span><br><span class="line">[toor@localhost test1]$</span><br></pre></td></tr></table></figure>

<p>说明：<br>递归地给test1目录下所有文件和子目录的属主分配权限</p>
<p>** 其他实例：**</p>
<p>给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限，命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 751 file</span><br><span class="line">chmod u=rwx,g=rx,o=x file</span><br></pre></td></tr></table></figure>

<p>为所有用户分配读权限，命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 444 file</span><br><span class="line">chmod a-wx,a+r   file</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/11/29/2794010.html">http://www.cnblogs.com/peida/archive/2012/11/29/2794010.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/10/Linux-bash%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/10/Linux-bash%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Linux bash学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-10 14:53:18" itemprop="dateCreated datePublished" datetime="2018-05-10T14:53:18+00:00">2018-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://cn.linux.vbird.org/linux_basic/0320bash.php">http://cn.linux.vbird.org/linux_basic/0320bash.php</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html">https://www.cnblogs.com/skywang12345/archive/2013/05/30/3106570.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/skywang12345/archive/2013/05/31/3107871.html">http://www.cnblogs.com/skywang12345/archive/2013/05/31/3107871.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/05/10/Linux-ps%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/10/Linux-ps%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux ps命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-10 11:16:26" itemprop="dateCreated datePublished" datetime="2018-05-10T11:16:26+00:00">2018-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 08:28:34" itemprop="dateModified" datetime="2021-05-07T08:28:34+00:00">2021-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-ps命令"><a href="#Linux-ps命令" class="headerlink" title="Linux ps命令"></a>Linux ps命令</h1><p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
<p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p>
<p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。</p>
<p>kill 命令用于杀死进程。</p>
<h2 id="linux上进程有5种状态"><a href="#linux上进程有5种状态" class="headerlink" title="linux上进程有5种状态"></a>linux上进程有5种状态</h2><ol>
<li>运行(正在运行或在运行队列中等待)</li>
<li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>
<li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>
<li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</li>
<li>停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</li>
</ol>
<h2 id="ps工具标识进程的5种状态码"><a href="#ps工具标识进程的5种状态码" class="headerlink" title="ps工具标识进程的5种状态码"></a>ps工具标识进程的5种状态码</h2><p>D 不可中断 uninterruptible sleep (usually IO)<br>R 运行 runnable (on run queue)<br>S 中断 sleeping<br>T 停止 traced or stopped<br>Z 僵死 a defunct (”zombie”) process</p>
<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>** 命令格式：**<br>ps [参数]</p>
<p>** 命令功能：**<br>用来显示当前进程的状态</p>
<p>** 命令参数：**</p>
<p>a  显示所有进程<br>-a 显示同一终端下的所有程序<br>-A 显示所有进程<br>c  显示进程的真实名称<br>-N 反向选择<br>-e 等于“-A”<br>e  显示环境变量<br>f  显示程序间的关系<br>-H 显示树状结构<br>r  显示当前终端的进程<br>T  显示当前终端的所有程序<br>u  指定用户的所有进程<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>-C&lt;命令&gt; 列出指定命令的状况<br>–lines&lt;行数&gt; 每页显示的行数<br>–width&lt;字符数&gt; 每页显示的字符数<br>–help 显示帮助信息<br>–version 显示版本显示</p>
<p>** 使用实例 **</p>
<p><code>ps -A</code>:显示所有进程信息</p>
<p><code>ps -u root</code>:显示指定用户信息</p>
<p><code>ps -ef|grep ssh</code>:ps 与grep 常用组合用法，查找特定进程</p>
<p><code>ps -l</code>:将目前属于您自己这次登入的 PID 与相关信息列示出来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Desktop]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0   2774   2722  0  80   0 - 47498 do_wai pts/0    00:00:00 su</span><br><span class="line">4 S     0   2780   2774  0  80   0 - 29075 do_wai pts/0    00:00:00 bash</span><br><span class="line">0 R     0  23118   2780  0  80   0 - 37235 -      pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>** 说明：**</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</span><br><span class="line">S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</span><br><span class="line">UID 程序被该 UID 所拥有</span><br><span class="line">PID 就是这个程序的 ID ！</span><br><span class="line">PPID 则是其上级父程序的ID</span><br><span class="line">C CPU 使用的资源百分比</span><br><span class="line">PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</span><br><span class="line">NI 这个是 Nice 值，在下一小节我们会持续介绍</span><br><span class="line">ADDR 这个是 kernel <span class="keyword">function</span>，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 <span class="string">&quot;-&quot;</span></span><br><span class="line">SZ 使用掉的内存大小</span><br><span class="line">WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</span><br><span class="line">TTY 登入者的终端机位置</span><br><span class="line">TIME 使用掉的 CPU 时间。</span><br><span class="line">CMD 所下达的指令为何</span><br><span class="line">在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有三个 PID。</span><br></pre></td></tr></table></figure>

<p><code>ps -axjf</code>:列出类似程序树的程序显示</p>
<p><code>ps aux | egrep &#39;(cron|syslog)&#39;</code>:找出与 cron 与 syslog 这两个服务有关的 PID 号码</p>
<p><code>ps -aux |more</code>:用 | 管道和 more 连接起来分页查看</p>
<p><code>ps -aux &gt; ps001.txt</code>:把所有进程显示出来，并输出到ps001.txt文件</p>
<p><code>ps -o pid,ppid,pgrp,session,tpgid,comm</code>:输出指定字段</p>
<h2 id="ps-ef和ps-aux的区别"><a href="#ps-ef和ps-aux的区别" class="headerlink" title="ps -ef和ps aux的区别"></a>ps -ef和ps aux的区别</h2><p>Linux下显示系统进程的命令ps，最常用的有ps -ef 和ps aux。这两个到底有什么区别呢？两者没太大差别，讨论这个问题，要追溯到Unix系统中的两种风格，System Ｖ风格和BSD 风格，ps aux最初用到Unix Style中，而ps -ef被用在System V Style中，两者输出略有不同。现在的大部分Linux系统都是可以同时使用这两种方式的。</p>
<p>** <code>ps -ef</code>:显示所有进程信息，连同命令行 **</p>
<p>ps -ef 是用标准的格式显示进程的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Desktop]<span class="comment"># ps -ef</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 09:40 ?        00:00:03 /usr/lib/systemd/systemd --swi</span><br><span class="line">root          2      0  0 09:40 ?        00:00:00 [kthreadd]</span><br><span class="line">root          3      2  0 09:40 ?        00:00:00 [ksoftirqd/0]</span><br><span class="line">root          5      2  0 09:40 ?        00:00:00 [kworker/0:0H]</span><br><span class="line">root          7      2  0 09:40 ?        00:00:00 [migration/0]</span><br><span class="line">root          8      2  0 09:40 ?        00:00:00 [rcu_bh]</span><br><span class="line">root          9      2  0 09:40 ?        00:00:02 [rcu_sched]</span><br><span class="line">root         10      2  0 09:40 ?        00:00:00 [watchdog/0]</span><br></pre></td></tr></table></figure>

<p>参数详解：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UID    //用户ID、但输出的是用户名</span><br><span class="line">PID    //进程的ID</span><br><span class="line">PPID   //父进程ID</span><br><span class="line">C      //进程占用CPU的百分比</span><br><span class="line">STIME  //进程启动到现在的时间</span><br><span class="line">TTY    //该进程在那个终端上运行，若与终端无关，则显示? 若为pts/0等，则表示由网络连接主机进程。</span><br><span class="line">CMD    //命令的名称和参数</span><br></pre></td></tr></table></figure>

<p>** <code>ps aux</code>:列出目前所有的正在内存当中的程序 ** </p>
<p>ps aux 是用BSD的格式来显示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@localhost Desktop]<span class="comment"># ps -aux</span></span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.4 193720  4236 ?        Ss   09:40   0:03 /usr/lib/syste</span><br><span class="line">root          2  0.0  0.0      0     0 ?        S    09:40   0:00 [kthreadd]</span><br><span class="line">root          3  0.0  0.0      0     0 ?        S    09:40   0:00 [ksoftirqd/0]</span><br><span class="line">root          5  0.0  0.0      0     0 ?        S&lt;   09:40   0:00 [kworker/0:0H]</span><br><span class="line">root          7  0.0  0.0      0     0 ?        S    09:40   0:00 [migration/0]</span><br><span class="line">root          8  0.0  0.0      0     0 ?        S    09:40   0:00 [rcu_bh]</span><br><span class="line">root          9  0.0  0.0      0     0 ?        R    09:40   0:02 [rcu_sched]</span><br><span class="line">root         10  0.0  0.0      0     0 ?        S    09:40   0:00 [watchdog/0]</span><br><span class="line">root         12  0.0  0.0      0     0 ?        S    09:40   0:00 [kdevtmpfs]</span><br></pre></td></tr></table></figure>

<p>同ps -ef 不同的有列有</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER      //用户名</span><br><span class="line">%CPU      //进程占用的CPU百分比</span><br><span class="line">%MEM      //占用内存的百分比</span><br><span class="line">VSZ       //该进程使用的虚拟內存量（KB）</span><br><span class="line">RSS       //该进程占用的固定內存量（KB）（驻留中页的数量）</span><br><span class="line">STAT      //进程的状态</span><br><span class="line">START     //该进程被触发启动时间</span><br><span class="line">TIME      //该进程实际使用CPU运行的时间</span><br></pre></td></tr></table></figure>

<p>其中STAT状态位常见的状态字符有</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D      //无法中断的休眠状态（通常 IO 的进程）；</span><br><span class="line">R      //正在运行可中在队列中可过行的；</span><br><span class="line">S      //处于休眠状态；</span><br><span class="line">T      //停止或被追踪；</span><br><span class="line">W      //进入内存交换 （从内核2.6开始无效）；</span><br><span class="line">X      //死掉的进程 （基本很少见）；</span><br><span class="line">Z      //僵尸进程；</span><br><span class="line">&lt;      //优先级高的进程</span><br><span class="line">N      //优先级较低的进程</span><br><span class="line">L      //有些页被锁进内存；</span><br><span class="line">s      //进程的领导者（在它之下有子进程）；</span><br><span class="line">l      //多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）；</span><br><span class="line">+      //位于后台的进程组；</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html">http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2016-07/133515.htm">https://www.linuxidc.com/Linux/2016-07/133515.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">411</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">121</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">176</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
