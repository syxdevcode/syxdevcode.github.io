<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/2/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-sed%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-sed%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux sed命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 10:18:17" itemprop="dateCreated datePublished" datetime="2021-03-29T10:18:17+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux 三剑客，它们是 grep、awk、sed。</p>
<p>sed 全名叫 <code>stream editor</code>，流编辑器，用程序的方式来编辑文本，与 vim 的交互式编辑方式截然不同。它的功能十分强大，加上正则表达式的支持，可以进行大量的复杂文本的编辑操作。</p>
<p>使用场景：</p>
<ul>
<li>自动化程序中，不适合交互方式编辑的；</li>
<li>大批量重复性的编辑需求；</li>
<li>编辑命令太过复杂，在交互文本编辑器难以输入的情况；</li>
</ul>
<p>Linux sed 命令是利用脚本来处理文本文件。sed 命令采用的是流编辑模式，最明显的特点是，在 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</p>
<p>默认情况下 sed 并不会修改原始文件，这里被删除的行只是从 sed 的输出中消失了，原始文件没做任何改变。</p>
<p>sed 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下：</p>
<ul>
<li>1，每次仅读取一行内容；</li>
<li>2，根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；</li>
<li>3，将执行结果输出。</li>
</ul>
<p><strong>工作原理</strong></p>
<p>sed 作为一种非交互式编辑器，它使用预先设定好的编辑指令对输入的文本进行编辑，完成之后输出编辑结果。</p>
<p>简单描述 sed 工作原理：</p>
<ul>
<li>sed 从输入文件中读取内容，每次处理一行内容，并把当前的一行内容存储在临时的缓冲区中，称为 模式空间。</li>
<li>接着用 sed 命令处理缓存区中的内容；</li>
<li>处理完毕后，把缓存区的内容送往屏幕；</li>
<li>接着处理下一行；</li>
</ul>
<p>这样不断重复，直到文件末尾，文件内容并没有改变，除非你使用重定向输出或指定了 i 参数</p>
<p>当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。</p>
<p>语法 <code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-e 脚本命令</td>
<td align="left">该选项会将其后跟的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td align="center">-f 脚本命令文件</td>
<td align="left">该选项会将其后文件中的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td align="center">-n或–quiet或–silent</td>
<td align="left">仅显示script处理后的结果，默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</td>
</tr>
<tr>
<td align="center">-h或–help</td>
<td align="left">显示帮助。</td>
</tr>
<tr>
<td align="center">-V或–version</td>
<td align="left">显示版本信息。</td>
</tr>
</tbody></table>
<p>动作说明</p>
<p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除， d 后面通常不接任何字符；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：打印， 将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行<br>s ：取代， 通常搭配正规表示法，例如 1,20s/old/new/g</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>sed 基本上就是用正则表达式模式匹配。</p>
<h3 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h3><ul>
<li><code>.</code> 表示匹配任意一个字符，除了换行符，类似 Shell 通配符中的 ?；</li>
<li><code>*</code> 表示前边字符有 0 个或多个；</li>
<li><code>.*</code> 表示任意一个字符有 0 个或多个，也就是能匹配任意的字符；</li>
<li><code>^</code> 表示行首，也就是每一行的开始位置，^abc 匹配以 abc 开头的字符串；</li>
<li><code>$</code> 表示行尾，也就是每一行的结尾位置，}$ 匹配以大括号结尾的字符串；</li>
<li><code>&#123;&#125;</code> 表示前边字符的数量范围，{2}，表示重复 2 次，{2,}重复至少 2次，{2,4} 重复 2-4 次；</li>
<li><code>[]</code> 括号中可以包含表示字符集的表达式，使用方法大概如下几种</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330113252.png" alt="微信截图_20210330113252.png"></p>
<h3 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h3><p>扩展正则表达式使用频率上没有基本表达式那么高，但依然很重要，很多情况下没有扩展正则是搞不定的，sed 命令使用扩展正则时需要加上选项 <code>-r</code>。</p>
<ul>
<li><code>?</code>：表示前置字符有 0 个或 1 个；</li>
<li><code>+</code>：表示前置字符有 1 个或多个；</li>
<li><code>|</code>：表示匹配其中的一项即可；</li>
<li><code>()</code>：表示分组，(a|b)b 表示可以匹配 ab 或 bb 子串，且命令表达式中可以通过 \1、\2 来表示匹配的变量</li>
<li><code>&#123;&#125;</code>：和基本正则中的大括号中意义相同，只不过使用时不用加 转义符号；</li>
</ul>
<h2 id="数字定址和正则定址"><a href="#数字定址和正则定址" class="headerlink" title="数字定址和正则定址"></a>数字定址和正则定址</h2><p>默认情况下 sed 会对每一行内容进行匹配、处理、输出，有时候我们不需要对所有内容进行操作，只需要修改一种一部分，比如 1-10 行，偶数行，或包括 hello 字符串的行。</p>
<p>这种情况下，就需要我们去定位特定的行来进行处理，而不是全部内容，这里把定位指定的行叫做 定址。</p>
<h3 id="数字定址"><a href="#数字定址" class="headerlink" title="数字定址"></a>数字定址</h3><p>数字定址其实就是通过数字去指定要操作的行，有几种方式，每种方式都有不同的应用场景。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只将第4行中hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;4s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将第2-4行中hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;2,4s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第2行开始，往下数4行，也就是2-6行</span></span><br><span class="line">$ sed <span class="string">&#x27;2,+4s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将最后1行中hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;$s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了第1行，其它行将hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;1!s/hello/A/g&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h3 id="正则定址"><a href="#正则定址" class="headerlink" title="正则定址"></a>正则定址</h3><p>正则定址，是通过正则表达式的匹配来确定需要处理编辑哪些行，其它行就不需要处理</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将匹配到hello的行执行删除操作，d 表示删除</span></span><br><span class="line">$ sed <span class="string">&#x27;/hello/d&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空行，&quot;^$&quot; 表示空行</span></span><br><span class="line">$ sed <span class="string">&#x27;/^$/d&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将匹配到以ts开头的行到以te开头的行之间所有行进行删除</span></span><br><span class="line">$ sed <span class="string">&#x27;/^ts/,/^te/d&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h3 id="数字定址和正则定址混用"><a href="#数字定址和正则定址混用" class="headerlink" title="数字定址和正则定址混用"></a>数字定址和正则定址混用</h3><p>数字定址和正则定址可以配合使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配从第1行到ts开头的行，把匹配的行执行删除</span></span><br><span class="line">$ sed <span class="string">&#x27;1,/^ts/d&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h2 id="sed脚本命令"><a href="#sed脚本命令" class="headerlink" title="sed脚本命令"></a>sed脚本命令</h2><h3 id="sed-s-替换脚本命令"><a href="#sed-s-替换脚本命令" class="headerlink" title="sed s 替换脚本命令"></a>sed s 替换脚本命令</h3><p>此命令的基本格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>
<p>address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。</p>
<p>sed s命令flags标记及功能:</p>
<table>
<thead>
<tr>
<th align="center">flags 标记</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n</td>
<td align="left">1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td>
</tr>
<tr>
<td align="center">g</td>
<td align="left">对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td>
</tr>
<tr>
<td align="center">p</td>
<td align="left">会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td>
</tr>
<tr>
<td align="center">w file</td>
<td align="left">将缓冲区中的内容写到指定的 file 文件中；</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="left">用正则表达式匹配的内容进行替换；</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配第 n 个子串，该子串之前在 pattern 中用 <code>\(\)</code> 指定。</td>
</tr>
<tr>
<td align="center">\</td>
<td align="left">转义（转义替换部分包含：&amp; ，\ 等）。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed 编辑器只替换每行中第 2 次出现的匹配模式</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/2&#x27;</span> data4.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 g 标记，在新文件替换所有匹配的字符串</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/g&#x27;</span> data4.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n 选项会禁止 sed 输出，p 标记会输出修改过的行，</span></span><br><span class="line"><span class="comment"># 二者匹配使用的效果就是只输出被替换命令修改过的行</span></span><br><span class="line">sed -n <span class="string">&#x27;s/test/trial/p&#x27;</span> data5.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># w 标记会将匹配后的结果保存到指定文件中</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/w test.txt&#x27;</span> data5.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换类似文件路径的字符串，需要将路径中的正斜线进行转义</span></span><br><span class="line">sed <span class="string">&#x27;s/\/bin\/bash/\/bin\/csh/&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="sed-d-替换脚本命令"><a href="#sed-d-替换脚本命令" class="headerlink" title="sed d 替换脚本命令"></a>sed d 替换脚本命令</h3><p>基本格式为：<code>[address]d</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有内容</span></span><br><span class="line">sed <span class="string">&#x27;d&#x27;</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过行号指定，比如删除 data6.txt 文件内容中的第 3 行：</span></span><br><span class="line">sed <span class="string">&#x27;3d&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过特定行区间指定，比如删除 data6.txt 文件内容中的第 2、3行</span></span><br><span class="line">sed <span class="string">&#x27;2,3d&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用两个文本模式来删除某个区间内的行</span></span><br><span class="line"><span class="comment"># 指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，</span></span><br><span class="line"><span class="comment"># 因此，sed 会删除两个指定行之间的所有行（包括指定的行）</span></span><br><span class="line"><span class="comment"># 删除第 1~3 行的文本数据</span></span><br><span class="line">sed <span class="string">&#x27;/1/,/3/d&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过特殊的文件结尾字符，比如删除 data6.txt 文件内容中第 3 行开始的所有的内容</span></span><br><span class="line">sed <span class="string">&#x27;3,$d&#x27;</span> data6.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-a-和-i-脚本命令"><a href="#sed-a-和-i-脚本命令" class="headerlink" title="sed a 和 i 脚本命令"></a>sed a 和 i 脚本命令</h3><p>a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行</p>
<p>基本格式：<code>[address]a（或 i）\新文本内容</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个新行插入到数据流第三行前</span></span><br><span class="line">sed <span class="string">&#x27;3i\</span></span><br><span class="line"><span class="string">&gt; This is an inserted line.&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个新行附加到数据流中第三行后</span></span><br><span class="line">sed <span class="string">&#x27;3a\</span></span><br><span class="line"><span class="string">&gt; This is an appended line.&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可</span></span><br><span class="line"> sed <span class="string">&#x27;1i\</span></span><br><span class="line"><span class="string">&gt; This is one line of new text.\</span></span><br><span class="line"><span class="string">&gt; This is another line of new text.&#x27;</span> data6.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-c-替换脚本命令"><a href="#sed-c-替换脚本命令" class="headerlink" title="sed c 替换脚本命令"></a>sed c 替换脚本命令</h3><p>c 命令表示将指定行中的所有内容，替换成该选项后面的字符串。</p>
<p>基本格式为：<code>[address]c\用于替换的新文本</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;3c\</span></span><br><span class="line"><span class="string">&gt; This is a changed line of text.&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sed <span class="string">&#x27;/number 3/c\</span></span><br><span class="line"><span class="string">&gt; This is a changed line of text.&#x27;</span> data6.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-y-转换脚本命令"><a href="#sed-y-转换脚本命令" class="headerlink" title="sed y 转换脚本命令"></a>sed y 转换脚本命令</h3><p>y 转换命令是唯一可以处理单个字符的 sed 脚本命令</p>
<p>基本格式：<code>[address]y/inchars/outchars/</code></p>
<p>转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…这个映射过程会一直持续到处理完指定字符。</p>
<p>如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;y/123/789/&#x27;</span> data8.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换命令是一个全局命令，它会文本行中找到的所有指定字符自动进行转换，</span></span><br><span class="line"><span class="comment"># 而不会考虑它们出现的位置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This 1 is a test of 1 try.&quot;</span> | sed <span class="string">&#x27;y/123/456/&#x27;</span></span><br><span class="line">This 4 is a <span class="built_in">test</span> of 4 try.</span><br></pre></td></tr></table></figure>

<h3 id="sed-p-打印脚本命令"><a href="#sed-p-打印脚本命令" class="headerlink" title="sed p 打印脚本命令"></a>sed p 打印脚本命令</h3><p>p 命令表示搜索符号条件的行，并输出该行的内容</p>
<p>基本格式为：<code>[address]p</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p 命令常见的用法是打印包含匹配文本模式的行</span></span><br><span class="line">sed -n <span class="string">&#x27;/number 3/p&#x27;</span> data6.txt</span><br><span class="line">This is line number 3.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找包含数字 3 的行，然后执行两条命令。</span></span><br><span class="line"><span class="comment"># 首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。</span></span><br><span class="line"><span class="comment"># 输出同时显示了原来的行文本和新的行文本。</span></span><br><span class="line">sed -n <span class="string">&#x27;/3/&#123;</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; s/line/test/p</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data6.txt</span><br><span class="line">This is line number 3.</span><br><span class="line">This is <span class="built_in">test</span> number 3.</span><br></pre></td></tr></table></figure>

<h3 id="sed-w-脚本命令"><a href="#sed-w-脚本命令" class="headerlink" title="sed w 脚本命令"></a>sed w 脚本命令</h3><p>w 命令用来将文本中指定行的内容写入文件中</p>
<p>基本格式如下：<code>[address]w filename</code></p>
<p>filename 表示文件名，可以使用相对路径或绝对路径，运行 sed 命令的用户都必须有文件的写权限。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 data6.txt 1，2行打印到 test.txt</span></span><br><span class="line">sed <span class="string">&#x27;1,2w test.txt&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想让行直接输出，可以用 -n 选项</span></span><br><span class="line">sed -n <span class="string">&#x27;/Browncoat/w Browncoats.txt&#x27;</span> data11.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-r-脚本命令"><a href="#sed-r-脚本命令" class="headerlink" title="sed r 脚本命令"></a>sed r 脚本命令</h3><p>r 命令用于将一个独立文件的数据插入到当前数据流的指定位置，</p>
<p>基本格式为：<code>[address]r filename</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed 命令会将 filename 文件中的内容插入到 address 指定行的后面</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat data12.txt</span></span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;3r data12.txt&#x27; data6.txt</span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定文件中的数据插入到数据流的末尾，可以使用 $ 地址符</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;$r data12.txt&#x27; data6.txt</span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br></pre></td></tr></table></figure>

<h3 id="sed-q-退出脚本命令"><a href="#sed-q-退出脚本命令" class="headerlink" title="sed q 退出脚本命令"></a>sed q 退出脚本命令</h3><p>q 命令的作用是使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sed 命令在打印输出第 2 行之后，就停止</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;2q&#x27; test.txt</span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 q 命令之后，sed 命令会在匹配到 number 1 时，将其替换成 number 0，然后直接退出。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;/number 1/&#123; s/number 1/number 0/;q; &#125;&#x27; test.txt</span></span><br><span class="line">This is line number 0.</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4028.html">Linux sed命令完全攻略</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4056.html">Linux sed命令高级用法精讲</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-wc%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-wc%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux wc命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 10:01:16" itemprop="dateCreated datePublished" datetime="2021-03-29T10:01:16+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux wc 命令用于计算字数。利用 <code>wc</code> 指令可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则 <code>wc</code> 指令会从标准输入设备读取数据。</p>
<p>语法 <code>wc [-clw][--help][--version][文件...]</code></p>
<p>参数：</p>
<ul>
<li>-c或–bytes或–chars 只显示Bytes数。</li>
<li>-l或–lines 显示行数。</li>
<li>-w或–words 只显示字数。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<p>实例</p>
<p>在默认的情况下，wc将计算指定文件的 行数、字数，以及字节数。使用的命令为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testfile文件的统计信息</span></span><br><span class="line">wc testfile</span><br><span class="line">3 92 598 testfile  <span class="comment"># testfile文件的行数为3、单词数92、字节数598 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#统计三个文件的信息</span></span><br><span class="line">wc testfile testfile_1 testfile_2</span><br><span class="line">3 92 598 testfile                    <span class="comment">#第一个文件行数为3、单词数92、字节数598  </span></span><br><span class="line">9 18 78 testfile_1                   <span class="comment">#第二个文件的行数为9、单词数18、字节数78  </span></span><br><span class="line">3 6 32 testfile_2                    <span class="comment">#第三个文件的行数为3、单词数6、字节数32  </span></span><br><span class="line">15 116 708 总用量                    <span class="comment">#三个文件总共的行数为15、单词数116、字节数708 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行数</span></span><br><span class="line">wc -l</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-Head%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-Head%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux Head命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 09:56:55" itemprop="dateCreated datePublished" datetime="2021-03-29T09:56:55+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>head</code> 命令可用于查看文件的开头部分的内容，有一个常用的参数 <code>-n</code> 用于显示行数，默认为 <code>10</code>，即显示 <code>10</code> 行的内容。</p>
<p>命令格式：<code>head [参数] [文件]</code></p>
<p>参数：</p>
<ul>
<li>-q 隐藏文件名</li>
<li>-v 显示文件名</li>
<li>-c&lt;数目&gt; 显示的字节数。</li>
<li>-n&lt;行数&gt; 显示的行数。</li>
</ul>
<p>实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 15 1.log</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/25/Linux-rlogin%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/Linux-rlogin%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux rlogin命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 13:33:02" itemprop="dateCreated datePublished" datetime="2021-03-25T13:33:02+00:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux rlogin命令用于远端登入。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>rlogin [-8EL][-e &lt;脱离字符&gt;][-l &lt;用户名称&gt;][主机名称或IP地址]</p>
<p><strong>必要参数：</strong></p>
<ul>
<li>-E 忽略escape字符</li>
<li>-8 只识别8位字的字符</li>
<li>-L 允许rlogin会话运行在litout模式</li>
<li>-ec 设置escape字符为c</li>
<li>-c 断开连接前要求确认</li>
<li>-a 强制要求远程主机在发送完一个空的本地用户名之后请求一个密码</li>
<li>-f 向远端主机发送一个本地认证</li>
<li>-F 向远程主机发送一个可转寄的本地认证</li>
<li>-7 强制执行7为的传输</li>
<li>-d 打开用于远端主机通信的TCP套接口的调试</li>
<li>-k 要求包含远端主机的tisckets</li>
<li>-x 启动数据传输的DES加密</li>
<li>-4 只使用 kerkberos的版本4的认证</li>
</ul>
<p><strong>选择参数：</strong></p>
<ul>
<li>-e&lt;字符&gt;  设置退出字符</li>
<li>-l&lt;用户&gt;  指定登陆的用户</li>
<li>-t&lt;终端类型&gt; 设置终端类型</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>显示rlogin服务是否开启</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list //检测rlogin服务是否开启</span><br></pre></td></tr></table></figure>

<p>开启rlogin服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rlogin on //开启rlogin服务</span><br></pre></td></tr></table></figure>

<p>登陆远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rlogin 192.168.1.88</span><br><span class="line">Password：</span><br><span class="line">Password：</span><br><span class="line">Login incorrect (不准确)</span><br></pre></td></tr></table></figure>

<p>指定用户名登陆远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rlogin 192.125.30.112 -l root</span><br><span class="line"></span><br><span class="line">Passord:</span><br><span class="line">Last login：Mon May 25 13：40:25 from 192.125.30.112</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-rlogin.html">Linux rlogin命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/25/Linux-ar%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/Linux-ar%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux ar命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 09:37:23" itemprop="dateCreated datePublished" datetime="2021-03-25T09:37:23+00:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux ar命令用于建立或修改备存文件，或是从备存文件中抽取文件。</p>
<p>ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</p>
<p>参数：</p>
<p>必要参数：</p>
<ul>
<li>-d 　删除备存文件中的成员文件。</li>
<li>-m 　变更成员文件在备存文件中的次序。</li>
<li>-p 　显示备存文件中的成员文件内容。</li>
<li>-q 　将文件附加在备存文件末端。</li>
<li>-r 　将文件插入备存文件中。</li>
<li>-t 　显示备存文件中所包含的文件。</li>
<li>-x 　自备存文件中取出成员文件。</li>
</ul>
<p>选项参数：</p>
<ul>
<li>a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。</li>
<li>b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</li>
<li>c 　建立备存文件。</li>
<li>f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。</li>
<li>i&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</li>
<li>o 　保留备存文件中文件的日期。</li>
<li>s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</li>
<li>S 　不产生符号表。</li>
<li>u 　只将日期较新文件插入备存文件中。</li>
<li>v 　程序执行时显示详细的信息。</li>
<li>V 　显示版本信息。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>打包文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls   //显示当前目录文件   </span></span><br><span class="line">a.c    b.c d.c   install.log      qte</span><br><span class="line">anaconda-ks.cfg c.c Desktop </span><br><span class="line"></span><br><span class="line"><span class="comment"># ar rv one.bak a.c b.c //打包 a.c b.c文件 </span></span><br><span class="line">ar: 正在创建 one.bak</span><br><span class="line">a - a.c</span><br><span class="line">a - b.c</span><br></pre></td></tr></table></figure>

<ul>
<li>打包多个文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar rv two.bak *.c  //打包以.c结尾的文件  </span></span><br><span class="line">ar: 正在创建 two.bak</span><br><span class="line">a - a.c</span><br><span class="line">a - b.c</span><br><span class="line">a - c.c</span><br><span class="line">a - d.c</span><br></pre></td></tr></table></figure>

<ul>
<li>显示打包文件的内容</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar t two.bak    </span></span><br><span class="line">a.c</span><br><span class="line">b.c</span><br><span class="line">c.c</span><br><span class="line">d.c</span><br></pre></td></tr></table></figure>

<ul>
<li>删除打包文件的成员文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar d two.bak a.c b.c c.c  </span></span><br><span class="line"><span class="comment"># ar t two.bak       </span></span><br><span class="line">d.c</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-ar.html">Linux ar命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/24/ELF-%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/ELF-%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">ELF格式文件解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 15:13:06" itemprop="dateCreated datePublished" datetime="2021-03-24T15:13:06+00:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ELF/" itemprop="url" rel="index"><span itemprop="name">ELF</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象文件-Object-files-分类"><a href="#对象文件-Object-files-分类" class="headerlink" title="对象文件(Object files)分类"></a>对象文件(Object files)分类</h2><h3 id="一，可重定位的对象文件-Relocatable-file"><a href="#一，可重定位的对象文件-Relocatable-file" class="headerlink" title="一，可重定位的对象文件(Relocatable file)"></a>一，可重定位的对象文件(Relocatable file)</h3><p>&emsp;&emsp;由汇编器汇编生成的 <code>.o</code> 文件。后面的链接器(link editor)拿一个或一些 Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。可以使用 <code>ar</code> 工具将众多的 <code>.o</code> (Relocatable object files) 归档(archive)成 <code>.a</code> 静态库文件。内核可加载模块 <code>.ko</code> 文件也是 Relocatable object file。</p>
<h3 id="二，可执行的对象文件-Executable-file"><a href="#二，可执行的对象文件-Executable-file" class="headerlink" title="二，可执行的对象文件(Executable file)"></a>二，可执行的对象文件(Executable file)</h3><p>&emsp;&emsp;文本编辑器vi、调式用的工具gdb、播放mp3歌曲的软件mplayer等等都是 Executable object file。在 Linux 系统里面，存在两种可执行的东西。除了 Executable object file，另外一种就是可执行的脚本(如shell脚本)。注意这些脚本不是 Executable object file，它们只是文本文件，但是执行这些脚本所用的解释器就是 Executable object file，比如 bash shell 程序。</p>
<h3 id="三，可被共享的对象文件-Shared-object-file"><a href="#三，可被共享的对象文件-Shared-object-file" class="headerlink" title="三，可被共享的对象文件(Shared object file)"></a>三，可被共享的对象文件(Shared object file)</h3><p>&emsp;&emsp;可被共享的对象文件，即 动态库文件，也即 <code>.so</code> 文件。</p>
<p>动态库在发挥作用的过程中，必须经过两个步骤：</p>
<ul>
<li>a) 链接编辑器(link editor)拿它和其他 Relocatable object file 以及其他 shared object file 作为输入，经链接处理后，生存另外的 shared object file 或者 executable file。</li>
<li>b) 在运行时，动态链接器(dynamic linker)拿它和一个 Executable file 以及另外一些 Shared object file 来一起处理，在 Linux 系统里面创建一个进程映像。</li>
</ul>
<h2 id="gcc翻译过程"><a href="#gcc翻译过程" class="headerlink" title="gcc翻译过程"></a>gcc翻译过程</h2><p><img src="/img/20170611205306090.png" alt="20170611205306090.png"></p>
<p>在Unix系统中，从源文件到可执行目标文件是由编译驱动程序完成的，如大名鼎鼎的gcc，翻译过程包括图中的是个阶段；</p>
<p><strong>一，预处理阶段</strong></p>
<p>预处理器（cpp）根据以字符#开头的命令修给原始的C程序，结果得到另一个C程序，通常以.i作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。</p>
<p>对应的命令：<code>linux&gt; gcc -E hello.c hello.i</code></p>
<p><strong>二，编译阶段</strong></p>
<p>编译器将文本文件hello.i翻译成hello.s，包含相应的汇编语言程序</p>
<p>对应的命令：<code>linux&gt; gcc -S hello.c hello.s</code></p>
<p><strong>三，汇编阶段</strong></p>
<p>将.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件.o中(把汇编语言翻译成机器语言的过程)。</p>
<p>把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。</p>
<p>对应的命令：<code>linux&gt; gcc -c hello.c hello.o</code></p>
<p><strong>四，链接阶段</strong></p>
<p>&emsp;&emsp;此时hello程序调用了 printf 函数。 printf 函数存在于一个名为printf.o的单独的预编译目标文件中。 链接器（ld）就负责处理把这个文件并入到 hello.o 程序中，结果得到 hell.o 文件，一个可执行文件。最后可执行文件加载到储存器后由系统负责执行。</p>
<p>函数库一般分为静态库和动态库两种。</p>
<ul>
<li>静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为 <code>.a</code>。</li>
<li>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为 <code>.so</code>，gcc 在编译时默认使用动态库。</li>
</ul>
<h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><p>&emsp;&emsp;ELF 全称 <code>Executable and Linkable Format</code>，可执行可链接文件格式，目前常见的 Linux、 Android 可执行文件、共享库（<code>.so</code>）、目标文件（<code>.o</code>）以及Core 文件（吐核）均为此格式。</p>
<p>&emsp;&emsp;ELF 文件由4部分组成，分别是 ELF 头（ELF header）、程序头表（Program header table）、节（Section）和节区头部表（Section header table）。ELF 头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p>
<p><img src="/img/20160521110158483.png" alt="20160521110158483.png"></p>
<ul>
<li>ELF header： 描述整个文件的组织。</li>
<li>Program Header Table: 描述文件中的各种 segments，用来告诉系统如何创建进程映像的。</li>
<li>sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。</li>
<li>Section Header Table: 包含了文件各个segction的属性信息。</li>
</ul>
<p>&emsp;&emsp;ELF 文件格式提供了两种视图，分别是链接视图和执行视图，链接视图是以节（section）为单位，执行视图是以段（segment）为单位。</p>
<p>&emsp;&emsp;在汇编器和链接器看来，ELF 文件是由 Section Header Table 描述的一系列 Section 的集合，而执行一个 ELF 文件时，在加载器（Loader）看来它是由 Program Header Table 描述的一系列Segment的集合。</p>
<p><img src="/img/elf.png" alt="elf.png"></p>
<p><strong>程序头部表</strong>（Program Header Table），如果存在的话，告诉系统如何创建进程映像。<br><strong>节区头部表</strong>（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。</p>
<p>执行命令 <code>readelf -S android_server</code> 来查看该可执行文件中有哪些section。</p>
<p><img src="/img/20160521110452230.png" alt="20160521110452230.png"></p>
<p>行命令 <code>readelf –segments android_server</code>，可以查看该文件的执行视图。</p>
<p><img src="/img/20160521110508766.png" alt="20160521110508766.png"></p>
<p><strong>segment是section的一个集合，sections按照一定规则映射到segment。为什么需要区分两种不同视图？</strong></p>
<p>&emsp;&emsp;当ELF文件被加载到内存中后，系统会将多个具有相同权限（flg值）section合并一个segment。操作系统往往以页为基本单位来管理内存分配，一般页的大小为4096B，即4KB的大小。同时，内存的权限管理的粒度也是以页为单位，页内的内存是具有同样的权限等属性，并且操作系统对内存的管理往往追求高效和高利用率这样的目标。ELF文件在被映射时，是以系统的页长度为单位的，那么每个section在映射时的长度都是系统页长度的整数倍，如果section的长度不是其整数倍，则导致多余部分也将占用一个页。而我们从上面的例子中知道，一个ELF文件具有很多的section，那么会导致内存浪费严重。这样可以减少页面内部的碎片，节省了空间，显著提高内存利用率。</p>
<h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>转载自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feglass/article/details/51469511?spm=1001.2014.3001.5501">ELF文件格式解析</a></p>
<p>32位ELF文件中常用的数据格式：</p>
<p><img src="/img/20160521110646983.png" alt="20160521110646983.png"></p>
<p><code>readelf -h android_server</code> 命令，可以看到 ELF Header 结构的内容:</p>
<p><img src="/img/20160521110756954.png" alt="20160521110756954.png"></p>
<p>对比以下三类ELF文件，我们得到了以下结论：<br>（1）e_type标识了文件类型<br>（2）Relocatable File（.o文件）不需要执行，因此e_entry字段为0，且没有Program Header Table等执行视图<br>（3）不同类型的ELF文件的Section也有较大区别，比如只有Relocatable File有.strtab节。 </p>
<p>(1) Shared Object File（.so文件）:<br><img src="/img/20160521110949018.png" alt="20160521110949018.png"></p>
<p>(2) Executable File（可执行文件android_server）:</p>
<p><img src="/img/20160521111008408.png" alt="20160521111008408.png"></p>
<p>(3) Relocatable File（.o文件）:</p>
<p><img src="/img/20160521111020956.png" alt="20160521111020956.png"></p>
<p>在 ELF Header 中需要重点关注以下几个字段：</p>
<ul>
<li>1，e_entry：程序入口地址<br>这个 sum.o 的进入点是 0x0(e_entry)，这表面Relocatable objects不会有程序进入点。所谓程序进入点是指当程序真正执行起来的时候，其第一条要运行的指令的运行时地址。因为Relocatable objects file只是供再链接而已，所以它不存在进入点。而可执行文件test和动态库.so都存在所谓的进入点，且可执行文件的 e_entry 指向C库中的_start，而动态库.so中的进入点指向 call_gmon_start。<br>如上图中 e_entry = 0xD8B0 (Executable File 文件)，我们用ida打开该文件看到确实是 _start() 函数的地址。</li>
</ul>
<p><img src="/img/20160521111227521.png" alt="20160521111227521.png"></p>
<ul>
<li>2，e_ehsize：ELF Header结构大小</li>
<li>3，e_phoff、e_phentsize、e_phnum：描述Program Header Table的偏移、大小、结构。</li>
<li>4，e_shoff、e_shentsize、e_shnum：描述Section Header Table的偏移、大小、结构。</li>
<li>5，e_shstrndx：这一项描述的是字符串表在 Section Header Table 中的索引，值25表示的是 Section Header Table 中第25项是字符串表（String Table）。</li>
</ul>
<h3 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h3><p>&emsp;&emsp;一个ELF文件中到底有哪些具体的 sections，由包含在这个ELF文件中的 section head table(SHT) 决定。在SHT中，针对每一个section，都设置有一个条目（entry），用来描述对应的这个section，其内容主要包括该 section 的名称、类型、大小以及在整个ELF文件中的字节偏移位置等等。我们也可以在TISCv1.2规范中找到SHT表中条目的C结构定义：</p>
<p><img src="/img/20160521111301410.png" alt="20160521111301410.png"></p>
<p>解析 android_server 可执行ELF文件，我们可以看到 Section Header Table 中确实有23（17h (16进制表示)）个条目，且索引为22（16h(16进制表示)）确实为 section header section string table。</p>
<p><img src="/img/20160521111322394.png" alt="20160521111322394.png"></p>
<p>打开条目，我们可以看到每个 entry 的具体字段，与上图的 Elf32_Shdr 结构一致。</p>
<p><img src="/img/20160521111341347.png" alt="20160521111341347.png"></p>
<p>&emsp;&emsp;需要注意的是，sh_name 值实际上是 .shstrtab 中的索引，该string table中存储着所有section的名字。下图中蓝色部分是.shstrtab的数据，我们可以看到，sh_name实际上是从索引1开始的”.shstrtab”字符串，因此这里的sh_name值为1h。</p>
<p><img src="/img/20160521111400597.png" alt="20160521111400597.png"></p>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>下面我们分析一些so文件中重要的Section，包括符号表、重定位表、GOT表等。</p>
<p><strong>-符号表(.dynsym)</strong></p>
<p>&emsp;&emsp;符号表包含用来定位、重定位程序中符号定义和引用的信息，简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过修饰了的函数名或者变量名，不同的编译器有不同的修饰规则。例如符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。</p>
<p>符号表项的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">     Elf32_Word st_name;        <span class="comment">//符号表项名称。如果该值非0，则表示符号名的字</span></span><br><span class="line">                                   <span class="comment">//符串表索引(offset)，否则符号表项没有名称。</span></span><br><span class="line">     Elf32_Addr st_value;       <span class="comment">//符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span></span><br><span class="line">     Elf32_Word st_size;        <span class="comment">//符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;     <span class="comment">//符号的类型和绑定属性。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;    <span class="comment">//未定义。</span></span><br><span class="line">     Elf32_Half st_shndx;        <span class="comment">//每个符号表项都以和其他节区的关系的方式给出定义。</span></span><br><span class="line">　　　　　　　　　　　　　         <span class="comment">//此成员给出相关的节区头部表索引。</span></span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>通过 010Editor 解析出的符号表 .dynsym 的 section header 表项：</p>
<p><img src="/img/20160521111537942.png" alt="20160521111537942.png"></p>
<p>符号表的具体内容：</p>
<p><img src="/img/20160521111608073.png" alt="20160521111608073.png"></p>
<p><strong>-字符串表（.dynstr）</strong></p>
<p>字符串表中存放着所有符号的名称字符串。</p>
<p>字符串表的section header表项：</p>
<p><img src="/img/20160521111628840.png" alt="20160521111628840.png"></p>
<p>再看一下下图中字符串表的具体内容，我们可以看出，.dynstr和.shstrtab 结构完全相同，不过一个存储的是符号名称的字符串，而另一个是Section 名称的字符串。</p>
<p><img src="/img/20160521111652559.png" alt="20160521111652559.png"></p>
<p><strong>-重定位表</strong></p>
<p>&emsp;&emsp;重定位表在ELF文件中扮演很重要的角色，首先我们得理解重定位的概念，程序从代码到可执行文件这个过程中，要经历编译器，汇编器和链接器对代码的处理。然而编译器和汇编器通常为每个文件创建程序地址从0开始的目标代码，但是几乎没有计算机会允许从地址0加载你的程序。如果一个程序是由多个子程序组成的，那么所有的子程序必需要加载到互不重叠的地址上。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。简单的言之，则是将程序中的各个部分映射到合理的地址上来。</p>
<p>&emsp;&emsp;换句话来说，重定位是将符号引用与符号定义进行连接的过程。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。<br>具体来说，就是把符号的value进行重新定位。</p>
<p>可重定位文件必须包含如何修改其节区内容的信息，从而允许可执行文件和共享目标文件保存进程的程序映象的正确信息。这就是重定位表项做的工作。重定位表项的格式如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    Elf32_Addr r_offset;     <span class="comment">//重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span></span><br><span class="line">    Elf32_Word r_info;       <span class="comment">//要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span></span><br><span class="line">                                         <span class="comment">//其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span></span><br><span class="line">&#125; Elf32_Rel; </span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Addr r_offset;  </span><br><span class="line">    Elf32_Word r_info;  </span><br><span class="line">    Elf32_Word r_addend;</span><br><span class="line"> &#125; Elf32_Rela; </span><br></pre></td></tr></table></figure>

<p>对 r_info 成员使用 ELF32_R_TYPE 宏运算可得到重定位类型，使用 ELF32_R_SYM 宏运算可得到符号在符号表里的索引值。 三种宏的具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(i) ((i)&gt;&gt;8) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(i) ((unsigned char)(i)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(s, t) (((s)</span></span><br></pre></td></tr></table></figure>

<p>重定位表中的内容:</p>
<p><img src="/img/20160521111838248.png" alt="20160521111838248.png"></p>
<p>以下是.rel.plt表的具体内容：</p>
<p><img src="/img/20160521111856928.png" alt="20160521111856928.png"></p>
<p>我们可以看到，每8个字节(s_entsize)一个表项。第一个表项中的r_offset值为0xc7660，r_info为0xa16。其中r_offset指向下图中GOT表中第一项__imp_clock_gettime外部函数地址。那么我们如何利用r_offset值来找到其对应的符号呢？如上所述，进行 ELF32_R_SYM宏运算实际上就是将r_info右移8位，0xa16右移8位得到0xa，因此这就是其在符号表中的索引。 </p>
<p><img src="/img/20160521111921663.png" alt="20160521111921663.png"></p>
<p>从下图中可以看见符号表的s_entsize值为10h，即16个字节每条目。因此我们可以找到其索引为0xa的条目的st_name值为0x9ea。那么怎么证明我们确实找到的是clock_gettime函数的符号呢？我们再来看一下st_name值是不是正确的。</p>
<p><img src="/img/20160521111941390.png" alt="20160521111941390.png"></p>
<p>st_name值表示的是符号名字符串中的第一个字符在字符串表中的偏移量，因此我们用0x9ea加上符号表的起始位置(0x7548)就能得到该字符串在‭0x7F32位置。如下图所示:</p>
<p><img src="/img/20160521112219618.png" alt="20160521112219618.png"></p>
<p><strong>-常见的重定位表类型：</strong></p>
<ul>
<li><p>.rel.text：重定位的地方在.text段内，以offset指定具体要定位位置。在链接时候由链接器完成。.rel.text属于普通重定位辅助段 ,他由编译器编译产生，存在于obj文件内。连接器连接时，他用于最终可执行文件或者动态库的重定位。通过它修改原obj文件的.text段后，合并到最终可执行文件或者动态文件的.text段。其类型一般为R_386_32和R_386_PC32。</p>
</li>
<li><p>.rel.dyn：重定位的地方在.got段内。主要是针对外部数据变量符号。例如全局数据。重定位在程序运行时定位，一般是在.init段内。定位过程：获得符号对应value后，根据rel.dyn表中对应的offset，修改.got表对应位置的value。另外，.rel.dyn 含义是指和dyn有关，一般是指在程序运行时候，动态加载。区别于rel.plt，rel.plt是指和plt相关，具体是指在某个函数被调用时候加载。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。</p>
</li>
<li><p>.rel.dyn和.rel.plt是动态定位辅助段。由连接器产生，存在于可执行文件或者动态库文件内。借助这两个辅助段可以动态修改对应.got和.got.plt段，从而实现运行时重定位。</p>
</li>
<li><p>.rel.plt：重定位的地方在.got.plt段内（注意也是.got内,具体区分而已）。 主要是针对外部函数符号。一般是函数首次被调用时候重定位。首次调用时会重定位函数地址，把最终函数地址放到.got内，以后读取该.got就直接得到最终函数地址。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。</p>
</li>
<li><p>.plt段（过程链接表）：所有外部函数调用都是经过一个对应桩函数，这些桩函数都在.plt段内。具体调用外部函数过程是：<br>调用对应桩函数—&gt;桩函数取出.got表表内地址—&gt;然后跳转到这个地址.如果是第一次,这个跳转地址默认是桩函数本身跳转处地址的下一个指令地址(目的是通过桩函数统一集中取地址和加载地址),后续接着把对应函数的真实地址加载进来放到.got表对应处,同时跳转执行该地址指令.以后桩函数从.got取得地址都是真实函数地址了。<br>下图是.plt某表项，它包含了取.got表地址和跳转执行两条指令。</p>
</li>
</ul>
<p><img src="/img/20160521112646041.png" alt="20160521112646041.png"></p>
<ul>
<li>.got（全局偏移表）</li>
</ul>
<h3 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h3><p>&emsp;&emsp;程序头部（Program Header）描述与程序执行直接相关的目标文件结构信息。用来在文件中定位各个段的映像。同时包含其他一些用来为程序创建映像所必须的信息。<br>可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段或者系统准备程序执行所必须的其他信息。目标文件的 “段” 包含一个或者多个 “节区”，也就是 “段内容（Segment Contents）”。程序头部仅对可执行文件和共享目标文件有意义。</p>
<p>程序头部的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    Elf32_Word p_type;           <span class="comment">//此数组元素描述的段的类型，或者如何解释此数组元素的信息。 </span></span><br><span class="line">    Elf32_Off  p_offset;           <span class="comment">//此成员给出从文件头到该段第一个字节的偏移</span></span><br><span class="line">    Elf32_Addr p_vaddr;         <span class="comment">//此成员给出段的第一个字节将被放到内存中的虚拟地址</span></span><br><span class="line">    Elf32_Addr p_paddr;        <span class="comment">//此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。</span></span><br><span class="line">    Elf32_Word p_filesz;         <span class="comment">//此成员给出段在文件映像中所占的字节数。可以为0。</span></span><br><span class="line">    Elf32_Word p_memsz;     <span class="comment">//此成员给出段在内存映像中占用的字节数。可以为0。</span></span><br><span class="line">    Elf32_Word p_flags;         <span class="comment">//此成员给出与段相关的标志。</span></span><br><span class="line">    Elf32_Word p_align;        <span class="comment">//此成员给出段在文件中和内存中如何对齐。</span></span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>

<p>我们看到，以下两个工具确实是照此格式解析的:</p>
<p><img src="/img/20160521112705213.png" alt="20160521112705213.png"></p>
<p><img src="/img/20160521112720713.png" alt="20160521112720713.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mergerly/article/details/94585901">ELF文件格式解析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/daide2012/article/details/73065204">ELF文件详解—初步认识</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.virbox.com/?p=119">ELF 格式详解（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/feglass/article/details/51469511?spm=1001.2014.3001.5501">ELF文件格式解析</a></p>
<p><a target="_blank" rel="noopener" href="http://www.choudan.net/2013/10/25/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0%28%E4%BA%8C%29.html">Linux进程地址空间学习(二)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/24/Linux-readelf%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/Linux-readelf%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux readelf命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 15:01:06" itemprop="dateCreated datePublished" datetime="2021-03-24T15:01:06+00:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>&emsp;&emsp;readelf 命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的elf-file(s)就表示那些被检查的文件。可以支持32位，64位的elf格式文件，也支持包含elf文件的文档（这里一般指的是使用ar命令将一些elf文件打包之后生成的例如lib*.a之类的 “静态库” 文件）。</p>
<p>&emsp;&emsp;常见的文件如在Linux上的可执行文件，动态库(<em>.so)或者静态库(</em>.a) 等包含ELF格式的文件。以下命令的使用是基于android编译出来的so文件上面去运行。</p>
<p>运行 readelf 的时候，除了-v 和 -H 之外，其它的选项必须有一个被指定。 </p>
<p>选项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">-a </span><br><span class="line">--all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I. </span><br><span class="line"></span><br><span class="line">-h </span><br><span class="line">--file-header 显示elf文件开始的文件头信息. </span><br><span class="line"></span><br><span class="line">-l </span><br><span class="line">--program-headers  </span><br><span class="line">--segments 显示程序头（段头）信息(如果有的话)。 </span><br><span class="line"></span><br><span class="line">-S </span><br><span class="line">--section-headers  </span><br><span class="line">--sections 显示节头信息(如果有的话)。 </span><br><span class="line"></span><br><span class="line">-g </span><br><span class="line">--section-groups 显示节组信息(如果有的话)。 </span><br><span class="line"></span><br><span class="line">-t </span><br><span class="line">--section-details 显示节的详细信息(-S的)。 </span><br><span class="line"></span><br><span class="line">-s </span><br><span class="line">--syms        </span><br><span class="line">--symbols 显示符号表段中的项（如果有的话）。 </span><br><span class="line"></span><br><span class="line">-e </span><br><span class="line">--headers 显示全部头信息，等价于: -h -l -S </span><br><span class="line"></span><br><span class="line">-n </span><br><span class="line">--notes 显示note段（内核注释）的信息。 </span><br><span class="line"></span><br><span class="line">-r </span><br><span class="line">--relocs 显示可重定位段的信息。 </span><br><span class="line"></span><br><span class="line">-u </span><br><span class="line">--unwind 显示unwind段信息。当前只支持IA64 ELF的unwind段信息。 </span><br><span class="line"></span><br><span class="line">-d </span><br><span class="line">--dynamic 显示动态段的信息。 </span><br><span class="line"></span><br><span class="line">-V </span><br><span class="line">--version-info 显示版本段的信息。 </span><br><span class="line"></span><br><span class="line">-A </span><br><span class="line">--arch-specific 显示CPU构架信息。 </span><br><span class="line"></span><br><span class="line">-D </span><br><span class="line">--use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 </span><br><span class="line"></span><br><span class="line">-x &lt;number or name&gt; </span><br><span class="line">--hex-dump=&lt;number or name&gt; 以16进制方式显示指定段内内容。number指定段表中段的索引,或字符串指定文件中的段名。 </span><br><span class="line"></span><br><span class="line">-w[liaprmfFsoR] or </span><br><span class="line">--debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges] 显示调试段中指定的内容。 </span><br><span class="line"></span><br><span class="line">-I </span><br><span class="line">--histogram 显示符号的时候，显示bucket list长度的柱状图。 </span><br><span class="line"></span><br><span class="line">-v </span><br><span class="line">--version 显示readelf的版本信息。 </span><br><span class="line"></span><br><span class="line">-H </span><br><span class="line">--<span class="built_in">help</span> 显示readelf所支持的命令行选项。 </span><br><span class="line"></span><br><span class="line">-W </span><br><span class="line">--wide 宽行输出。 </span><br><span class="line"></span><br><span class="line">@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。 </span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>读取可执行文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h main </span><br></pre></td></tr></table></figure>

<ul>
<li>读取目标文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h myfile.o </span><br></pre></td></tr></table></figure>

<ul>
<li>读取静态库文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h libmy.a </span><br></pre></td></tr></table></figure>

<ul>
<li>读取动态库文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h libmy.so </span><br></pre></td></tr></table></figure>

<ul>
<li>查看可执行的elf文件程序头表信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l main </span><br></pre></td></tr></table></figure>

<ul>
<li>查看目标文件的elf文件程序头表信息： </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l myfile.o </span><br></pre></td></tr></table></figure>

<ul>
<li>查看静态库文件的elf文件程序头表信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l libmy.a </span><br></pre></td></tr></table></figure>

<ul>
<li>查看动态库文件的elf文件程序头表信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l libmy.so </span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个可执行的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S main</span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个包含调试信息的可执行的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S main.debug </span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个目标文件的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S myfile.o</span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个静态库文件的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S libmy.a </span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个动态库文件的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S libmy.so </span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://man.linuxde.net/readelf">readelf命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/22/IDEA%E5%88%9B%E5%BB%BAMapper%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/IDEA%E5%88%9B%E5%BB%BAMapper%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">IDEA创建Mapper文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 14:47:29" itemprop="dateCreated datePublished" datetime="2021-03-22T14:47:29+00:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在设置中添加：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322145045.png" alt="微信截图_20210322145045.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322144935.png" alt="微信截图_20210322144935.png"></p>
<p>模版内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322145748.png" alt="微信截图_20210322145748.png"></p>
<p>检验：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322145835.png" alt="微信截图_20210322145835.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/19/Spring-Boot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/19/Spring-Boot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">Spring Boot常用注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 15:23:57" itemprop="dateCreated datePublished" datetime="2021-03-19T15:23:57+00:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用注解的优势：<br>1.采用纯java代码，不在需要配置繁杂的xml文件<br>2.在配置中也可享受面向对象带来的好处<br>3.类型安全对重构可以提供良好的支持<br>4.减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</p>
<h2 id="启动注解-SpringBootApplication"><a href="#启动注解-SpringBootApplication" class="headerlink" title="启动注解@SpringBootApplication"></a>启动注解@SpringBootApplication</h2><p>&emsp;&emsp;<code>@SpringBootApplication</code> 是一个复合注解，包含了 <code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code> 这三个注解。</p>
<h3 id="SpringBootConfiguration注解，继承-Configuration注解，主要用于加载配置文件"><a href="#SpringBootConfiguration注解，继承-Configuration注解，主要用于加载配置文件" class="headerlink" title="@SpringBootConfiguration注解，继承@Configuration注解，主要用于加载配置文件"></a>@SpringBootConfiguration注解，继承@Configuration注解，主要用于加载配置文件</h3><p>&emsp;&emsp;<code>@SpringBootConfiguration</code> 和 <code>@Configuration</code> 二者功能一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以 <code>@Bean</code> 注解标记的方法的实例纳入到 <code>Spring</code> 容器中，并且实例名就是方法名。</p>
<p><code>@Configuration</code>：等同于 <code>Spring</code> 的XML配置文件；使用Java代码可以检查类型安全。</p>
<h3 id="EnableAutoConfiguration注解，开启自动配置功能"><a href="#EnableAutoConfiguration注解，开启自动配置功能" class="headerlink" title="@EnableAutoConfiguration注解，开启自动配置功能"></a>@EnableAutoConfiguration注解，开启自动配置功能</h3><p>&emsp;&emsp;<code>@EnableAutoConfiguration</code>可以帮助 <code>SpringBoot</code> 应用将所有符合条件的 <code>@Configuration</code> 配置都加载到当前 <code>SpringBoot</code> 创建并使用的IoC容器。借助于 <code>Spring</code> 框架原有的一个工具类：<code>SpringFactoriesLoader</code> 的支持，<code>@EnableAutoConfiguration</code> 可以智能的自动配置功效才得以大功告成</p>
<h3 id="ComponentScan注解，主要用于组件扫描和自动装配"><a href="#ComponentScan注解，主要用于组件扫描和自动装配" class="headerlink" title="@ComponentScan注解，主要用于组件扫描和自动装配"></a>@ComponentScan注解，主要用于组件扫描和自动装配</h3><p>&emsp;&emsp;<code>@ComponentScan</code> 的功能其实就是自动扫描并加载符合条件的组件或bean定义，最终将这些bean定义加载到容器中。我们可以通过 <code>basePackages</code> 等属性指定 <code>@ComponentScan</code> 自动扫描的范围，如果不指定，则默认 <code>Spring</code> 框架实现从声明 <code>@ComponentScan</code> 所在类的 <code>package</code> 进行扫描，默认情况下是不指定的，所以 <code>SpringBoot</code> 的启动类最好放在 <code>root package</code>下。</p>
<h2 id="Controller-相关注解"><a href="#Controller-相关注解" class="headerlink" title="Controller 相关注解"></a>Controller 相关注解</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解 <code>@RequestMapping</code>。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p><code>@ResponseBody</code>：表示该方法的返回结果直接写入 <code>HTTP response body</code> 中，一般在异步获取数据时使用，用于构建 <code>RESTful</code> 的 <code>api</code>。在使用 <code>@RequestMapping</code> 后，返回值通常解析为跳转路径，加上 <code>@Responsebody</code> 后返回结果不会被解析为跳转路径，而是直接写入 <code>HTTP response body</code> 中。比如异步获取json数据，加上 <code>@Responsebody</code> 后，会直接返回json数据。该注解一般会配合<code>@RequestMapping</code>一起使用。</p>
<h3 id="RestController-复合注解"><a href="#RestController-复合注解" class="headerlink" title="@RestController 复合注解"></a>@RestController 复合注解</h3><p>用于标注控制层组件(如struts中的action)，<code>@ResponseBody</code> 和 <code>@Controller</code> 的合集，<code>@RestController</code> 效果是将方法返回的对象直接在浏览器上展示成json格式。</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>通过 <code>HttpMessageConverter</code> 读取 <code>Request Body</code> 并反序列化为 Object 对象。</p>
<p>使用 <code>@RequestBody</code> 接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p><code>@RequestMapping</code> 提供路由信息，负责URL到Controller中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<code>@RequestMapping</code> 用在类上可以没有，但是用在方法上必须有。</p>
<h3 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h3><p>将 <code>HTTP Get</code> 请求映射到特定处理程序的方法注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/go&quot;,method = RequestMethod.GET)</span> 等价于：<span class="meta">@GetMapping(value = &quot;/go&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h3><p>将 <code>HTTP Post</code> 请求映射到特定处理程序的方法注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/go&quot;,method = RequestMethod.POST)</span> 等价于：<span class="meta">@PostMapping(value = &quot;/go&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="请求参数值"><a href="#请求参数值" class="headerlink" title="请求参数值"></a>请求参数值</h2><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p><code>@PathVariable</code>：接收请求路径中占位符的值。</p>
<p>注意：<code>@RequestMapping</code> 与 <code>@PathVariable</code> 中的值必须保持一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 占位符映射</span></span><br><span class="line"><span class="comment"> * 语法：<span class="doctag">@RequestMapping</span>(value=”user/&#123;userId&#125;/&#123;userName&#125;”)</span></span><br><span class="line"><span class="comment"> * 请求路径：http://localhost:8080/springboot/show/1/wang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;show/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long ids ,<span class="meta">@PathVariable(&quot;name&quot;)</span> String names)</span></span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;占位符映射：id:&quot;</span>+ids+<span class="string">&quot;;name:&quot;</span>+names);</span><br><span class="line">    mv.setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p><code>@RequestParam</code>：获取请求参数的值</p>
<p>常用来处理简单类型的绑定，通过 <code>Request.getParameter()</code> 获取的 <code>String</code> 可直接转换为简单类型的情况（String–&gt; 简单类型的转换操作由 <code>ConversionService</code> 配置的转换器来完成）；因为使用 <code>request.getParameter()</code> 方式获取参数，所以可以处理 <code>get</code> 方式中<code>queryString</code>的值，也可以处理 <code>post</code>方式中 <code>body data</code> 的值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求示例：/getUser?uid=123</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(<span class="meta">@RequestParam(&quot;uid&quot;)</span>Integer id, Model model)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>把 <code>Request</code> 请求 <code>header</code> 部分的值绑定到方法的参数上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test1&quot;)</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="keyword">long</span> keepAlive)</span>  </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>把 <code>Request header</code> 中关于 <code>cookie</code> 的值绑定到方法的参数上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test1&quot;)</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="meta">@CookieValue(&quot;UserInfo&quot;)</span> String cookie)</span>  </span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注入bean"><a href="#注入bean" class="headerlink" title="注入bean"></a>注入bean</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p><code>@Repository</code>：使用 <code>@Repository</code> 注解可以确保 <code>DAO</code> 或者 <code>repositories</code> 提供异常转译，这个注解修饰的 <code>DAO</code> 或者<code>repositories</code>类会被 <code>ComponetScan</code> 发现并配置，同时也不需要为它们提供XML配置项。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><ul>
<li><code>@Service</code> 是 <code>@Component</code> 注解的一个特例，作用在类上</li>
<li><code>@Service</code> 注解作用域默认为单例</li>
<li>使用注解配置和类路径扫描时，被 <code>@Service</code> 注解标注的类会被 <code>Spring</code> 扫描并注册为 <code>Bean</code></li>
<li><code>@Service</code> 用于标注服务层组件,表示定义一个 <code>bean</code></li>
<li><code>@Service</code> 使用时没有传参数，<code>Bean</code> 名称默认为当前类的类名，首字母小写</li>
<li><code>@Service(&quot;serviceBeanId&quot;)</code> 或 <code>@Service(value=&quot;serviceBeanId&quot;)</code> 使用时传参数，使用 <code>value</code> 作为 <code>Bean</code> 名字</li>
</ul>
<h3 id="Scope作用域"><a href="#Scope作用域" class="headerlink" title="@Scope作用域"></a>@Scope作用域</h3><p><code>@Scope</code> 作用在类上和方法上，用来配置 <code>spring bean</code> 的作用域，它标识 <code>bean</code> 的作用域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  Scope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for &#123;<span class="doctag">@link</span> #scopeName&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #scopeName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">scopeName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性介绍</p>
<p><strong>value</strong></p>
<ul>
<li>singleton   表示该bean是单例的。(默认)</li>
<li>prototype   表示该bean是多例的，即每次使用该bean时都会新建一个对象。</li>
<li>request     在一次http请求中，一个bean对应一个实例。</li>
<li>session     在一个httpSession中，一个bean对应一个实例。</li>
</ul>
<p><strong>proxyMode</strong></p>
<ul>
<li>DEFAULT         不使用代理。(默认)</li>
<li>NO              不使用代理，等价于DEFAULT。</li>
<li>INTERFACES      使用基于接口的代理(jdk dynamic proxy)。</li>
<li>TARGET_CLASS    使用基于类的代理(cglib)。</li>
</ul>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p><code>@Table(name=&quot;&quot;)</code>：表明这是一个实体类，必须与 <code>@Id</code> 注解 结合使用,否则  <code>No identifier specified for entity:</code>。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，<code>@Table</code>可以省略。<br><code>@Table(name =&quot;数据库表名&quot;)</code>，这个注解也注释在实体类上，对应数据库中相应的表。<br><code>@Id</code>、<code>@Column</code> 注解用于标注实体类中的字段，pk字段标注为 <code>@Id</code>，其余 <code>@Column</code>。</p>
<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>导入依赖：<code>lombok.Data</code> ,</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.16.10&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>@Data</code>: 注解在类上, 为类提供读写属性, 此外还提供了 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 方法。</p>
<h3 id="Bean产生一个bean的方法"><a href="#Bean产生一个bean的方法" class="headerlink" title="@Bean产生一个bean的方法"></a>@Bean产生一个bean的方法</h3><p><code>@Bean</code> 明确告诉方法，产生一个 <code>Bean</code> 对象，并且交给 <code>Spring</code> 容器管理。支持别名 <code>@Bean(&quot;xx-name&quot;)</code>，产生这个 <code>Bean</code> 对象的方法 <code>Spring</code> 只会调用一次，随后这个 <code>Spring</code> 将会将这个 <code>Bean</code> 对象放在自己的IOC容器中。</p>
<h3 id="Autowired-自动导入"><a href="#Autowired-自动导入" class="headerlink" title="@Autowired 自动导入"></a>@Autowired 自动导入</h3><ul>
<li><code>@Autowired</code> 注解作用在构造函数、方法、方法参数、类字段以及注解上</li>
<li><code>@Autowired</code> 注解可以实现Bean的自动注入</li>
</ul>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<p>把普通 <code>pojo</code> 实例化到 <code>spring</code> 容器中。</p>
<h2 id="导入配置文件"><a href="#导入配置文件" class="headerlink" title="导入配置文件"></a>导入配置文件</h2><h3 id="PropertySource导入属性"><a href="#PropertySource导入属性" class="headerlink" title="@PropertySource导入属性"></a>@PropertySource导入属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入单个properties文件：</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath : xxxx/xxx.properties&quot;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入多个properties文件：</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath : xxxx/xxx.properties&quot;，&quot;classpath : xxxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="ImportResource导入xml配置文件"><a href="#ImportResource导入xml配置文件" class="headerlink" title="@ImportResource导入xml配置文件"></a>@ImportResource导入xml配置文件</h3><p>可以额外分为两种模式 <code>相对路径classpath</code>，<code>绝对路径file</code><br>注意：单文件可以不写 <code>value</code> 或 <code>locations</code> ，<code>value</code>和 <code>locations</code>都可用</p>
<p><strong>相对路径（classpath）</strong></p>
<ul>
<li>引入单个xml配置文件：<code>@ImportSource(&quot;classpath : xxx/xxxx.xml&quot;)</code></li>
<li>引入多个xml配置文件：<code>@ImportSource(locations=&#123;&quot;classpath : xxxx.xml&quot; , &quot;classpath : yyyy.xml&quot;&#125;)</code></li>
</ul>
<p><strong>绝对路径（file）</strong></p>
<ul>
<li>引入单个xml配置文件：<code>@ImportSource(locations= &#123;&quot;file : d:/hellxz/dubbo.xml&quot;&#125;)</code></li>
<li>引入多个xml配置文件：<code>@ImportSource(locations= &#123;&quot;file : d:/hellxz/application.xml&quot; , &quot;file : d:/hellxz/dubbo.xml&quot;&#125;)</code></li>
</ul>
<p>取值：使用 <code>@Value</code> 注解取配置文件中的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;properties中的键&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String xxx;`</span><br></pre></td></tr></table></figure>

<h3 id="Import-导入额外的配置信息"><a href="#Import-导入额外的配置信息" class="headerlink" title="@Import 导入额外的配置信息"></a>@Import 导入额外的配置信息</h3><p>功能类似XML配置的，用来导入配置类，可以导入带有 <code>@Configuration</code> 注解的配置类或实现了 <code>ImportSelector/ImportBeanDefinitionRegistrar</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import(&#123;SysConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务注解-Transactional"><a href="#事务注解-Transactional" class="headerlink" title="事务注解 @Transactional"></a>事务注解 @Transactional</h2><p>在Spring中，事务有两种实现方式，分别是编程式事务管理和声明式事务管理两种方式</p>
<ul>
<li><p>编程式事务管理： 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</p>
</li>
<li><p>声明式事务管理： 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务，通过@Transactional就可以进行事务操作，更快捷而且简单。推荐使用</p>
</li>
</ul>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><h3 id="ControllerAdvice-统一处理异常"><a href="#ControllerAdvice-统一处理异常" class="headerlink" title="@ControllerAdvice 统一处理异常"></a>@ControllerAdvice 统一处理异常</h3><p><code>@ControllerAdvice</code> 注解定义全局异常处理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ExceptionHandler-注解声明异常处理方法"><a href="#ExceptionHandler-注解声明异常处理方法" class="headerlink" title="@ExceptionHandler 注解声明异常处理方法"></a>@ExceptionHandler 注解声明异常处理方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">handleException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Exception Deal!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20957669/article/details/87686899">spring boot注解@RequestMapping、@RequestBody的详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40753536/article/details/81285046">SpringBoot注解最全详解(整合超详细版本)</a></p>
<p><a target="_blank" rel="noopener" href="https://tqlin.cn/2019/11/22/issueGather/Spring%20Boot%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">Spring Boot 常用注解汇总</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/18/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-Win10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-Win10/" class="post-title-link" itemprop="url">Maven安装配置-Win10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 09:31:05" itemprop="dateCreated datePublished" datetime="2021-03-18T09:31:05+00:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Maven/" itemprop="url" rel="index"><span itemprop="name">Maven</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载：<a target="_blank" rel="noopener" href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318093326.png" alt="微信截图_20210318093326.png"></p>
<h2 id="安装和配置环境变量"><a href="#安装和配置环境变量" class="headerlink" title="安装和配置环境变量"></a>安装和配置环境变量</h2><p>下载完成，解压 <code>E:\java\apache-maven-3.6.3</code> (需要选择路径)。</p>
<p>添加 <code>系统变量</code>：<code>MAVEN_HOME=E:\java\apache-maven-3.6.3</code>，<br>修改系统变量 <code>Path</code>：<code>Path = %MAVEN_HOME%\bin</code></p>
<p>如图：</p>
<p>MAVEN_HOME:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318094904.png" alt="微信截图_20210318094904.png"></p>
<p>Path:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318093938.png" alt="微信截图_20210318093938.png"></p>
<p>cmd 输入 <code>mvn -version</code>，输出:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318094339.png" alt="微信截图_20210318094339.png"></p>
<h2 id="配置settings文件"><a href="#配置settings文件" class="headerlink" title="配置settings文件"></a>配置settings文件</h2><p>找到 <code>E:\java\apache-maven-3.6.3\conf\settings.xml</code> 文件，定位到第52行，这里是maven默认的仓库。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318095342.png" alt="微信截图_20210318095342.png"></p>
<h3 id="修改localRepository："><a href="#修改localRepository：" class="headerlink" title="修改localRepository："></a>修改localRepository：</h3><p><code>&lt;localRepository&gt;E:/java/maven-repository&lt;/localRepository&gt;</code></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101139.png" alt="微信截图_20210318101139.png"></p>
<h3 id="修改成阿里云镜像服务器"><a href="#修改成阿里云镜像服务器" class="headerlink" title="修改成阿里云镜像服务器"></a>修改成阿里云镜像服务器</h3><p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101320.png" alt="微信截图_20210318101320.png"></p>
<h3 id="配置jdk"><a href="#配置jdk" class="headerlink" title="配置jdk"></a>配置jdk</h3><p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101409.png" alt="微信截图_20210318101409.png"></p>
<h3 id="检测配置结果"><a href="#检测配置结果" class="headerlink" title="检测配置结果"></a>检测配置结果</h3><p>cmd 输入：<code>mvn help:system</code> 测试：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101541.png" alt="微信截图_20210318101541.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101755.png" alt="微信截图_20210318101755.png"></p>
<p><code>settings.xml</code> 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:/java/maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- pluginGroups</span></span><br><span class="line"><span class="comment">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span></span><br><span class="line"><span class="comment">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</span></span><br><span class="line"><span class="comment">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- pluginGroup</span></span><br><span class="line"><span class="comment">     | Specifies a further group identifier to use for plugin lookup.</span></span><br><span class="line"><span class="comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- proxies</span></span><br><span class="line"><span class="comment">   | This is a list of proxies which can be used on this machine to connect to the network.</span></span><br><span class="line"><span class="comment">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span></span><br><span class="line"><span class="comment">   | specification in this list marked as active will be used.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- proxy</span></span><br><span class="line"><span class="comment">     | Specification for one proxy, to be used in connecting to the network.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;proxy&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;optional&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;active&gt;true&lt;/active&gt;</span></span><br><span class="line"><span class="comment">      &lt;protocol&gt;http&lt;/protocol&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;proxyuser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;proxypass&lt;/password&gt;</span></span><br><span class="line"><span class="comment">      &lt;host&gt;proxy.host.net&lt;/host&gt;</span></span><br><span class="line"><span class="comment">      &lt;port&gt;80&lt;/port&gt;</span></span><br><span class="line"><span class="comment">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">    &lt;/proxy&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- servers</span></span><br><span class="line"><span class="comment">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span></span><br><span class="line"><span class="comment">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- server</span></span><br><span class="line"><span class="comment">     | Specifies the authentication information to use when connecting to a particular server, identified by</span></span><br><span class="line"><span class="comment">     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are</span></span><br><span class="line"><span class="comment">     |       used together.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;repouser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;repopwd&lt;/password&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Another sample, using keys to authenticate.</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;siteServer&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span></span><br><span class="line"><span class="comment">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- mirrors</span></span><br><span class="line"><span class="comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span><br><span class="line"><span class="comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span><br><span class="line"><span class="comment">   | it to several places.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span><br><span class="line"><span class="comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span></span><br><span class="line"><span class="comment">   | server for that repository.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 阿里云仓库 开始--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--或者 </span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;Nexus aliyun&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line"><span class="comment">     &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 阿里云仓库 结束--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- profiles</span></span><br><span class="line"><span class="comment">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span></span><br><span class="line"><span class="comment">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span></span><br><span class="line"><span class="comment">   | specific paths and repository locations which allow the build to work in the local environment.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span></span><br><span class="line"><span class="comment">   | your Tomcat instance is installed, you can provide a variable here such that the variable is</span></span><br><span class="line"><span class="comment">   | dereferenced during the build process to configure the cactus plugin.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span></span><br><span class="line"><span class="comment">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span></span><br><span class="line"><span class="comment">   | relies on the detection of a system property, either matching a particular value for the property,</span></span><br><span class="line"><span class="comment">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a</span></span><br><span class="line"><span class="comment">   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.</span></span><br><span class="line"><span class="comment">   | Finally, the list of active profiles can be specified directly from the command line.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | <span class="doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span></span><br><span class="line"><span class="comment">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span></span><br><span class="line"><span class="comment">   |       variables for plugins in the POM.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- activeProfiles</span></span><br><span class="line"><span class="comment">   | List of profiles that are active for all builds.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  &lt;activeProfiles&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">  &lt;/activeProfiles&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IDEA配置Maven"><a href="#IDEA配置Maven" class="headerlink" title="IDEA配置Maven"></a>IDEA配置Maven</h3><p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318102733.png" alt="微信截图_20210318102733.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/12/IP%E7%BD%91%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/IP%E7%BD%91%E5%85%B3/" class="post-title-link" itemprop="url">IP网关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 15:54:40" itemprop="dateCreated datePublished" datetime="2021-03-12T15:54:40+00:00">2021-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IP%E7%BD%91%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">IP网关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;&emsp;网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p>
<p>&emsp;&emsp;由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP。</p>
<p>&emsp;&emsp;在OSI中，网关有两种：一种是面向连接的网关，一种是无连接的网关。当两个子网之间有一定距离时，往往将一个网关分成两半，中间用一条链路连接起来，我们称之为半网关。</p>
<p>&emsp;&emsp;按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的 <code>网关</code> 均指TCP/IP协议下的网关。</p>
<p>&emsp;&emsp;网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为 <code>192.168.1.1~192. 168.1.254</code>，子网掩码为 <code>255.255.255.0</code> ；网络B的IP地址范围为 <code>192.168.2.1~192.168.2.254</code> ，子网掩码为 <code>255.255.255.0</code> 。在没有路由器的情况下，两个网络之间是不能进行 <code>TCP/IP</code> 通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（<code>255.255.255.0</code>）与主机的IP 地址作 <code>与</code> 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络A向网络B转发数据包的过程。</p>
<p>&emsp;&emsp;只有设置好网关的IP地址，<code>TCP/IP</code> 协议才能实现不同网络之间的相互通信。网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p>
<p>&emsp;&emsp;在和 Novell NetWare 网络交互操作的上下文中，网关在 Windows 网络中使用的服务器信息块 (SMB) 协议以及NetWare网络使用的 NetWare 核心协议 (NCP) 之间起着桥梁的作用。网关也被称为 IP路由器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/08/%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80/" class="post-title-link" itemprop="url">快速计算广播地址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-08 09:31:27" itemprop="dateCreated datePublished" datetime="2021-03-08T09:31:27+00:00">2021-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>192.168.1.53/27，快速计算公式：</strong></p>
<ul>
<li>1，用32减去掩码长度：32-27 =5</li>
<li>2，计算每个子网段的步长（Step）：2^5= 32</li>
<li>3，每个子网段的前缀（Prefix）= 192.168.1</li>
<li>4，每个子网段的起始地址为步长32的整数倍：0、32、64、96、128、160、192、224</li>
</ul>
<p>看看53落在上述哪两个数中间？显然落在32与64之间，那么这个IP的网络ID = <code>192.168.1.32</code><br>广播ID = <code>192.168.1.63</code>， 63 =64-1，这里的64是下一个网络ID的起始地址，比它小1即为前一个网段的广播地址。</p>
<p><strong>192.168.129.53/18，问它的网段的起始IP、广播IP</strong></p>
<ul>
<li>1，用24减去掩码长度：24-18 = 6</li>
<li>2，计算步长：2^6= 64</li>
<li>3，每个子网段的前缀（Prefix）= 192.168</li>
<li>4，每个子网段的起始地址为步长64的整数倍：0、64、128、192</li>
</ul>
<p>看看129落在上述哪两个数中间？显然落在128与192之间，那么这个IP的网络ID = <code>192.168.128.0</code><br>广播ID = <code>192.168.191.255</code></p>
<p><font color=#ff0000 size=4 face="黑体">32,24,16 是根据掩码长度确定的。</font></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aSKDasPUEj0u12GEV0kfJg">如何快速算出192.168.1.53/27的广播地址？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/" class="post-title-link" itemprop="url">Linux下网络丢包故障定位</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 11:34:08" itemprop="dateCreated datePublished" datetime="2021-03-01T11:34:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DP0F3Q7TnOixxWZ9-_KA4A">云网络丢包故障定位全景指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">网络数据包发送和接收过程解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 10:34:08" itemprop="dateCreated datePublished" datetime="2021-03-01T10:34:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h2><p><img src="/img/651016-20190403213253371-112748496.png" alt="651016-20190403213253371-112748496.png"></p>
<h2 id="数据包名称简介"><a href="#数据包名称简介" class="headerlink" title="数据包名称简介"></a>数据包名称简介</h2><ul>
<li>包：可以说是全能性术语；</li>
<li>帧：用于表示数据链路层中包的单位；</li>
<li>数据包：是 IP 和 UDP 等网络层以上的分层中包的单位；</li>
<li>段：则表示 TCP 数据流中的信息；</li>
<li>消息：是指应用协议中数据的单位。</li>
</ul>
<p>&emsp;&emsp;每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="/img/651016-20190403213115559-1163198356.jpg" alt="651016-20190403213115559-1163198356.jpg"></p>
<h2 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h2><p>用户 a 向用户 b 发送邮件为例子：</p>
<p><img src="/img/1c7ddca5e0e0415c8b4c69047e680fc7.jpeg" alt="1c7ddca5e0e0415c8b4c69047e680fc7.jpeg"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090819.png" alt="微信截图_20210330090819.png"></p>
<p><strong>1，应用程序处理</strong></p>
<p>&emsp;&emsp;首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>
<p><strong>2，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>
<p><strong>3，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>
<p><strong>4，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<p><strong>5，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>
<p><strong>6，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>
<p><strong>7，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<p><strong>8，应用程序的处理</strong></p>
<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
<h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>
<p><strong>(1) TCP</strong> 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p>
<p><strong>(2) UDP</strong> 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
<p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>&emsp;&emsp;数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>
<p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p><img src="/img/3f35fe4b91bb4a27b4ab30f84639d32a.jpeg" alt="3f35fe4b91bb4a27b4ab30f84639d32a.jpeg"><br><img src="/img/65b24665096545c089a7a18300218c6d.jpeg" alt="65b24665096545c089a7a18300218c6d.jpeg"></p>
<ul>
<li>(1) 和 (2) 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</li>
<li>(3) 和 (1) 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li>
<li>当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li>
</ul>
<h4 id="端口号的确定"><a href="#端口号的确定" class="headerlink" title="端口号的确定"></a>端口号的确定</h4><ul>
<li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 <code>0~1023</code> 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 <code>1024~49151</code> 之间，不过这些端口号可用于任何通信用途。</li>
<li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 <code>49152~65535</code> 之间。</li>
</ul>
<h4 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h4><p>&emsp;&emsp;端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li>
<li>UDP 将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>
<li>传输途中出现丢包，UDP 也不负责重发。</li>
<li>当包的到达顺序出现乱序时也没有纠正的功能。</li>
<li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li>
</ul>
<p>UDP 常用于一下几个方面：</p>
<ul>
<li>1.包总量较少的通信（DNS、SNMP等）；</li>
<li>2.视频、音频等多媒体通信（即时通信）；</li>
<li>3.限定于 LAN 等特定网络中的应用通信；</li>
<li>4.广播通信（广播、多播）。</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>&emsp;&emsp;TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
<p>&emsp;&emsp;根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>&emsp;&emsp;TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。三次握手是指建立一个 TCP 连接时,需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p>
<p><img src="/img/3148139034514574a74a055e2a35b6fd.jpeg" alt="3148139034514574a74a055e2a35b6fd.jpeg"></p>
<ul>
<li><strong>第一次握手</strong>：客户端将标志位 <code>SYN</code> 置为1，随机产生一个值 <code>seq=J</code>，并将该数据包发送给服务器端，客户端进入 <code>SYN_SENT</code> 状态，等待服务器端确认。</li>
<li><strong>第二次握手</strong>：服务器端收到数据包后由标志位 <code>SYN=1</code>,知道客户端请求建立连接，服务器端将标志位 <code>SYN</code> 和 <code>ACK</code> 都置为1，<code>ack=J+1</code>，随机产生一个值 <code>seq=K</code> ，并将该数据包发送给客户端以确认连接请求，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
<li><strong>第三次握手</strong>：客户端收到确认后，检查 <code>ack</code> 是否为 <code>J+1</code>，<code>ACK</code> 是否为1，如果正确,则将标志位 <code>ACK</code>置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查 <code>ack</code> 是否为 <code>K+1</code>， <code>ACK</code> 是否为1，如果正确则连接建立成功，客户端和服务器端进入 <code>ESTABLISHED</code> 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>&emsp;&emsp;四次挥手即终止 TCP 连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在 <code>socket</code> 编程中，这一过程由 客户端 或 服务端 任一方执行 <code>close</code> 来触发。</p>
<p>&emsp;&emsp;由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 <code>FIN</code> 来终止这一方向的连接，收到一个 <code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了 <code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><img src="/img/3e49dad546ba48eca6777783a8456a97.jpeg" alt="3e49dad546ba48eca6777783a8456a97.jpeg"></p>
<p>中断连接端可以是客户端，也可以是服务器端。</p>
<ul>
<li><strong>第一次挥手</strong>：客户端发送一个 <code>FIN=M</code>，用来关闭客户端到服务器端的数据传送，客户端进入 <code>FIN_WAIT_1</code> 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li><strong>第二次挥手</strong>：服务器端收到 <code>FIN</code> 后，先发送 <code>ack=M+1</code>，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 <code>FIN_WAIT_2</code> 状态，继续等待服务器端的 <code>FIN</code> 报文。</li>
<li><em>第三次挥手*</em>：当服务器端确定数据已发送完成，则向客户端发送 <code>FIN=N</code> 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 <code>LAST_ACK</code> 状态。</li>
<li><em>第四次挥手*</em>：客户端收到 <code>FIN=N</code> 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 <code>ack=N+1</code> 后进入 <code>TIME_WAIT</code> 状态，如果 <code>Server</code> 端没有收到 <code>ACK</code> 则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了 <code>2MSL</code> 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，</p>
<p><img src="/img/4c5ab6ed942c431bbed30009959783c0.jpeg" alt="4c5ab6ed942c431bbed30009959783c0.jpeg"></p>
<h4 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h4><p>&emsp;&emsp;在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。 反之，则数据丢失的可能性很大。</p>
<p>&emsp;&emsp;在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>
<p>&emsp;&emsp;未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>
<p>&emsp;&emsp;此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>
<p>&emsp;&emsp;对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此引入了序列号。</p>
<p>&emsp;&emsp;序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p>
<h4 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h4><p>&emsp;&emsp;重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证 “确认应答一定能在这个时间内返回”。</p>
<p>&emsp;&emsp;TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</p>
<p>&emsp;&emsp;在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>
<p>&emsp;&emsp;此外， 数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>
<h4 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h4><p>&emsp;&emsp;在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，<font color=#ff0000 size=4 face="黑体">最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</font></p>
<p>&emsp;&emsp;TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</p>
<p>&emsp;&emsp;MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</p>
<h4 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h4><p>&emsp;&emsp;TCP 以 1 个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长,通信性能就越低。</p>
<p>&emsp;&emsp;为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p>
<p><img src="/img/8c6eab31573940a5bc369ea648d45591.jpeg" alt="8c6eab31573940a5bc369ea648d45591.jpeg"></p>
<p>&emsp;&emsp;窗口大小就是指：无需等待确认应答，而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段，同时进行确认应答的功能。</p>
<h4 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h4><p><img src="/img/0f015679fbef46deb30d6669d5e28ddf.jpeg" alt="0f015679fbef46deb30d6669d5e28ddf.jpeg"></p>
<p>&emsp;&emsp;上图中的窗口内的数据，即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>
<p>&emsp;&emsp;在滑动窗口以外的部分，包括未发送的数据，以及已经确认对端已收到的数据。当数据发出后，若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>
<p>&emsp;&emsp;收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为 <code>滑动窗口控制</code>。</p>
<h4 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h4><p>&emsp;&emsp;在使用窗口控制中， 出现丢包一般分为两种情况：</p>
<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>
<p><img src="/img/f665dba5def44bb8a9ae13848602442c.jpeg" alt="f665dba5def44bb8a9ae13848602442c.jpeg"></p>
<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为 <code>高速重发控制</code>。</p>
<p><img src="/img/1a1667fade0340998a1879a9f06d8511.jpeg" alt="1a1667fade0340998a1879a9f06d8511.jpeg"></p>
<h2 id="网络层中的-IP-协议"><a href="#网络层中的-IP-协议" class="headerlink" title="网络层中的 IP 协议"></a>网络层中的 IP 协议</h2><p>&emsp;&emsp;IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是 “实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点通信”。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090750.png" alt="微信截图_20210330090750.png"></p>
<ul>
<li>主机：配置有 IP 地址，不进行路由控制的设备。</li>
<li>路由器：既有 IP 地址又具有路由控制功能的设备。</li>
<li>节点：主机和路由器的统称。</li>
</ul>
<p>&emsp;&emsp;网络的下一层—数据链路层 的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上，也能实现两端节点之间的数据包传输。</p>
<p>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）、IP 分包与组包。</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>&emsp;&emsp;在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</p>
<p>&emsp;&emsp;作为网络层的 IP,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在 “连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</p>
<p>&emsp;&emsp;不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</p>
<p>&emsp;&emsp;IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</p>
<p><img src="/img/902f8a4e03a242ecb6e16e3f718371e6.jpeg" alt="902f8a4e03a242ecb6e16e3f718371e6.jpeg"></p>
<p>将 IP 地址的32位二进制进行计算，得出约 43 亿个 IP 地址。</p>
<p>实际上，网络的发展超乎想象，互联网上的设备远超 43 亿， 2019 年 11 月 25 日全球的 IPv4 地址已经彻底耗尽，但是直到现在大家仍然还在用 IPv4 ，并没有因为地址没了而无法上网。是因为除了 IPv6 之外，我们使用 NAT 技术缓解了地址不足的问题。</p>
<h4 id="IP-地址组成"><a href="#IP-地址组成" class="headerlink" title="IP 地址组成"></a>IP 地址组成</h4><p>IP 地址由网络号（网段地址）和主机号（主机地址）两部分组成。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090934.png" alt="微信截图_20210330090934.png"></p>
<p><strong>IP地址的主机标识</strong></p>
<p>&emsp;&emsp;如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的 “主机标识” 则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠，即 IP 地址具有了唯一性。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091419.png" alt="微信截图_20210330091419.png"></p>
<p><strong>IP地址的网络标识</strong></p>
<p>&emsp;&emsp;如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091204.png" alt="微信截图_20210330091204.png"></p>
<h4 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h4><p>&emsp;&emsp;IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091531.png" alt="微信截图_20210330091531.png"></p>
<ul>
<li>A 类 IP 地址是首位以 <code>0</code> 开头的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 8 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>0.0.0.0~127.0.0.0</code> 是 A 类的网络地址。<font color=#ff0000 size=4 face="黑体">A 类地址的后 24 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为 <code>16,777,214</code>(2的24次方-2) 个。其中 0 和 127 属于保留地址，减去两个保留地址，因此有 126 个可用的 A 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091724.png" alt="微信截图_20210330091724.png"><br><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091808.png" alt="微信截图_20210330091808.png"></p>
<ul>
<li>B 类 IP 地址是前两位 <code>10</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 16 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>128.0.0.0~191.255.0.0</code> 是 B 类的网络地址。<font color=#ff0000 size=4 face="黑体">B 类地址的后 16 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为<code>65,534</code> (2的16次方-2)个。其中 <code>128.0</code> 和 <code>191.255</code> 属于保留地址，减去两个保留地址，因此有 16382 个可用的 B 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091932.png" alt="微信截图_20210330091932.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092058.png" alt="微信截图_20210330092058.png"></p>
<ul>
<li>C 类 IP 地址是前三位为 <code>110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 24 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>192.0.0.0~223.255.255.0</code> 是 C 类的网络地址。<font color=#ff0000 size=4 face="黑体">C 类地址的后 8 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为 <code>254</code> (2的8次方-2)个。其中 <code>192.0.0</code> 和 <code>223.255.255</code> 属于保留地址，减去两个保留地址，因此有 <code>2097150</code> 个可用的 C 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092208.png" alt="微信截图_20210330092208.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092307.png" alt="微信截图_20210330092307.png"></p>
<ul>
<li>D 类 IP 地址是前四位为 <code>1110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 32 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>224.0.0.0~239.255.255.255</code> 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li>
</ul>
<p><code>127.x.x.x</code> 段地址空间是被保留的回环地址。</p>
<p>&emsp;&emsp;在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 2的8次方- 2 = 254）个主机地址的原因。</p>
<h4 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h4><p>&emsp;&emsp;广播地址(<code>Broadcast Address</code>) 是专门用于同时向网络中所有工作站进行发送的一个地址。在使用 <code>TCP/IP</code> 协议的网络中，主机标识段 <code>host ID</code>为全1 (11111111，即十进制的255) 的IP 地址为广播地址，广播的分组传送给<code>host ID</code>段所涉及的所有计算机。例如，对于 <code>10.1.1.0</code> （255.0.0.0 ）网段，其直播广播地址为 <code>10.255.255.255</code> （255 即为 2 进制的11111111），当发出一个目的地址为 <code>10.255.255.255</code> 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<p>广播地址应用于网络内的所有主机,广播分为受限广播(本地广播)和直接广播两种。在本网络内的广播叫做受限广播(本地广播)；在不同网络之间的广播叫做直接广播。</p>
<ul>
<li>（1）受限广播(本地广播)<br>它不被路由发送，但会被送到相同物理网络段上的所有主机<br>IP地址的网络字段和主机字段全为1就是地址 <code>255.255.255.255</code></li>
<li>（2）直接广播<br>网络广播会被路由，并会发送到专门网络上的每台主机<br>IP地址的网络字段定义这个网络，主机字段通常全为1，如 <code>192.168.10.255</code></li>
</ul>
<h5 id="受限地址"><a href="#受限地址" class="headerlink" title="受限地址"></a>受限地址</h5><p>&emsp;&emsp;受限的广播地址是 <code>255.255.255.255</code>。该地址用于主机配置过程中IP数据包的目的地址，此时，主机可能还不知道它所在网络的网络掩码，甚至连它的IP地址也不知道。在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出本地网络中。</p>
<h5 id="指向网络"><a href="#指向网络" class="headerlink" title="指向网络"></a>指向网络</h5><p>&emsp;&emsp;指向网络的广播地址是主机号为全1(11111111)的地址。A类网络广播地址为 netid.255.255.255，其中netid为A类网络的网络号。一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p>
<h5 id="指向子网"><a href="#指向子网" class="headerlink" title="指向子网"></a>指向子网</h5><p>&emsp;&emsp;指向子网的广播地址为主机号为全1(11111111)且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。例如，如果路由器收到发往 <code>128.1.2.255</code> 的数据报，当B类网络 <code>128.1</code> 的子网掩码为 <code>255.255.255.0</code>时，该地址就是指向子网的广播地址；但如果该子网的掩码为 <code>255.255.254.0</code>，该地址就不是指向子网的广播地址。</p>
<h5 id="指向所有子网"><a href="#指向所有子网" class="headerlink" title="指向所有子网"></a>指向所有子网</h5><p>&emsp;&emsp;指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。指向所有子网的广播地址的子网号及主机号为全1。例如，如果目的子网掩码为 <code>255.255.255.0</code> ，那么IP地址 <code>128.1.255.255</code> 是一个指向所有子网的广播地址。然而，如果网络没有划分子网，这就是一个指向网络的广播。</p>
<h4 id="IP多播-组播"><a href="#IP多播-组播" class="headerlink" title="IP多播(组播)"></a>IP多播(组播)</h4><p>&emsp;&emsp;<code>IP多播</code>（也称 <code>多址广播</code> 或 <code>组播</code>）技术，是一种允许一台或多台主机（多播源）发送单一数据包到多台主机（一次的，同时的）的TCP/IP网络技术。多播作为一点对多点的通信，是节省网络带宽的有效方法之一。在网络音频/视频广播的应用中，当需要将一个节点的信号传送到多个节点时，无论是采用重复点对点通信方式，还是采用广播方式，都会严重浪费网络带宽，只有多播才是最好的选择。多播能使一个或多个多播源只把数据包发送给特定的多播组，而只有加入该多播组的主机才能接收到数据包。目前，IP多播技术被广泛应用在 网络音频/视频广播、AOD/VOD、网络视频会议、多媒体远程教育、”push”技术（如股票行情等）和虚拟现实游戏等方面。</p>
<p>&emsp;&emsp;有些应用会有这样的要求：一些分布在各处的进程需要以组的方式协同工作，组中的进程通常要给其他所有的成员发送消息。即有这样的一种方法能够给一些明确定义的组发送消息，这些组的成员数量虽然很多，但是与整个网络规模相比却很小。给这样一个组发送消息称为多点点播送，简称多播。需要注意的是多播数据包的目的ip地址实际上不可能对应某一台真实存在的主机的ip地址，也就是说该目的ip地址永远不可能作为源地址，即多播ip地址只能用于目的ip地址，不能用于源ip地址。</p>
<p>组播使用 D 类地址。因此 IP 地址前四位是 “1110” 开头的，就是组播地址。剩下的 28 位就是组播的组编号。组播的地址范围是 <code>224.0.0.0 ~ 239.255.255.255</code> ，其中 <code>224.0.0.0 ~ 224.0.0.255</code> 既可以在同一个网段内实现组播，又可以跨网段给全网所有组员发送组播包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093819.png" alt="微信截图_20210330093819.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093945.png" alt="微信截图_20210330093945.png"></p>
<h5 id="1．多播地址和多播组"><a href="#1．多播地址和多播组" class="headerlink" title="1．多播地址和多播组"></a>1．多播地址和多播组</h5><p>&emsp;&emsp;IP多播通信必须依赖于IP多播地址，在 IPv4 中它是一个D类IP地址，并且ip首部中的协议字段为2，表明采用的是IGMP网际组管理协议。范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类。因此，如果从首位开始到第 4 位是 <code>1110</code> ，就可以认为是多播地址，而剩下的 28 位可以成为多播的组编号。所有的主机（路由器以外的主机和终端主机）必须属于 <code>224.0.0.1</code> 的组，所有的路由器必须属于 <code>224.0.0.2</code> 的组。</p>
<ul>
<li>局部链接多播地址范围在 <code>224.0.0.0~224.0.0.255</code>，这是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包；</li>
<li>预留多播地址为 <code>224.0.1.0~238.255.255.255</code>，可用于全球范围（如Internet）或网络协议；</li>
<li>管理权限多播地址为 <code>239.0.0.0~239.255.255.255</code>，可供组织内部使用，类似于私有IP地址，不能用于 Internet，可限制多播范围。</li>
</ul>
<p>&emsp;&emsp;使用同一个IP多播地址接收多播数据包的所有主机构成了一个主机组，也称为多播组。一个多播组的成员是随时变动的，一台主机可以随时加入或离开多播组，多播组成员的数目和所在的地理位置也不受限制，一台主机也可以属于几个多播组。此外，不属于某一个多播组的主机也可以向该多播组发送数据包。</p>
<h5 id="2-多播技术硬件支持"><a href="#2-多播技术硬件支持" class="headerlink" title="2. 多播技术硬件支持"></a>2. 多播技术硬件支持</h5><p>要实现IP多播通信，要求介于多播源和接收者之间的路由器、集线器、交换机以及主机均需支持IP多播。目前，IP多播技术已得到硬件、软件厂商的广泛支持。</p>
<ul>
<li>（1）主机<br>支持IP多播通信的平台包括 Windows CE 2.1、Windows 95、Windows 98、Windows NT 4 和 Windows 2000 等，运行这些操作系统的主机都可以进行IP多播通信。此外，新生产的网卡也几乎都提供了对IP多播的支持。</li>
<li>（2）集线器和交换机<br>目前大多数集线器、交换机只是简单地把多播数据当成广播来发送接收，但一些中、高档交换机提供了对IP多播的支持。例如，在 3COM SuperStack 3 Swith 3300 交换机上可启用 802.1p 或 IGMP 多播过滤功能，只为已侦测到IGMP 数据包的端口转发多播数据包。</li>
<li>（3）路由器<br>多播通信要求多播源节点和目的节点之间的所有路由器必须提供对 Internet组管理协议（IGMP）、多播路由协议（如PIM、DVMRP等）的支持。</li>
</ul>
<p>&emsp;&emsp;多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p>
<p><img src="/img/71e3a03024f04d32954f591d6e1edb43.jpeg" alt="71e3a03024f04d32954f591d6e1edb43.jpeg"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>&emsp;&emsp;子网掩码是在IPv4地址资源紧缺的背景下为了解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面。如果是都是使用的IPV6的话是没有子网掩码的概念。IPV6是端到端的连接通信，不需要子网了。</p>
<p>&emsp;&emsp;子网掩码用 32 位的二进制表示， IP 地址的网段地址部分设置为 1 ， IP 地址的主机地址部分设置为 0 。换句话说， IP 地址有多少位网段地址，子网掩码就有多少位取 1 ，其余都取 0 。为了方便记录，每 8 位为一组，以 <code>.</code> 隔开，再转换为十进制数。</p>
<p>将子网掩码和 IP 地址进行与（ AND ）运算，可得到这个 IP 地址的网段地址。</p>
<p>详情参考：<a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" title="IP4-子网掩码">IP4-子网掩码</a></p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">特征</th>
<th align="left">网络范围</th>
<th align="left">默认掩码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类地址</td>
<td align="left">第1个8位中的第1位始终为0</td>
<td align="left">0-127.x.x.x</td>
<td align="left">255.0.0.0/8</td>
</tr>
<tr>
<td align="left">B类地址</td>
<td align="left">第1个8位中的第1、2位始终为10</td>
<td align="left">128-191.x.x.x</td>
<td align="left">255.255.0.0/16</td>
</tr>
<tr>
<td align="left">C类地址</td>
<td align="left">第1个8位中的第1、2、3位始终为110</td>
<td align="left">192-y.x.x.x</td>
<td align="left">255.255.255.0/24</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</p>
<p><img src="/img/bb3cd3458dc94871a4a68f3fdd4897eb.jpeg" alt="bb3cd3458dc94871a4a68f3fdd4897eb.jpeg"></p>
<p>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用  <code>/</code> 隔开，如下：</p>
<p><img src="/img/050f0e2d38554dd89fdc4427226cc688.jpeg" alt="050f0e2d38554dd89fdc4427226cc688.jpeg"></p>
<h5 id="CIDR-与-VLSM"><a href="#CIDR-与-VLSM" class="headerlink" title="CIDR 与 VLSM"></a>CIDR 与 VLSM</h5><p>解决 IP 地址浪费问题，除了使用子网掩码，还使用了 CIDR 和 VLSM 技术。</p>
<p><strong>CIDR</strong> ，即无类域间路由，采用任意长度分割 IP 地址的网络号和主机号。它有两个作用：</p>
<ul>
<li>把多个网段聚合到一起，生成一个更大的网段；</li>
<li>汇总路由表 IP 地址，分担路由表压力。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330094830.png" alt="微信截图_20210330094830.png"></p>
<p><strong>VLSM</strong> ，即可变长子网掩码，它可以对 A 、 B 、 C 类地址再进行子网划分，以达到充分利用 IP 地址的目的。</p>
<p>假如一家企业有 100 台电脑，按以前的办法，只能分配一个 C 类地址 <code>222.222.222.0</code> 。但是 VLSM 可以在一个 C 类地址上划分出多个子网地址，再分配其中一个容纳主机数量与稍大于企业需求数量的子网地址给企业，这样就可以实现 IP 地址的合理使用。</p>
<p>计算容纳 100 台电脑的子网：使用主机号的位数计算出子网的主机地址数量。当主机号有 7 位时，有 126 个可用主机地址，可容纳 100 台电脑。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095148.png" alt="微信截图_20210330095148.png"></p>
<p>计算子网地址：当主机号有 7 位时，网络号有 32 - 7 = 25 位，也就是 <code>222.222.222.0/24</code> 向主机位借了一位作为子网位，那么子网掩码也就是 <code>255.255.255.128</code>。可分配 <code>222.222.222.0/25</code> 使用。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095237.png" alt="微信截图_20210330095237.png"></p>
<p>222.222.222.0/25子网详情：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095312.png" alt="微信截图_20210330095312.png"></p>
<p><strong>CIDR 和 VLSM 的区别</strong></p>
<p>CIDR 是主机号向网络号借位，目的是把几个网络汇总成一个大的网络，增加子网主机数量；</p>
<p>VLSM 是网络号向主机号借位，目的是把一个标准的网络划分成几个子网，减少子网主机数量。</p>
<h4 id="公网地址与私有地址"><a href="#公网地址与私有地址" class="headerlink" title="公网地址与私有地址"></a>公网地址与私有地址</h4><p>IP 地址分为公网地址和私有地址。公网地址是在互联网上使用的，私有地址是在局域网中使用的。</p>
<p>公网地址由 Internet NIC 负责分配，通过它直接访问互联网。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095612.png" alt="微信截图_20210330095612.png"></p>
<p>私有地址是一段保留的 IP 地址。只在局域网中使用，无法在互联网上使用。但是私有地址可以通过 NAT 技术，将私有地址转换为公网地址接入互联网。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095637.png" alt="微信截图_20210330095637.png"></p>
<p>公网 IP 地址在互联网范围内是唯一的，私有 IP 地址只要在同一个局域网内唯一即可。在不同局域网内出现相同的私有 IP 不会影响使用。</p>
<h3 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h3><p>&emsp;&emsp;发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于 <code>指明路由器或主机</code> 的信息，以便真正发往目标地址。保存这种信息的就是 <code>路由控制表</code>。</p>
<p>&emsp;&emsp;IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做 <code>路由协议</code> 的协议制作而成。</p>
<p>当一个数据包到达路由器时，路由器根据数据包的目的地址查询路由表，根据查询结果将数据包转发出去，这个过程就是 IP路由。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101202.png" alt="微信截图_20210330101202.png"></p>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>&emsp;&emsp;为了将数据包发给目的节点，所有节点都维护着一张路由表。路由表记录 IP 数据在下一跳应该发给哪个路由器。IP 包将根据这个路由表在各个数据链路上传输。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101335.png" alt="微信截图_20210330101335.png"></p>
<p>&emsp;&emsp;路由控制表的形成方式有两种：一种是管理员手动设置，也叫做 <strong>静态路由控制</strong>；另一种是路由器与其他路由器相互交换信息时自动刷新，叫做 <strong>动态路由控制</strong>。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101457.png" alt="微信截图_20210330101457.png"></p>
<h4 id="下一跳"><a href="#下一跳" class="headerlink" title="下一跳"></a>下一跳</h4><p>Hop ，中文叫 “跳”。它是指网络中的一个区间。IP 包就是在网络中一跳一跳的转发，在每一个区间内决定 IP 包下一跳的路径。</p>
<p>一跳是指数据链路中广播域的区间，也就是说不经过路由器而能直接到达的相连主机或路由器网卡的一个区间。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101607.png" alt="微信截图_20210330101607.png"></p>
<p>IP 数据包就像包裹，而送货车就像数据链路。包裹不可能自己移动，必须有送货车承载转运。而一辆送货车只能将包裹送到某个区间范围内。每个不同区间的包裹将由对应的送货车承载、运输。IP 的工作原理也是如此。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101639.png" alt="微信截图_20210330101639.png"></p>
<h4 id="路由条目类型"><a href="#路由条目类型" class="headerlink" title="路由条目类型"></a>路由条目类型</h4><h5 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h5><p>默认路由是指路由表中任何一个地址都能与之匹配的条目。所有数据包都可以使用默认路由进行数据转发。默认路由为 <code>0.0.0.0/0</code> 或 <code>default</code> 。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102027.png" alt="微信截图_20210330102027.png"></p>
<h5 id="主机路由"><a href="#主机路由" class="headerlink" title="主机路由"></a>主机路由</h5><p><code>IP地址/32</code> 被称为主机路由，它是路由表中指向单个 IP 地址或主机名的路由条目。例如：<code>192.168.153.15/32</code> 就是一条主机路由，表示整个 IP 地址的所有位都将参与路由。</p>
<h5 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h5><p>以 127 开头的 IP 地址都是环回地址，其所在的回环接口可以理解为虚拟网卡。使用回环地址时，数据包会直接被主机的 IP 层获取，而不经过链路层，也不会流向网络。一般用来检查主机上运行的网络服务是否正常。</p>
<h4 id="路由汇总"><a href="#路由汇总" class="headerlink" title="路由汇总"></a>路由汇总</h4><p>路由汇总主要是为了减少路由条目，把可以聚合的路由汇聚为一个大网络。</p>
<p>路由表越大，查找路由表所需的内存和 CPU 也就越多，时间也会越长，导致转发 IP 数据包的性能下降。如果想要搭建大规模、高性能的网络，就需要尽可能的路由表的大小。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102240.png" alt="微信截图_20210330102240.png"><br><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102302.png" alt="微信截图_20210330102302.png"></p>
<h4 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h4><p>IP 地址的网络地址部分用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</p>
<p>&emsp;&emsp;在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p>
<p><img src="/img/97e1e1332e5445c5b3da354f7cf407f9.jpeg" alt="97e1e1332e5445c5b3da354f7cf407f9.jpeg"></p>
<h3 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h3><h4 id="数据链路与MTU"><a href="#数据链路与MTU" class="headerlink" title="数据链路与MTU"></a>数据链路与MTU</h4><p>数据链路不同， MTU 则不同。</p>
<p>&emsp;&emsp;每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同，网络层的 IP 是数据链路的上一层， IP 通过分片屏蔽数据链路的差异，实现不同数据链路互通。从 IP 的上一层看，它完全可以忽略各个数据链路上的 MTU ，只需要按照源 IP 地址发送的长度接收数据包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102721.png" alt="微信截图_20210330102721.png"></p>
<h4 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h4><p>&emsp;&emsp;任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104125.png" alt="微信截图_20210330104125.png"></p>
<h4 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h4><p>分片机制有两点不足：</p>
<ul>
<li>加重路由器的处理性能；</li>
<li>在分片传输中，一旦某个分片丢失，会造成整个 IP 数据包作废。</li>
</ul>
<p>因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</p>
<p>为了应对分片机制的不足，<code>路径MTU发现</code>(Path MTU Discovery) 技术应运而生。</p>
<p>&emsp;&emsp;路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的值。即路径中存在的所有数据链路中最小的 MTU 。进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104310.png" alt="微信截图_20210330104310.png"></p>
<p>路径 MTU 发现的工作原理如下：</p>
<ul>
<li><p>1，发送端主机发送 IP 数据包时将其头部的分片禁止标志位设置为 1 。根据这个标志位，途中的路由器即使收到需要分片的大包，也不会分片，而是直接将包丢弃。之后通过一个 ICMP 不可达消息将数据链路上 MTU 值给发送端主机。</p>
</li>
<li><p>2，发送端主机根据收到的 MTU 值对数据包进行分片处理，再把 IP 数据包发送给相同的目的主机。如此重复，直到数据包被发送到目标主机为止没有再收到任何 ICMP ，就认为最后一次 ICMP 所通知的 MTU 即是一个合适的 MTU 值。MTU 值至少可以缓存约 10 分钟，在这 10 分钟内使用刚得到的 MTU ，过了 10 分钟后就重新做一次路径 MTU 发现。</p>
</li>
</ul>
<p>上面的例子是 UDP ，如果是在 TCP 的情况下，根据路径 MTU 的大小计算出最大段长度（ MSS ），然后再根据这些信息进行数据包的发送。因此，在 TCP 中如果使用路径 MTU 发现， IP 层则不会再分片。</p>
<h3 id="路由器三层转发原理"><a href="#路由器三层转发原理" class="headerlink" title="路由器三层转发原理"></a>路由器三层转发原理</h3><p>&emsp;&emsp;路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的网络号，再根据路由表进行转发，路由表中有匹配的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。</p>
<h4 id="路由器如何进行三层转发"><a href="#路由器如何进行三层转发" class="headerlink" title="路由器如何进行三层转发"></a>路由器如何进行三层转发</h4><p>当一台路由器收到一个数据包时，会执行如下步骤：</p>
<p>1，对数据包进行解封装。<br>    通过解封装，查看网络层头部信息的 目的 IP 地址。</p>
<p>2，在路由表中查找匹配的路由条目。</p>
<p>查找匹配的路由条目，就需要将数据包的目的 IP 地址与各个路由条目的网段地址先进行二进制与（ AND ）运算，再将运算结果与路由条目的网段地址进行比较，若一致则该条目与目的 IP 地址相匹配。最后，与所有路由条目完成运算和比较，可得到一条或多条相匹配的路由条目。也可能没有匹配的路由条目，那么丢弃数据包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104705.png" alt="微信截图_20210330104705.png"></p>
<p>3，从多个匹配项中选择掩码最长的路由条目。</p>
<p>如果路由表中有多条路由条目都匹配数据包的目的 IP 地址，则路由器会选择掩码长度最长的路由条目，这种匹配方式称为最长匹配原则。</p>
<p>例如：<code>10.1.3.10</code> 的网络地址与 <code>10.1.3.0/16</code> 和 <code>10.1.3.0/24</code> 两项都匹配，这时应该选择匹配度最长的 <code>10.1.3.0/24</code>。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104813.png" alt="微信截图_20210330104813.png"></p>
<p>4，将数据包按照相应路由条目进行转发。</p>
<p>路由条目中包含下一跳和出接口。当路由器找到相应的路由条目后，它就会根据对应的下一跳和出接口，将数据包从出接口发送数据给下一跳设备。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104927.png" alt="微信截图_20210330104927.png"></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>&emsp;&emsp;IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节</p>
<h4 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h4><ul>
<li>IP 地址的扩大与路由控制表的聚合。</li>
<li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li>
<li>支持即插即用功能。即使没有 <code>DHCP服务器</code> 也可以实现自动分配 IP 地址。</li>
<li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li>
<li>多播、Mobile IP 成为扩展功能。</li>
</ul>
<h4 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h4><p>&emsp;&emsp;一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（ <code>:</code> ）隔开进行标记。而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（<code>::</code>）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
<h4 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h4><p>&emsp;&emsp;IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</p>
<p><img src="/img/be1bff3dd05c4f999c7836ca26598c7d.jpeg" alt="be1bff3dd05c4f999c7836ca26598c7d.jpeg"></p>
<h4 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h4><p>&emsp;&emsp;全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</p>
<p>&emsp;&emsp;格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</p>
<p><img src="/img/478cf4cd8c2b43339b80d7b667a6520a.jpeg" alt="478cf4cd8c2b43339b80d7b667a6520a.jpeg"></p>
<h4 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h4><p>&emsp;&emsp;链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p>
<p><img src="/img/d9e6580e7ce245aa9116004055f69b8b.jpeg" alt="d9e6580e7ce245aa9116004055f69b8b.jpeg"></p>
<h4 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h4><p>&emsp;&emsp;唯一本地地址是不进行互联网通信时所用的地址。唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</p>
<ul>
<li>L 通常被置为 1</li>
<li>全局 ID 的值随机决定</li>
<li>子网 ID 是指该域子网地址</li>
<li>接口 ID 即为接口的 ID</li>
</ul>
<p><img src="/img/8efd0df062b049978546f10dc3895af5.jpeg" alt="8efd0df062b049978546f10dc3895af5.jpeg"></p>
<h4 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h4><p>&emsp;&emsp;IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</p>
<p>&emsp;&emsp;IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行 <code>路径MTU发现</code>，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</p>
<h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><p>&emsp;&emsp;IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>&emsp;&emsp;我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</p>
<p>&emsp;&emsp;这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>&emsp;&emsp;地址解析协议，即 <code>ARP（Address Resolution Protocol）</code>，是根据IP地址获取物理地址的一个 <code>TCP/IP</code> 协议。主机发送信息时将包含目标IP地址的 <code>ARP</code> 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机 <code>ARP缓存</code> 中，并保留一定时间，下次请求时直接查询 <code>ARP缓存</code> 以节约资源。</p>
<p>&emsp;&emsp;地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送 <code>ARP</code> 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 <code>ARP缓存</code>；由此攻击者就可以向某一主机发送伪 <code>ARP</code> 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 <code>ARP欺骗</code>。ARP命令可用于查询本机 <code>ARP缓存</code> 中 IP 地址和 MAC 地址的对应关系、添加或删除静态对应关系等。相关协议有 <code>RARP</code>、<code>代理ARP</code>。NDP用于在IPv6中代替地址解析协议。</p>
<p>&emsp;&emsp;只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时，还要知道每个 IP 地址所对应的 MAC 地址。</p>
<p>&emsp;&emsp;ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</p>
<p>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</p>
<h5 id="ARP-的工作原理"><a href="#ARP-的工作原理" class="headerlink" title="ARP 的工作原理"></a>ARP 的工作原理</h5><p><strong>当主机 A 向同一个网段内的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。</strong></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105123.png" alt="微信截图_20210330105123.png"></p>
<p>1，ARP 请求：主机 A 以主机 C 的 IP 地址为目的 IP 地址，以广播 MAC 地址为目的 MAC 地址，在同网段内发送这个广播报文，这个报文就叫 ARP 请求报文。</p>
<p>二层交换机不查看 IP 地址，根据目的 MAC 地址将报文除接收端口外的所有端口发送。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105217.png" alt="微信截图_20210330105217.png"></p>
<p>2，ARP 响应：主机 C 发现目的 IP 地址是自己的 IP 地址，于是主机 C 以自己 MAC 地址和 IP 地址作为源 MAC 地址和源 IP 地址，以主机 A 的 MAC 地址和 IP 地址作为目的 MAC 地址和目的 IP 地址，发送响应报文给主机 A ，这个报文就叫 ARP 响应报文。其它主机收到主机 A 的 ARP 请求报文，因为目的 IP 地址不是自己的 IP 地址，因此不会进行响应。</p>
<p>当主机 A 在发送 ARP 广播请求报文时，二层交换机已经有主机 A 的 MAC 地址表条目。当收到主机 C 发送的单播 ARP 响应报文时，二层交换机将报文从相应端口发送出去。并将主机 C 的 MAC 地址和对应端口记录到 MAC 地址表中。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105326.png" alt="微信截图_20210330105326.png"></p>
<p>3，更新 ARP 缓存表：主机 A 收到 ARP 响应报文后，将主机 C 的 IP 地址和 MAC 地址记录到 ARP 缓存表中。下次再向主机 C 发送数据时，直接将缓存的目的 MAC 地址进行封装。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105401.png" alt="微信截图_20210330105401.png"></p>
<p><strong>当主机 A 向不同网段的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。</strong></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105435.png" alt="微信截图_20210330105435.png"></p>
<p>1，主机 A 使用主机 C 的 IP 地址查询 ARP ，ARP 发现主机 C 不在同一个网段，需要通过默认网关（即默认路由的下一跳地址），但是没有网关 MAC 地址；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105523.png" alt="微信截图_20210330105523.png"></p>
<p>2，主机 A 先将发送给主机 C 的数据放入缓存中，然后发送 ARP 请求报文，主机 A 以网关 IP 地址为目的 IP 地址发送 ARP 广播请求报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105548.png" alt="微信截图_20210330105548.png"></p>
<p>3，路由器收到 ARP 广播请求报文后，将主机 A 的 MAC 地址和对应端口添加到自己的 MAC 表中，然后查看目的 IP 地址发现是请求自己的 MAC 地址，于是单播发送 ARP 响应报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105612.png" alt="微信截图_20210330105612.png"></p>
<p>4，主机 A 收到 ARP 响应报文后，将发送给主机 C 的数据封装网关 MAC 地址为目的 MAC 地址进行发送；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105634.png" alt="微信截图_20210330105634.png"></p>
<p>5，路由器收到报文后，查看目的 IP 地址，是发送给主机 C 的，于是查询路由表从相应端口发送数据。由于没有主机 C 的 MAC 地址，路由器发送 ARP 请求报文，源 MAC 地址和源 IP 地址替换为发送端口的MAC 地址和 IP 地址；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105656.png" alt="微信截图_20210330105656.png"></p>
<p>6，主机 C 收到 ARP 请求报文后，添加路由器的端口和 MAC 地址到 MAC 地址表，单播发送 ARP 响应报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105715.png" alt="微信截图_20210330105715.png"></p>
<p>7，路由器收到主机 C 的 MAC 地址后，将其添加到 MAC 地址表中。将主机 A 发送给主机 C 的报文重新封装，以自己的 MAC 地址为源 MAC 地址，以主机 C 的 MAC 地址为目的 MAC 地址，发送给主机 C ；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105737.png" alt="微信截图_20210330105737.png"></p>
<p>8，主机 C 收到主机 A 发送的数据，发送过程结束。</p>
<p>当主机 C 向主机 A 发送回复报文时，同主机 A 向主机 C 发送数据的步骤一致。</p>
<h5 id="ARP-代理"><a href="#ARP-代理" class="headerlink" title="ARP 代理"></a>ARP 代理</h5><p>如果 ARP 请求是从一个网络的主机发往同一网段却不在同一物理网络上的另一台主机，那么连接它们的具有代理 ARP 功能的设备就可以回答该请求，这个过程称作 代理ARP 。</p>
<p>代理 ARP 功能屏蔽了分离的物理网络，让用户使用起来，跟在同一个物理网络上一样。</p>
<h5 id="免费-ARP"><a href="#免费-ARP" class="headerlink" title="免费 ARP"></a>免费 ARP</h5><p>免费 ARP 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。</p>
<p>与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，目标 IP 地址是自己的 IP 地址。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110049.png" alt="微信截图_20210330110049.png"></p>
<p>免费 ARP 的作用：</p>
<ul>
<li>起到一个宣告作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。</li>
<li>可用于检测 IP 地址冲突。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</li>
<li>可用于更新其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。</li>
</ul>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>IP 提供尽力而为的服务，指为了把数据包发送到目的地址尽最大努力。它并不做对端目的主机是否收到数据包的验证，无法保证服务质量。</p>
<p>&emsp;&emsp;<code>ICMP（Internet Control Message Protocol）</code> Internet控制报文协议。它是 <code>TCP/IP</code> 协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>&emsp;&emsp;<code>ICMP</code> 使用 IP 的基本支持，就像它是一个更高级别的协议，但是，<code>ICMP</code> 实际上是IP的一个组成部分，必须由每个IP模块实现。</p>
<p>&emsp;&emsp;<code>ICMP</code> 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>
<p>&emsp;&emsp;IPv4 中 <code>ICMP</code> 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 <code>ICMP</code>，仍然可以实现 IP 通信。然而，在 IPv6 中，<code>ICMP</code> 的作用被扩大，如果没有 <code>ICMPv6</code>，IPv6 就无法进行正常通信。</p>
<p>ICMP 报文像 TCP/UDP 一样通过 IP 进行传输，但是 ICMP 的功能不是传输层的补充，应该把它当做网络层协议。’</p>
<p>ICMP 头部封装字段如:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110618.png" alt="微信截图_20210330110618.png"></p>
<p>通过类型字段和编码字段的取值判断这个 ICMP 消息的类型。常见的 ICMP 消息所对应的类型和编码值如下图。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110640.png" alt="微信截图_20210330110640.png"></p>
<p>从功能上，ICMP 的消息分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110700.png" alt="微信截图_20210330110700.png"></p>
<h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>我们常用的 ping 工具就是通过 ICMP 消息测试网络层连通性的。源主机发出 Echo request 消息，目的主机回应 Echo reply 消息，则两台主机间的网络层通信正常。也可以通过 ping 命令来判断目标主机是否启用。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110752.png" alt="微信截图_20210330110752.png"></p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>&emsp;&emsp;如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</p>
<p>&emsp;&emsp;于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</p>
<p>&emsp;&emsp;<code>DHCP</code> (Dynamic Host Configuration Protocol，动态主机配置协议) 是一个局域网的网络协议，使用UDP协议工作，指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为 <code>Windows Server</code> 的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。</p>
<p>&emsp;&emsp;主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<p>&emsp;&emsp;在RFC 2131中有详细的描述，DHCP有3个端口，其中 <code>UDP67</code> 和 <code>UDP68</code> 为正常的 <code>DHCP</code> 服务端口，分别作为 <code>DHCP Server</code> 和 <code>DHCP Client</code> 的服务端口；546号端口用于 <code>DHCPv6 Client</code>，而不用于 <code>DHCPv4</code> ，是为 <code>DHCP failover</code> 服务，这是需要特别开启的服务，<code>DHCP failover</code> 是用来做双机热备的。</p>
<p>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>&emsp;&emsp;<code>NAT</code>（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</p>
<p>&emsp;&emsp;除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 <code>NAPT</code>（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</p>
<p>&emsp;&emsp;<code>NAT（NAPT）</code>实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 <code>NAT-PT</code>。</p>
<h4 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h4><p><img src="/img/e11421fc61d14423adab54661884f497.jpeg" alt="e11421fc61d14423adab54661884f497.jpeg"></p>
<p>夹着 IPv4 网络的两个 IPv6 网络</p>
<p>&emsp;&emsp;如上图的网络环境中，网络A 网络B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</p>
<p>&emsp;&emsp;IP 隧道可以将那网络A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发网络C。</p>
<p>&emsp;&emsp;一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中 “IP首部的后面还是 IP首部” 或者 “IP首部 的后面是 IPv6的首部” 等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做 “IP隧道”。</p>
<h2 id="扩展：运行在传输层中的-TCP-和-UDP-的协议"><a href="#扩展：运行在传输层中的-TCP-和-UDP-的协议" class="headerlink" title="扩展：运行在传输层中的 TCP 和 UDP 的协议"></a>扩展：运行在传输层中的 TCP 和 UDP 的协议</h2><p>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</p>
<p><strong>运行在 TCP协议上的协议：</strong></p>
<ul>
<li>HTTP（HypertextTransferProtocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）, HTTP协议的安全版本。</li>
<li>FTP（FileTransferProtocol，文件传输协议），用于文件传输。</li>
<li>POP3（PostOfficeProtocol,version3，邮局协议），收邮件用。</li>
<li>SMTP（SimpleMailTransferProtocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletypeover theNetwork，网络电传），通过一个 终端（terminal）登陆到网络。</li>
<li>SSH（SecureShell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p><strong>运行在 UDP协议上的协议：</strong></p>
<ul>
<li>BOOTP（BootProtocol，启动协议），应用于无盘设备。</li>
<li>NTP（NetworkTimeProtocol，网络时间协议），用于网络同步。</li>
<li>DHCP（DynamicHostConfigurationProtocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p><strong>运行在 TCP和 UDP协议上：</strong></p>
<ul>
<li>DNS（DomainNameService，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/339068354_774177">https://www.sohu.com/a/339068354_774177</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jbjrR-7EGQ1vMgAdTT450A">71张图详解IP 地址、IP 路由、分片和重组、三层转发、ARP、ICMP</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44630560/article/details/108100907">https://blog.csdn.net/weixin_44630560/article/details/108100907</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" class="post-title-link" itemprop="url">IP4-子网掩码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 10:33:08" itemprop="dateCreated datePublished" datetime="2021-03-01T10:33:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-06 07:19:08" itemprop="dateModified" datetime="2021-04-06T07:19:08+00:00">2021-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">子网掩码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络掩码"><a href="#网络掩码" class="headerlink" title="网络掩码"></a>网络掩码</h2><p>&emsp;&emsp;子网掩码是在IPv4地址资源紧缺的背景下为了解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面。如果是都是使用的IPV6的话是没有子网掩码的概念。IPV6是端到端的连接通信，不需要子网了。</p>
<p>&emsp;&emsp;网络掩码做为一个辅助工具，可以帮助主机区分以上三种情况，所以网络掩码是必不可少的，和IP地址如影相随。最初的网络掩码长度为8的整数倍，8、16、24、32，这里的长度为二进制的长度，即一个字节长度的整数倍。</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">特征</th>
<th align="left">网络范围</th>
<th align="left">默认掩码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类地址</td>
<td align="left">第1个8位中的第1位始终为0</td>
<td align="left">0-127.x.x.x</td>
<td align="left">255.0.0.0/8</td>
</tr>
<tr>
<td align="left">B类地址</td>
<td align="left">第1个8位中的第1、2位始终为10</td>
<td align="left">128-191.x.x.x</td>
<td align="left">255.255.0.0/16</td>
</tr>
<tr>
<td align="left">C类地址</td>
<td align="left">第1个8位中的第1、2、3位始终为110</td>
<td align="left">192-y.x.x.x</td>
<td align="left">255.255.255.0/24</td>
</tr>
</tbody></table>
<p><strong>1.1.1.1/8</strong><br>这个组合经常出现的路由器的配置里，其中 <code>1.1.1.1</code> 为IP地址。 <code>/8</code> 表示网络掩码的长度，8个二进制长度。</p>
<p><strong>172.16.1.1/16</strong><br><code>172.16.1.1</code> 为IP地址。<code>/16</code> 表示网络掩码的长度，16个二进制长度。</p>
<p><strong>192.168.1.1/24</strong><br><code>192.168.1.1</code> 为IP地址。<code>/24</code>表示网络掩码的长度，24个二进制长度。</p>
<p><strong>127.0.0.1/32</strong><br><code>127.0.0.1</code> 为IP地址。<code>/32</code> 表示网络掩码的长度，32个二进制长度。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>如果不对掩码长度是8的整数倍做强制要求，那么就实现精细化的子网掩码。</p>
<p><code>CIDR</code> :( Classless Inter-Domain Routing，元类域间路由选择).我们需要了解这种网络表示法。形式如：192.168.10.32/28。前面的数字是我们的网络地址，后面的28表示用28位来表示网络位，用32-28=4位来表示主机位。通过这种记法，我们能明确两个信息：<br>网络地址：<code>192.168.10.32</code><br>子网掩码：<code>255.255.255.240</code></p>
<p>通过下表我们能明确 <code>子网掩码</code> 和 <code>斜杠表示法</code> 之间的关系:</p>
<p><img src="/img/1679092-20190709175902328-586874586.png" alt="1679092-20190709175902328-586874586.png"><br><img src="/img/1679092-20190709175913957-2145237488.png" alt="1679092-20190709175913957-2145237488.png"></p>
<p>其中 <code>/8-/15</code> 只能用于A类网络，<code>/16-/23</code> 可用于A类和B类网络，而 <code>/24-/30</code> 可用于A类、B类和C类网络。这就是大多数公司都使用A类网络地址的一大原因，因为它们可使用所有的子网掩码，进行网络设计时的灵活性最大。</p>
<p>假设现有一IP地址 <code>180.210.242.131</code>，即 <code>10110100.11010010.11110010.10000011</code><br>同时指定子网掩码为 <code>255.255.248.0</code>  即 <code>11111111.11111111.11111000.00000000</code>，则</p>
<p>网络号：两者进行与运算，即 <code>10110100.11010010.11110000.00000000（180.210.240.0）</code><br>主机号：子网掩码取反再和IP做与运算，即 <code>00000000.00000000.00000010.10000011（0.0.2.131）</code><br>子网号：这个IP本来是B类地址，默认的子网掩码是 <code>255.255.0.0</code>，所以本来的网络号是16位，但它实际网络号是21位，就是借了5位网络位，所以可以划分 <code>2^5</code> 个子网，即32个，实际使用30个，这个网段可以容纳主机 <code>2^11</code> 个，即2048个，有效2046个一头一尾分别做网络号和广播。</p>
<p>从前有一个地主，有256间房子，地主家的门牌号码是 <code>192.168.1</code>，那么他家第一间房子的门牌号码是 <code>192.168.1.0</code> ，第二间是 <code>192.168.1.1</code>,……第256间的编号是 <code>192.168.1.255</code>。</p>
<p>地主老了，需要把256间房子分给4个儿子，平均分配，每个儿子可以分64间。</p>
<p>请来一位先生主持公道，先生这么来操作：</p>
<p><code>192.168.1.0-192.168.1.63</code> 分给大儿子<br><code>192.168.1.64-192.168.1.127</code> 分给二儿子<br><code>192.168.1.128 -192.168.1.191</code> 分给三儿子<br><code>192.168.1.192-192.168.1.255</code> 分给四儿子</p>
<p>如何来描述四个儿子的子网网段呢?</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0/26</span><br><span class="line">192.168.1.64/26</span><br><span class="line">192.168.1.128/26</span><br><span class="line">192.168.1.192/26</span><br></pre></td></tr></table></figure>

<p><strong>/26 解析</strong></p>
<p><code>255.255.255.192</code> 的二进制是：<code>11111111-11111111-11111111-11</code> 总共是26个1，为了简化子网掩码的表示，用 <code>/26</code> 代替 <code>255.255.255.192</code>。</p>
<p>按位与运算我们来看大儿子的网段 <code>192.168.1.0/26</code> 是如何得到的？</p>
<p>以大儿子的房间为例：<code>192.168.1.0-192.168.1.63</code></p>
<p>二进制表示：</p>
<p><code>192.168.1.0</code> 对于二进制：<code>11000000.10101000.00000001.00000000</code></p>
<p><code>192.168.1.63</code> 对于二进制：<code>11000000.10101000.00000001.00111111</code></p>
<p>首尾地址完全相同的是: <code>11000000.10101000.00000001.00</code>，总共26位！那么用这个 <code>192.168.1.0/26</code> 就可以表示大儿子所有房间。</p>
<p>对照房间的门牌号码 <code>192.168.1.199</code>，很显然属于四儿子的。</p>
<p>Q1：一个主机 <code>192.168.1.199/26</code> 能否和直连主机 <code>192.168.1.200/24</code> 通信？</p>
<p>可以的，因为都是四儿子的房间。</p>
<p>Q2：一个主机 <code>192.168.1.199/26</code> 能否和直连主机 <code>192.168.1.1/24</code> 通信？</p>
<p>不可以，因为一个是大儿子的房间，一个是四儿子的房间，无法直连通信！</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jAITB4o1nnO5M2wt0hDqjw">子网掩码有那么难吗？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">382</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">173</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
