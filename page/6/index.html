<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/6/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/CentOS7%E6%8E%92%E6%9F%A5CLOSE-WAIT%E8%BF%87%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/CentOS7%E6%8E%92%E6%9F%A5CLOSE-WAIT%E8%BF%87%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">CentOS7排查CLOSE_WAIT过多异常原因</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 15:33:01" itemprop="dateCreated datePublished" datetime="2021-03-29T15:33:01+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查看系统连接数"><a href="#查看系统连接数" class="headerlink" title="查看系统连接数"></a>查看系统连接数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前socket连接状态统计信息</span></span><br><span class="line">cat /proc/net/sockstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计当前各种状态的连接的数量的命令</span></span><br><span class="line">netstat -n | awk <span class="string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看端口范围"><a href="#查看端口范围" class="headerlink" title="查看端口范围"></a>查看端口范围</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许系统打开的端口范围，用于向外链接的端口范围</span></span><br><span class="line">cat /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">1024	65000</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/29/CentOS7%E6%8E%92%E6%9F%A5CLOSE-WAIT%E8%BF%87%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-ss%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-ss%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux ss命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 15:04:56" itemprop="dateCreated datePublished" datetime="2021-03-29T15:04:56+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ss命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。ss命令是Linux CentOS 7中iproute软件包的一部分，默认已经安装。</p>
<p>当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。</p>
<p>ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iproute</span><br><span class="line">yum info iproute</span><br></pre></td></tr></table></figure>

<p>语法</p>
<p><code>ss(选项)</code></p>
<p>选项</p>
<ul>
<li>-h：显示帮助信息；</li>
<li>-V：显示指令版本信息；</li>
<li>-n：不解析服务名称，以数字方式显示；</li>
<li>-a：显示所有的套接字；</li>
<li>-l：显示处于监听状态的套接字；</li>
<li>-o：显示计时器信息；</li>
<li>-m：显示套接字的内存使用情况；</li>
<li>-p：显示使用套接字的进程信息；</li>
<li>-i：显示内部的TCP信息；</li>
<li>-4：只显示ipv4的套接字；</li>
<li>-6：只显示ipv6的套接字；</li>
<li>-t：只显示tcp套接字；</li>
<li>-u：只显示udp套接字；</li>
<li>-d：只显示DCCP套接字；</li>
<li>-w：仅显示RAW套接字；</li>
<li>-x：仅显示UNIX域套接字。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示ICP连接</span></span><br><span class="line">ss -t -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 Sockets 摘要</span></span><br><span class="line">ss -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有打开的网络连接端口</span></span><br><span class="line">ss -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程使用的socket</span></span><br><span class="line">ss -pl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有UDP Sockets</span></span><br><span class="line">ss -u -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看6379端口</span></span><br><span class="line">ss -ta sport = :6379 | head</span><br><span class="line">ss -pl | grep 3306</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有状态为established的SMTP连接</span></span><br><span class="line">ss -o state established <span class="string">&#x27;( dport = :smtp or sport = :smtp )&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有状态为Established的HTTP连接</span></span><br><span class="line">ss -o state established <span class="string">&#x27;( dport = :http or sport = :http )&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字</span></span><br><span class="line">ss -o state fin-wait-1 <span class="string">&#x27;( sport = :http or sport = :https )&#x27;</span> dst 193.233.7/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用TCP 状态过滤Sockets</span></span><br><span class="line">ss -4 state closing </span><br><span class="line">ss -4 state FILTER-NAME</span><br><span class="line">ss -6 state FILTER-NAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># FILTER-NAME-HERE 可以代表以下任何一个：</span></span><br><span class="line"></span><br><span class="line">established</span><br><span class="line">syn-sent</span><br><span class="line">syn-recv</span><br><span class="line">fin-wait-1</span><br><span class="line">fin-wait-2</span><br><span class="line">time-wait</span><br><span class="line">closed</span><br><span class="line">close-wait</span><br><span class="line">last-ack</span><br><span class="line">listen</span><br><span class="line">closing</span><br><span class="line">all : 所有以上状态</span><br><span class="line">connected : 除了listen and closed的所有状态</span><br><span class="line">synchronized :所有已连接的状态除了syn-sent</span><br><span class="line">bucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.</span><br><span class="line">big : 和bucket相反.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配远程地址和端口号</span></span><br><span class="line">ss dst ADDRESS_PATTERN</span><br><span class="line">ss dst 192.168.1.5</span><br><span class="line">ss dst 192.168.119.113:http </span><br><span class="line">ss dst 192.168.119.113:smtp </span><br><span class="line">ss dst 192.168.119.113:443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配本地地址和端口号</span></span><br><span class="line">ss src ADDRESS_PATTERN</span><br><span class="line">ss src 192.168.119.103</span><br><span class="line">ss src 192.168.119.103:http</span><br><span class="line">ss src 192.168.119.103:80</span><br><span class="line">ss src 192.168.119.103:smtp</span><br><span class="line">ss src 192.168.119.103:25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地或者远程端口和一个数比较</span></span><br><span class="line">ss dport OP PORT </span><br><span class="line">ss sport OP PORT</span><br><span class="line"></span><br><span class="line"><span class="comment"># ss dport OP PORT 远程端口和一个数比较；</span></span><br><span class="line"><span class="comment"># ss sport OP PORT 本地端口和一个数比较。</span></span><br><span class="line">OP 可以代表以下任意一个: </span><br><span class="line">&lt;= or le : 小于或等于端口号</span><br><span class="line">&gt;= or ge : 大于或等于端口号</span><br><span class="line">== or eq : 等于端口号</span><br><span class="line">!= or ne : 不等于端口号</span><br><span class="line">&lt; or gt : 小于端口号</span><br><span class="line">&gt; or lt : 大于端口号</span><br><span class="line"></span><br><span class="line"><span class="comment"># ss 和 netstat 效率对比</span></span><br><span class="line">time netstat -at</span><br><span class="line">time ss</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://man.linuxde.net/ss">ss命令</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/03/11/2953420.html">每天一个linux命令（57）：ss命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-sed%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-sed%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux sed命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 10:18:17" itemprop="dateCreated datePublished" datetime="2021-03-29T10:18:17+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux 三剑客，它们是 grep、awk、sed。</p>
<p>sed 全名叫 <code>stream editor</code>，流编辑器，用程序的方式来编辑文本，与 vim 的交互式编辑方式截然不同。它的功能十分强大，加上正则表达式的支持，可以进行大量的复杂文本的编辑操作。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/29/Linux-sed%E5%91%BD%E4%BB%A4/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-wc%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-wc%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux wc命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 10:01:16" itemprop="dateCreated datePublished" datetime="2021-03-29T10:01:16+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux wc 命令用于计算字数。利用 <code>wc</code> 指令可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则 <code>wc</code> 指令会从标准输入设备读取数据。</p>
<p>语法 <code>wc [-clw][--help][--version][文件...]</code></p>
<p>参数：</p>
<ul>
<li>-c或–bytes或–chars 只显示Bytes数。</li>
<li>-l或–lines 显示行数。</li>
<li>-w或–words 只显示字数。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<p>实例</p>
<p>在默认的情况下，wc将计算指定文件的 行数、字数，以及字节数。使用的命令为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testfile文件的统计信息</span></span><br><span class="line">wc testfile</span><br><span class="line">3 92 598 testfile  <span class="comment"># testfile文件的行数为3、单词数92、字节数598 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#统计三个文件的信息</span></span><br><span class="line">wc testfile testfile_1 testfile_2</span><br><span class="line">3 92 598 testfile                    <span class="comment">#第一个文件行数为3、单词数92、字节数598  </span></span><br><span class="line">9 18 78 testfile_1                   <span class="comment">#第二个文件的行数为9、单词数18、字节数78  </span></span><br><span class="line">3 6 32 testfile_2                    <span class="comment">#第三个文件的行数为3、单词数6、字节数32  </span></span><br><span class="line">15 116 708 总用量                    <span class="comment">#三个文件总共的行数为15、单词数116、字节数708 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行数</span></span><br><span class="line">wc -l</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-Head%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-Head%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux Head命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 09:56:55" itemprop="dateCreated datePublished" datetime="2021-03-29T09:56:55+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>head</code> 命令可用于查看文件的开头部分的内容，有一个常用的参数 <code>-n</code> 用于显示行数，默认为 <code>10</code>，即显示 <code>10</code> 行的内容。</p>
<p>命令格式：<code>head [参数] [文件]</code></p>
<p>参数：</p>
<ul>
<li>-q 隐藏文件名</li>
<li>-v 显示文件名</li>
<li>-c&lt;数目&gt; 显示的字节数。</li>
<li>-n&lt;行数&gt; 显示的行数。</li>
</ul>
<p>实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 15 1.log</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/25/Linux-rlogin%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/Linux-rlogin%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux rlogin命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 13:33:02" itemprop="dateCreated datePublished" datetime="2021-03-25T13:33:02+00:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux rlogin命令用于远端登入。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>rlogin [-8EL][-e &lt;脱离字符&gt;][-l &lt;用户名称&gt;][主机名称或IP地址]</p>
<p><strong>必要参数：</strong></p>
<ul>
<li>-E 忽略escape字符</li>
<li>-8 只识别8位字的字符</li>
<li>-L 允许rlogin会话运行在litout模式</li>
<li>-ec 设置escape字符为c</li>
<li>-c 断开连接前要求确认</li>
<li>-a 强制要求远程主机在发送完一个空的本地用户名之后请求一个密码</li>
<li>-f 向远端主机发送一个本地认证</li>
<li>-F 向远程主机发送一个可转寄的本地认证</li>
<li>-7 强制执行7为的传输</li>
<li>-d 打开用于远端主机通信的TCP套接口的调试</li>
<li>-k 要求包含远端主机的tisckets</li>
<li>-x 启动数据传输的DES加密</li>
<li>-4 只使用 kerkberos的版本4的认证</li>
</ul>
<p><strong>选择参数：</strong></p>
<ul>
<li>-e&lt;字符&gt;  设置退出字符</li>
<li>-l&lt;用户&gt;  指定登陆的用户</li>
<li>-t&lt;终端类型&gt; 设置终端类型</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>显示rlogin服务是否开启</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list //检测rlogin服务是否开启</span><br></pre></td></tr></table></figure>

<p>开启rlogin服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rlogin on //开启rlogin服务</span><br></pre></td></tr></table></figure>

<p>登陆远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rlogin 192.168.1.88</span><br><span class="line">Password：</span><br><span class="line">Password：</span><br><span class="line">Login incorrect (不准确)</span><br></pre></td></tr></table></figure>

<p>指定用户名登陆远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rlogin 192.125.30.112 -l root</span><br><span class="line"></span><br><span class="line">Passord:</span><br><span class="line">Last login：Mon May 25 13：40:25 from 192.125.30.112</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-rlogin.html">Linux rlogin命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/25/Linux-ar%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/Linux-ar%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux ar命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 09:37:23" itemprop="dateCreated datePublished" datetime="2021-03-25T09:37:23+00:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux ar命令用于建立或修改备存文件，或是从备存文件中抽取文件。</p>
<p>ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</p>
<p>参数：</p>
<p>必要参数：</p>
<ul>
<li>-d 　删除备存文件中的成员文件。</li>
<li>-m 　变更成员文件在备存文件中的次序。</li>
<li>-p 　显示备存文件中的成员文件内容。</li>
<li>-q 　将文件附加在备存文件末端。</li>
<li>-r 　将文件插入备存文件中。</li>
<li>-t 　显示备存文件中所包含的文件。</li>
<li>-x 　自备存文件中取出成员文件。</li>
</ul>
<p>选项参数：</p>
<ul>
<li>a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。</li>
<li>b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</li>
<li>c 　建立备存文件。</li>
<li>f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。</li>
<li>i&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</li>
<li>o 　保留备存文件中文件的日期。</li>
<li>s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</li>
<li>S 　不产生符号表。</li>
<li>u 　只将日期较新文件插入备存文件中。</li>
<li>v 　程序执行时显示详细的信息。</li>
<li>V 　显示版本信息。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>打包文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls   //显示当前目录文件   </span></span><br><span class="line">a.c    b.c d.c   install.log      qte</span><br><span class="line">anaconda-ks.cfg c.c Desktop </span><br><span class="line"></span><br><span class="line"><span class="comment"># ar rv one.bak a.c b.c //打包 a.c b.c文件 </span></span><br><span class="line">ar: 正在创建 one.bak</span><br><span class="line">a - a.c</span><br><span class="line">a - b.c</span><br></pre></td></tr></table></figure>

<ul>
<li>打包多个文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar rv two.bak *.c  //打包以.c结尾的文件  </span></span><br><span class="line">ar: 正在创建 two.bak</span><br><span class="line">a - a.c</span><br><span class="line">a - b.c</span><br><span class="line">a - c.c</span><br><span class="line">a - d.c</span><br></pre></td></tr></table></figure>

<ul>
<li>显示打包文件的内容</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar t two.bak    </span></span><br><span class="line">a.c</span><br><span class="line">b.c</span><br><span class="line">c.c</span><br><span class="line">d.c</span><br></pre></td></tr></table></figure>

<ul>
<li>删除打包文件的成员文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar d two.bak a.c b.c c.c  </span></span><br><span class="line"><span class="comment"># ar t two.bak       </span></span><br><span class="line">d.c</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-ar.html">Linux ar命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/24/ELF-%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/ELF-%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">ELF格式文件解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 15:13:06" itemprop="dateCreated datePublished" datetime="2021-03-24T15:13:06+00:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ELF/" itemprop="url" rel="index"><span itemprop="name">ELF</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象文件-Object-files-分类"><a href="#对象文件-Object-files-分类" class="headerlink" title="对象文件(Object files)分类"></a>对象文件(Object files)分类</h2><h3 id="一，可重定位的对象文件-Relocatable-file"><a href="#一，可重定位的对象文件-Relocatable-file" class="headerlink" title="一，可重定位的对象文件(Relocatable file)"></a>一，可重定位的对象文件(Relocatable file)</h3><p>&emsp;&emsp;由汇编器汇编生成的 <code>.o</code> 文件。后面的链接器(link editor)拿一个或一些 Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。可以使用 <code>ar</code> 工具将众多的 <code>.o</code> (Relocatable object files) 归档(archive)成 <code>.a</code> 静态库文件。内核可加载模块 <code>.ko</code> 文件也是 Relocatable object file。</p>
<h3 id="二，可执行的对象文件-Executable-file"><a href="#二，可执行的对象文件-Executable-file" class="headerlink" title="二，可执行的对象文件(Executable file)"></a>二，可执行的对象文件(Executable file)</h3><p>&emsp;&emsp;文本编辑器vi、调式用的工具gdb、播放mp3歌曲的软件mplayer等等都是 Executable object file。在 Linux 系统里面，存在两种可执行的东西。除了 Executable object file，另外一种就是可执行的脚本(如shell脚本)。注意这些脚本不是 Executable object file，它们只是文本文件，但是执行这些脚本所用的解释器就是 Executable object file，比如 bash shell 程序。</p>
<h3 id="三，可被共享的对象文件-Shared-object-file"><a href="#三，可被共享的对象文件-Shared-object-file" class="headerlink" title="三，可被共享的对象文件(Shared object file)"></a>三，可被共享的对象文件(Shared object file)</h3><p>&emsp;&emsp;可被共享的对象文件，即 动态库文件，也即 <code>.so</code> 文件。</p>
<p>动态库在发挥作用的过程中，必须经过两个步骤：</p>
<ul>
<li>a) 链接编辑器(link editor)拿它和其他 Relocatable object file 以及其他 shared object file 作为输入，经链接处理后，生存另外的 shared object file 或者 executable file。</li>
<li>b) 在运行时，动态链接器(dynamic linker)拿它和一个 Executable file 以及另外一些 Shared object file 来一起处理，在 Linux 系统里面创建一个进程映像。</li>
</ul>
<h2 id="gcc翻译过程"><a href="#gcc翻译过程" class="headerlink" title="gcc翻译过程"></a>gcc翻译过程</h2><p><img src="/img/20170611205306090.png" alt="20170611205306090.png"></p>
<p>在Unix系统中，从源文件到可执行目标文件是由编译驱动程序完成的，如大名鼎鼎的gcc，翻译过程包括图中的是个阶段；</p>
<p><strong>一，预处理阶段</strong></p>
<p>预处理器（cpp）根据以字符#开头的命令修给原始的C程序，结果得到另一个C程序，通常以.i作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。</p>
<p>对应的命令：<code>linux&gt; gcc -E hello.c hello.i</code></p>
<p><strong>二，编译阶段</strong></p>
<p>编译器将文本文件hello.i翻译成hello.s，包含相应的汇编语言程序</p>
<p>对应的命令：<code>linux&gt; gcc -S hello.c hello.s</code></p>
<p><strong>三，汇编阶段</strong></p>
<p>将.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件.o中(把汇编语言翻译成机器语言的过程)。</p>
<p>把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。</p>
<p>对应的命令：<code>linux&gt; gcc -c hello.c hello.o</code></p>
<p><strong>四，链接阶段</strong></p>
<p>&emsp;&emsp;此时hello程序调用了 printf 函数。 printf 函数存在于一个名为printf.o的单独的预编译目标文件中。 链接器（ld）就负责处理把这个文件并入到 hello.o 程序中，结果得到 hell.o 文件，一个可执行文件。最后可执行文件加载到储存器后由系统负责执行。</p>
<p>函数库一般分为静态库和动态库两种。</p>
<ul>
<li>静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为 <code>.a</code>。</li>
<li>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为 <code>.so</code>，gcc 在编译时默认使用动态库。</li>
</ul>
<h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><p>&emsp;&emsp;ELF 全称 <code>Executable and Linkable Format</code>，可执行可链接文件格式，目前常见的 Linux、 Android 可执行文件、共享库（<code>.so</code>）、目标文件（<code>.o</code>）以及Core 文件（吐核）均为此格式。</p>
<p>&emsp;&emsp;ELF 文件由4部分组成，分别是 ELF 头（ELF header）、程序头表（Program header table）、节（Section）和节区头部表（Section header table）。ELF 头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p>
<p><img src="/img/20160521110158483.png" alt="20160521110158483.png"></p>
<ul>
<li>ELF header： 描述整个文件的组织。</li>
<li>Program Header Table: 描述文件中的各种 segments，用来告诉系统如何创建进程映像的。</li>
<li>sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。</li>
<li>Section Header Table: 包含了文件各个segction的属性信息。</li>
</ul>
<p>&emsp;&emsp;ELF 文件格式提供了两种视图，分别是链接视图和执行视图，链接视图是以节（section）为单位，执行视图是以段（segment）为单位。</p>
<p>&emsp;&emsp;在汇编器和链接器看来，ELF 文件是由 Section Header Table 描述的一系列 Section 的集合，而执行一个 ELF 文件时，在加载器（Loader）看来它是由 Program Header Table 描述的一系列Segment的集合。</p>
<p><img src="/img/elf.png" alt="elf.png"></p>
<p><strong>程序头部表</strong>（Program Header Table），如果存在的话，告诉系统如何创建进程映像。<br><strong>节区头部表</strong>（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。</p>
<p>执行命令 <code>readelf -S android_server</code> 来查看该可执行文件中有哪些section。</p>
<p><img src="/img/20160521110452230.png" alt="20160521110452230.png"></p>
<p>行命令 <code>readelf –segments android_server</code>，可以查看该文件的执行视图。</p>
<p><img src="/img/20160521110508766.png" alt="20160521110508766.png"></p>
<p><strong>segment是section的一个集合，sections按照一定规则映射到segment。为什么需要区分两种不同视图？</strong></p>
<p>&emsp;&emsp;当ELF文件被加载到内存中后，系统会将多个具有相同权限（flg值）section合并一个segment。操作系统往往以页为基本单位来管理内存分配，一般页的大小为4096B，即4KB的大小。同时，内存的权限管理的粒度也是以页为单位，页内的内存是具有同样的权限等属性，并且操作系统对内存的管理往往追求高效和高利用率这样的目标。ELF文件在被映射时，是以系统的页长度为单位的，那么每个section在映射时的长度都是系统页长度的整数倍，如果section的长度不是其整数倍，则导致多余部分也将占用一个页。而我们从上面的例子中知道，一个ELF文件具有很多的section，那么会导致内存浪费严重。这样可以减少页面内部的碎片，节省了空间，显著提高内存利用率。</p>
<h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>转载自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feglass/article/details/51469511?spm=1001.2014.3001.5501">ELF文件格式解析</a></p>
<p>32位ELF文件中常用的数据格式：</p>
<p><img src="/img/20160521110646983.png" alt="20160521110646983.png"></p>
<p><code>readelf -h android_server</code> 命令，可以看到 ELF Header 结构的内容:</p>
<p><img src="/img/20160521110756954.png" alt="20160521110756954.png"></p>
<p>对比以下三类ELF文件，我们得到了以下结论：<br>（1）e_type标识了文件类型<br>（2）Relocatable File（.o文件）不需要执行，因此e_entry字段为0，且没有Program Header Table等执行视图<br>（3）不同类型的ELF文件的Section也有较大区别，比如只有Relocatable File有.strtab节。 </p>
<p>(1) Shared Object File（.so文件）:<br><img src="/img/20160521110949018.png" alt="20160521110949018.png"></p>
<p>(2) Executable File（可执行文件android_server）:</p>
<p><img src="/img/20160521111008408.png" alt="20160521111008408.png"></p>
<p>(3) Relocatable File（.o文件）:</p>
<p><img src="/img/20160521111020956.png" alt="20160521111020956.png"></p>
<p>在 ELF Header 中需要重点关注以下几个字段：</p>
<ul>
<li>1，e_entry：程序入口地址<br>这个 sum.o 的进入点是 0x0(e_entry)，这表面Relocatable objects不会有程序进入点。所谓程序进入点是指当程序真正执行起来的时候，其第一条要运行的指令的运行时地址。因为Relocatable objects file只是供再链接而已，所以它不存在进入点。而可执行文件test和动态库.so都存在所谓的进入点，且可执行文件的 e_entry 指向C库中的_start，而动态库.so中的进入点指向 call_gmon_start。<br>如上图中 e_entry = 0xD8B0 (Executable File 文件)，我们用ida打开该文件看到确实是 _start() 函数的地址。</li>
</ul>
<p><img src="/img/20160521111227521.png" alt="20160521111227521.png"></p>
<ul>
<li>2，e_ehsize：ELF Header结构大小</li>
<li>3，e_phoff、e_phentsize、e_phnum：描述Program Header Table的偏移、大小、结构。</li>
<li>4，e_shoff、e_shentsize、e_shnum：描述Section Header Table的偏移、大小、结构。</li>
<li>5，e_shstrndx：这一项描述的是字符串表在 Section Header Table 中的索引，值25表示的是 Section Header Table 中第25项是字符串表（String Table）。</li>
</ul>
<h3 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h3><p>&emsp;&emsp;一个ELF文件中到底有哪些具体的 sections，由包含在这个ELF文件中的 section head table(SHT) 决定。在SHT中，针对每一个section，都设置有一个条目（entry），用来描述对应的这个section，其内容主要包括该 section 的名称、类型、大小以及在整个ELF文件中的字节偏移位置等等。我们也可以在TISCv1.2规范中找到SHT表中条目的C结构定义：</p>
<p><img src="/img/20160521111301410.png" alt="20160521111301410.png"></p>
<p>解析 android_server 可执行ELF文件，我们可以看到 Section Header Table 中确实有23（17h (16进制表示)）个条目，且索引为22（16h(16进制表示)）确实为 section header section string table。</p>
<p><img src="/img/20160521111322394.png" alt="20160521111322394.png"></p>
<p>打开条目，我们可以看到每个 entry 的具体字段，与上图的 Elf32_Shdr 结构一致。</p>
<p><img src="/img/20160521111341347.png" alt="20160521111341347.png"></p>
<p>&emsp;&emsp;需要注意的是，sh_name 值实际上是 .shstrtab 中的索引，该string table中存储着所有section的名字。下图中蓝色部分是.shstrtab的数据，我们可以看到，sh_name实际上是从索引1开始的”.shstrtab”字符串，因此这里的sh_name值为1h。</p>
<p><img src="/img/20160521111400597.png" alt="20160521111400597.png"></p>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>下面我们分析一些so文件中重要的Section，包括符号表、重定位表、GOT表等。</p>
<p><strong>-符号表(.dynsym)</strong></p>
<p>&emsp;&emsp;符号表包含用来定位、重定位程序中符号定义和引用的信息，简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过修饰了的函数名或者变量名，不同的编译器有不同的修饰规则。例如符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。</p>
<p>符号表项的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">     Elf32_Word st_name;        <span class="comment">//符号表项名称。如果该值非0，则表示符号名的字</span></span><br><span class="line">                                   <span class="comment">//符串表索引(offset)，否则符号表项没有名称。</span></span><br><span class="line">     Elf32_Addr st_value;       <span class="comment">//符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span></span><br><span class="line">     Elf32_Word st_size;        <span class="comment">//符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;     <span class="comment">//符号的类型和绑定属性。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;    <span class="comment">//未定义。</span></span><br><span class="line">     Elf32_Half st_shndx;        <span class="comment">//每个符号表项都以和其他节区的关系的方式给出定义。</span></span><br><span class="line">　　　　　　　　　　　　　         <span class="comment">//此成员给出相关的节区头部表索引。</span></span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>通过 010Editor 解析出的符号表 .dynsym 的 section header 表项：</p>
<p><img src="/img/20160521111537942.png" alt="20160521111537942.png"></p>
<p>符号表的具体内容：</p>
<p><img src="/img/20160521111608073.png" alt="20160521111608073.png"></p>
<p><strong>-字符串表（.dynstr）</strong></p>
<p>字符串表中存放着所有符号的名称字符串。</p>
<p>字符串表的section header表项：</p>
<p><img src="/img/20160521111628840.png" alt="20160521111628840.png"></p>
<p>再看一下下图中字符串表的具体内容，我们可以看出，.dynstr和.shstrtab 结构完全相同，不过一个存储的是符号名称的字符串，而另一个是Section 名称的字符串。</p>
<p><img src="/img/20160521111652559.png" alt="20160521111652559.png"></p>
<p><strong>-重定位表</strong></p>
<p>&emsp;&emsp;重定位表在ELF文件中扮演很重要的角色，首先我们得理解重定位的概念，程序从代码到可执行文件这个过程中，要经历编译器，汇编器和链接器对代码的处理。然而编译器和汇编器通常为每个文件创建程序地址从0开始的目标代码，但是几乎没有计算机会允许从地址0加载你的程序。如果一个程序是由多个子程序组成的，那么所有的子程序必需要加载到互不重叠的地址上。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。简单的言之，则是将程序中的各个部分映射到合理的地址上来。</p>
<p>&emsp;&emsp;换句话来说，重定位是将符号引用与符号定义进行连接的过程。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。<br>具体来说，就是把符号的value进行重新定位。</p>
<p>可重定位文件必须包含如何修改其节区内容的信息，从而允许可执行文件和共享目标文件保存进程的程序映象的正确信息。这就是重定位表项做的工作。重定位表项的格式如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    Elf32_Addr r_offset;     <span class="comment">//重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span></span><br><span class="line">    Elf32_Word r_info;       <span class="comment">//要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span></span><br><span class="line">                                         <span class="comment">//其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span></span><br><span class="line">&#125; Elf32_Rel; </span><br></pre></td></tr></table></figure>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Addr r_offset;  </span><br><span class="line">    Elf32_Word r_info;  </span><br><span class="line">    Elf32_Word r_addend;</span><br><span class="line"> &#125; Elf32_Rela; </span><br></pre></td></tr></table></figure>

<p>对 r_info 成员使用 ELF32_R_TYPE 宏运算可得到重定位类型，使用 ELF32_R_SYM 宏运算可得到符号在符号表里的索引值。 三种宏的具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(i) ((i)&gt;&gt;8) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(i) ((unsigned char)(i)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(s, t) (((s)</span></span><br></pre></td></tr></table></figure>

<p>重定位表中的内容:</p>
<p><img src="/img/20160521111838248.png" alt="20160521111838248.png"></p>
<p>以下是.rel.plt表的具体内容：</p>
<p><img src="/img/20160521111856928.png" alt="20160521111856928.png"></p>
<p>我们可以看到，每8个字节(s_entsize)一个表项。第一个表项中的r_offset值为0xc7660，r_info为0xa16。其中r_offset指向下图中GOT表中第一项__imp_clock_gettime外部函数地址。那么我们如何利用r_offset值来找到其对应的符号呢？如上所述，进行 ELF32_R_SYM宏运算实际上就是将r_info右移8位，0xa16右移8位得到0xa，因此这就是其在符号表中的索引。 </p>
<p><img src="/img/20160521111921663.png" alt="20160521111921663.png"></p>
<p>从下图中可以看见符号表的s_entsize值为10h，即16个字节每条目。因此我们可以找到其索引为0xa的条目的st_name值为0x9ea。那么怎么证明我们确实找到的是clock_gettime函数的符号呢？我们再来看一下st_name值是不是正确的。</p>
<p><img src="/img/20160521111941390.png" alt="20160521111941390.png"></p>
<p>st_name值表示的是符号名字符串中的第一个字符在字符串表中的偏移量，因此我们用0x9ea加上符号表的起始位置(0x7548)就能得到该字符串在‭0x7F32位置。如下图所示:</p>
<p><img src="/img/20160521112219618.png" alt="20160521112219618.png"></p>
<p><strong>-常见的重定位表类型：</strong></p>
<ul>
<li><p>.rel.text：重定位的地方在.text段内，以offset指定具体要定位位置。在链接时候由链接器完成。.rel.text属于普通重定位辅助段 ,他由编译器编译产生，存在于obj文件内。连接器连接时，他用于最终可执行文件或者动态库的重定位。通过它修改原obj文件的.text段后，合并到最终可执行文件或者动态文件的.text段。其类型一般为R_386_32和R_386_PC32。</p>
</li>
<li><p>.rel.dyn：重定位的地方在.got段内。主要是针对外部数据变量符号。例如全局数据。重定位在程序运行时定位，一般是在.init段内。定位过程：获得符号对应value后，根据rel.dyn表中对应的offset，修改.got表对应位置的value。另外，.rel.dyn 含义是指和dyn有关，一般是指在程序运行时候，动态加载。区别于rel.plt，rel.plt是指和plt相关，具体是指在某个函数被调用时候加载。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。</p>
</li>
<li><p>.rel.dyn和.rel.plt是动态定位辅助段。由连接器产生，存在于可执行文件或者动态库文件内。借助这两个辅助段可以动态修改对应.got和.got.plt段，从而实现运行时重定位。</p>
</li>
<li><p>.rel.plt：重定位的地方在.got.plt段内（注意也是.got内,具体区分而已）。 主要是针对外部函数符号。一般是函数首次被调用时候重定位。首次调用时会重定位函数地址，把最终函数地址放到.got内，以后读取该.got就直接得到最终函数地址。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。</p>
</li>
<li><p>.plt段（过程链接表）：所有外部函数调用都是经过一个对应桩函数，这些桩函数都在.plt段内。具体调用外部函数过程是：<br>调用对应桩函数—&gt;桩函数取出.got表表内地址—&gt;然后跳转到这个地址.如果是第一次,这个跳转地址默认是桩函数本身跳转处地址的下一个指令地址(目的是通过桩函数统一集中取地址和加载地址),后续接着把对应函数的真实地址加载进来放到.got表对应处,同时跳转执行该地址指令.以后桩函数从.got取得地址都是真实函数地址了。<br>下图是.plt某表项，它包含了取.got表地址和跳转执行两条指令。</p>
</li>
</ul>
<p><img src="/img/20160521112646041.png" alt="20160521112646041.png"></p>
<ul>
<li>.got（全局偏移表）</li>
</ul>
<h3 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h3><p>&emsp;&emsp;程序头部（Program Header）描述与程序执行直接相关的目标文件结构信息。用来在文件中定位各个段的映像。同时包含其他一些用来为程序创建映像所必须的信息。<br>可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段或者系统准备程序执行所必须的其他信息。目标文件的 “段” 包含一个或者多个 “节区”，也就是 “段内容（Segment Contents）”。程序头部仅对可执行文件和共享目标文件有意义。</p>
<p>程序头部的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    Elf32_Word p_type;           <span class="comment">//此数组元素描述的段的类型，或者如何解释此数组元素的信息。 </span></span><br><span class="line">    Elf32_Off  p_offset;           <span class="comment">//此成员给出从文件头到该段第一个字节的偏移</span></span><br><span class="line">    Elf32_Addr p_vaddr;         <span class="comment">//此成员给出段的第一个字节将被放到内存中的虚拟地址</span></span><br><span class="line">    Elf32_Addr p_paddr;        <span class="comment">//此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。</span></span><br><span class="line">    Elf32_Word p_filesz;         <span class="comment">//此成员给出段在文件映像中所占的字节数。可以为0。</span></span><br><span class="line">    Elf32_Word p_memsz;     <span class="comment">//此成员给出段在内存映像中占用的字节数。可以为0。</span></span><br><span class="line">    Elf32_Word p_flags;         <span class="comment">//此成员给出与段相关的标志。</span></span><br><span class="line">    Elf32_Word p_align;        <span class="comment">//此成员给出段在文件中和内存中如何对齐。</span></span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>

<p>我们看到，以下两个工具确实是照此格式解析的:</p>
<p><img src="/img/20160521112705213.png" alt="20160521112705213.png"></p>
<p><img src="/img/20160521112720713.png" alt="20160521112720713.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mergerly/article/details/94585901">ELF文件格式解析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/daide2012/article/details/73065204">ELF文件详解—初步认识</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.virbox.com/?p=119">ELF 格式详解（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/feglass/article/details/51469511?spm=1001.2014.3001.5501">ELF文件格式解析</a></p>
<p><a target="_blank" rel="noopener" href="http://www.choudan.net/2013/10/25/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0%28%E4%BA%8C%29.html">Linux进程地址空间学习(二)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/24/Linux-readelf%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/Linux-readelf%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux readelf命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 15:01:06" itemprop="dateCreated datePublished" datetime="2021-03-24T15:01:06+00:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>&emsp;&emsp;readelf 命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的elf-file(s)就表示那些被检查的文件。可以支持32位，64位的elf格式文件，也支持包含elf文件的文档（这里一般指的是使用ar命令将一些elf文件打包之后生成的例如lib*.a之类的 “静态库” 文件）。</p>
<p>&emsp;&emsp;常见的文件如在Linux上的可执行文件，动态库(<em>.so)或者静态库(</em>.a) 等包含ELF格式的文件。以下命令的使用是基于android编译出来的so文件上面去运行。</p>
<p>运行 readelf 的时候，除了-v 和 -H 之外，其它的选项必须有一个被指定。 </p>
<p>选项</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">-a </span><br><span class="line">--all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I. </span><br><span class="line"></span><br><span class="line">-h </span><br><span class="line">--file-header 显示elf文件开始的文件头信息. </span><br><span class="line"></span><br><span class="line">-l </span><br><span class="line">--program-headers  </span><br><span class="line">--segments 显示程序头（段头）信息(如果有的话)。 </span><br><span class="line"></span><br><span class="line">-S </span><br><span class="line">--section-headers  </span><br><span class="line">--sections 显示节头信息(如果有的话)。 </span><br><span class="line"></span><br><span class="line">-g </span><br><span class="line">--section-groups 显示节组信息(如果有的话)。 </span><br><span class="line"></span><br><span class="line">-t </span><br><span class="line">--section-details 显示节的详细信息(-S的)。 </span><br><span class="line"></span><br><span class="line">-s </span><br><span class="line">--syms        </span><br><span class="line">--symbols 显示符号表段中的项（如果有的话）。 </span><br><span class="line"></span><br><span class="line">-e </span><br><span class="line">--headers 显示全部头信息，等价于: -h -l -S </span><br><span class="line"></span><br><span class="line">-n </span><br><span class="line">--notes 显示note段（内核注释）的信息。 </span><br><span class="line"></span><br><span class="line">-r </span><br><span class="line">--relocs 显示可重定位段的信息。 </span><br><span class="line"></span><br><span class="line">-u </span><br><span class="line">--unwind 显示unwind段信息。当前只支持IA64 ELF的unwind段信息。 </span><br><span class="line"></span><br><span class="line">-d </span><br><span class="line">--dynamic 显示动态段的信息。 </span><br><span class="line"></span><br><span class="line">-V </span><br><span class="line">--version-info 显示版本段的信息。 </span><br><span class="line"></span><br><span class="line">-A </span><br><span class="line">--arch-specific 显示CPU构架信息。 </span><br><span class="line"></span><br><span class="line">-D </span><br><span class="line">--use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 </span><br><span class="line"></span><br><span class="line">-x &lt;number or name&gt; </span><br><span class="line">--hex-dump=&lt;number or name&gt; 以16进制方式显示指定段内内容。number指定段表中段的索引,或字符串指定文件中的段名。 </span><br><span class="line"></span><br><span class="line">-w[liaprmfFsoR] or </span><br><span class="line">--debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges] 显示调试段中指定的内容。 </span><br><span class="line"></span><br><span class="line">-I </span><br><span class="line">--histogram 显示符号的时候，显示bucket list长度的柱状图。 </span><br><span class="line"></span><br><span class="line">-v </span><br><span class="line">--version 显示readelf的版本信息。 </span><br><span class="line"></span><br><span class="line">-H </span><br><span class="line">--<span class="built_in">help</span> 显示readelf所支持的命令行选项。 </span><br><span class="line"></span><br><span class="line">-W </span><br><span class="line">--wide 宽行输出。 </span><br><span class="line"></span><br><span class="line">@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。 </span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>读取可执行文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h main </span><br></pre></td></tr></table></figure>

<ul>
<li>读取目标文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h myfile.o </span><br></pre></td></tr></table></figure>

<ul>
<li>读取静态库文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h libmy.a </span><br></pre></td></tr></table></figure>

<ul>
<li>读取动态库文件形式的elf文件头信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -h libmy.so </span><br></pre></td></tr></table></figure>

<ul>
<li>查看可执行的elf文件程序头表信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l main </span><br></pre></td></tr></table></figure>

<ul>
<li>查看目标文件的elf文件程序头表信息： </li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l myfile.o </span><br></pre></td></tr></table></figure>

<ul>
<li>查看静态库文件的elf文件程序头表信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l libmy.a </span><br></pre></td></tr></table></figure>

<ul>
<li>查看动态库文件的elf文件程序头表信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l libmy.so </span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个可执行的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S main</span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个包含调试信息的可执行的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S main.debug </span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个目标文件的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S myfile.o</span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个静态库文件的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S libmy.a </span><br></pre></td></tr></table></figure>

<ul>
<li>查看一个动态库文件的elf文件的节信息：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -S libmy.so </span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://man.linuxde.net/readelf">readelf命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/22/IDEA%E5%88%9B%E5%BB%BAMapper%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/IDEA%E5%88%9B%E5%BB%BAMapper%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">IDEA创建Mapper文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 14:47:29" itemprop="dateCreated datePublished" datetime="2021-03-22T14:47:29+00:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IDEA/" itemprop="url" rel="index"><span itemprop="name">IDEA</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在设置中添加：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322145045.png" alt="微信截图_20210322145045.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322144935.png" alt="微信截图_20210322144935.png"></p>
<p>模版内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322145748.png" alt="微信截图_20210322145748.png"></p>
<p>检验：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210322145835.png" alt="微信截图_20210322145835.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/19/Spring-Boot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/19/Spring-Boot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/" class="post-title-link" itemprop="url">Spring Boot常用注解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-19 15:23:57" itemprop="dateCreated datePublished" datetime="2021-03-19T15:23:57+00:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring-Boot/" itemprop="url" rel="index"><span itemprop="name">Spring Boot</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用注解的优势：<br>1.采用纯java代码，不在需要配置繁杂的xml文件<br>2.在配置中也可享受面向对象带来的好处<br>3.类型安全对重构可以提供良好的支持<br>4.减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</p>
<h2 id="启动注解-SpringBootApplication"><a href="#启动注解-SpringBootApplication" class="headerlink" title="启动注解@SpringBootApplication"></a>启动注解@SpringBootApplication</h2><p>&emsp;&emsp;<code>@SpringBootApplication</code> 是一个复合注解，包含了 <code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code> 这三个注解。</p>
<h3 id="SpringBootConfiguration注解，继承-Configuration注解，主要用于加载配置文件"><a href="#SpringBootConfiguration注解，继承-Configuration注解，主要用于加载配置文件" class="headerlink" title="@SpringBootConfiguration注解，继承@Configuration注解，主要用于加载配置文件"></a>@SpringBootConfiguration注解，继承@Configuration注解，主要用于加载配置文件</h3><p>&emsp;&emsp;<code>@SpringBootConfiguration</code> 和 <code>@Configuration</code> 二者功能一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以 <code>@Bean</code> 注解标记的方法的实例纳入到 <code>Spring</code> 容器中，并且实例名就是方法名。</p>
<p><code>@Configuration</code>：等同于 <code>Spring</code> 的XML配置文件；使用Java代码可以检查类型安全。</p>
<h3 id="EnableAutoConfiguration注解，开启自动配置功能"><a href="#EnableAutoConfiguration注解，开启自动配置功能" class="headerlink" title="@EnableAutoConfiguration注解，开启自动配置功能"></a>@EnableAutoConfiguration注解，开启自动配置功能</h3><p>&emsp;&emsp;<code>@EnableAutoConfiguration</code>可以帮助 <code>SpringBoot</code> 应用将所有符合条件的 <code>@Configuration</code> 配置都加载到当前 <code>SpringBoot</code> 创建并使用的IoC容器。借助于 <code>Spring</code> 框架原有的一个工具类：<code>SpringFactoriesLoader</code> 的支持，<code>@EnableAutoConfiguration</code> 可以智能的自动配置功效才得以大功告成</p>
<h3 id="ComponentScan注解，主要用于组件扫描和自动装配"><a href="#ComponentScan注解，主要用于组件扫描和自动装配" class="headerlink" title="@ComponentScan注解，主要用于组件扫描和自动装配"></a>@ComponentScan注解，主要用于组件扫描和自动装配</h3><p>&emsp;&emsp;<code>@ComponentScan</code> 的功能其实就是自动扫描并加载符合条件的组件或bean定义，最终将这些bean定义加载到容器中。我们可以通过 <code>basePackages</code> 等属性指定 <code>@ComponentScan</code> 自动扫描的范围，如果不指定，则默认 <code>Spring</code> 框架实现从声明 <code>@ComponentScan</code> 所在类的 <code>package</code> 进行扫描，默认情况下是不指定的，所以 <code>SpringBoot</code> 的启动类最好放在 <code>root package</code>下。</p>
<h2 id="Controller-相关注解"><a href="#Controller-相关注解" class="headerlink" title="Controller 相关注解"></a>Controller 相关注解</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>用于定义控制器类，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解 <code>@RequestMapping</code>。</p>
<h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p><code>@ResponseBody</code>：表示该方法的返回结果直接写入 <code>HTTP response body</code> 中，一般在异步获取数据时使用，用于构建 <code>RESTful</code> 的 <code>api</code>。在使用 <code>@RequestMapping</code> 后，返回值通常解析为跳转路径，加上 <code>@Responsebody</code> 后返回结果不会被解析为跳转路径，而是直接写入 <code>HTTP response body</code> 中。比如异步获取json数据，加上 <code>@Responsebody</code> 后，会直接返回json数据。该注解一般会配合<code>@RequestMapping</code>一起使用。</p>
<h3 id="RestController-复合注解"><a href="#RestController-复合注解" class="headerlink" title="@RestController 复合注解"></a>@RestController 复合注解</h3><p>用于标注控制层组件(如struts中的action)，<code>@ResponseBody</code> 和 <code>@Controller</code> 的合集，<code>@RestController</code> 效果是将方法返回的对象直接在浏览器上展示成json格式。</p>
<h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>通过 <code>HttpMessageConverter</code> 读取 <code>Request Body</code> 并反序列化为 Object 对象。</p>
<p>使用 <code>@RequestBody</code> 接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p><code>@RequestMapping</code> 提供路由信息，负责URL到Controller中的具体函数的映射，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。<code>@RequestMapping</code> 用在类上可以没有，但是用在方法上必须有。</p>
<h3 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h3><p>将 <code>HTTP Get</code> 请求映射到特定处理程序的方法注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/go&quot;,method = RequestMethod.GET)</span> 等价于：<span class="meta">@GetMapping(value = &quot;/go&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h3><p>将 <code>HTTP Post</code> 请求映射到特定处理程序的方法注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/go&quot;,method = RequestMethod.POST)</span> 等价于：<span class="meta">@PostMapping(value = &quot;/go&quot;)</span></span><br></pre></td></tr></table></figure>

<h2 id="请求参数值"><a href="#请求参数值" class="headerlink" title="请求参数值"></a>请求参数值</h2><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p><code>@PathVariable</code>：接收请求路径中占位符的值。</p>
<p>注意：<code>@RequestMapping</code> 与 <code>@PathVariable</code> 中的值必须保持一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 占位符映射</span></span><br><span class="line"><span class="comment"> * 语法：<span class="doctag">@RequestMapping</span>(value=”user/&#123;userId&#125;/&#123;userName&#125;”)</span></span><br><span class="line"><span class="comment"> * 请求路径：http://localhost:8080/springboot/show/1/wang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> names</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;show/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long ids ,<span class="meta">@PathVariable(&quot;name&quot;)</span> String names)</span></span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;占位符映射：id:&quot;</span>+ids+<span class="string">&quot;;name:&quot;</span>+names);</span><br><span class="line">    mv.setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p><code>@RequestParam</code>：获取请求参数的值</p>
<p>常用来处理简单类型的绑定，通过 <code>Request.getParameter()</code> 获取的 <code>String</code> 可直接转换为简单类型的情况（String–&gt; 简单类型的转换操作由 <code>ConversionService</code> 配置的转换器来完成）；因为使用 <code>request.getParameter()</code> 方式获取参数，所以可以处理 <code>get</code> 方式中<code>queryString</code>的值，也可以处理 <code>post</code>方式中 <code>body data</code> 的值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求示例：/getUser?uid=123</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(<span class="meta">@RequestParam(&quot;uid&quot;)</span>Integer id, Model model)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p>把 <code>Request</code> 请求 <code>header</code> 部分的值绑定到方法的参数上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test1&quot;)</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="keyword">long</span> keepAlive)</span>  </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p>把 <code>Request header</code> 中关于 <code>cookie</code> 的值绑定到方法的参数上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test1&quot;)</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="meta">@CookieValue(&quot;UserInfo&quot;)</span> String cookie)</span>  </span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注入bean"><a href="#注入bean" class="headerlink" title="注入bean"></a>注入bean</h2><h3 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h3><p><code>@Repository</code>：使用 <code>@Repository</code> 注解可以确保 <code>DAO</code> 或者 <code>repositories</code> 提供异常转译，这个注解修饰的 <code>DAO</code> 或者<code>repositories</code>类会被 <code>ComponetScan</code> 发现并配置，同时也不需要为它们提供XML配置项。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h3><ul>
<li><code>@Service</code> 是 <code>@Component</code> 注解的一个特例，作用在类上</li>
<li><code>@Service</code> 注解作用域默认为单例</li>
<li>使用注解配置和类路径扫描时，被 <code>@Service</code> 注解标注的类会被 <code>Spring</code> 扫描并注册为 <code>Bean</code></li>
<li><code>@Service</code> 用于标注服务层组件,表示定义一个 <code>bean</code></li>
<li><code>@Service</code> 使用时没有传参数，<code>Bean</code> 名称默认为当前类的类名，首字母小写</li>
<li><code>@Service(&quot;serviceBeanId&quot;)</code> 或 <code>@Service(value=&quot;serviceBeanId&quot;)</code> 使用时传参数，使用 <code>value</code> 作为 <code>Bean</code> 名字</li>
</ul>
<h3 id="Scope作用域"><a href="#Scope作用域" class="headerlink" title="@Scope作用域"></a>@Scope作用域</h3><p><code>@Scope</code> 作用在类上和方法上，用来配置 <code>spring bean</code> 的作用域，它标识 <code>bean</code> 的作用域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  Scope &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for &#123;<span class="doctag">@link</span> #scopeName&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #scopeName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">scopeName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedProxyMode <span class="title">proxyMode</span><span class="params">()</span> <span class="keyword">default</span> ScopedProxyMode.DEFAULT</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>属性介绍</p>
<p><strong>value</strong></p>
<ul>
<li>singleton   表示该bean是单例的。(默认)</li>
<li>prototype   表示该bean是多例的，即每次使用该bean时都会新建一个对象。</li>
<li>request     在一次http请求中，一个bean对应一个实例。</li>
<li>session     在一个httpSession中，一个bean对应一个实例。</li>
</ul>
<p><strong>proxyMode</strong></p>
<ul>
<li>DEFAULT         不使用代理。(默认)</li>
<li>NO              不使用代理，等价于DEFAULT。</li>
<li>INTERFACES      使用基于接口的代理(jdk dynamic proxy)。</li>
<li>TARGET_CLASS    使用基于类的代理(cglib)。</li>
</ul>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p><code>@Table(name=&quot;&quot;)</code>：表明这是一个实体类，必须与 <code>@Id</code> 注解 结合使用,否则  <code>No identifier specified for entity:</code>。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，<code>@Table</code>可以省略。<br><code>@Table(name =&quot;数据库表名&quot;)</code>，这个注解也注释在实体类上，对应数据库中相应的表。<br><code>@Id</code>、<code>@Column</code> 注解用于标注实体类中的字段，pk字段标注为 <code>@Id</code>，其余 <code>@Column</code>。</p>
<h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>导入依赖：<code>lombok.Data</code> ,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.16</span><span class="number">.10</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><code>@Data</code>: 注解在类上, 为类提供读写属性, 此外还提供了 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 方法。</p>
<h3 id="Bean产生一个bean的方法"><a href="#Bean产生一个bean的方法" class="headerlink" title="@Bean产生一个bean的方法"></a>@Bean产生一个bean的方法</h3><p><code>@Bean</code> 明确告诉方法，产生一个 <code>Bean</code> 对象，并且交给 <code>Spring</code> 容器管理。支持别名 <code>@Bean(&quot;xx-name&quot;)</code>，产生这个 <code>Bean</code> 对象的方法 <code>Spring</code> 只会调用一次，随后这个 <code>Spring</code> 将会将这个 <code>Bean</code> 对象放在自己的IOC容器中。</p>
<h3 id="Autowired-自动导入"><a href="#Autowired-自动导入" class="headerlink" title="@Autowired 自动导入"></a>@Autowired 自动导入</h3><ul>
<li><code>@Autowired</code> 注解作用在构造函数、方法、方法参数、类字段以及注解上</li>
<li><code>@Autowired</code> 注解可以实现Bean的自动注入</li>
</ul>
<h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p>
<p>把普通 <code>pojo</code> 实例化到 <code>spring</code> 容器中。</p>
<h2 id="导入配置文件"><a href="#导入配置文件" class="headerlink" title="导入配置文件"></a>导入配置文件</h2><h3 id="PropertySource导入属性"><a href="#PropertySource导入属性" class="headerlink" title="@PropertySource导入属性"></a>@PropertySource导入属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入单个properties文件：</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath : xxxx/xxx.properties&quot;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入多个properties文件：</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath : xxxx/xxx.properties&quot;，&quot;classpath : xxxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="ImportResource导入xml配置文件"><a href="#ImportResource导入xml配置文件" class="headerlink" title="@ImportResource导入xml配置文件"></a>@ImportResource导入xml配置文件</h3><p>可以额外分为两种模式 <code>相对路径classpath</code>，<code>绝对路径file</code><br>注意：单文件可以不写 <code>value</code> 或 <code>locations</code> ，<code>value</code>和 <code>locations</code>都可用</p>
<p><strong>相对路径（classpath）</strong></p>
<ul>
<li>引入单个xml配置文件：<code>@ImportSource(&quot;classpath : xxx/xxxx.xml&quot;)</code></li>
<li>引入多个xml配置文件：<code>@ImportSource(locations=&#123;&quot;classpath : xxxx.xml&quot; , &quot;classpath : yyyy.xml&quot;&#125;)</code></li>
</ul>
<p><strong>绝对路径（file）</strong></p>
<ul>
<li>引入单个xml配置文件：<code>@ImportSource(locations= &#123;&quot;file : d:/hellxz/dubbo.xml&quot;&#125;)</code></li>
<li>引入多个xml配置文件：<code>@ImportSource(locations= &#123;&quot;file : d:/hellxz/application.xml&quot; , &quot;file : d:/hellxz/dubbo.xml&quot;&#125;)</code></li>
</ul>
<p>取值：使用 <code>@Value</code> 注解取配置文件中的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;properties中的键&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String xxx;`</span><br></pre></td></tr></table></figure>

<h3 id="Import-导入额外的配置信息"><a href="#Import-导入额外的配置信息" class="headerlink" title="@Import 导入额外的配置信息"></a>@Import 导入额外的配置信息</h3><p>功能类似XML配置的，用来导入配置类，可以导入带有 <code>@Configuration</code> 注解的配置类或实现了 <code>ImportSelector/ImportBeanDefinitionRegistrar</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import(&#123;SysConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务注解-Transactional"><a href="#事务注解-Transactional" class="headerlink" title="事务注解 @Transactional"></a>事务注解 @Transactional</h2><p>在Spring中，事务有两种实现方式，分别是编程式事务管理和声明式事务管理两种方式</p>
<ul>
<li><p>编程式事务管理： 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</p>
</li>
<li><p>声明式事务管理： 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务，通过@Transactional就可以进行事务操作，更快捷而且简单。推荐使用</p>
</li>
</ul>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><h3 id="ControllerAdvice-统一处理异常"><a href="#ControllerAdvice-统一处理异常" class="headerlink" title="@ControllerAdvice 统一处理异常"></a>@ControllerAdvice 统一处理异常</h3><p><code>@ControllerAdvice</code> 注解定义全局异常处理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ExceptionHandler-注解声明异常处理方法"><a href="#ExceptionHandler-注解声明异常处理方法" class="headerlink" title="@ExceptionHandler 注解声明异常处理方法"></a>@ExceptionHandler 注解声明异常处理方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">handleException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Exception Deal!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20957669/article/details/87686899">spring boot注解@RequestMapping、@RequestBody的详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40753536/article/details/81285046">SpringBoot注解最全详解(整合超详细版本)</a></p>
<p><a target="_blank" rel="noopener" href="https://tqlin.cn/2019/11/22/issueGather/Spring%20Boot%20%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">Spring Boot 常用注解汇总</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/18/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-Win10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/Maven%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-Win10/" class="post-title-link" itemprop="url">Maven安装配置-Win10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 09:31:05" itemprop="dateCreated datePublished" datetime="2021-03-18T09:31:05+00:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Maven/" itemprop="url" rel="index"><span itemprop="name">Maven</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载：<a target="_blank" rel="noopener" href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318093326.png" alt="微信截图_20210318093326.png"></p>
<h2 id="安装和配置环境变量"><a href="#安装和配置环境变量" class="headerlink" title="安装和配置环境变量"></a>安装和配置环境变量</h2><p>下载完成，解压 <code>E:\java\apache-maven-3.6.3</code> (需要选择路径)。</p>
<p>添加 <code>系统变量</code>：<code>MAVEN_HOME=E:\java\apache-maven-3.6.3</code>，<br>修改系统变量 <code>Path</code>：<code>Path = %MAVEN_HOME%\bin</code></p>
<p>如图：</p>
<p>MAVEN_HOME:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318094904.png" alt="微信截图_20210318094904.png"></p>
<p>Path:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318093938.png" alt="微信截图_20210318093938.png"></p>
<p>cmd 输入 <code>mvn -version</code>，输出:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318094339.png" alt="微信截图_20210318094339.png"></p>
<h2 id="配置settings文件"><a href="#配置settings文件" class="headerlink" title="配置settings文件"></a>配置settings文件</h2><p>找到 <code>E:\java\apache-maven-3.6.3\conf\settings.xml</code> 文件，定位到第52行，这里是maven默认的仓库。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318095342.png" alt="微信截图_20210318095342.png"></p>
<h3 id="修改localRepository："><a href="#修改localRepository：" class="headerlink" title="修改localRepository："></a>修改localRepository：</h3><p><code>&lt;localRepository&gt;E:/java/maven-repository&lt;/localRepository&gt;</code></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101139.png" alt="微信截图_20210318101139.png"></p>
<h3 id="修改成阿里云镜像服务器"><a href="#修改成阿里云镜像服务器" class="headerlink" title="修改成阿里云镜像服务器"></a>修改成阿里云镜像服务器</h3><p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101320.png" alt="微信截图_20210318101320.png"></p>
<h3 id="配置jdk"><a href="#配置jdk" class="headerlink" title="配置jdk"></a>配置jdk</h3><p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101409.png" alt="微信截图_20210318101409.png"></p>
<h3 id="检测配置结果"><a href="#检测配置结果" class="headerlink" title="检测配置结果"></a>检测配置结果</h3><p>cmd 输入：<code>mvn help:system</code> 测试：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101541.png" alt="微信截图_20210318101541.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318101755.png" alt="微信截图_20210318101755.png"></p>
<p><code>settings.xml</code> 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>E:/java/maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- pluginGroups</span></span><br><span class="line"><span class="comment">   | This is a list of additional group identifiers that will be searched when resolving plugins by their prefix, i.e.</span></span><br><span class="line"><span class="comment">   | when invoking a command line like &quot;mvn prefix:goal&quot;. Maven will automatically add the group identifiers</span></span><br><span class="line"><span class="comment">   | &quot;org.apache.maven.plugins&quot; and &quot;org.codehaus.mojo&quot; if these are not already contained in the list.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- pluginGroup</span></span><br><span class="line"><span class="comment">     | Specifies a further group identifier to use for plugin lookup.</span></span><br><span class="line"><span class="comment">    &lt;pluginGroup&gt;com.your.plugins&lt;/pluginGroup&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- proxies</span></span><br><span class="line"><span class="comment">   | This is a list of proxies which can be used on this machine to connect to the network.</span></span><br><span class="line"><span class="comment">   | Unless otherwise specified (by system property or command-line switch), the first proxy</span></span><br><span class="line"><span class="comment">   | specification in this list marked as active will be used.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- proxy</span></span><br><span class="line"><span class="comment">     | Specification for one proxy, to be used in connecting to the network.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;proxy&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;optional&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;active&gt;true&lt;/active&gt;</span></span><br><span class="line"><span class="comment">      &lt;protocol&gt;http&lt;/protocol&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;proxyuser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;proxypass&lt;/password&gt;</span></span><br><span class="line"><span class="comment">      &lt;host&gt;proxy.host.net&lt;/host&gt;</span></span><br><span class="line"><span class="comment">      &lt;port&gt;80&lt;/port&gt;</span></span><br><span class="line"><span class="comment">      &lt;nonProxyHosts&gt;local.net|some.host.com&lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">    &lt;/proxy&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- servers</span></span><br><span class="line"><span class="comment">   | This is a list of authentication profiles, keyed by the server-id used within the system.</span></span><br><span class="line"><span class="comment">   | Authentication profiles can be used whenever maven must make a connection to a remote server.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- server</span></span><br><span class="line"><span class="comment">     | Specifies the authentication information to use when connecting to a particular server, identified by</span></span><br><span class="line"><span class="comment">     | a unique name within the system (referred to by the &#x27;id&#x27; attribute below).</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">     | <span class="doctag">NOTE:</span> You should either specify username/password OR privateKey/passphrase, since these pairings are</span></span><br><span class="line"><span class="comment">     |       used together.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;deploymentRepo&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;username&gt;repouser&lt;/username&gt;</span></span><br><span class="line"><span class="comment">      &lt;password&gt;repopwd&lt;/password&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Another sample, using keys to authenticate.</span></span><br><span class="line"><span class="comment">    &lt;server&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;siteServer&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;privateKey&gt;/path/to/private/key&lt;/privateKey&gt;</span></span><br><span class="line"><span class="comment">      &lt;passphrase&gt;optional; leave empty if not used.&lt;/passphrase&gt;</span></span><br><span class="line"><span class="comment">    &lt;/server&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- mirrors</span></span><br><span class="line"><span class="comment">   | This is a list of mirrors to be used in downloading artifacts from remote repositories.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | It works like this: a POM may declare a repository to use in resolving certain artifacts.</span></span><br><span class="line"><span class="comment">   | However, this repository may have problems with heavy traffic at times, so people have mirrored</span></span><br><span class="line"><span class="comment">   | it to several places.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | That repository definition will have a unique id, so we can create a mirror reference for that</span></span><br><span class="line"><span class="comment">   | repository, to be used as an alternate download site. The mirror site will be the preferred</span></span><br><span class="line"><span class="comment">   | server for that repository.</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mirror</span></span><br><span class="line"><span class="comment">     | Specifies a repository mirror site to use instead of a given repository. The repository that</span></span><br><span class="line"><span class="comment">     | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used</span></span><br><span class="line"><span class="comment">     | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.</span></span><br><span class="line"><span class="comment">     |</span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">      &lt;id&gt;mirrorId&lt;/id&gt;</span></span><br><span class="line"><span class="comment">      &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">      &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">      &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt;</span></span><br><span class="line"><span class="comment">    &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 阿里云仓库 开始--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--或者 </span></span><br><span class="line"><span class="comment">    &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">        &lt;id&gt;nexus-aliyun&lt;/id&gt;</span></span><br><span class="line"><span class="comment">        &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">        &lt;name&gt;Nexus aliyun&lt;/name&gt;</span></span><br><span class="line"><span class="comment">        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line"><span class="comment">     &lt;/mirror&gt;</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 阿里云仓库 结束--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- profiles</span></span><br><span class="line"><span class="comment">   | This is a list of profiles which can be activated in a variety of ways, and which can modify</span></span><br><span class="line"><span class="comment">   | the build process. Profiles provided in the settings.xml are intended to provide local machine-</span></span><br><span class="line"><span class="comment">   | specific paths and repository locations which allow the build to work in the local environment.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | For example, if you have an integration testing plugin - like cactus - that needs to know where</span></span><br><span class="line"><span class="comment">   | your Tomcat instance is installed, you can provide a variable here such that the variable is</span></span><br><span class="line"><span class="comment">   | dereferenced during the build process to configure the cactus plugin.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | As noted above, profiles can be activated in a variety of ways. One way - the activeProfiles</span></span><br><span class="line"><span class="comment">   | section of this document (settings.xml) - will be discussed later. Another way essentially</span></span><br><span class="line"><span class="comment">   | relies on the detection of a system property, either matching a particular value for the property,</span></span><br><span class="line"><span class="comment">   | or merely testing its existence. Profiles can also be activated by JDK version prefix, where a</span></span><br><span class="line"><span class="comment">   | value of &#x27;1.4&#x27; might activate a profile when the build is executed on a JDK version of &#x27;1.4.2_07&#x27;.</span></span><br><span class="line"><span class="comment">   | Finally, the list of active profiles can be specified directly from the command line.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | <span class="doctag">NOTE:</span> For profiles defined in the settings.xml, you are restricted to specifying only artifact</span></span><br><span class="line"><span class="comment">   |       repositories, plugin repositories, and free-form properties to be used as configuration</span></span><br><span class="line"><span class="comment">   |       variables for plugins in the POM.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   |--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- activeProfiles</span></span><br><span class="line"><span class="comment">   | List of profiles that are active for all builds.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">  &lt;activeProfiles&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;alwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">    &lt;activeProfile&gt;anotherAlwaysActiveProfile&lt;/activeProfile&gt;</span></span><br><span class="line"><span class="comment">  &lt;/activeProfiles&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="IDEA配置Maven"><a href="#IDEA配置Maven" class="headerlink" title="IDEA配置Maven"></a>IDEA配置Maven</h3><p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210318102733.png" alt="微信截图_20210318102733.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/12/IP%E7%BD%91%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/IP%E7%BD%91%E5%85%B3/" class="post-title-link" itemprop="url">IP网关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-12 15:54:40" itemprop="dateCreated datePublished" datetime="2021-03-12T15:54:40+00:00">2021-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IP%E7%BD%91%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">IP网关</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;&emsp;网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p>
<p>&emsp;&emsp;由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关，在今天很多局域网采用都是路由来接入网络，因此通常指的网关就是路由器的IP。</p>
<p>&emsp;&emsp;在OSI中，网关有两种：一种是面向连接的网关，一种是无连接的网关。当两个子网之间有一定距离时，往往将一个网关分成两半，中间用一条链路连接起来，我们称之为半网关。</p>
<p>&emsp;&emsp;按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的 <code>网关</code> 均指TCP/IP协议下的网关。</p>
<p>&emsp;&emsp;网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为 <code>192.168.1.1~192. 168.1.254</code>，子网掩码为 <code>255.255.255.0</code> ；网络B的IP地址范围为 <code>192.168.2.1~192.168.2.254</code> ，子网掩码为 <code>255.255.255.0</code> 。在没有路由器的情况下，两个网络之间是不能进行 <code>TCP/IP</code> 通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（<code>255.255.255.0</code>）与主机的IP 地址作 <code>与</code> 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络A向网络B转发数据包的过程。</p>
<p>&emsp;&emsp;只有设置好网关的IP地址，<code>TCP/IP</code> 协议才能实现不同网络之间的相互通信。网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p>
<p>&emsp;&emsp;在和 Novell NetWare 网络交互操作的上下文中，网关在 Windows 网络中使用的服务器信息块 (SMB) 协议以及NetWare网络使用的 NetWare 核心协议 (NCP) 之间起着桥梁的作用。网关也被称为 IP路由器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/08/%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80/" class="post-title-link" itemprop="url">快速计算广播地址</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-08 09:31:27" itemprop="dateCreated datePublished" datetime="2021-03-08T09:31:27+00:00">2021-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>192.168.1.53/27，快速计算公式：</strong></p>
<ul>
<li>1，用32减去掩码长度：32-27 =5</li>
<li>2，计算每个子网段的步长（Step）：2^5= 32</li>
<li>3，每个子网段的前缀（Prefix）= 192.168.1</li>
<li>4，每个子网段的起始地址为步长32的整数倍：0、32、64、96、128、160、192、224</li>
</ul>
<p>看看53落在上述哪两个数中间？显然落在32与64之间，那么这个IP的网络ID = <code>192.168.1.32</code><br>广播ID = <code>192.168.1.63</code>， 63 =64-1，这里的64是下一个网络ID的起始地址，比它小1即为前一个网段的广播地址。</p>
<p><strong>192.168.129.53/18，问它的网段的起始IP、广播IP</strong></p>
<ul>
<li>1，用24减去掩码长度：24-18 = 6</li>
<li>2，计算步长：2^6= 64</li>
<li>3，每个子网段的前缀（Prefix）= 192.168</li>
<li>4，每个子网段的起始地址为步长64的整数倍：0、64、128、192</li>
</ul>
<p>看看129落在上述哪两个数中间？显然落在128与192之间，那么这个IP的网络ID = <code>192.168.128.0</code><br>广播ID = <code>192.168.191.255</code></p>
<p><font color=#ff0000 size=4 face="黑体">32,24,16 是根据掩码长度确定的。</font></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/aSKDasPUEj0u12GEV0kfJg">如何快速算出192.168.1.53/27的广播地址？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/" class="post-title-link" itemprop="url">Linux下网络丢包故障定位</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 11:34:08" itemprop="dateCreated datePublished" datetime="2021-03-01T11:34:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-08 14:31:55" itemprop="dateModified" datetime="2021-06-08T14:31:55+00:00">2021-06-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DP0F3Q7TnOixxWZ9-_KA4A">云网络丢包故障定位全景指南</a></p>
<h2 id="硬件网卡丢包"><a href="#硬件网卡丢包" class="headerlink" title="硬件网卡丢包"></a>硬件网卡丢包</h2><h3 id="Ring-Buffer溢出"><a href="#Ring-Buffer溢出" class="headerlink" title="Ring Buffer溢出"></a>Ring Buffer溢出</h3><p><img src="/img/640.png" alt="640.png"></p>
<p>如图所示，物理介质上的数据帧到达后首先由NIC（网络适配器）读取，写入设备内部缓冲区 Ring Buffer中，再由中断处理程序触发 Softirq 从中消费，Ring Buffer 的大小因网卡设备而异。当网络数据包到达（生产）的速率快于内核处理（消费）的速率时，Ring Buffer 很快会被填满，新来的数据包将被丢弃；</p>
<ol>
<li>查看：</li>
</ol>
<p>通过 ethtool 或 /proc/net/dev 可以查看因 Ring Buffer 满而丢弃的包统计，在统计项中,以fifo标识：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool -S eth0|grep rx_fifo</span><br><span class="line">rx_fifo_errors: 0</span><br><span class="line"></span><br><span class="line">$ cat /proc/net/dev</span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">  eth0: 3623955871 24771436    0    0    0     0          0         0 1876696873 11380645    0    0    0     0       0          0</span><br><span class="line">    lo: 5324832  115757    0    0    0     0          0         0  5324832  115757    0    0    0     0       0          0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看eth0网卡Ring Buffer最大值和当前设置</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -g eth0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>解决方案：修改网卡eth0接收与发送硬件缓存区大小</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -G eth0 rx 4096 tx 4096</span><br></pre></td></tr></table></figure>

<h3 id="网卡端口协商丢包"><a href="#网卡端口协商丢包" class="headerlink" title="网卡端口协商丢包"></a>网卡端口协商丢包</h3><ol>
<li>查看网卡丢包统计：<code>ethtool -S eth0</code></li>
</ol>
<p><img src="/img/640-1.png" alt="640-1.png"></p>
<ol start="2">
<li>查看网卡配置状态：<code>ethtool eth0</code></li>
</ol>
<p><img src="/img/640.webp" alt="640.webp"></p>
<p>主要查看网卡和上游网络设备协商速率和模式是否符合预期；</p>
<p>解决方案：</p>
<ol>
<li>重新自协商：<code>ethtool -r eth0</code>;</li>
<li>如果上游不支持自协商，可以强制设置端口速率：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -s eth0 speed 1000 duplex full autoneg off</span><br></pre></td></tr></table></figure>

<h3 id="网卡流控丢包"><a href="#网卡流控丢包" class="headerlink" title="网卡流控丢包"></a>网卡流控丢包</h3><ol>
<li>查看流控统计：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth1 | grep control</span><br></pre></td></tr></table></figure>

<p><img src="/img/640-2.png" alt="640-2.png"></p>
<p>rx_flow_control_xon 是在网卡的 RX Buffer 满或其他网卡内部的资源受限时，给交换机端口发送的开启流控的pause帧计数。对应的，tx_flow_control_xoff 是在资源可用之后发送的关闭流控的pause帧计数。</p>
<ol start="2">
<li>查看网络流控配置：<code>ethtool -a eth1</code></li>
</ol>
<p><img src="/img/640-3.png" alt="640-3.png"></p>
<ol start="3">
<li>解决方案：关闭网卡流控</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ethtool -A ethx autoneg off  <span class="comment"># 自协商关闭</span></span><br><span class="line">ethtool -A ethx tx off  <span class="comment"># 发送模块关闭</span></span><br><span class="line">ethtool -A ethx rx off <span class="comment"># 接收模块关闭</span></span><br></pre></td></tr></table></figure>

<h3 id="报文mac地址丢包"><a href="#报文mac地址丢包" class="headerlink" title="报文mac地址丢包"></a>报文mac地址丢包</h3><p>一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据，如果报文的目的mac地址不是对端的接口的mac地址，一般都会丢包，一般这种情况很有可能是源端设置静态arp表项或者动态学习的arp表项没有及时更新，但目的端mac地址已发生变化（换了网卡），没有更新通知到源端（比如更新报文被丢失，中间交换机异常等情况）；</p>
<p>查看： </p>
<ol>
<li>目的端抓包，tcpdump可以开启混杂模式，可以抓到对应的报文，然后查看mac地址；</li>
<li>源端查看arp表或者抓包（上一跳设备），看发送的mac地址是否和下一跳目的端的mac地址一致；</li>
</ol>
<p>解决方案：</p>
<ol>
<li>刷新arp表然后发包触发arp重新学习（可能影响其他报文，增加延时，需要小心操作）；</li>
<li>可以在源端手动设置正确的静态的arp表项；</li>
</ol>
<h3 id="其他网卡异常丢包"><a href="#其他网卡异常丢包" class="headerlink" title="其他网卡异常丢包"></a>其他网卡异常丢包</h3><p>这类异常比少见，但如果都不是上面哪些情况，但网卡统计里面仍然有丢包计数，可以试着排查一下：</p>
<h4 id="网卡firmware版本"><a href="#网卡firmware版本" class="headerlink" title="网卡firmware版本:"></a>网卡firmware版本:</h4><p>排查一下网卡phy芯片firmware是不是有bug，安装的版本是不是符合预期，查看 ethtool -i eth1:</p>
<p>eth1:</p>
<p><img src="/img/640-4.png" alt="640-4.png"></p>
<p>和厂家提case询问是不是已知问题，有没有新版本等；</p>
<h4 id="网线接触不良："><a href="#网线接触不良：" class="headerlink" title="网线接触不良："></a>网线接触不良：</h4><p>如果网卡统计里面存在crc error 计数增长，很可能是网线接触不良，可以通知网管排查一下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth0</span><br></pre></td></tr></table></figure>

<p><img src="/img/640-1.webp" alt="640-1.webp"></p>
<p>解决方案：一般试着重新插拔一下网线，或者换一根网线，排查插口是否符合端口规格等;</p>
<h4 id="报文长度丢包"><a href="#报文长度丢包" class="headerlink" title="报文长度丢包"></a>报文长度丢包</h4><p>网卡有接收正确报文长度范围，一般正常以太网报文长度范围：64-1518，发送端正常情况会填充或者分片来适配，偶尔会发生一些异常情况导致发送报文不正常丢包；</p>
<p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -S eth1|grep length_errors</span><br></pre></td></tr></table></figure>

<p><img src="/img/640-2.webp" alt="640-2.webp"></p>
<p>解决方案：</p>
<p>1  调整接口MTU配置，是否开启支持以太网巨帧；</p>
<p>2  发送端开启PATH MTU进行合理分片；</p>
<p>简单总结一下网卡丢包：</p>
<p><img src="/img/640-3.webp" alt="640-3.webp"></p>
<h2 id="网卡驱动丢包"><a href="#网卡驱动丢包" class="headerlink" title="网卡驱动丢包"></a>网卡驱动丢包</h2><p>查看：<code>ifconfig eth1/eth0</code> 等接口</p>
<p><img src="/img/640-5.png" alt="640-5.png"></p>
<ol>
<li>RX errors: 表示总的收包的错误数量，还包括too-long-frames错误，Ring Buffer 溢出错误，crc 校验错误，帧同步错误，fifo overruns 以及 missed pkg 等等。</li>
<li>RX dropped: 表示数据包已经进入了 Ring Buffer，但是由于内存不够等系统原因，导致在拷贝到内存的过程中被丢弃。</li>
<li>RX overruns: 表示了 fifo 的 overruns，这是由于 Ring Buffer(aka Driver Queue) 传输的 IO 大于 kernel 能够处理的 IO 导致的，而 Ring Buffer 则是指在发起 IRQ 请求之前的那块 buffer。很明显，overruns 的增大意味着数据包没到 Ring Buffer 就被网卡物理层给丢弃了，而 CPU 无法即使的处理中断是造成 Ring Buffer 满的原因之一，上面那台有问题的机器就是因为 interruprs 分布的不均匀(都压在 core0)，没有做 affinity 而造成的丢包。</li>
<li>RX frame: 表示 misaligned 的 frames。</li>
<li>对于 TX 的来说，出现上述 counter 增大的原因主要包括 aborted transmission, errors due to carrirer, fifo error, heartbeat erros 以及 windown error，而 collisions 则表示由于 CSMA/CD 造成的传输中断。</li>
</ol>
<h3 id="驱动溢出丢包"><a href="#驱动溢出丢包" class="headerlink" title="驱动溢出丢包"></a>驱动溢出丢包</h3><p>netdev_max_backlog 是内核从NIC(网卡(Network Interface Card，简称NIC)，也称网络适配器)收到包后，交由协议栈（如IP、TCP）处理之前的缓冲队列。每个CPU核都有一个backlog队列，与 Ring Buffer 同理，当接收包的速率大于内核协议栈处理的速率时，CPU的backlog队列不断增长，当达到设定的 netdev_max_backlog 值时，数据包将被丢弃。</p>
<p>查看:</p>
<p>通过查看 <code>/proc/net/softnet_stat</code> 可以确定是否发生了 <code>netdev backlog</code> 队列溢出：</p>
<p><img src="/img/640-6.png" alt="640-6.png"></p>
<p>其中：每一行代表每个CPU核的状态统计，从CPU0依次往下；每一列代表一个CPU核的各项统计：第一列代表中断处理程序收到的包总数；第二列即代表由于 netdev_max_backlog 队列溢出而被丢弃的包总数。从上面的输出可以看出，这台服务器统计中，并没有因为 netdev_max_backlog 导致的丢包。</p>
<p>解决方案：</p>
<p>netdev_max_backlog 的默认值是 1000，在高速链路上，可能会出现上述第二统计不为0的情况，可以通过修改内核参数 net.core.netdev_max_backlog 来解决：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.core.netdev_max_backlog=2000</span><br></pre></td></tr></table></figure>

<h3 id="单核负载高导致丢包"><a href="#单核负载高导致丢包" class="headerlink" title="单核负载高导致丢包"></a>单核负载高导致丢包</h3><p>单核CPU软中断占有高, 导致应用没有机会收发或者收包比较慢，即使调整 netdev_max_backlog 队列大小仍然会一段时间后丢包，处理速度跟不上网卡接收的速度;</p>
<p>查看：<code>mpstat -P ALL 1</code></p>
<p><img src="/img/640-7.png" alt="640-7.png"></p>
<p>单核软中断占有100%，导致应用没有机会收发或者收包比较慢而丢包；</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>调整网卡RSS队列配置：</li>
</ol>
<p>查看：<code>ethtool -x ethx</code>；<br>调整：<code>ethtool -X ethx xxxx</code>；</p>
<ol start="2">
<li>看一下网卡中断配置是否均衡 <code>cat /proc/interrupts</code></li>
</ol>
<p>调整：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1） irqbalance 调整；</span></span><br><span class="line"><span class="comment"># 查看当前运行情况</span></span><br><span class="line">service irqbalance status</span><br><span class="line"><span class="comment"># 终止服务</span></span><br><span class="line">service irqbalance stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2） 中断绑CPU核 </span></span><br><span class="line"><span class="built_in">echo</span> mask &gt; /proc/irq/xxx/smp_affinity</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据CPU和网卡队列个数调整网卡多队列和RPS配置</li>
</ol>
<p>-CPU大于网卡队列个数：</p>
<p>查看网卡队列 <code>ethtool -x ethx</code>；</p>
<p>协议栈开启RPS并设置RPS；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$mask</span>（CPU配置）&gt; /sys/class/net/<span class="variable">$eth</span>/queues/rx-<span class="variable">$i</span>/rps_cpus</span><br><span class="line"><span class="built_in">echo</span> 4096（网卡buff）&gt; /sys/class/net/<span class="variable">$eth</span>/queues/rx-<span class="variable">$i</span>/rps_flow_cnt</span><br></pre></td></tr></table></figure>

<p>2）CPU小于网卡队列个数，绑中断就可以，可以试着关闭RPS看一下效果：</p>
<p><code>echo 0 &gt; /sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_cpus</code></p>
<p>4.numa CPU 调整，对齐网卡位置，可以提高内核处理速度，从而给更多CPU给应用收包，减缓丢包概率；</p>
<p>查看网卡numa位置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ethtool -i eth1|grep bus-info</span><br><span class="line">lspci -s bus-info -vv|grep node</span><br></pre></td></tr></table></figure>

<p>上面中断和RPS设置里面mask需要重新按numa CPU分配重新设置;</p>
<p>5.可以试着开启中断聚合（看网卡是否支持）</p>
<p>查看 : </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ethtool -c ethx</span><br><span class="line">Coalesce parameters <span class="keyword">for</span> eth1:</span><br><span class="line">Adaptive RX: on  TX: on</span><br><span class="line">stats-block-usecs: 0</span><br><span class="line">sample-interval: 0</span><br><span class="line">pkt-rate-low: 0</span><br><span class="line">pkt-rate-high: 0</span><br><span class="line"></span><br><span class="line">rx-usecs: 25</span><br><span class="line">rx-frames: 0</span><br><span class="line">rx-usecs-irq: 0</span><br><span class="line">rx-frames-irq: 256</span><br><span class="line"></span><br><span class="line">tx-usecs: 25</span><br><span class="line">tx-frames: 0</span><br><span class="line">tx-usecs-irq: 0</span><br><span class="line">tx-frames-irq: 256</span><br><span class="line"></span><br><span class="line">rx-usecs-low: 0</span><br><span class="line">rx-frame-low: 0</span><br><span class="line">tx-usecs-low: 0</span><br><span class="line">tx-frame-low: 0</span><br><span class="line"></span><br><span class="line">rx-usecs-high: 0</span><br><span class="line">rx-frame-high: 0</span><br><span class="line">tx-usecs-high: 0</span><br><span class="line">tx-frame-high: 0</span><br></pre></td></tr></table></figure>

<p>调整：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethtool -C ethx adaptive-rx on</span><br></pre></td></tr></table></figure>

<p>简单总结一下网卡驱动丢包处理：</p>
<p><img src="/img/640-8.png" alt="640-8.png"></p>
<h2 id="内核协议栈丢包"><a href="#内核协议栈丢包" class="headerlink" title="内核协议栈丢包"></a>内核协议栈丢包</h2><h3 id="以太网链路层丢包"><a href="#以太网链路层丢包" class="headerlink" title="以太网链路层丢包"></a>以太网链路层丢包</h3><h4 id="neighbor-系统arp丢包"><a href="#neighbor-系统arp丢包" class="headerlink" title="neighbor 系统arp丢包"></a>neighbor 系统arp丢包</h4><h5 id="arp-ignore-配置丢包"><a href="#arp-ignore-配置丢包" class="headerlink" title="arp_ignore 配置丢包"></a>arp_ignore 配置丢包</h5><p>arp_ignore 参数的作用是控制系统在收到外部的arp请求时，是否要返回arp响应。arp_ignore 参数常用的取值主要有 0，1，2，3~8 较少用到；</p>
<p>查看：<code>sysctl -a|grep arp_ignore</code></p>
<p><img src="/img/640-9.png" alt="640-9.png"></p>
<p>解决方案：根据实际场景设置对应值；</p>
<ul>
<li>0：响应任意网卡上接收到的对本机IP地址的arp请求（包括环回网卡上的地址），而不管该目的IP是否在接收网卡上。</li>
<li>1：只响应目的IP地址为接收网卡上的本地地址的arp请求。</li>
<li>2：只响应目的IP地址为接收网卡上的本地地址的arp请求，并且arp请求的源IP必须和接收网卡同网段。</li>
<li>3：如果ARP请求数据包所请求的IP地址对应的本地地址其作用域（scope）为主机（host），则不回应ARP响应数据包，如果作用域为全局（global）或链路（link），则回应ARP响应数据包。</li>
</ul>
<p><img src="/img/640-10.png" alt="640-10.png"></p>
<p><img src="/img/640-11.png" alt="640-11.png"></p>
<h5 id="arp-filter配置丢包"><a href="#arp-filter配置丢包" class="headerlink" title="arp_filter配置丢包"></a>arp_filter配置丢包</h5><p>在多接口系统里面（比如腾讯云的弹性网卡场景），这些接口都可以回应arp请求，导致对端有可能学到不同的mac地址，后续报文发送可能由于mac地址和接收报文接口mac地址不一样而导致丢包，arp_filter主要是用来适配这种场景；</p>
<p>查看：<code>sysctl -a | grep arp_filter</code></p>
<p><img src="/img/640-14.png" alt="640-14.png"></p>
<p>解决方案： </p>
<p>根据实际场景设置对应的值，一般默认是关掉此过滤规则，特殊情况可以打开；<br>0：默认值，表示回应arp请求的时候不检查接口情况；<br>1：表示回应arp请求时会检查接口是否和接收请求接口一致，不一致就不回应；</p>
<h4 id="arp表满导致丢包"><a href="#arp表满导致丢包" class="headerlink" title="arp表满导致丢包"></a>arp表满导致丢包</h4><p>比如下面这种情况，由于突发arp表项很多 超过协议栈默认配置，发送报文的时候部分arp创建失败，导致发送失败，从而丢包：</p>
<p><img src="/img/640-12.png" alt="640-12.png"></p>
<p>查看：</p>
<ol>
<li>查看arp状态：<code>cat /proc/net/stat/arp_cache</code> ，table_fulls 统计：</li>
</ol>
<p><img src="/img/640-4.webp" alt="640-4.webp"></p>
<ol start="2">
<li>查看dmesg消息（内核打印）：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg|grep neighbour</span><br><span class="line">neighbour: arp_cache: neighbor table overflow!</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看当前arp表大小：<code>ip n|wc -l</code></li>
</ol>
<p>查看系统配额：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a |grep net.ipv4.neigh.default.gc_thresh</span><br><span class="line">gc_thresh1：存在于ARP高速缓存中的最少层数，如果少于这个数，垃圾收集器将不会运行。缺省值是128。</span><br><span class="line"></span><br><span class="line">gc_thresh2 ：保存在 ARP 高速缓存中的最多的记录软限制。垃圾收集器在开始收集前，允许记录数超过这个数字 5 秒。缺省值是 512。</span><br><span class="line">gc_thresh3 ：保存在 ARP 高速缓存中的最多记录的硬限制，一旦高速缓存中的数目高于此，垃圾收集器将马上运行。缺省值是1024。</span><br></pre></td></tr></table></figure>

<p>一般在内存足够情况下，可以认为 gc_thresh3 值是arp 表总大小；</p>
<p><img src="/img/640-5.webp" alt="640-5.webp"></p>
<p>解决方案：根据实际arp最大值情况（比如访问其他子机最大个数），调整arp表大小</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.neigh.default.gc_thresh1=1024</span><br><span class="line">sudo sysctl -w net.ipv4.neigh.default.gc_thresh2=2048</span><br><span class="line">sudo sysctl -w net.ipv4.neigh.default.gc_thresh3=4096</span><br><span class="line">sudo sysctl  -p</span><br></pre></td></tr></table></figure>

<h4 id="arp请求缓存队列溢出丢包"><a href="#arp请求缓存队列溢出丢包" class="headerlink" title="arp请求缓存队列溢出丢包"></a>arp请求缓存队列溢出丢包</h4><p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># unresolved_discards是否有新增计数</span></span><br><span class="line">cat /proc/net/<span class="built_in">stat</span>/arp_cache</span><br></pre></td></tr></table></figure>

<p>解决方案：根据客户需求调整缓存队列大小 unres_qlen_bytes </p>
<p><code>sysctl -a | grep unres_qlen_bytes</code></p>
<p><img src="/img/640-13.png" alt="640-13.png"></p>
<h3 id="网络IP层丢包"><a href="#网络IP层丢包" class="headerlink" title="网络IP层丢包"></a>网络IP层丢包</h3><h4 id="接口ip地址配置丢包"><a href="#接口ip地址配置丢包" class="headerlink" title="接口ip地址配置丢包"></a>接口ip地址配置丢包</h4><ol>
<li>本机服务不通，检查lo接口有没有配置地址是 127.0.0.1；</li>
<li>本机接收失败， 查看local路由表：<code>ip r show table local | grep 子机ip地址</code>；这种丢包一般会出现在多IP场景，子机底层配置多ip失败，导致对应ip收不到包而丢包；</li>
</ol>
<p><img src="/img/640-6.webp" alt="640-6.webp"></p>
<p>解决方案：</p>
<ol>
<li>配置正确接口ip地址；比如 <code>ip a add 1.1.1.1 dev eth0</code></li>
<li>如果发现接口有地址还丢包，可能是local路由表没有对应条目，紧急情况下，可以用手工补上：<br>比如 <code>ip r add local</code> 本机ip地址 <code>dev eth0 table local</code> ；</li>
</ol>
<h4 id="路由丢包"><a href="#路由丢包" class="headerlink" title="路由丢包"></a>路由丢包</h4><h5 id="路由配置丢包"><a href="#路由配置丢包" class="headerlink" title="路由配置丢包"></a>路由配置丢包</h5><p>查看：</p>
<ol>
<li>查看配置 路由是否设置正确（是否可达），是否配置策略路由（在弹性网卡场景会出现此配置）<code>ip rule</code>：</li>
</ol>
<p><img src="/img/640-7.webp" alt="640-7.webp"></p>
<p>然后找到对应路由表。查看路由表：</p>
<p><img src="/img/640-15.png" alt="640-15.png"></p>
<p>或者直接用 ip r get x.x.x.x，让系统帮你查找是否存在可达路由，接口是否符合预期；</p>
<ol start="2">
<li>查看系统统计信息：  </li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep <span class="string">&quot;dropped because of missing route&quot;</span></span><br></pre></td></tr></table></figure>

<p>解决方案：重新配置正确的路由；</p>
<h5 id="反向路由过滤丢包"><a href="#反向路由过滤丢包" class="headerlink" title="反向路由过滤丢包"></a>反向路由过滤丢包</h5><p>反向路由过滤机制是Linux通过反向路由查询，检查收到的数据包源IP是否可路由（Loose mode）、是否最佳路由（Strict mode），如果没有通过验证，则丢弃数据包，设计的目的是防范IP地址欺骗攻击。</p>
<p>查看：</p>
<p>rp_filter 提供三种模式供配置：</p>
<ul>
<li>0 - 不验证</li>
<li>1 - RFC3704定义的严格模式：对每个收到的数据包，查询反向路由，如果数据包入口和反向路由出口不一致，则不通过</li>
<li>2 - RFC3704定义的松散模式：对每个收到的数据包，查询反向路由，如果任何接口都不可达，则不通过</li>
</ul>
<p>查看当前 rp_filter 策略配置：</p>
<p><code>cat /proc/sys/net/ipv4/conf/eth0/rp_filter</code></p>
<p>如果这里设置为1，就需要查看主机的网络环境和路由策略是否可能会导致客户端的入包无法通过反向路由验证了。</p>
<p>从原理来看这个机制工作在网络层，因此，如果客户端能够Ping通服务器，就能够排除这个因素了。</p>
<p>解决方案：</p>
<p>根据实际网络环境将rp_filter设置为 0 或 2：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.conf.all.rp_filter=2</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">sysctl -w net.ipv4.conf.eth0.rp_filter=2</span><br></pre></td></tr></table></figure>

<h4 id="防火墙丢包"><a href="#防火墙丢包" class="headerlink" title="防火墙丢包"></a>防火墙丢包</h4><h5 id="客户设置规则导致丢包"><a href="#客户设置规则导致丢包" class="headerlink" title="客户设置规则导致丢包"></a>客户设置规则导致丢包</h5><p>查看：</p>
<p><code>iptables -nvL |grep DROP</code></p>
<p>解决方案：修改防火墙规则；</p>
<h4 id="连接跟踪导致丢包"><a href="#连接跟踪导致丢包" class="headerlink" title="连接跟踪导致丢包"></a>连接跟踪导致丢包</h4><p><strong>连接跟踪表溢出丢包</strong></p>
<p>kernel 用 ip_conntrack 模块来记录 iptables 网络包的状态，并把每条记录保存到 table 里（这个 table 在内存里，可以通过 <code>/proc/net/ip_conntrack</code> 查看当前已经记录的总数），如果网络状况繁忙，比如高连接，高并发连接等会导致逐步占用这个 table 可用空间，一般这个 table 很大不容易占满并且可以自己清理，table 的记录会一直呆在 table 里占用空间直到源 IP 发一个 RST 包，但是如果出现被攻击、错误的网络配置、有问题的路由/路由器、有问题的网卡等情况的时候，就会导致源 IP 发的这个 RST 包收不到，这样就积累在 table 里，越积累越多直到占满。无论，哪种情况导致table变满，满了以后就会丢包，出现外部无法连接服务器的情况。内核会报如下错误信息：<code>kernel: ip_conntrack: table full, dropping packet</code>；</p>
<p>查看当前连接跟踪数 :</p>
<p><code>cat /proc/sys/net/netfilter/nf_conntrack_max</code></p>
<p>解决方案：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增大跟踪的最大条数</span></span><br><span class="line">net.netfilter.nf_conntrack_max  = 3276800</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减少跟踪连接的最大有效时间</span></span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 1200</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout_stream = 180</span><br><span class="line">net.netfilter.nf_conntrack_icmp_timeout = 30</span><br></pre></td></tr></table></figure>

<h4 id="ct创建冲突失导致丢包"><a href="#ct创建冲突失导致丢包" class="headerlink" title="ct创建冲突失导致丢包"></a>ct创建冲突失导致丢包</h4><p>查看：当前连接跟踪统计：<code>cat /proc/net/stat/nf_conntrack</code>，可以查各种ct异常丢包统计</p>
<p><img src="/img/640-16.png" alt="640-16.png"></p>
<p>解决方案：内核热补丁修复或者更新内核版本（合入补丁修改）；</p>
<h3 id="传输层UDP-TCP丢包"><a href="#传输层UDP-TCP丢包" class="headerlink" title="传输层UDP/TCP丢包"></a>传输层UDP/TCP丢包</h3><h4 id="tcp-连接跟踪安全检查丢包"><a href="#tcp-连接跟踪安全检查丢包" class="headerlink" title="tcp 连接跟踪安全检查丢包"></a>tcp 连接跟踪安全检查丢包</h4><p>丢包原因：由于连接没有断开，但服务端或者client之前出现过发包异常等情况（报文没有经过连接跟踪模块更新窗口计数），没有更新合法的 <code>window</code> 范围，导致后续报文安全检查被丢包；协议栈用 <code>nf_conntrack_tcp_be_liberal</code> 来控制这个选项：</p>
<ul>
<li>1：关闭，只有不在tcp窗口内的rst包被标志为无效；</li>
<li>0：开启;   所有不在tcp窗口中的包都被标志为无效；</li>
</ul>
<p>查看： </p>
<p>查看配置 ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a|grep nf_conntrack_tcp_be_liberal </span><br><span class="line">net.netfilter.nf_conntrack_tcp_be_liberal = 1</span><br></pre></td></tr></table></figure>

<p>查看log：<br>一般情况下 netfiler 模块默认没有加载log，需要手动加载;</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe ipt_LOG11</span><br><span class="line">sysctl -w net.netfilter.nf_log.2=ipt_LOG</span><br></pre></td></tr></table></figure>

<p>然后发包后在查看syslog；</p>
<p>解决方案：根据实际抓包分析情况判断是不是此机制导致的丢包，可以试着关闭试一下；</p>
<h4 id="分片重组丢包"><a href="#分片重组丢包" class="headerlink" title="分片重组丢包"></a>分片重组丢包</h4><p>情况总结：超时</p>
<p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep timeout</span><br><span class="line">601 fragments dropped after timeout</span><br></pre></td></tr></table></figure>

<p>解决方法：调整超时时间</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ipfrag_time = 30</span><br><span class="line">sysctl -w net.ipv4.ipfrag_time=60</span><br></pre></td></tr></table></figure>

<h4 id="frag-high-thresh-分片的内存超过一定阈值会导致系统安全检查丢包"><a href="#frag-high-thresh-分片的内存超过一定阈值会导致系统安全检查丢包" class="headerlink" title="frag_high_thresh, 分片的内存超过一定阈值会导致系统安全检查丢包"></a>frag_high_thresh, 分片的内存超过一定阈值会导致系统安全检查丢包</h4><p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep reassembles</span><br><span class="line">8094 packet reassembles failed</span><br></pre></td></tr></table></figure>

<p>解决方案：调整大小</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ipfrag_high_thresh </span><br><span class="line">net.ipv4.ipfrag_low_thresh</span><br></pre></td></tr></table></figure>

<h4 id="分片安全距检查离丢包"><a href="#分片安全距检查离丢包" class="headerlink" title="分片安全距检查离丢包"></a>分片安全距检查离丢包</h4><p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep reassembles</span><br><span class="line">8094 packet reassembles failed</span><br></pre></td></tr></table></figure>

<p>解决方案： 把 ipfrag_max_dist 设置为0，就关掉此安全检查</p>
<p><img src="/img/640-17.png" alt="640-17.png"></p>
<p>pfrag_max_dist 特性，在一些场景下其实并不适用：</p>
<ol>
<li>有大量的网络报文交互</li>
<li>发送端的并发度很高，同时SMP架构，导致很容易造成这种乱序情况；</li>
</ol>
<p>分片 hash bucket 冲突链太长超过系统默认值128</p>
<p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmesg|grep <span class="string">&quot;Dropping fragment&quot;</span></span><br><span class="line">inet_frag_find: Fragment <span class="built_in">hash</span> bucket 128 list length grew over <span class="built_in">limit</span>. Dropping fragment.</span><br></pre></td></tr></table></figure>

<p>解决方案：热补丁调整hash大小；</p>
<h4 id="系统内存不足，创建新分片队列失败"><a href="#系统内存不足，创建新分片队列失败" class="headerlink" title="系统内存不足，创建新分片队列失败"></a>系统内存不足，创建新分片队列失败</h4><p>查看方法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s|grep reassembles</span><br><span class="line">8094 packet reassembles failed</span><br></pre></td></tr></table></figure>

<p>dropwatch查看丢包位置 ：</p>
<p><img src="/img/640-18.png" alt="640-18.png"></p>
<p>解决方案：</p>
<ol>
<li>增大系统网络内存：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.core.rmem_default </span><br><span class="line">net.core.rmem_max </span><br><span class="line">net.core.wmem_default</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>系统回收内存：</li>
</ol>
<p>紧急情况下，可以用 <code>/proc/sys/vm/drop_caches</code>, 去释放一下虚拟内存；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To free pagecache:</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line"><span class="comment"># To free dentries and inodes:</span></span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line"><span class="comment"># To free pagecache, dentries and inodes:</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<h4 id="MTU丢包"><a href="#MTU丢包" class="headerlink" title="MTU丢包"></a>MTU丢包</h4><p><img src="/img/640-19.png" alt="640-19.png"></p>
<p>查看：</p>
<ol>
<li>检查接口MTU配置，<code>ifconfig eth1/eth0</code>，默认是1500；</li>
<li>进行MTU探测，然后设置接口对应的MTU值；</li>
</ol>
<p>解决方案：</p>
<ol>
<li>根据实际情况，设置正确 MTU 值；</li>
<li>设置合理的 tcp mss，启用 TCP MTU Probe:</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_mtu_probing</span><br><span class="line">tcp_mtu_probing - INTEGER Controls TCP Packetization-Layer Path MTU Discovery.</span><br><span class="line">Takes three values:</span><br><span class="line">0 - Disabled </span><br><span class="line">1 - Disabled by default, enabled when an ICMP black hole detected</span><br><span class="line">2 - Always enabled, use initial MSS of tcp_base_mss.</span><br></pre></td></tr></table></figure>

<h4 id="tcp层丢包"><a href="#tcp层丢包" class="headerlink" title="tcp层丢包"></a>tcp层丢包</h4><h5 id="TIME-WAIT-过多丢包"><a href="#TIME-WAIT-过多丢包" class="headerlink" title="TIME_WAIT 过多丢包"></a>TIME_WAIT 过多丢包</h5><p>大量 TIMEWAIT 出现，并且需要解决的场景，在高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接。。。这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上；</p>
<p>查看：</p>
<p>查看系统log ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmsg</span><br><span class="line">TCP: time <span class="built_in">wait</span> bucket table overflow；</span><br></pre></td></tr></table></figure>

<p>查看系统配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a|grep tcp_max_tw_buckets</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 16384</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<ol>
<li>tw_reuse，tw_recycle 必须在客户端和服务端 timestamps 开启时才管用（默认打开）</li>
<li>tw_reuse 只对客户端起作用，开启后客户端在1s内回收；</li>
<li>tw_recycle 对客户端和服务器同时起作用，开启后在 3.5*RTO 内回收，RTO 200ms~ 120s具体时间视网络状况。内网状况比 tw_reuse 稍快，公网尤其移动网络大多要比 tw_reuse 慢，优点就是能够回收服务端的 TIME_WAIT 数量；在服务端，如果网络路径会经过NAT节点，不要启用 net.ipv4.tcp_tw_recycle，会导致时间戳混乱，引起其他丢包问题；</li>
<li>调整 tcp_max_tw_buckets 大小，如果内存足够：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_tw_buckets=163840；</span><br></pre></td></tr></table></figure>

<h5 id="时间戳异常丢包"><a href="#时间戳异常丢包" class="headerlink" title="时间戳异常丢包"></a>时间戳异常丢包</h5><p>当多个客户端处于同一个 NAT 环境时，同时访问服务器，不同客户端的时间可能不一致，此时服务端接收到同一个NAT发送的请求，就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。在服务器借助下面的命令可以来确认数据包是否有不断被丢弃的现象。</p>
<p>检查：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s | grep rejects</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>如果网络路径会经过NAT节点，不要启用 <code>net.ipv4.tcp_tw_recycle</code>；</p>
<h5 id="TCP队列问题导致丢包"><a href="#TCP队列问题导致丢包" class="headerlink" title="TCP队列问题导致丢包"></a>TCP队列问题导致丢包</h5><p>原理：</p>
<p>tcp状态机（三次握手）</p>
<p><img src="/img/640-20.png" alt="640-20.png"></p>
<p>协议处理：</p>
<p><img src="/img/640-8.webp" alt="640-8.webp"></p>
<p><strong>一个是半连接队列（syn queue）：</strong></p>
<p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了 request_sock 结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包（会进行第二次握手发送SYN＋ACK的包加以确认）。这些条目所标识的连接在服务器处于Syn_RECV 状态，当服务器收到客户的确认包时，删除该条目，服务器进入 ESTABLISHED 状态。该队列为SYN队列，长度为 max(64,/proc/sys/net/ipv4/tcp_max_syn_backlog),  机器的 tcp_max_syn_backlog 值在 /proc/sys/net/ipv4/tcp_max_syn_backlog 下配置;</p>
<p><strong>一个是全连接队列（accept queue）：</strong></p>
<p>第三次握手时，当server接收到ACK 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 可以有我们的应用程序去定义的;</p>
<p>查看：</p>
<p>连接建立失败,syn丢包：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -s |grep -i listen</span><br><span class="line">SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure>

<p>也会受到连接满丢包影响</p>
<p>解决方案： 增加大小 <code>tcp_max_syn_backlog</code></p>
<h5 id="连接满丢包"><a href="#连接满丢包" class="headerlink" title="连接满丢包"></a>连接满丢包</h5><p><code>-xxx times the listen queue of a socket overflowed</code></p>
<p>查看：</p>
<ul>
<li>查看 accept队列大小 ：<code>net.core.somaxconn</code></li>
<li>ss -lnt 查询socket 队列 ：LISTEN 状态: Recv-Q 表示的当前等待服务端调用 accept 完成三次握手的 listen backlog 数值，也就是说，当客户端通过 connect() 去连接正在 listen() 的服务端时，这些连接会一直处于这个 queue 里面直到被服务端 accept()；Send-Q 表示的则是最大的 listen backlog 数值，这就就是上面提到的 min(backlog, somaxconn) 的值，</li>
<li>看一下是不是应用程序设置限制， int listen(int sockfd, int backlog)；</li>
</ul>
<p>解决方案：</p>
<ul>
<li>Linux内核参进行优化，可以缓解压力 tcp_abort_on_overflow=1</li>
<li>调整 net.core.somaxconn 大小;</li>
<li>应用程序设置问题，通知客户程序修改；</li>
</ul>
<h5 id="syn-flood攻击丢包"><a href="#syn-flood攻击丢包" class="headerlink" title="syn flood攻击丢包"></a>syn flood攻击丢包</h5><p>目前，Linux 下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题;</p>
<p>查看：  </p>
<p>查看syslog：  </p>
<p>kernel: [3649830.269068] TCP: Possible SYN flooding on port xxx. Sending cookies. Check SNMP counters.</p>
<p>解决方案：</p>
<ul>
<li>增大tcp_max_syn_backlog</li>
<li>减少tcp_synack_retries</li>
<li>启用tcp_syncookies</li>
<li>启用 tcp_abort_on_overflow， tcp_abort_on_overflow 修改成 1，1表示第三步的时候如果全连接队列满了，server发送一个reset包给client，表示废掉这个握手过程和这个连接（本来在server端这个连接就还没建立起来）；</li>
</ul>
<h5 id="PAWS机制丢包"><a href="#PAWS机制丢包" class="headerlink" title="PAWS机制丢包"></a>PAWS机制丢包</h5><p>原理：PAWS(Protect Against Wrapped Sequence numbers)，高带宽下，TCP序列号可能在较短的时间内就被重复使用(recycle/wrapped)，就可能导致同一条TCP流在短时间内出现序号一样的两个合法的数据包及其确认包。</p>
<p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -s |grep -e <span class="string">&quot;passive connections rejected because of time </span></span><br><span class="line"><span class="string">stamp&quot;</span> -e <span class="string">&quot;packets rejects in established connections because of </span></span><br><span class="line"><span class="string">timestamp&quot;</span> </span><br><span class="line">387158 passive connections rejected because of time stamp</span><br><span class="line">825313 packets rejects <span class="keyword">in</span> established connections because of timestamp</span><br></pre></td></tr></table></figure>

<p>通过 sysctl 查看是否启用了 tcp_tw_recycle 及 tcp_timestamp:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl net.ipv4.tcp_tw_recycle</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 </span><br><span class="line"></span><br><span class="line">$ sysctl net.ipv4.tcp_timestamps</span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br></pre></td></tr></table></figure>

<ol>
<li>tcp_tw_recycle 参数。它用来快速回收 TIME_WAIT 连接，不过如果在NAT环境下会引发问题;</li>
<li>当多个客户端通过NAT方式联网并与服务端交互时，服务端看到的是同一个IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。如果发生了此类问题，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK。</li>
</ol>
<p>解决方案： </p>
<p>在NAT环境下，清除tcp时间戳选项，或者不开启 tcp_tw_recycle 参数；</p>
<h5 id="TLP问题丢包"><a href="#TLP问题丢包" class="headerlink" title="TLP问题丢包"></a>TLP问题丢包</h5><p>TLP主要是为了解决尾丢包重传效率的问题，TLP能够有效的避免较长的RTO超时，进而提高TCP性能，详细参考文章：</p>
<p><a target="_blank" rel="noopener" href="http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/">http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/</a>；</p>
<p>但在低时延场景下（短连接小包量），TLP与延迟ACK组合可能会造成无效重传，导致客户端感发现大量假重传包，加大了响应延迟；</p>
<p>查看：</p>
<p>查看协议栈统计：</p>
<p><code>netstat -s |grep TCPLossProbes</code></p>
<p>查看系统配置：</p>
<p><code>sysctl -a | grep tcp_early_retrans</code></p>
<p><img src="/img/640-21.png" alt="640-21.png"></p>
<p>解决方案：</p>
<ol>
<li>关掉延迟ack，打开快速ack；</li>
<li>linux实现nodelay语意不是快速ack，只是关闭nagle算法；</li>
<li>打开快速ack选项，socket里面有个 TCP_QUICKACK 选项， 需要每次recv后再设置一次。</li>
</ol>
<h5 id="内存不足导致丢包"><a href="#内存不足导致丢包" class="headerlink" title="内存不足导致丢包"></a>内存不足导致丢包</h5><p>查看：</p>
<p>查看log：<br><code>dmesg|grep &quot;out of memory&quot;</code></p>
<p>查看系统配置： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_mem</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_rmem</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_wmem</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>根据TCP业务并发流量，调整系统参数，一般试着增大2倍或者其他倍数来看是否缓解；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysclt -w net.ipv4.tcp_mem=</span><br><span class="line">sysclt -w net.ipv4.tcp_wmem=</span><br><span class="line">sysclt -w net.ipv4.tcp_rmem=</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h5 id="TCP超时丢包"><a href="#TCP超时丢包" class="headerlink" title="TCP超时丢包"></a>TCP超时丢包</h5><p>查看：</p>
<p>抓包分析一下网络RTT：</p>
<p><img src="/img/640-9.webp" alt="640-9.webp"></p>
<p>用其他工具测试一下当前端到端网络质量（hping等）；</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hping -S 9.199.10.104 -A</span><br><span class="line">HPING 9.199.10.104 (bond1 9.199.10.104): SA <span class="built_in">set</span>, 40 headers + 0 data bytes</span><br><span class="line">len=46 ip=9.199.10.104 ttl=53 DF id=47617 sport=0 flags=R seq=0 win=0 rtt=38.3 ms</span><br><span class="line">len=46 ip=9.199.10.104 ttl=53 DF id=47658 sport=0 flags=R seq=1 win=0 rtt=38.3 ms</span><br><span class="line">len=46 ip=9.199.10.104 ttl=53 DF id=47739 sport=0 flags=R seq=2 win=0 rtt=30.4 ms</span><br><span class="line">len=46 ip=9.199.10.104 ttl=53 DF id=47842 sport=0 flags=R seq=3 win=0 rtt=30.4 ms</span><br><span class="line">len=46 ip=9.199.10.104 ttl=53 DF id=48485 sport=0 flags=R seq=4 win=0 rtt=38.7 ms</span><br><span class="line">len=46 ip=9.199.10.104 ttl=53 DF id=49274 sport=0 flags=R seq=5 win=0 rtt=34.1 ms</span><br><span class="line">len=46 ip=9.199.10.104 ttl=53 DF id=49491 sport=0 flags=R seq=6 win=0 rtt=30.3 ms</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<ul>
<li><p>关闭Nagle算法，减少小包延迟；</p>
</li>
<li><p>关闭延迟ack: <code>sysctl -w net.ipv4.tcp_no_delay_ack=1</code></p>
</li>
</ul>
<h5 id="TCP乱序丢包"><a href="#TCP乱序丢包" class="headerlink" title="TCP乱序丢包"></a>TCP乱序丢包</h5><p>此时TCP会无法判断是数据包丢失还是乱序，因为丢包和乱序都会导致接收端收到次序混乱的数据包，造成接收端的数据空洞。TCP会将这种情况暂定为数据包的乱序，因为乱序是时间问题（可能是数据包的迟到），而丢包则意味着重传。当TCP意识到包出现乱序的情况时，会立即ACK，该ACK的TSER部分包含的TSEV值会记录当前接收端收到有序报文段的时刻。这会使得数据包的RTT样本值增大，进一步导致RTO时间延长。这对TCP来说无疑是有益的，因为TCP有充分的时间判断数据包到底是失序还是丢了来防止不必要的数据重传。当然严重的乱序则会让发送端以为是丢包一旦重复的ACK超过TCP的阈值，便会触发超时重传机制，以及时解决这种问题；详细请参考博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/78692585">https://blog.csdn.net/dog250/article/details/78692585</a></p>
<p>查看：抓包分析是否存在很多乱序报文：</p>
<p><img src="/img/640-10.webp" alt="640-10.webp"></p>
<p>解决方案：如果在多径传输场景或者网络质量不好，可以通过修改下面值来提供系统对TCP无序传送的容错率：</p>
<p><img src="/img/640-11.webp" alt="640-11.webp"></p>
<h5 id="拥塞控制丢包"><a href="#拥塞控制丢包" class="headerlink" title="拥塞控制丢包"></a>拥塞控制丢包</h5><p>在互联网发展的过程当中，TCP算法也做出了一定改变，先后演进了</p>
<p>Reno、NewReno、Cubic和Vegas，这些改进算法大体可以分为基于丢包和基于延时的拥塞控制算法。基于丢包的拥塞控制算法以Reno、NewReno为代表，它的主要问题有Buffer bloat和长肥管道两种，基于丢包的协议拥塞控制机制是被动式的，其依据网络中的丢包事件来做网络拥塞判断。即使网络中的负载很高，只要没有产生拥塞丢包，协议就不会主动降低自己的发送速度。最初路由器转发出口的Buffer 是比较小的，TCP在利用时容易造成全局同步，降低带宽利用率，随后路由器厂家由于硬件成本下降不断地增加Buffer，基于丢包反馈的协议在不丢包的情况下持续占用路由器buffer，虽然提高了网络带宽的利用率，但同时也意味着发生拥塞丢包后，网络抖动性加大。另外对于带宽和RTT都很高的长肥管道问题来说，管道中随机丢包的可能性很大，TCP的默认buffer设置比较小加上随机丢包造成的cwnd经常下折，导致带宽利用率依旧很低；  BBR（Bottleneck Bandwidth and Round-trip propagation time）是一种基于带宽和延迟反馈的拥塞控制算法。目前已经演化到第二版，是一个典型的封闭反馈系统，发送多少报文和用多快的速度发送这些报文都是在每次反馈中不断调节。在BBR提出之前，拥塞控制都是基于事件的算法，需要通过丢包或延时事件驱动；BBR提出之后，拥塞控制是基于反馈的自主自动控制算法，对于速率的控制是由算法决定，而不由网络事件决定，BBR算法的核心是找到最大带宽（Max BW）和最小延时（Min RTT）这两个参数，最大带宽和最小延时的乘积可以得到BDP(Bandwidth Delay Product), 而BDP就是网络链路中可以存放数据的最大容量。BDP驱动Probing State Machine得到Rate quantum和cwnd，分别设置到发送引擎中就可以解决发送速度和数据量的问题。</p>
<p>Linux 4.9内核首次采用BBR拥塞控制算法第一个版本，BBR抗丢包能力比其他算法要强，但这个版本在某些场景下面有问题（缺点），BBR在实时音视频领域存在的问题，深队列竞争不过Cubic。</p>
<p>问题现象就是：在深队列场景，BBR的ProbeRTT阶段只发4个包，发送速率下降太多会引发延迟加大和卡顿问题。</p>
<p>查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -sti //在源端 ss -sti | grep 10.125.42.49:47699 -A 3 <span class="comment">#（10.125.42.49:47699 是目的端地址和端口号）</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/640-12.webp" alt="640-12.webp"></p>
<p><img src="/img/640-13.webp" alt="640-13.webp"></p>
<p>解决方案：</p>
<ul>
<li>ProbeRTT并不适用实时音视频领域，因此可以选择直接去除，或者像BBRV2把probe RTT缩短到2.5s一次，使用0.5xBDP发送；</li>
<li>如果没有特殊需求，切换成稳定的cubic算法；</li>
</ul>
<h4 id="UDP层丢包"><a href="#UDP层丢包" class="headerlink" title="UDP层丢包"></a>UDP层丢包</h4><p>收发包失败丢包</p>
<p>查看：netstat 统计</p>
<p>如果有持续的 receive buffer errors/send buffer errors 计数；</p>
<p><img src="/img/640-22.png" alt="640-22.png"></p>
<p>解决方案：</p>
<ol>
<li>CPU负载（多核绑核配置），网络负载（软中断优化，调整驱动队列netdev_max_backlog），内存配置（协议栈内存）；</li>
<li>按峰值在来，增大buffer缓存区大小：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.udp_mem = xxx</span><br><span class="line">net.ipv4.udp_rmem_min = xxx</span><br><span class="line">net.ipv4.udp_wmem_min = xxx</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调整应用设计：</li>
</ol>
<ul>
<li>UDP本身就是无连接不可靠的协议，适用于报文偶尔丢失也不影响程序状态的场景，比如视频、音频、游戏、监控等。对报文可靠性要求比较高的应用不要使用 UDP，推荐直接使用 TCP。当然，也可以在应用层做重试、去重保证可靠性</li>
<li>如果发现服务器丢包，首先通过监控查看系统负载是否过高，先想办法把负载降低再看丢包问题是否消失</li>
<li>如果系统负载过高，UDP丢包是没有有效解决方案的。如果是应用异常导致CPU、memory、IO 过高，请及时定位异常应用并修复；如果是资源不够，监控应该能及时发现并快速扩容</li>
<li>对于系统大量接收或者发送UDP报文的，可以通过调节系统和程序的 socket buffer size 来降低丢包的概率</li>
<li>应用程序在处理UDP报文时，要采用异步方式，在两次接收报文之间不要有太多的处理逻辑</li>
</ul>
<h3 id="应用层socket丢包"><a href="#应用层socket丢包" class="headerlink" title="应用层socket丢包"></a>应用层socket丢包</h3><h4 id="socket缓存区接收丢包"><a href="#socket缓存区接收丢包" class="headerlink" title="socket缓存区接收丢包"></a>socket缓存区接收丢包</h4><p>查看：  </p>
<ol>
<li>抓包分析是否存在丢包情况；</li>
<li>查看统计：</li>
</ol>
<p><code>netstat -s|grep &quot;packet receive errors&quot;</code></p>
<p>解决方案：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调整socket缓冲区大小：</span></span><br><span class="line"><span class="comment"># socket配置（所有协议socket）：</span></span><br><span class="line"><span class="comment"># Default Socket Receive Buffer</span></span><br><span class="line">net.core.rmem_default = 31457280</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximum Socket Receive Buffer</span></span><br><span class="line">net.core.rmem_max = 67108864</span><br></pre></td></tr></table></figure>

<p>具体大小调整原理：</p>
<p>缓冲区大小没有任何设置值是最佳的，因为最佳大小随具体情况而不同</p>
<p>缓冲区估算原理：在数据通信中，带宽时延乘积（英语：bandwidth-delay product；或称带宽延时乘积、带宽延时积等）指的是一个数据链路的能力（每秒比特）与来回通信延迟（单位秒）的乘积。[1][2]其结果是以比特（或字节）为单位的一个数据总量，等同在任何特定时间该网络线路上的最大数据量——已发送但尚未确认的数据。</p>
<p><strong>BDP = 带宽 * RTT</strong></p>
<p>可以通过计算当面节点带宽和统计平均时延来估算BDP，即缓冲区的大小，可以参考下面常见场景估计：</p>
<p><img src="/img/640-23.png" alt="640-23.png"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E56344_01/html/E53803/gnkor.html">https://docs.oracle.com/cd/E56344_01/html/E53803/gnkor.html</a></p>
<h4 id="应用设置tcp连接数大小丢包"><a href="#应用设置tcp连接数大小丢包" class="headerlink" title="应用设置tcp连接数大小丢包"></a>应用设置tcp连接数大小丢包</h4><p>查看：</p>
<p>请参考上面TCP连接队列分析；</p>
<p>解决方案：</p>
<p>设置合理的连接队列大小，当第三次握手时，当server接收到ACK 报之后， 会进入一个新的叫 accept 的队列，该队列的长度为 min(backlog, somaxconn)，默认情况下，somaxconn 的值为 128，表示最多有 129 的 ESTAB 的连接等待 accept()，而 backlog 的值则应该是由 int listen(int sockfd, int backlog) 中的第二个参数指定，listen 里面的 backlog 可以有我们的应用程序去定义的；</p>
<h4 id="应用发送太快导致丢包"><a href="#应用发送太快导致丢包" class="headerlink" title="应用发送太快导致丢包"></a>应用发送太快导致丢包</h4><p>查看统计：</p>
<p><code>netstat -s|grep &quot;send buffer errors&quot;</code></p>
<p>解决方案：</p>
<ul>
<li>ICMP/UDP没有流控机制，需要应用设计合理发送方式和速度，照顾到底层buff大小和CPU负载以及网络带宽质量；</li>
<li>设置合理的sock缓冲区大小：<br><code>setsockopt(s,SOL_SOCKET,SO_SNDBUF,  i(const char*)&amp;nSendBuf,sizeof(int));</code></li>
<li>调整系统socket缓冲区大小：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default Socket Send Buffer</span></span><br><span class="line">net.core.wmem_default = 31457280</span><br><span class="line"><span class="comment"># Maximum Socket Send Buffer</span></span><br><span class="line">net.core.wmem_max = 33554432</span><br></pre></td></tr></table></figure>

<p>附：简单总结一下内核协议栈丢包：</p>
<p><img src="/img/640-24.png" alt="640-24.png"></p>
<h2 id="相关工具介绍"><a href="#相关工具介绍" class="headerlink" title="相关工具介绍"></a>相关工具介绍</h2><p>1.dropwatch工具</p>
<p>原理：  监听 kfree_skb（把网络报文丢弃时会调用该函数）函数或者事件吗，然后打印对应调用堆栈；想要详细了解 linux 系统在执行哪个函数时丢包的话，可以使用 dropwatch 工具，它监听系统丢包信息，并打印出丢包发生的函数：</p>
<p><img src="/img/640-25.png" alt="640-25.png"></p>
<ol start="2">
<li>tcpdump工具</li>
</ol>
<p>原理: tcpdump 是一个Unix下一个功能强大的网络抓包工具，它允许用户拦截和显示发送或收到过网络连接到该计算机的TCP/IP和其他数据包</p>
<p><img src="/img/640-26.png" alt="640-26.png"></p>
<p>抓包命令参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.tcpdump.org/manpages/tcpdump.1.html">https://www.tcpdump.org/manpages/tcpdump.1.html</a></p>
<p>数据包分析：</p>
<p>1.用wireshark工具分析  参考：Wireshark数据包分析实战.pdf<br>2.可以转化生成CSV数据，用Excel或者shell去分析特定场景报文；<br>3.可以在linux上用tshark命令行工具进行分析:</p>
<p><a target="_blank" rel="noopener" href="https://www.wireshark.org/docs/man-pages/tshark.html">https://www.wireshark.org/docs/man-pages/tshark.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">444</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">180</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
