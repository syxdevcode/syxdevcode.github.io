<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/24/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9008-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9008-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">DotNet面试题解析08-多线程与线程同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-20 16:29:55" itemprop="dateCreated datePublished" datetime="2018-12-20T16:29:55+00:00">2018-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>我们运行一个exe，就是一个进程实例，系统中有很多个进程。每一个进程都有自己的内存地址空间，每个进程相当于一个独立的边界，有自己的独占的资源，进程之间不能共享代码和数据空间。</p>
<p><img src="/img/151257-20160321141549448-1325816759.png" alt="151257-20160321141549448-1325816759.png"></p>
<p>每一个进程有一个或多个线程，进程内多个线程可以共享所属进程的资源和数据，线程是操作系统调度的基本单元。线程是由操作系统来调度和执行的，她的基本状态如下图。</p>
<p><img src="/img/151257-20160321141550120-2131692214.png" alt="151257-20160321141550120-2131692214.png"></p>
<h3 id="线程的开销及调度"><a href="#线程的开销及调度" class="headerlink" title="线程的开销及调度"></a>线程的开销及调度</h3><p>创建一个线程,主要包括线程内核对象、线程环境块、1M大小的用户模式栈、内核模式栈。其中用户模式栈对于普通的系统线程那1M是预留的，在需要的时候才会分配，但是对于CLR线程，那1M是一开始就分类了内存空间的。</p>
<p><img src="/img/151257-20160321141550589-1339297361.png" alt="151257-20160321141550589-1339297361.png"></p>
<p>操作系统中那么多线程（一般都有上千个线程，大部分都处于休眠状态），对于单核CPU，一次只能有一个线程被调度执行，那么多线程怎么分配的呢？Windows系统采用时间轮询机制，CPU计算资源以时间片(大约30ms)的形式分配给执行线程。</p>
<p>计算机资源（CPU核心和CPU寄存器）一次只能调度一个线程，具体的调度流程：</p>
<ul>
<li>把CPU寄存器内的数据保存到当前线程内部（线程上下文等地方），给下一个线程腾地方；</li>
<li>线程调度：在线程集合里取出一个需要执行的线程；</li>
<li>加载新线程的上下文数据到CPU寄存器；</li>
<li>新线程执行，享受她自己的CPU时间片（大约30ms），完了之后继续回到第一步，继续轮回；</li>
</ul>
<p>上面线程调度的过程，就是一次线程切换，一次切换就涉及到线程上下文等数据的搬入搬出，性能开销是很大的。因此线程不可滥用，线程的创建和消费也是很昂贵的，这也是为什么建议尽量使用线程池的一个主要原因。</p>
<p>线程的主要几点性能影响：</p>
<ul>
<li>线程的创建、销毁都是很昂贵的；</li>
<li>线程上下文切换有极大的性能开销，当然假如需要调度的新线程与当前是同一线程的话，就不需要线程上下文切换了，效率要快很多；</li>
<li>GC执行回收时，首先要（安全的）挂起所有线程，遍历所有线程栈（根），GC回收后更新所有线程的根地址，再恢复线程调用，线程越多，GC要干的活就越多；</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池(ThreadPool)"></a>线程池(ThreadPool)</h3><p>将任务添加进线程池:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(方法名));</span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line">ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(方法名), 参数);</span><br></pre></td></tr></table></figure>

<p>因为ThreadPool是静态类 所以不需要实例化.</p>
<p>每个CLR都有一个线程池，线程池在CLR内可以多个AppDomain共享，线程池是CLR内部管理的一个线程集合，初始是没有线程的，在需要的时候才会创建。</p>
<p>基本流程如下：</p>
<ul>
<li>线程池内部维护一个请求列队，用于缓存用户请求需要执行的代码任务，就是ThreadPool.QueueUserWorkItem提交的请求；</li>
<li>有新任务后，线程池使用空闲线程或新线程来执行队列请求；</li>
<li>任务执行完后线程不会销毁，留着重复使用；</li>
<li>线程池自己负责维护线程的创建和销毁，当线程池中有大量闲置的线程时，线程池会自动结束一部分多余的线程来释放资源；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">namespace</span> 多线程池试验</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//新建ManualResetEvent对象并且初始化为无信号状态</span></span><br><span class="line">            ManualResetEvent eventX = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">            ThreadPool.SetMaxThreads(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">            thr t = <span class="keyword">new</span> thr(<span class="number">15</span>, eventX);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(t.ThreadProc), i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等待事件的完成，即线程调用ManualResetEvent.Set()方法</span></span><br><span class="line">            <span class="comment">//eventX.WaitOne  阻止当前线程，直到当前 WaitHandle 收到信号为止。 </span></span><br><span class="line">            eventX.WaitOne(Timeout.Infinite, <span class="literal">true</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;断点测试&quot;</span>);</span><br><span class="line">            Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">thr</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">thr</span>(<span class="params"><span class="built_in">int</span> count,ManualResetEvent mre</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                iMaxCount = count;</span><br><span class="line">                eventX = mre;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> iCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> iMaxCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> ManualResetEvent eventX;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThreadProc</span>(<span class="params"><span class="built_in">object</span> i</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Thread[&quot;</span> + i.ToString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">//Interlocked.Increment()操作是一个原子操作，作用是:iCount++ 具体请看下面说明 </span></span><br><span class="line">                <span class="comment">//原子操作，就是不能被更高等级中断抢夺优先的操作。你既然提这个问题，我就说深一点。</span></span><br><span class="line">                <span class="comment">//由于操作系统大部分时间处于开中断状态，</span></span><br><span class="line">                <span class="comment">//所以，一个程序在执行的时候可能被优先级更高的线程中断。</span></span><br><span class="line">                <span class="comment">//而有些操作是不能被中断的，不然会出现无法还原的后果，这时候，这些操作就需要原子操作。</span></span><br><span class="line">                <span class="comment">//就是不能被中断的操作。</span></span><br><span class="line">                Interlocked.Increment(<span class="keyword">ref</span> iCount);</span><br><span class="line">                <span class="keyword">if</span> (iCount == iMaxCount)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;发出结束信号!&quot;</span>);</span><br><span class="line">                    <span class="comment">//将事件状态设置为终止状态，允许一个或多个等待线程继续。</span></span><br><span class="line">                    eventX.Set();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AutoResetEvent和ManualResetEvent区别：</strong><br><font color=#0099ff size=4 face="黑体">AutoResetEvent的WaitOne()方法执行后会自动又将信号置为不发送状态也就是阻塞状态，当再次遇到WaitOne()方法是又会被阻塞，而ManualResetEvent则不会，只要线程处于非阻塞状态则无论遇到多少次WaitOne()方法都不会被阻塞，除非调用ReSet()方法来手动阻塞线程。</font></p>
<p>线程池是有一个容量的，可以设置线程池的最大活跃线程数，调用方法ThreadPool.SetMaxThreads可以设置相关参数。但很多编程实践里都不建议程序猿们自己去设置这些参数，其实微软为了提高线程池性能，做了大量的优化，线程池可以很智能的确定是否要创建或是消费线程，大多数情况都可以满足需求了。</p>
<p>线程池使得线程可以充分有效地被利用，减少了任务启动的延迟，也不用大量的去创建线程，避免了大量线程的创建和销毁对性能的极大影响。</p>
<p>线程池的不足：</p>
<ul>
<li>线程池内的线程不支持线程的挂起、取消等操作，如想要取消线程里的任务，.NET支持一种协作式方式取消，使用起来也不很方便，而且有些场景并不满足需求；</li>
<li>线程内的任务没有返回值，也不知道何时执行完成；</li>
<li>不支持设置线程的优先级，还包括其他类似需要对线程有更多的控制的需求都不支持；</li>
</ul>
<h3 id="任务Task与并行Parallel"><a href="#任务Task与并行Parallel" class="headerlink" title="任务Task与并行Parallel"></a>任务Task与并行Parallel</h3><p>任务Task与并行Parallel本质上内部都是使用的线程池，提供了更丰富的并行编程的方式。任务Task基于线程池，可支持返回值，支持比较强大的任务执行计划定制等功能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个任务</span></span><br><span class="line">Task&lt;<span class="built_in">int</span>&gt; t1 = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(n =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    System.Threading.Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span>)n;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//定制一个延续任务计划</span></span><br><span class="line">t1.ContinueWith(task =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;end&quot;</span> + t1.Result);</span><br><span class="line">&#125;, TaskContinuationOptions.AttachedToParent);</span><br><span class="line">t1.Start();</span><br><span class="line"><span class="comment">//使用Task.Factory创建并启动一个任务</span></span><br><span class="line"><span class="keyword">var</span> t2 = System.Threading.Tasks.Task.Factory.StartNew(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;t1:&quot;</span> + t1.Status);</span><br><span class="line">&#125;);</span><br><span class="line">Task.WaitAll();</span><br><span class="line">Console.WriteLine(t1.Result);</span><br></pre></td></tr></table></figure>

<p>并行Parallel内部其实使用的是Task对象（TPL会在内部创建System.Threading.Tasks.Task的实例），所有并行任务完成后才会返回。少量短时间任务建议就不要使用并行Parallel了，并行Parallel本身也是有性能开销的，而且还要进行并行任务调度、创建调用方法的委托等等。</p>
<p><img src="/img/221025576742743.png" alt="221025576742743.png"></p>
<h3 id="GUI线程处理模型"><a href="#GUI线程处理模型" class="headerlink" title="GUI线程处理模型"></a>GUI线程处理模型</h3><p>这是很多开发C/S客户端应用程序会遇到的问题，GUI程序的界面控件不允许跨线程访问，如果在其他线程中访问了界面控件，运行时就会抛出一个异常，就像下面的图示，是不是很熟悉！这其中的罪魁祸首就是，就是“GUI的线程处理模型”。</p>
<p><img src="/img/151257-20160321141551714-1827445547.png" alt="151257-20160321141551714-1827445547.png"></p>
<p>.NET支持多种不同应用程序模型，大多数的线程都是可以做任何事情（他们可能没有引入线程模型），但GUI应用程序（主要是Winform、WPF）引入了一个特殊线程处理模型，<font color=#0099ff size=4 face="黑体">UI控件元素只能由创建它的线程访问或修改，微软这样处理是为了保证UI控件的线程安全。</font></p>
<p>为什么在UI线程中执行一个耗时的计算操作，会导致UI假死呢？这个问题要追溯到Windows的消息机制了。</p>
<p>因为Windows是基于消息机制的，我们在UI上所有的键盘、鼠标操作都是以消息的形式发送给各个应用程序的。GUI线程内部就有一个消息队列，GUI线程不断的循环处理这些消息，并根据消息更新UI的呈现。如果这个时候，你让GUI线程去处理一个耗时的操作（比如花10秒去下载一个文件），那GUI线程就没办法处理消息队列了，UI界面就处于假死的状态。</p>
<p><img src="/img/151257-20160321141552292-299214517.png" alt="151257-20160321141552292-299214517.png"></p>
<p>在线程里处理事件完成后，需要更新UI控件的状态:</p>
<p><font color=#0099ff size=4 face="黑体">（1）使用GUI控件提供的方法，Winform是控件的Invoke方法，WPF中是控件的Dispatcher.Invoke方法</font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Winform：Invoke方法和BeginInvoke</span></span><br><span class="line"> <span class="keyword">this</span>.label.Invoke(method, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.WPF：Dispatcher.Invoke</span></span><br><span class="line"><span class="keyword">this</span>.label.Dispatcher.Invoke(method, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">（2）使用.NET中提供的BackgroundWorker执行耗时计算操作，在其任务完成事件RunWorkerCompleted 中更新UI控件</font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (BackgroundWorker bw = <span class="keyword">new</span> BackgroundWorker())</span><br><span class="line">&#123;</span><br><span class="line">    bw.RunWorkerCompleted += <span class="keyword">new</span> RunWorkerCompletedEventHandler((ojb,arg) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.label.Text = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    bw.RunWorkerAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">（3）使用GUI线程处理模型的同步上下文来送封UI控件修改操作，这样可以不需要调用UI控件元素</font></p>
<p>.NET中提供一个用于同步上下文的类SynchronizationContext，利用它可以把应用程序模型链接到他的线程处理模型，其实它的本质还是调用的第一步（1）中的方法。</p>
<p>实现代码分为三步，第一步定义一个静态类，用于GUI线程的UI元素访问封装：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GUIThreadHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> System.Threading.SynchronizationContext GUISyncContext</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _GUISyncContext; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _GUISyncContext = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> System.Threading.SynchronizationContext _GUISyncContext =</span><br><span class="line">        System.Threading.SynchronizationContext.Current;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 主要用于GUI线程的同步回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SyncContextCallback</span>(<span class="params">Action callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (GUISyncContext == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            callback();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        GUISyncContext.Post(result =&gt; callback(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 支持APM异步编程模型的GUI线程的同步回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncCallback <span class="title">SyncContextCallback</span>(<span class="params">AsyncCallback callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="literal">null</span>) <span class="keyword">return</span> callback;</span><br><span class="line">        <span class="keyword">if</span> (GUISyncContext == <span class="literal">null</span>) <span class="keyword">return</span> callback;</span><br><span class="line">        <span class="keyword">return</span> asynresult =&gt; GUISyncContext.Post(result =&gt; callback(result <span class="keyword">as</span> IAsyncResult), asynresult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，在主窗口注册当前SynchronizationContext：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            CLRTest.ConsoleTest.GUIThreadHelper.GUISyncContext = System.Threading.SynchronizationContext.Current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第三步，就是使用了，可以在任何地方使用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GUIThreadHelper.SyncContextCallback(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.txtMessage.Text = res.ToString();</span><br><span class="line">    <span class="keyword">this</span>.btnTest.Content = <span class="string">&quot;DoTest&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>.btnTest.IsEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="线程同步构造"><a href="#线程同步构造" class="headerlink" title="线程同步构造"></a>线程同步构造</h2><p>基元线程同步构造分为：基元用户模式构造和基元内核模式构造，两种同步构造方式各有优缺点，而混合构造（如lock）就是综合两种构造模式的优点。</p>
<h3 id="用户模式构造"><a href="#用户模式构造" class="headerlink" title="用户模式构造"></a>用户模式构造</h3><p>基元用户模式比基元内核模式速度要快，她使用特殊的cpu指令来协调线程，在硬件中发生，速度很快。但也因此Windows操作系统永远检测不到一个线程在一个用户模式构造上阻塞了。举个例子来模拟一下用户模式构造的同步方式：</p>
<ul>
<li>线程1请求了临界资源，并在资源门口使用了用户模式构造的锁；</li>
<li>线程2请求临界资源时，发现有锁，因此就在门口等待，并不停的去询问资源是否可用；</li>
<li>线程1如果使用资源时间较长，则线程2会一直运行，并且占用CPU时间。占用CPU干什么呢？她会不停的轮询锁的状态，直到资源可用，这就是所谓的活锁；</li>
</ul>
<p>缺点：<font color=#0099ff size=4 face="黑体">线程2会一直使用CPU时间（假如当前系统只有这两个线程在运行），也就意味着不仅浪费了CPU时间，而且还会有频繁的线程上下文切换，对性能影响是很严重的。</font></p>
<p><font color=#0099ff size=4 face="黑体">当然她的优点是效率高，适合哪种对资源占用时间很短的线程同步。</font></p>
<p>.NET中为我们提供了两种原子性操作，利用原子操作可以实现一些简单的用户模式锁（如自旋锁）。</p>
<ul>
<li>System.Threading.Interlocked：易失构造，它在包含一个简单数据类型的变量上执行原子性的读或写操作。</li>
<li>Thread.VolatileRead 和 Thread.VolatileWrite：互锁构造，它在包含一个简单数据类型的变量上执行原子性的读和写操作。</li>
</ul>
<h3 id="内核模式构造"><a href="#内核模式构造" class="headerlink" title="内核模式构造"></a>内核模式构造</h3><p>这是针对用户模式的一个补充，先模拟一个内核模式构造的同步流程来理解她的工作方式：</p>
<ul>
<li>线程1请求了临界资源，并在资源门口使用了内核模式构造的锁；</li>
<li>线程2请求临界资源时，发现有锁，就会被系统要求睡眠（阻塞），线程2就不会被执行了，也就不会浪费CPU和线程上下文切换了；</li>
<li>等待线程1使用完资源后，解锁后会发送一个通知，然后操作系统会把线程2唤醒。假如有多个线程在临界资源门口等待，则会挑选一个唤醒；</li>
</ul>
<p>看上去是不是非常棒！彻底解决了用户模式构造的缺点，但内核模式也有缺点的：将线程从用户模式切换到内核模式（或相反）导致巨大性能损失。调用线程将从托管代码转换为内核代码，再转回来，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此尽量不要让线程从用户模式转到内核模式。</p>
<p><font color=#0099ff size=4 face="黑体">它的优点就是阻塞线程，不浪费CPU时间，适合那种需要长时间占用资源的线程同步。</font></p>
<p>内核模式构造的主要有两种方式，以及基于这两种方式的常见的锁：</p>
<ul>
<li>基于事件：如AutoResetEvent、ManualResetEvent</li>
<li>基于信号量：如Semaphore</li>
</ul>
<h3 id="混合线程同步"><a href="#混合线程同步" class="headerlink" title="混合线程同步"></a>混合线程同步</h3><p>Lock、SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim</p>
<p>lock的本质就是使用的Monitor，lock只是一种简化的语法形式，实质的语法形式如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Enter(obj, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockTaken) Monitor.Exit(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Semaphore 信号量</strong></p>
<p>它可以控制对某一段代码或者对某个资源访问的线程的数量，超过这个数量之后，其它的线程就得等待，只有等现在有线程释放了之后，下面的线程才能访问。这个跟锁有相似的功能，只不过不是独占的，它允许一定数量的线程同时访问。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SemaphoreSlim _sem = <span class="keyword">new</span> SemaphoreSlim(<span class="number">3</span>);    <span class="comment">// 我们限制能同时访问的线程数量是3</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="keyword">new</span> Thread(Enter).Start(i);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Enter</span>(<span class="params"><span class="built_in">object</span> id</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(id + <span class="string">&quot; 开始排队...&quot;</span>);</span><br><span class="line">    _sem.Wait();</span><br><span class="line">    Console.WriteLine(id + <span class="string">&quot; 开始执行！&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span> * (<span class="built_in">int</span>)id);</span><br><span class="line">    Console.WriteLine(id + <span class="string">&quot; 执行完毕，离开！&quot;</span>);</span><br><span class="line">    _sem.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/222030017324376.png" alt="222030017324376.png"></p>
<p>同步索引块是.NET中解决对象同步问题的基本机制，该机制为每个堆内的对象（即引用类型对象实例）分配一个同步索引，她其实是一个地址指针，初始值为-1不指向任何地址。</p>
<ul>
<li>创建一个锁对象Object obj，obj的同步索引块（地址）为-1，不指向任何地址；</li>
<li>Monitor.Enter（obj），创建或使用一个空闲的同步索引块（如下图中的同步块1），这个才是真正的同步索引块，其内部结构就是一个混合锁的结构，包含线程ID、递归计数、等待线程统计、内核对象等，类似一个混合锁AnotherHybridLock。obj对象（同步索引块AsynBlockIndex）指向该同步块1；</li>
<li>Exit时，重置为-1，那个同步索引块1可以被重复利用；</li>
</ul>
<h3 id="Lock关键字"><a href="#Lock关键字" class="headerlink" title="Lock关键字"></a>Lock关键字</h3><p>lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p>
<p>通常，应避免锁定 public 类型，否则实例将超出代码的控制范围。常见的结构 lock (this)、lock (typeof (MyType)) 和 lock (“myLock”) 违反此准则：</p>
<ul>
<li>如果实例可以被公共访问，将出现 lock (this) 问题。</li>
<li>如果 MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题。</li>
<li>由于进程中使用同一字符串的任何其他代码将共享同一个锁，所以出现lock(“myLock”) 问题。</li>
</ul>
<p>最佳做法是定义 private 对象来锁定, 或 private static 对象变量来保护所有实例所共有的数据。</p>
<p><font color=#0099ff size=4 face="黑体">不要Lock值类型,不要Lock(this),不要Lock(null对象),推荐Lock只读静态对象。</font></p>
<p><img src="/img/151257-20160321141553854-448927161.jpg" alt="151257-20160321141553854-448927161.jpg"></p>
<p>因此，锁对象要求必须为一个引用对象（在堆上）。</p>
<h3 id="多线程使用及线程同步总结"><a href="#多线程使用及线程同步总结" class="headerlink" title="多线程使用及线程同步总结"></a>多线程使用及线程同步总结</h3><p>在使用Lock时，关键点就是锁对象了，需要注意以下几个方面：</p>
<ul>
<li>这个对象肯定要是引用类型，值类型可不可呢？值类型可以装箱啊！你觉得可不可以？但也不要用值类型，因为值类型多次装箱后的对象是不同的，会导致无法锁定；</li>
<li>不要锁定this，尽量使用一个没有意义的Object对象来锁；</li>
<li>不要锁定一个类型对象，因类型对象是全局的；</li>
<li>不要锁定一个字符串，因为字符串可能被驻留，不同字符对象可能指向同一个字符串；</li>
<li>不要使用[System.Runtime.CompilerServices.MethodImpl(MethodImplOptions.Synchronized)]，这个可以使用在方法上面，保证方法同一时刻只能被一个线程调用。她实质上是使用lock的，如果是实例方法，会锁定this，如果是静态方法，则会锁定类型对象</li>
</ul>
<h2 id="题目答案解析"><a href="#题目答案解析" class="headerlink" title="题目答案解析"></a>题目答案解析</h2><h3 id="1-描述线程与进程的区别？"><a href="#1-描述线程与进程的区别？" class="headerlink" title="1. 描述线程与进程的区别？"></a>1. 描述线程与进程的区别？</h3><ul>
<li>一个应用程序实例是一个进程，一个进程内包含一个或多个线程，线程是进程的一部分；</li>
<li>进程之间是相互独立的，他们有各自的私有内存空间和资源，进程内的线程可以共享其所属进程的所有资源；</li>
</ul>
<h3 id="2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"><a href="#2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？" class="headerlink" title="2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"></a>2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？</h3><p>因为GUI应用程序引入了一个特殊的线程处理模型，为了保证UI控件的线程安全，这个线程处理模型不允许其他子线程跨线程访问UI元素。解决方法还是比较多的，如：</p>
<ul>
<li>利用UI控件提供的方法，Winform是控件的Invoke方法，WPF中是控件的Dispatcher.Invoke方法；</li>
<li>使用BackgroundWorker；</li>
<li>使用GUI线程处理模型的同步上下文SynchronizationContext来提交UI更新操作</li>
</ul>
<p>上面几个方式在文中已详细给出。</p>
<h3 id="3-简述后台线程和前台线程的区别？"><a href="#3-简述后台线程和前台线程的区别？" class="headerlink" title="3. 简述后台线程和前台线程的区别？"></a>3. 简述后台线程和前台线程的区别？</h3><p>应用程序必须运行完所有的前台线程才可以退出，或者主动结束前台线程，不管后台线程是否还在运行，应用程序都会结束；而对于后台线程，应用程序则可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时都会自动结束。</p>
<p>通过将 Thread.IsBackground 设置为 true，就可以将线程指定为后台线程，主线程就是一个前台线程。</p>
<h3 id="4-说说常用的锁，lock是一种什么样的锁？"><a href="#4-说说常用的锁，lock是一种什么样的锁？" class="headerlink" title="4. 说说常用的锁，lock是一种什么样的锁？"></a>4. 说说常用的锁，lock是一种什么样的锁？</h3><p>常用的如如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock是一个混合锁，其实质是Monitor[‘mɒnɪtə]。</p>
<h3 id="5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"><a href="#5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？" class="headerlink" title="5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"></a>5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？</h3><p>lock的锁对象要求为一个引用类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。</p>
<p>对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向一个真正的锁（同步块），这个锁（同步块）会被复用。</p>
<h3 id="6-多线程和异步有什么关系和区别？"><a href="#6-多线程和异步有什么关系和区别？" class="headerlink" title="6. 多线程和异步有什么关系和区别？"></a>6. 多线程和异步有什么关系和区别？</h3><p>多线程是实现异步的主要方式之一，异步并不等同于多线程。实现异步的方式还有很多，比如利用硬件的特性、使用进程或纤程等。在.NET中就有很多的异步编程支持，比如很多地方都有Begin、End的方法，就是一种异步编程支持，她内部有些是利用多线程，有些是利用硬件的特性来实现的异步编程。</p>
<h3 id="7-线程池的优点有哪些？又有哪些不足？"><a href="#7-线程池的优点有哪些？又有哪些不足？" class="headerlink" title="7. 线程池的优点有哪些？又有哪些不足？"></a>7. 线程池的优点有哪些？又有哪些不足？</h3><p>优点：减小线程创建和销毁的开销，可以复用线程；也从而减少了线程上下文切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。</p>
<p>缺点：线程池无法对一个线程有更多的精确的控制，如了解其运行状态等；不能设置线程的优先级；加入到线程池的任务（方法）不能有返回值；对于需要长期运行的任务就不适合线程池。</p>
<h3 id="8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？"><a href="#8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？" class="headerlink" title="8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？"></a>8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？</h3><p>Mutex是一个基于内核模式的互斥锁，支持锁的递归调用，而Lock是一个混合锁，一般建议使用Lock更好，因为lock的性能更好。</p>
<h3 id="9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"><a href="#9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。" class="headerlink" title="9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"></a>9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeadLockTest</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (<span class="keyword">this</span>)   <span class="comment">//或者lock一个静态object变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i--);</span><br><span class="line">            DeadLockTest(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会的，因为lock是一个混合锁，支持锁的递归调用，如果你使用一个ManualResetEvent或AutoResetEvent可能就会发生死锁。</p>
<h3 id="10-用双检锁实现一个单例模式Singleton。"><a href="#10-用双检锁实现一个单例模式Singleton。" class="headerlink" title="10. 用双检锁实现一个单例模式Singleton。"></a>10. 用双检锁实现一个单例模式Singleton。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>,<span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T _Instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> _lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取单例对象的实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Instance != <span class="literal">null</span>) <span class="keyword">return</span> _Instance;</span><br><span class="line">        <span class="keyword">lock</span> (_lockObj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_Instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = Activator.CreateInstance&lt;T&gt;();</span><br><span class="line">                System.Threading.Interlocked.Exchange(<span class="keyword">ref</span> _Instance, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-下面代码输出结果是什么？为什么？如何改进她？"><a href="#11-下面代码输出结果是什么？为什么？如何改进她？" class="headerlink" title="11.下面代码输出结果是什么？为什么？如何改进她？"></a>11.下面代码输出结果是什么？为什么？如何改进她？</h3><p>int a = 0;<br>System.Threading.Tasks.Parallel.For(0, 100000, (i) =&gt;<br>{<br>    a++;<br>});<br>Console.Write(a);</p>
<p>输出结果不稳定，小于等于100000。因为多线程访问，没有使用锁机制，会导致有更新丢失。</p>
<p>改进：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Threading.Interlocked.Add(<span class="keyword">ref</span> a, <span class="number">1</span>);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5301754.html">.NET面试题解析(07)-多线程编程与线程同步</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=netframework-4.7.2">https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=netframework-4.7.2</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yifengjianbai/p/5499493.html">C#多线程–线程池（ThreadPool）</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/henw/archive/2012/01/06/2314870.html">C#多线程学习 之 线程池[ThreadPool]</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/chengqscjh/archive/2010/12/12/1903784.html">C#深入学习笔记—Lock</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9007-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9007-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">DotNet面试题解析07-GC与内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-20 11:28:04" itemprop="dateCreated datePublished" datetime="2018-12-20T11:28:04+00:00">2018-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h2><h3 id="1-简述一下一个引用对象的生命周期？"><a href="#1-简述一下一个引用对象的生命周期？" class="headerlink" title="1. 简述一下一个引用对象的生命周期？"></a>1. 简述一下一个引用对象的生命周期？</h3><ul>
<li>new 创建对象并分配内存</li>
<li>对象初始化</li>
<li>对象操作、使用</li>
<li>资源清理（非托管资源）</li>
<li>GC 垃圾回收</li>
</ul>
<h3 id="2-创建下面对象实例，需要申请多少内存空间？"><a href="#2-创建下面对象实例，需要申请多少内存空间？" class="headerlink" title="2. 创建下面对象实例，需要申请多少内存空间？"></a>2. 创建下面对象实例，需要申请多少内存空间？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _Name = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; _Names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>40字节内存空间。</p>
<p>详细信息参考：<a target="_blank" rel="noopener" href="https://syxdevcode.github.io/2018/12/14/DotNet%E5%9F%BA%E7%A1%80-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">DotNet基础-GC与内存管理</a></p>
<h3 id="3-什么是垃圾？"><a href="#3-什么是垃圾？" class="headerlink" title="3. 什么是垃圾？"></a>3. 什么是垃圾？</h3><p>一个变量如果在其生存期内的某一时刻已经不再被引用，那么，这个对象就有可能成为垃圾</p>
<h3 id="4-GC是什么，简述一下GC的工作方式？"><a href="#4-GC是什么，简述一下GC的工作方式？" class="headerlink" title="4. GC是什么，简述一下GC的工作方式？"></a>4. GC是什么，简述一下GC的工作方式？</h3><p>GC 是<strong>垃圾回收（Garbage Collect）</strong>的缩写，是 .NET 核心机制的重要部分。她的基本工作原理就是遍历托管堆中的对象，标记哪些被使用对象（哪些没人使用的就是所谓的垃圾），然后把可达对象转移到一个连续的地址空间（也叫压缩），其余的所有没用的对象内存被回收掉。</p>
<h3 id="5-GC进行垃圾回收时的主要流程是？"><a href="#5-GC进行垃圾回收时的主要流程是？" class="headerlink" title="5. GC进行垃圾回收时的主要流程是？"></a>5. GC进行垃圾回收时的主要流程是？</h3><p><strong>(1)标记：</strong>先假设所有对象都是垃圾，根据应用程序根Root遍历堆上的每一个引用对象，生成可达对象图，对于还在使用的对象（可达对象）进行标记（其实就是在对象同步索引块中开启一个标示位）。</p>
<p><strong>(2)清除</strong>：针对所有不可达对象进行清除操作，针对普通对象直接回收内存，而对于实现了终结器的对象（实现了析构函数的对象）需要单独回收处理。清除之后，内存就会变得不连续了，就是步骤3的工作了。</p>
<p><strong>(3)压缩</strong>：把剩下的对象转移到一个连续的内存，因为这些对象地址变了，还需要把那些 Root 跟指针的地址修改为移动后的新地址。</p>
<h3 id="6-GC在哪些情况下回进行回收工作？"><a href="#6-GC在哪些情况下回进行回收工作？" class="headerlink" title="6. GC在哪些情况下回进行回收工作？"></a>6. GC在哪些情况下回进行回收工作？</h3><ul>
<li>内存不足溢出时（0代对象充满时）</li>
<li>Windwos 报告内存不足时，CLR 会强制执行垃圾回收</li>
<li>CLR 卸载 AppDomian，GC 回收所有</li>
<li>调用 GC.Collect</li>
<li>其他情况，如主机拒绝分配内存，物理内存不足，超出短期存活代的存段门限</li>
</ul>
<h3 id="7-using-语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？"><a href="#7-using-语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？" class="headerlink" title="7. using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？"></a>7. using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？</h3><p>using() 只是一种语法形式，其本质还是 try…finally 的结构，可以保证 Dispose 始终会被执行。</p>
<h3 id="8-解释一下C-里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？"><a href="#8-解释一下C-里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？" class="headerlink" title="8. 解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？"></a>8. 解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？</h3><p>C# 里的析构函数其实就是终结器 Finalize，因为长得像 C++ 里的析构函数而已。</p>
<p>有些编程建议里不推荐使用析构函数要原因在于：第一是 Finalize 本身性能并不好；其次很多人搞不清楚 Finalize 的原理，可能会滥用，导致内存泄露，因此就干脆别用了</p>
<h3 id="9-Finalize-和-Dispose-之间的区别？"><a href="#9-Finalize-和-Dispose-之间的区别？" class="headerlink" title="9. Finalize() 和 Dispose() 之间的区别？"></a>9. Finalize() 和 Dispose() 之间的区别？</h3><p>Finalize() 和 Dispose() 都是 .NET 中提供释放非托管资源的方式，他们的主要区别在于执行者和执行时间不同：</p>
<ul>
<li>finalize 由垃圾回收器调用；dispose 由对象调用。</li>
<li>finalize 无需担心因为没有调用 finalize 而使非托管资源得不到释放，而 dispose 必须手动调用。</li>
<li>finalize 不能保证立即释放非托管资源，Finalizer 被执行的时间是在对象不再被引用后的某个不确定的时间；而 dispose 一调用便释放非托管资源。</li>
<li>只有 class 类型才能重写 finalize ，而结构不能；类和结构都能实现 IDispose 。</li>
</ul>
<p>另外一个重点区别就是终结器会导致对象复活一次，也就说会被 GC 回收两次才最终完成回收工作，这也是不建议开发人员使用终结器的主要原因。</p>
<h3 id="10-Dispose和Finalize方法在何时被调用？"><a href="#10-Dispose和Finalize方法在何时被调用？" class="headerlink" title="10. Dispose和Finalize方法在何时被调用？"></a>10. Dispose和Finalize方法在何时被调用？</h3><ul>
<li>Dispose 一调用便释放非托管资源；</li>
<li>Finalize 不能保证立即释放非托管资源，Finalizer 被执行的时间是在对象不再被引用后的某个不确定的时间；</li>
</ul>
<h3 id="11-NET中的托管堆中是否可能出现内存泄露的现象？"><a href="#11-NET中的托管堆中是否可能出现内存泄露的现象？" class="headerlink" title="11. .NET中的托管堆中是否可能出现内存泄露的现象？"></a>11. .NET中的托管堆中是否可能出现内存泄露的现象？</h3><p>是的，可能会。比如：</p>
<ul>
<li>不正确的使用静态字段，导致大量数据无法被GC释放；</li>
<li>没有正确执行 Dispose()，非托管资源没有得到释放；</li>
<li>不正确的使用终结器 Finalize()，导致无法正常释放资源；</li>
<li>其他不正确的引用，导致大量托管对象无法被 GC 释放；</li>
</ul>
<h3 id="12-在托管堆上创建新对象有哪几种常见方式？"><a href="#12-在托管堆上创建新对象有哪几种常见方式？" class="headerlink" title="12. 在托管堆上创建新对象有哪几种常见方式？"></a>12. 在托管堆上创建新对象有哪几种常见方式？</h3><ul>
<li>new 一个对象；</li>
<li>字符串赋值，如 string s1=”abc”；</li>
<li>值类型装箱；</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5260319.html">.NET面试题解析(06)-GC与内存管理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/14/DotNet%E5%9F%BA%E7%A1%80-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/14/DotNet%E5%9F%BA%E7%A1%80-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">DotNet基础-GC与内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-14 14:33:47" itemprop="dateCreated datePublished" datetime="2018-12-14T14:33:47+00:00">2018-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">CSharp基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>GC的内存管理的目标主要都是引用类型对象。</p>
<h3 id="对象创建及生命周期"><a href="#对象创建及生命周期" class="headerlink" title="对象创建及生命周期"></a>对象创建及生命周期</h3><p>一个对象的生命周期简单概括就是：创建 &gt; 使用 &gt; 释放，在.NET中一个对象的生命周期：</p>
<ul>
<li>new创建对象并分配内存</li>
<li>对象初始化</li>
<li>对象操作、使用</li>
<li>资源清理（非托管资源）</li>
<li>GC垃圾回收</li>
</ul>
<p>大部分的对象创建都是开始于关键字 new,有个别引用类型是由专门 IL 指令的，比如 string 有 ldstr 指令。</p>
<p>引用对象都是分配在托管堆上的， 先来看看托管堆的基本结构，如下图，托管堆中的对象是顺序存放的，托管堆维护着一个指针 NextObjPtr，它指向下一个对象在堆中的分配位置。</p>
<p><img src="/img/82a2b4be6318aebc0dc9b7b29c2a7599.png" alt="82a2b4be6318aebc0dc9b7b29c2a7599.png"></p>
<p>创建一个新对象的主要流程:</p>
<p><img src="/img/151257-20160309235623241-1001221060.png" alt="151257-20160309235623241-1001221060.png"></p>
<p>模拟一个对象的创建过程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _Name = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; _Names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1，对象大小估算，共计40个字节：<br>  (1) 属性 Age 值类型 Int，4字节；<br>  (2) 属性 Name，引用类型，初始为 NULL，4个字节，指向空地址；<br>  (3) 字段 _Name 初始赋值了，代码会被编译器优化为 _Name=”123abc” 。一个字符两个字节，字符串占用 2×6+8（附加成员：4字节 TypeHandle 地址，4字节 同步索引块 ）= 20 字节，总共 内存大小 = 字符串对象20字节 + _Name 指向字符串的内存地址4字节=24字节；<br>  (4) 引用类型字段 List<string> _Names 初始默认为 NULL，4个字节；<br>  (5) User对象的初始附加成员（4字节 TypeHandle 地址，4字节同步索引块）8个字节；</li>
<li>2，内存申请： 申请 44 个字节的内存块，从指针 NextObjPtr 开始验证，空间是否足够，若不够则触发垃圾回收。</li>
<li>3，内存分配： 从指针 NextObjPtr 处开始划分 44 个字节内存块。</li>
<li>4，对象初始化： 首先初始化对象附加成员，再调用User对象的构造函数，对成员初始化，值类型默认初始为0，引用类型默认初始化为 NULL；</li>
<li>5，托管堆指针后移： 指针 NextObjPtr 后移44个字节。</li>
<li>6，返回内存地址： 返回对象的内存地址给引用变量。</li>
</ul>
<h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><p>GC是垃圾回收（ Garbage Collect）的缩写，是 .NET 核心机制的重要部分。她的基本工作原理就是遍历托管堆中的对象，标记哪些被使用对象（那些没人使用的就是所谓的垃圾），然后把可达对象转移到一个连续的地址空间（也叫压缩），其余的所有没用的对象内存被回收掉。</p>
<p><img src="/img/151257-20160309235624382-1396676769.png" alt="151257-20160309235624382-1396676769.png"></p>
<h3 id="垃圾回收基本流程"><a href="#垃圾回收基本流程" class="headerlink" title="垃圾回收基本流程"></a>垃圾回收基本流程</h3><h4 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h4><p>先假设所有对象都是垃圾，根据应用程序根指针 Root 遍历堆上的每一个引用对象，生成可达对象图，对于还在使用的对象（可达对象）进行标记（其实就是在对象同步索引块中开启一个标示位）。</p>
<p>其中 Root 根指针保存了当前所有需要使用的对象引用，他其实只是一个统称，意思就是这些对象当前还在使用，主要包含：静态对象/静态字段的引用；线程栈引用（局部变量、方法参数、栈帧）；任何引用对象的 CPU 寄存器；根引用对象中引用的对象；GC Handle table；Freachable 队列等。</p>
<p><strong>对性能的影响</strong></p>
<p>标记阶段是一个 “几乎仅有只读操作” 的阶段。这个阶段中没有任何对象被移动，也没有任何内存被回收。</p>
<ul>
<li>1，当进行一次完整的标记时，垃圾回收器几乎遍历了每一个被引用的对象。若这部分数据并不存在于程序工作区（working set）中就会造成页面错误，从而导致重新加载对象时缓存丢失（cache miss）与缓存抖动(cache thrashing)。</li>
<li>2，在一个多处理器系统中，当垃圾回收器在对象的头部进行位标记操作时，若相应的对象已被加载至其他处理器的缓存中，则会造成缓存失效。</li>
<li>3，标记阶段的性能取决于引用图中对象的数目，但是和对象占用的内存大小并无关系。</li>
</ul>
<h5 id="根"><a href="#根" class="headerlink" title="根"></a>根</h5><p>垃圾回收器遍历对象图中所有被应用程序引用的对象。为了正确的遍历图中的对象，需要选定一系列起点保证引用对象的遍历，这些起点称为 <strong>根</strong>。</p>
<p><strong>1.局部根</strong></p>
<p>局部变量是一种最显而易见的根。</p>
<p><strong>2.静态根</strong></p>
<p>另一种类型的根是 <strong>静态变量</strong>。静态成员类型在类型加载时被创建，并且可以在整个应用程序域（ application domain ）的生命周期内作为潜藏根。</p>
<p>例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">event</span> EventHandler ButtonClick;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Button button = <span class="keyword">new</span> Button();</span><br><span class="line">            ButtonClick += button.OnClick;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Button</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnClick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会造成内存泄漏。因为静态事件包含一个委托列表，而这个委托列表引用了我们创建的对象。<br><font color=#0099ff size=4 face="黑体">事实上，.NET 内存泄漏的最普遍原因是静态变量引用了对象。</font></p>
<p>可以使用 SOS.DLL 查看根，!gcroot 命令提供跟得类型和引用链的简明信息。</p>
<h4 id="清理阶段与压缩阶段"><a href="#清理阶段与压缩阶段" class="headerlink" title="清理阶段与压缩阶段"></a>清理阶段与压缩阶段</h4><p><strong>清理</strong></p>
<p>针对所有不可达对象进行清除操作，针对普通对象直接回收内存，而对于实现了终结器的对象（实现了析构函数的对象）需要单独回收处理。清除之后，内存就会变得不连续了，这时就需要压缩阶段了。</p>
<p>建议不要随意手动调用垃圾回收 GC.Collect()，GC 会选择合适的时机、合适的方式进行内存回收的。</p>
<p><strong>压缩</strong></p>
<p>把剩下的对象转移到一个连续的内存，因为这些对象地址变了，还需要把那些 Root 根指针的地址修改为移动后的新地址。</p>
<p><img src="/img/net-mem-02-mark-compact.png" alt="net-mem-02-mark-compact.png"></p>
<p><strong>性能影响</strong></p>
<ul>
<li>1，移动对象意味着内存复制，这对于内存占用多的对象来说是昂贵的开销。</li>
<li>2，对象被移动之后，所有的引用的值必须更新其地址。对于频繁引用的对象来说，这种分散的内存操作势必造成性能影响。</li>
</ul>
<p><strong>固定</strong></p>
<p>该场景涉及到托管对象传递给非托管代码。</p>
<h3 id="垃圾回收器的特性"><a href="#垃圾回收器的特性" class="headerlink" title="垃圾回收器的特性"></a>垃圾回收器的特性</h3><p>垃圾回收器是如何和其他应用程序线程（通常称为赋值线程，mutator thread）进行交互的。</p>
<h4 id="垃圾回收时暂停线程"><a href="#垃圾回收时暂停线程" class="headerlink" title="垃圾回收时暂停线程"></a>垃圾回收时暂停线程</h4><p>垃圾回收器和其他应用程序线程并发执行可以产生的问题：</p>
<ul>
<li>假阴性（false negative）:一个对象满足垃圾回收的条件，但被标记为活动的。</li>
<li>假阳性（false positive）:一个对象被认为是可回收对象，但它依然被应用程序所引用。尽量避免该情况发生。</li>
</ul>
<h4 id="在垃圾回收时挂起线程"><a href="#在垃圾回收时挂起线程" class="headerlink" title="在垃圾回收时挂起线程"></a>在垃圾回收时挂起线程</h4><p>垃圾回收时会在安全点（safe point）出挂起线程，JIT 编译器通过生成额外的信息确保只有安全的时候才挂起线程进行垃圾回收。而 CLR 也会尝试安全的挂起线程。</p>
<p>非托管线程并不会由于托管线程的挂起而受到影响，除非它已经切换回了托管线程，这一过程有平台调用转换器负责的。</p>
<h5 id="在标记阶段挂起线程"><a href="#在标记阶段挂起线程" class="headerlink" title="在标记阶段挂起线程"></a>在标记阶段挂起线程</h5><p><strong>出现假阳性</strong><br>如果垃圾回收器在对象创建之前，已经完成了相关部分引用图更新，那么一个刚刚被创建的对象，即使已经被应用程序引用，也可能判断为未引用。</p>
<p><strong>出现假阴性</strong><br>对于一个已经被标记的对象，如果它的最后一个引用在标记阶段被移除，那么这个本该被回收的对象就会继续存活。<br>如果对象真的不可达，那就不可能重新变成可达状态，它将在下一轮垃圾回收周期中被回收。</p>
<h5 id="在清理阶段挂起线程"><a href="#在清理阶段挂起线程" class="headerlink" title="在清理阶段挂起线程"></a>在清理阶段挂起线程</h5><p>CLR 禁止应用程序和垃圾回收过程并发执行。</p>
<h4 id="工作站垃圾回收"><a href="#工作站垃圾回收" class="headerlink" title="工作站垃圾回收"></a>工作站垃圾回收</h4><p>工作站垃圾回收（workstation GC）,分为<strong>并发工作站垃圾回收</strong> 与 <strong>非并发工作站垃圾回收</strong></p>
<p><strong>并发工作站垃圾回收</strong></p>
<p>并发工作站垃圾回收 是默认的特征。在并发工作站垃圾回收下，有一个独立的专门的垃圾回收线程。该线程在执行垃圾回收的过程时，始终具有 THRAD_PRIORITY_HIGHEST 优先级。CRL 可以决定是否允许某些垃圾回收阶段与应用程序线程并发执行。<br>图形界面应用程序应该尽量避免从 UI 线程触发垃圾回收，即在后台线程进行资源分配，且不要显示的从 UI 线程调用 GC.Collect 方法。因为UI线程被垃圾回收阻塞的同时，其它应用程序线程却在和垃圾回收过程争抢资源。</p>
<p><strong>非并发工作站垃圾回收</strong></p>
<p>非并发工作站垃圾回收特征在标记和清理阶段均会挂起应用程序线程。适用于从 UI 线程触发垃圾回收的情形。<br>由于在 UI 线程等待垃圾回收时，其它的后台线程不会和垃圾回收器争夺资源，一次 UI 线程可以即可恢复响应。</p>
<h4 id="服务器垃圾回收"><a href="#服务器垃圾回收" class="headerlink" title="服务器垃圾回收"></a>服务器垃圾回收</h4><p>服务器垃圾回收专门针对服务器应用程序进行了优化。</p>
<p>使用服务器垃圾回收特征的唯一限制是物理处理器的数目。如果仅有一个处理器，则只能够选择工作站垃圾回收特征。</p>
<p>由于并发工作站垃圾回收是默认的垃圾回收特征，一般运行于默认的 CLR 宿主下的命令行，windonws 应用程序，windows 服务都使用默认的垃圾回收特征；不在默认的 CLR 宿主运行的应用程序则可以选择其他的垃圾回收特征。由于 IIS 大多安装在服务器上，在 IIS ASP.NET 宿主下运行的应用程序使用的就是服务器垃圾回收特征（可以通过 web.config 修改这个定义）</p>
<h4 id="切换垃圾回收特征"><a href="#切换垃圾回收特征" class="headerlink" title="切换垃圾回收特征"></a>切换垃圾回收特征</h4><p>在默认的宿主下，可以通过应用程序配置文件( app.config )修改垃圾回收特征及其子特征。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;runtime&gt;</span><br><span class="line">    &lt;gcServer enabled=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;gcConcurrent enabled=&quot;false&quot;/&gt;</span><br><span class="line">  &lt;/runtime&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p><strong>安全的使用低延迟垃圾回收</strong></p>
<p>安全的使用低延迟垃圾回收的唯一途径是将其放在受限执行区域（constrained execution region,CER）内。</p>
<p>需要引用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line">GCLatencyMode oldModel = GCSettings.LatencyMode;</span><br><span class="line">RuntimeHelpers.PrepareConstrainedRegions();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    GCSettings.LatencyMode = GCLatencyMode.LowLatency;</span><br><span class="line">    <span class="comment">// Perform time-sensitive work here (执行时间敏感操作)</span></span><br><span class="line">&#125;<span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    GCSettings.LatencyMode = oldModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代龄（Generation）"><a href="#代龄（Generation）" class="headerlink" title="代龄（Generation）"></a>代龄（Generation）</h3><p>.NET 垃圾回收器的“代”模型（generational model）使用局部垃圾回收进行性能优化。</p>
<p>和真实世界的人和动物不同，.NET 认为年轻的对象更容易死亡，而年老的对象更倾向于存货。<br>年轻和年老的定义取决于应用程序垃圾回收的频率。在大多数应用程序中，临时对象（在一个方法张中分配的对象）大多是年轻的，而随着应用程序初始化的对象大多是年老的。</p>
<p>分代(Generation)算法 是 CLR 垃圾回收器采用的一种机制，它唯一的目的就是提升应用程序的性能。分代回收，速度显然快于回收整个堆。分代( Generation )算法的假设前提条件：</p>
<ul>
<li>1、大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长</li>
<li>2、对部分内存进行回收比基于全部内存的回收操作要快</li>
<li>3、新创建的对象之间关联程度通常较强。heap 分配的对象是连续的，关联度较强有利于提高 CPU cache 的命中率</li>
</ul>
<p>在 “代”模型 中，托管堆被划分为三个区域：第0代，第1代和第2代。</p>
<ul>
<li>第0代，最新分配在堆上的对象，从来没有被垃圾收集过。任何一个新对象，当它第一次被分配在托管堆上时，就是第0代（大于85000的大对象除外）。 </li>
<li>第1代，0代满了会触发0代的垃圾回收，0代垃圾回收后，剩下的对象会搬到1代。 </li>
<li>第2代，当0代、1代满了，会触发0代、1代的垃圾回收，第0代升为第1代，第1代升为第2代。</li>
</ul>
<p><img src="/img/net-mem-06-generation.png" alt="net-mem-06-generation.png"></p>
<p>大部分情况，GC 只需要回收0代即可，这样可以显著提高 GC 的效率，而且 GC 使用启发式内存优化算法，自动优化内存负载，自动调整各代的内存大小。</p>
<p>如果 Gen 0 heap 内存达到阀值，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果Gen 1的内存达到阀值，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。</p>
<p>　　2代 GC 将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收，Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为full GC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时，full GC可能需要花费几秒时间。大致上来讲 .NET 应用运行期间，2代、1代和0代GC的频率应当大致为1:10:100。</p>
<h4 id="第0代"><a href="#第0代" class="headerlink" title="第0代"></a>第0代</h4><p>第0代通常以 256KB-4MB 起步，根据使用情况缓慢增长。当第0代已满而不能完成一个新的内存分配请求时，第0代就会发起一次垃圾回收。<br>由于第0代的大小受高速缓存大小的影响，因此很可能在高速缓存中就可以找到第0代的所有对象。<font color=#0099ff size=4 face="黑体">第0代的所有对象几乎都在一次垃圾回收结束之后清理殆尽。</font><br>但是，仍然有一些对象会出于各种原因得以存活。</p>
<ul>
<li>应用程序具有糟糕的行为，分配的临时对象在一次垃圾回收之后仍然存活。</li>
<li>应用程序处于初始化阶段，这个阶段分配的对象多是长生命周期对象。</li>
<li>应用程序创建的是短期临时对象，但是在垃圾回收触发时这些对象恰巧正在被使用。</li>
</ul>
<p>这些撑过一次垃圾回收的对象不会被排列在第0代的起始位置。它们会被提升到第1代。</p>
<p><strong>跨代移动固定对象</strong></p>
<p>垃圾回收器无法移动固定的对象。但是 CLR 用一种非常巧妙的方法完成了固定对象的代升级：如果第0代由于固定对象的原因严重碎片化了，则 CLR 可以将整个第0代声明为更高代，并将一块新的内存声明为第0代，在这块内存中处理新的分配请求。</p>
<h4 id="第1代"><a href="#第1代" class="headerlink" title="第1代"></a>第1代</h4><p>第1代是第0代和第2代之间的缓冲区域。第1代典型的初始长度为 512KB-4MB。当第1代被填满时，会在第1代触发垃圾回收。只有第1代中的对象会被垃圾回收器标记和清除。自然触发第1代垃圾回收的唯一时机是在第0代垃圾回收后，存活的对象被提升至第1级时（另一种是手动触发垃圾回收）。</p>
<h4 id="第2代"><a href="#第2代" class="headerlink" title="第2代"></a>第2代</h4><p>第2代是在至少两次垃圾回收过程后存活对象的终极区域（还有大对象），在“代”模型中，这些对象属于老年对象，这些对象不太可能在短期内回收。<font color=#0099ff size=4 face="黑体">第2代区域不会人为的进行大小限制，它可以扩展到整个系统进程的专用内存空间，在32位系统中为2GB，在64位系统中最多为8TB。第2代中设定了动态阈值（水印）以触发垃圾回收操作。</font></p>
<p>若垃圾回收发生在第二代，则这是一个完全的垃圾回收。这是昂贵的，需要消耗最多的时间。</p>
<h4 id="大对象堆"><a href="#大对象堆" class="headerlink" title="大对象堆"></a>大对象堆</h4><p>大对象堆（large object heap,LOH）是一个专门容纳大对象的特殊区域。指内存占用大于85KB（85000字节）的对象。这个区域的主要特点就是：不会轻易被回收；就是回收了也不会被压缩（因为对象太大，移动复制的成本太高了）。</p>
<p><font color=#0099ff size=4 face="黑体">这个大小指对象本身的大小而非以该对象为根的整个对象树的大小。</font>因此，包含1000个字符串（每个字符串含有100个字符）的数组不是一个大对象，但是一个长度为50000的整数数组是一个大对象。</p>
<p>大对象从 LOH 中直接分配而不会放在第0代，第1代或者第2代中。</p>
<p>垃圾回收在 LOH 上进行回收时，并不会清理大对象并进行数据复制。LOH 维护了一个未使用内存的链表，新的内存分配请求可以从链表中进行。</p>
<p><font color=#0099ff size=4 face="黑体">当第2代对象占用的内存达到阈值时，则 LOH 就会进行垃圾回收。类似的，若 LOH 占用的内存达到阈值，也会触发第2代垃圾回收。因此，创建太多大型的临时对象也会造成类似 “中年危机” –必须进行完全回收以释放这些对象。LOH 中的碎片是另一个潜在问题，因为 LOH 中对象之间的空洞无法在清理阶段被移除并达到对堆进行碎片整理的效果。一个有效的策略是缓存并重用大对象，或者是（如果数组中对象的类型是一致的）分配一个大对象，然后在需要时手动将其分成小块。</font></p>
<h2 id="GC-Collect-方法"><a href="#GC-Collect-方法" class="headerlink" title="GC.Collect() 方法"></a>GC.Collect() 方法</h2><p>作用：强制进行垃圾回收。</p>
<p>Collect()：强制对所有代进行即时垃圾回收。</p>
<p>Collect(Int32)：强制对零代到指定代进行即时垃圾回收。</p>
<p>Collect(Int32, GCCollectionMode)：强制在 GCCollectionMode 值所指定的时间对零代到指定代进行垃圾回收</p>
<p>GC注意事项：</p>
<ul>
<li>1、只管理内存，非托管资源，如文件句柄，GDI 资源，数据库连接等还需要用户去管理。</li>
<li>2、循环引用，网状结构等的实现会变得简单。GC 的标志-压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。</li>
<li>3、GC 通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于 COM 中的引用计数方法。</li>
<li>4、GC 在一个独立的线程中运行来删除不再被引用的内存。</li>
<li>5、GC 每次运行时会压缩托管堆。</li>
<li>6、你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。</li>
<li>7、对象的 Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数</li>
<li>8、Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer，不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer，而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。</li>
<li>9、.NET GC使用”代”(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。成员变量和全局变量很快变成第1代对象并最终成为第2代对象。</li>
<li>10、GC 对不同代的对象执行不同的检查策略以优化性能。每个 GC 周期都会检查第0代对象。大约1/10的 GC 周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。重新思考Finalization的代价：需要Finalization的对象可能比不需要 Finalization 在内存中停留额外9个GC周期。如果此时它还没有被Finalize，就变成第2代对象，从而在内存中停留更长时间。</li>
</ul>
<h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><p>一个高代对象引用一个低代对象的情形只会在一种类型的语句中出现：将一个非空引用类型对象赋值给一个引用类型的实例的成员变量（或者复制给一个数组的元素）。</p>
<h2 id="非托管资源回收"><a href="#非托管资源回收" class="headerlink" title="非托管资源回收"></a>非托管资源回收</h2><p>&emsp;&emsp;非托管资源不受 CLR 或者垃圾回收器的管理（如内核对象句柄，数据库连接和非托管内存等）。释放非托管资源需要使用 终结化特性，即一个对象与一段特定的代码关联起来。这段代码必须在该对象（代表一个非托管资源）不再需要时执行。</p>
<p>常见的有：ApplicationContext, Brush, Component, ComponentDesigner, Container, Context, Cursor, FileStream, Font, Icon, Image, Matrix, Object, OdbcDataReader, OleDBDataReader, Pen, Regex, Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源。</p>
<p>.NET 中提供释放非托管资源的方式主要是：Finalize() 和 Dispose()。</p>
<p>.NET的GC机制有这样两个问题：</p>
<ul>
<li>GC并不是能释放所有的资源。它不能自动释放非托管资源。</li>
<li>GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。</li>
</ul>
<p>　　GC 并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了 IDisposable 接口，IDisposable 接口定义了 Dispose 方法，这个方法用来供程序员显式调用以释放非托管资源。使用 using 语句可以简化资源管理。</p>
<p>当你用 Dispose 方法释放未托管对象的时候，应该调用 GC.SuppressFinalize。如果对象正在终结队列( finalization queue ), GC.SuppressFinalize 会阻止 GC 调用 Finalize 方法。因为 Finalize 方法的调用会牺牲部分性能。如果你的 Dispose 方法已经对委托管资源作了清理，就没必要让 GC 再调用对象的 Finalize 方法。</p>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><p>所有实现了终结器（析构函数）的对象，会被 GC 特殊照顾，GC 的终止化队列跟踪所有实现了 Finalize 方法（析构函数）的对象。</p>
<ul>
<li>当 CLR 在托管堆上分配对象时，GC 检查该对象是否实现了自定义的 Finalize 方法（析构函数）。如果是，对象会被标记为可终结的，同时这个对象的指针被保存在名为终结队列的内部队列中。终结队列是一个由垃圾回收器维护的表，它指向每一个在从堆上删除之前必须被终结的对象。</li>
<li>当 GC 执行并且检测到一个不被使用的对象时，需要进一步检查“终结队列”来查询该对象类型是否含有 Finalize 方法，如果没有则将该对象视为垃圾，如果存在则将该对象的引用移动到另外一张 Freachable 列表，此时对象会被复活一次。</li>
<li>CLR 将有一个单独的高优先级线程负责处理 Freachable 列表，就是依次调用其中每个对象的 Finalize 方法，然后删除引用，这时对象实例就被视为不再被使用，对象再次变成垃圾。</li>
<li>下一个 GC 执行时，将释放已经被调用 Finalize 方法的那些对象实例。</li>
</ul>
<p>简单总结：Finalize() 可以确保非托管资源会被释放，但需要很多额外的工作（比如终结对象特殊管理），而且 GC 需要执行两次才会真正释放资源。唯一的优点就是不需要显示调用。</p>
<h3 id="Finalization-Queue-和-Freachable-Queue"><a href="#Finalization-Queue-和-Freachable-Queue" class="headerlink" title="Finalization Queue 和 Freachable Queue"></a>Finalization Queue 和 Freachable Queue</h3><p>　　这两个队列和 .NET 对象所提供的 Finalize 方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了 new 操作符在 Managed Heap 上分配空间时，GC 会对其进行分析，如果该对象含有 Finalize 方法则在 Finalization Queue 中添加一个指向该对象的指针。</p>
<p>　　在 GC 被启动以后，经过 Mark 阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被 Finalization Queue 中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到 Freachable Queue 中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？因为这个对象的 Finalize 方法还没有被执行，所以不能让它死去。Freachable Queue 平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的 Finalize 方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。</p>
<p>　　.NET Framework 的 System.GC 类提供了控制Finalize的两个方法，ReRegisterForFinalize 和 SuppressFinalize。前者是请求系统完成对象的 Finalize 方法，后者是请求系统不要完成对象的 Finalize 方法。ReRegisterForFinalize 方法其实就是将指向对象的指针重新添加到 Finalization Queue 中。这就出现了一个很有趣的现象，因为在 Finalization Queue 中的对象可以复生，如果在对象的 Finalize 方法中调用 ReRegisterForFinalize 方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。</p>
<h3 id="手动确定性终结化"><a href="#手动确定性终结化" class="headerlink" title="手动确定性终结化"></a>手动确定性终结化</h3><p>手动确定性终结化，需要客户端释放资源。</p>
<h3 id="自动非确定性终结化"><a href="#自动非确定性终结化" class="headerlink" title="自动非确定性终结化"></a>自动非确定性终结化</h3><p>Finalize 来自 System.Object 中受保护的虚方法 Finalize，无法被子类显示重写，也无法显示调用。她的作用就是用来释放非托管资源，由 GC 来执行回收，因此可以保证非托管资源可以被释放。</p>
<ul>
<li>无法被子类显示重写：.NET 提供类似 C++ 析构函数的形式来实现重写，因此也有称之为析构函数，但其实她只是外表和C++ 里的析构函数像而已。</li>
<li>无法显示调用：由 GC 来管理和执行释放，不需要手动执行了，不用担心忘记调用Dispose。</li>
</ul>
<p>&emsp;&emsp;任何一种类型都可以通过重写 System.Object 定义的（protected）Finalize 方法表明该类型需要进行自动化终结。例如在 File 类中自动终结化方法 ~File（终结器,析构函数）。在对象将被销毁时，该方法必须得到执行。值类型只有在装箱的情况下才有垃圾回收的必要。</p>
<p>&emsp;&emsp;当一个拥有终结器的对象被创建时，他的一个引用将被添加到一个特殊的运行时队列上，成为终结队列（finalization queue）。这个队列被垃圾回收器界定为根。这意味着即使应用程序没有针对这个引用对象的引用，它仍然会子啊终结队列上保持活动状态。</p>
<p>&emsp;&emsp;当这个对象不再被应用程序引用，并开始垃圾回收时，若垃圾回收发现唯一一个针对该对象的引用来自于终结队列，则它会将这个对象的引用移动到另一个运行时管理的队列上，成为终结可达队列（freacheable queue）。该队列仍然被界定为根，因而，该对象仍然在被引用并保持存活。</p>
<p>&emsp;&emsp;<font color=#0099ff size=4 face="黑体">对象的终结器不会在垃圾回收的过程中执行。</font>在 CLR 初始化的过程会创建一个特殊的线程，称为 终结器线程（finalizaer thread）(每一个进程只会有一个终结器线程，这和垃圾回收器特征无关，该线程运行在 THREAD_PRIORITY_HIGHEST 优先级上)。这个线程会反复等待终结化事件（finalization event）的触发。在垃圾回收器完成垃圾回收并触发该事件后，如果终结可达队列中有对象放入，则终结器线程就会被激活。终结器线程将对象的引用从终结可达队列中移除，同时同步执行对象上的终结器方法。而当下一次垃圾回收开始时，由于该对象再无引用，因此垃圾回收可以将其内存回收。</p>
<h3 id="非确定性终结的缺点"><a href="#非确定性终结的缺点" class="headerlink" title="非确定性终结的缺点"></a>非确定性终结的缺点</h3><ul>
<li>有终结器的对象将至少位于第1代，更容易经历“中年危机”，从而更容易进行多次完整回收。</li>
<li>终结器线程的压力（有很多对象需要进行终结化）可能导致内存泄漏。如果应用程序线程分配对象的频率比终结器线程终结化对象的频率更高，那么应用程序将从等待终结化的对象中持续的泄漏内存。</li>
<li>自动非确定性终结化还是很多难以发现或调试错误的来源。因为终结化是异步的，因此多个对象的终结顺序是难以保证的。</li>
</ul>
<p><strong>终结器也许永远不会被调用</strong></p>
<p>&emsp;&emsp;终结器无法在进程被野蛮的关闭时执行。如用户通过任务管理器或者 TerminateProcess API 终止线程的执行，则终结器将无法进行资源回收。</p>
<p><strong>对象的复活</strong></p>
<p>终结化为对象提供了一个在其不被应用程序引用的情况下执行任意代码的机会。这种机会可以用于创建一个应用程序到该对象的引用，在对象即将失效时，另其起死回生，这种能力称为复活（resurrection）。主要的风险是，该对象引用的其它对象有可能已经被终结化而处于无效状态，此时，只能重新初始化该对象所有引用的对象；另一个问题是该对象的终结器不会被执行，因此你需要将该对象的引用作为参数传递个 GC.ReRegisterForFinnalize 方法。</p>
<p>适用于复活机制的场景之一就是对象池（object pooling）。</p>
<h3 id="Dispose模式"><a href="#Dispose模式" class="headerlink" title="Dispose模式"></a>Dispose模式</h3><p>.Net 规定所有需要进行确定终结化的对象都必须实现 IDisposable 接口。而该接口仅有一个方法，即 Dispose 方法。这个方法会释放非托管资源，进行确定终结化。</p>
<p>Dispose 需要手动调用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：显示接口调用</span></span><br><span class="line">SomeType st1=<span class="keyword">new</span> SomeType();</span><br><span class="line"><span class="comment">//do sth</span></span><br><span class="line">st1.Dispose();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：using()语法调用，自动执行Dispose接口</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> st2 = <span class="keyword">new</span> SomeType())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种方式，显示调用，缺点显而易见，如果程序猿忘了调用接口，则会造成资源得不到释放。或者调用前出现异常，当然这一点可以使用 try…finally 避免。</p>
</li>
<li><p>建议使用第二种实现方式，他可以保证无论如何 Dispose 接口都可以得到调用，原理其实很简单，using() 的 IL 代码如下图，因为 using 只是一种语法形式，本质上还是 try…finally 的结构。</p>
</li>
</ul>
<p><img src="/img/151257-20160309235625475-414934067.png" alt="151257-20160309235625475-414934067.png"></p>
<p>微软是推荐同时实现 IDisposable 接口和 Finalize （析构函数），其实 FCL 中很多类库都是这样实现的，这样可以兼具两者的优点：</p>
<ul>
<li>如果调用了 Dispose，则可以忽略对象的终结器，对象一次就回收了；</li>
<li>如果忘了调用 Dispose，则还有一层保障，终结器会负责对象资源的释放；</li>
</ul>
<h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h2><p>尽量不要手动执行垃圾回收的方法：GC.Collect()</p>
<p>垃圾回收的运行成本较高（涉及到了对象块的移动、遍历找到不再被使用的对象、很多状态变量的设置以及 Finalize 方法的调用等等），对性能影响也较大，因此我们在编写程序时，应该避免不必要的内存分配，也尽量减少或避免使用 GC.Collect() 来执行垃圾回收，一般 GC 会在最适合的时间进行垃圾回收。</p>
<p>需要注意，在执行垃圾回收的时候，所有线程都是要被挂起的（如果回收的时候，代码还在执行，那对象状态就不稳定了，也没办法回收了）。</p>
<p>推荐 Dispose 代替 Finalize</p>
<p>如果你了解 GC 内存管理以及 Finalize 的原理，可以同时使用 Dispose 和 Finalize 双保险，否则尽量使用 Dispose。</p>
<p>选择合适的垃圾回收机制：工作站模式、服务器模式。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用（weak reference）是用于管理托管对象引用的附加机制。典型的对象引用（通常为强引用（strong reference））是明确的：只要还拥有一个对象的引用，那么这个对象就会存活。这种行为的正确性是有垃圾回收器保证的。</p>
<p>但在某些情况下，我们还希望有一种隐形的 “绳索”，即能够绑在对象上，又不影响垃圾回收器回收它占用的内存。如果垃圾回收器回收了这个对象，那么我们可以探测到绳索的一端和对象断开了。如果垃圾回收器还没有处理这个对象，我们可以牵动“绳索”来获得这个对象的一个强引用并在此使用这个对象。</p>
<p>常见的场景：</p>
<ul>
<li>在不保持对象的存活的情况下提供外部服务。例如，定时器和事件服务可以为对象所用，但并不需要维持对象的引用。这可以避免很多典型的内存泄漏问题。</li>
<li>可以自动管理缓存或池策略。一个缓存可以保有最近使用对象的弱引用而不妨碍他们被回收。一个池可以划分为一个非常小的部分用以维持一小部分对象的强引用，以及另外一个可选部分对象的弱引用。</li>
<li>用以保存一个大对象的引用，并寄希望于它不会被回收。应用程序可以持有一个需要长时间才能初始化的大对象的弱引用。若这个对象被回收，则重新初始化该对象，否则可以在需要时直接复用该对象。</li>
</ul>
<p>引用程序代码可以通过 <code>System.WeakReference</code> 类来使用弱引用。可以基于 <code>System.WeakReference</code> 实现事件，这样可以规避.NET内存泄漏的元凶–忘记反注册事件。</p>
<p>弱引用默认不会跟踪对象的复活。若想允许复活追踪功能，就使用重载的构造函数并将第二个参数传参为true。</p>
<p><font color=#0099ff size=4 face="黑体">允许追踪对象复活状态的弱引用称为长弱引用（long weak reference）；不追踪对象复活状态的弱引用称为短弱引用（short weak reference）。</font></p>
<p><strong>垃圾回收句柄</strong></p>
<p>弱引用是一类特殊的垃圾回收句柄（ GC handle ）。一个垃圾回收句柄是一个特殊的底层值类型，它为对象引用提供了如下的功能。</p>
<ul>
<li>维持一个对象的标准的（强）引用，防止对象被回收。以 GCHandleType.Normal 表示。</li>
<li>维持一个对象的短弱引用。以 GCHandleType.Weak 表示。</li>
<li>维持一个对象的长弱引用。以 GCHandleType.WeakTrackResurrection 表示。</li>
<li>维持一个对象的引用，并进行固定，以防止它在内存中被移动。如果需要还可以获得该对象的地址。以 GCHandleType.Pinned 表示。</li>
</ul>
<p>实际开发中，我们几乎没有直接使用垃圾回收句柄的需要。但是它们，作为另一种可以保持对象的根，经常出现在诊断结果中。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5260319.html">.NET面试题解析(06)-GC与内存管理</a></p>
<p><a target="_blank" rel="noopener" href="https://kb.cnblogs.com/page/106720/">C#技术漫谈之垃圾回收机制(GC)</a></p>
<p>[.Net性能优化]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/14/CSharp%E8%BD%AC%E6%8D%A2%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/14/CSharp%E8%BD%AC%E6%8D%A2%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">CSharp转换关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-14 10:39:56" itemprop="dateCreated datePublished" datetime="2018-12-14T10:39:56+00:00">2018-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">CSharp基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSharp转换关键字"><a href="#CSharp转换关键字" class="headerlink" title="CSharp转换关键字"></a>CSharp转换关键字</h1><h2 id="explicit-显示转换"><a href="#explicit-显示转换" class="headerlink" title="explicit(显示转换)"></a>explicit(显示转换)</h2><p><code>explicit</code>:必须通过转换来调用的用户定义的类型转换运算符。</p>
<p>&emsp;&emsp;此转换运算符从源类型转换为目标类型。 源类型提供转换运算符。 不同于隐式转换，显式转换运算符必须通过转换的方式来调用。 如果转换操作会导致异常或丢失信息，则应将其标记为 explicit。 这可阻止编译器静默调用可能产生意外后果的转换操作。<br>省略转换将导致编译时错误 CS0266。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Digit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">byte</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define explicit byte-to-Digit conversion operator:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">byte</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Digit d = <span class="keyword">new</span> Digit(b);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;conversion occurred&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ExplicitTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span> b = <span class="number">3</span>;</span><br><span class="line">            Digit d = (Digit)b; <span class="comment">// explicit conversion</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; Exception caught.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">conversion occurred</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="implicit-隐式转换"><a href="#implicit-隐式转换" class="headerlink" title="implicit(隐式转换)"></a>implicit(隐式转换)</h2><p><code>implicit</code> 关键字用于声明隐式的用户定义类型转换运算符。 如果可以确保转换过程不会造成数据丢失，则可使用该关键字在用户定义类型和其他类型之间进行隐式转换。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Digit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">double</span> d</span>)</span> &#123; val = d; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> val;</span><br><span class="line">    <span class="comment">// ...other members</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// User-defined conversion from Digit to double</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">double</span>(<span class="params">Digit d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  User-defined conversion from double to Digit</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">double</span> d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Digit(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Digit dig = <span class="keyword">new</span> Digit(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//This call invokes the implicit &quot;double&quot; operator</span></span><br><span class="line">        <span class="built_in">double</span> num = dig;</span><br><span class="line">        <span class="comment">//This call invokes the implicit &quot;Digit&quot; operator</span></span><br><span class="line">        Digit dig2 = <span class="number">12</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;num = &#123;0&#125; dig2 = &#123;1&#125;&quot;</span>, num, dig2.val);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">num = 7 dig2 = 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="operator-运算符"><a href="#operator-运算符" class="headerlink" title="operator(运算符)"></a>operator(运算符)</h2><p>operator作用：</p>
<ul>
<li>1, 重载内置运算符</li>
<li>2, 在类或结构声明中提供用户定义的转换</li>
</ul>
<p>若要在自定义类或结构上重载运算符，可以在相应的类型中创建运算符声明。 重载内置 C# 运算符的运算符声明必须满足以下规则：</p>
<ul>
<li>同时包含 public 和 static 修饰符。</li>
<li>包含 operator X，其中 X 是被重载运算符的名称或符号。</li>
<li>一元运算符具有一个参数，二元运算符具有两个参数。 在每种情况下，都必须至少有一个参数与声明运算符的类或结构的类型相同。</li>
</ul>
<p>注：<font color=#0099ff size=4 face="黑体"><br>1,一元运算符：++，–，!;<br>2,二元运算符：+，-，* /;<br>3,三元运算符：a=3&gt;4?3:4<br></font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> num, den;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fraction</span>(<span class="params"><span class="built_in">int</span> num, <span class="built_in">int</span> den</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.den = den;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload operator +</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> +(Fraction a, Fraction b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction(a.num * b.den + b.num * a.den,</span><br><span class="line">           a.den * b.den);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload operator *</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> *(Fraction a, Fraction b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction(a.num * b.num, a.den * b.den);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user-defined conversion from Fraction to double</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">double</span>(<span class="params">Fraction f</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">double</span>)f.num / f.den;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Fraction a = <span class="keyword">new</span> Fraction(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Fraction b = <span class="keyword">new</span> Fraction(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        Fraction c = <span class="keyword">new</span> Fraction(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        Console.WriteLine((<span class="built_in">double</span>)(a * b + c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">0.880952380952381</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/explicit">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/explicit</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/13/DotNet%E8%A7%A3%E5%86%B3%E4%BA%8B%E4%BB%B6-Event-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/13/DotNet%E8%A7%A3%E5%86%B3%E4%BA%8B%E4%BB%B6-Event-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">DotNet解决事件(Event)内存泄漏通用方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-13 15:05:14" itemprop="dateCreated datePublished" datetime="2018-12-13T15:05:14+00:00">2018-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" itemprop="url" rel="index"><span itemprop="name">内存泄漏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DotNet解决事件-Event-内存泄漏通用方法"><a href="#DotNet解决事件-Event-内存泄漏通用方法" class="headerlink" title="DotNet解决事件(Event)内存泄漏通用方法"></a>DotNet解决事件(Event)内存泄漏通用方法</h1><p>&emsp;&emsp;一个生命周期较短的对象（对象A）注册到一个生命周期较长（对象B）的某个事件（Event）上，两者便无形之间建立一个引用关系（B引用A）。这种引用关系导致GC在进行垃圾回收的时候不会将A是为垃圾对象，最终使其常驻内存（或者说将A捆绑到B上，具有了和B一样的生命周期）。这种让无用的对象不能被GC垃圾回收的现象，在托管环境下就是一种典型的内存泄漏问题。</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1_zrGMRwiyB6Kky8t5kgFlA">代码下载</a><br>提取码：xazz</p>
<p><font color=#0099ff size=4 face="黑体">事实上，.NET内存泄漏的最普遍原因是静态变量引用了对象。</font></p>
<h2 id="造成事件-Event-内存泄漏的原因"><a href="#造成事件-Event-内存泄漏的原因" class="headerlink" title="造成事件(Event)内存泄漏的原因"></a>造成事件(Event)内存泄漏的原因</h2><p>事件本质上就是一个System.Delegate对象。<br>Delegate分解成两个部分：委托的事情和委托的对象。与之相似地，.NET的Delegate对象同样可以分解成两个部分：委托的功能（Method）和目标对象（Target），这可以直接从Delegate的定义就可以看出来：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Delegate</span> : <span class="title">ICloneable</span>, <span class="title">ISerializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Others</span></span><br><span class="line">    <span class="keyword">public</span> MethodInfo Method &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">object</span> Target &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的事件处理类型<code>EventHandler</code>和<code>EventHandler&lt;TEventArgs&gt;</code>本质上就是一个Delegate。</p>
<p>他们继承自<code>System.MulticastDelegate</code>，<code>MulticastDelegate</code>派生于<code>Delegate</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Serializable, ComVisible(true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>&lt;<span class="title">TEventArgs</span>&gt;(<span class="params"><span class="built_in">object</span> sender, TEventArgs e</span>) <span class="keyword">where</span> TEventArgs: EventArgs</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;经过简单一句事件注册代码就通过一个EventHandler（EventHandler<TodoListArgs>）事件的源（TodoListManager）和事件的监听者（TodoListForm）两着关联起来，三者之间的关系如下图所示。从这张图中我们可以看到：TodoListForm实际上是通过注册的EventHandler的Target属性被TodoListManager间接引用着的。所以才会导致TodoListForm在关闭之后，永远不能拿成为垃圾对象，因为TodoListManager是一个基于static属性定义的Singleton对象，永远是GC的根。</p>
<p><img src="/img/image_thumb_2.png" alt="image_thumb_2.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>&emsp;&emsp;当对象A注册到B的某个事件上，A并不受到B的“强制引用”。既然不能“强引用（Strong Reference）”，那就只能是“弱引用（Weak Reference）”。通过<code>System.WeakReference</code>来解决这个问题。</p>
<p>方法：采取某种机制，让事件源（Event Source）的EventHandler通过WeakReference的方式与事件监听者建立关系。只有在这种情况下，事件监听者没有了事件源的强制引用，在我们不用的时候才能及时成为垃圾对象，等待GC对它的清理。</p>
<p><img src="/img/image_thumb_3.png" alt="image_thumb_3.png"></p>
<p>&emsp;&emsp;通过传入<code>EventHandler&lt;TEventArgs&gt;</code>对象构造WeakReferenceHandler，在EventHandler<TEventArgs>的Target属性基础上建立WeakReference对象，在执行处理事件的时候通过该WeakReference找到真正的目标对象，如果找得到则通过反射在其基础上调用相应的方法；反之，如果通过不能得到Target，那么表明该事件的监听对象已经被GC当作垃圾对象回收掉了。为了在注册事件的时候方遍，特定义了一个隐式的类型转换：WeakReferenceHandler转换成EventHandler<TEventArgs>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Artech.MemLeakByEvents</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeakEventHandler</span>&lt;<span class="title">TEventArgs</span>&gt; <span class="keyword">where</span> <span class="title">TEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> WeakReference Reference</span><br><span class="line">        &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> MethodInfo Method</span><br><span class="line">        &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> EventHandler&lt;TEventArgs&gt; Handler</span><br><span class="line">         &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WeakEventHandler</span>(<span class="params">EventHandler&lt;TEventArgs&gt; eventHandler</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Reference = <span class="keyword">new</span> WeakReference(eventHandler.Target);</span><br><span class="line">            Method = eventHandler.Method;</span><br><span class="line">            Handler = Invoke;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"><span class="built_in">object</span> sender, TEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">object</span> target = Reference.Target;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != target)</span><br><span class="line">            &#123;</span><br><span class="line">                Method.Invoke(target, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; sender, e &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 隐式转换</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;weakHandler&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">EventHandler</span>&lt;<span class="title">TEventArgs</span>&gt;(<span class="params">WeakEventHandler&lt;TEventArgs&gt; weakHandler</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> weakHandler.Handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际进行事件注册:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TodoListForm_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext = SynchronizationContext.Current;</span><br><span class="line">    TodoListManager.Instance.TodoListChanged += <span class="keyword">new</span> WeakEventHandler&lt;TodoListEventArgs&gt;(TodoListManager_TodoListChanged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/artech/archive/2009/12/06/1618239.html">事件(Event)，绝大多数内存泄漏（Memory Leak）的元凶[下篇] （提供Source Code下载）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/13/DotNet%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-Memory-Leak-%E4%BA%8B%E4%BB%B6-Event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/13/DotNet%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-Memory-Leak-%E4%BA%8B%E4%BB%B6-Event/" class="post-title-link" itemprop="url">DotNet内存泄漏(Memory Leak)-事件(Event)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-13 11:06:53" itemprop="dateCreated datePublished" datetime="2018-12-13T11:06:53+00:00">2018-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">委托与事件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="DotNet内存泄漏-Memory-Leak-事件-Event"><a href="#DotNet内存泄漏-Memory-Leak-事件-Event" class="headerlink" title="DotNet内存泄漏(Memory Leak)-事件(Event)"></a>DotNet内存泄漏(Memory Leak)-事件(Event)</h1><p>通过<a target="_blank" rel="noopener" href="http://www.cnblogs.com/artech/archive/2009/12/03/1616507.html">事件(Event)，绝大多数内存泄漏（Memory Leak）的元凶[上篇]</a>这篇文章的实例，学习内存泄漏。</p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1_zrGMRwiyB6Kky8t5kgFlA">代码下载</a><br>提取码：xazz</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181213135838.png" alt="微信截图_20181213135838.png"></p>
<p>&emsp;&emsp;我们这个应用程序叫做TodoListManager，因为通过它可以实时查看属于用户的“待办事宜（Todolist）”。这是一个GUI的应用，有两个Windows Form组成：左侧的窗体是一个程序的主界面（为了简单起见，我甚至没有将其做成MDI窗体），点击Todo List菜单项，右面的Form被显示出来：所有的代码事宜将会全部列出，为了保证记录的实时显示，每隔5秒钟数据自动刷新一次。</p>
<p>&emsp;&emsp;首先定义表示每一项TotoList Item定义了一个相应的类型：MyEvent（不是我们谈到的导致内存泄漏的事件）。Event仅仅包含简单的属性：主题（Subject），截至日期（DueDate）和相应的描述性文字（Description），Event定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyEvent</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Subject &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> DateTime DueDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span>(<span class="params"><span class="built_in">string</span> subject, DateTime dueDate, <span class="built_in">string</span> desc</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(subject))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;subject&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.Subject = subject;</span><br><span class="line">            <span class="keyword">this</span>.DueDate = dueDate;</span><br><span class="line">            <span class="keyword">this</span>.Description = desc ?? <span class="built_in">string</span>.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后将所有逻辑（实际上仅仅是定期获取TodoList列表而已）定义在下面一个叫做TodoListManager的类型中。将其定义成Singleton的形式，并采用<code>System.Threading.Timer</code>实现定时地获取Todo List的操作。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TodoListManager</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> TodoListManager instance = <span class="keyword">new</span> TodoListManager();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;TodoListEventArgs&gt; TodoListChanged;</span><br><span class="line">        <span class="keyword">private</span> Timer todoListRefreshSchedler;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">TodoListManager</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            todoListRefreshSchedler = <span class="keyword">new</span> Timer</span><br><span class="line">            (</span><br><span class="line">                state =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> == TodoListChanged)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    TodoListChanged(<span class="literal">null</span>, <span class="keyword">new</span> TodoListEventArgs(GetTodolist()));</span><br><span class="line">                &#125;</span><br><span class="line">           , <span class="literal">null</span>, <span class="number">0</span>, <span class="number">5000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> TodoListManager Instance</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> List&lt;MyEvent&gt; <span class="title">GetTodolist</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;MyEvent&gt;();</span><br><span class="line">            list.Add(<span class="keyword">new</span> MyEvent(<span class="string">&quot;Meeting with Testing Team&quot;</span>, DateTime.Today.AddDays(<span class="number">2</span>), <span class="string">&quot;NIL&quot;</span>));</span><br><span class="line">            list.Add(<span class="keyword">new</span> MyEvent(<span class="string">&quot;Deliver progress report to manager &quot;</span>, DateTime.Today.AddDays(<span class="number">7</span>), <span class="string">&quot;NIL&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于Timer的每一个轮询，都会处触发一个类型为<code>EventHandler&lt;TodoListEventArgs&gt;</code>的事件，通过注册这个事件，可以通过类型为TodoListEventArgs的事件参数得到最新的TodoList的列表，TodoListEventArgs定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TodoListEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IEnumerable&lt;MyEvent&gt; TodoList</span><br><span class="line">    &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TodoListEventArgs</span>(<span class="params">IEnumerable&lt;MyEvent&gt; todoList</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == todoList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;todoList&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.TodoList = todoList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在窗体Load的时候注册TodoListManager的TodoListChanged事件，并将获取到的TodoList列表绑定到DataGridView上面。由于TodoListManager异步工作的原因，借助了SynchronizationContext这么一个对象实现对数据的绑定。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ToDoListForm</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> SynchronizationContext SynchronizationContext &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoListForm</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ToDoListForm_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SynchronizationContext = SynchronizationContext.Current;</span><br><span class="line">            TodoListManager.Instance.TodoListChanged += TodoListManager_TodoListChanged;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TodoListManager_TodoListChanged</span>(<span class="params"><span class="built_in">object</span> sender, TodoListEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SynchronizationContext.Post(</span><br><span class="line">                state =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    BindingSource bindingSource = <span class="keyword">new</span> BindingSource();</span><br><span class="line">                    bindingSource.DataSource = e.TodoList;</span><br><span class="line">                    <span class="keyword">this</span>.dataGridViewTodoList.DataSource = bindingSource;</span><br><span class="line">                &#125;, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在整个应用级别定义了一个静态的System.Threading.Timer，让它每隔半秒调用一次GC.Collect()。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> System.Threading.Timer gcScheduler = <span class="keyword">new</span> System.Threading.Timer</span><br><span class="line">            (state =&gt; GC.Collect(), <span class="literal">null</span>, <span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 应用程序的主入口点。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">STAThread</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Application.EnableVisualStyles();</span><br><span class="line">            Application.SetCompatibleTextRenderingDefault(<span class="literal">false</span>);</span><br><span class="line">            Application.Run(<span class="keyword">new</span> MainForm());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看内存泄漏，需要借助响应的Memory Profiling工具:</p>
<p>JetBrains的<code>dotTrace</code>（免费），<br>RedGate的<code>ANTS Memory Profiler</code>(收费)</p>
<p>&emsp;&emsp;ANTS Memory Profiler通过这样的原理来确定你的应用程序是否有泄漏问题：如果你怀疑某个操作会导致应该被GC回收的对象没有被回收，那么你在之前对内存分配情况拍一张快照（Snapshot），然后执行该操作，在操作完成并确定GC完成相应的回收操作后，在拍一张快照。通过对比，找出多余的对象，并根据具体的情况分析该对象是否应该被GC回收，如果是的，怎意味着你的程序存在着内存泄漏问题。</p>
<p>通过ANTS Memory Profiler启动我们的应用程序后，在一开始的时候我们拍摄一张反映程序初始状态的内存快照，然后选择File\Todo List打开TodoListForm，等待一定的时间，再将TodoListForm关闭。为了让GC有充分的时间进行垃圾回收，不妨再作相应的等待，然后拍下第二张快照。在Class List视图中，你会发现原本应该被垃圾回收的TodoListForm窗体对象还存在于内存之中。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181213144749.png" alt="微信截图_20181213144749.png"></p>
<p>&emsp;&emsp;通过上图可以看得，该对象被TodoListManager的一个类型为<code>EventHandler&lt;TodoListEventArgs&gt;</code>的事件引用，这个对象实际上是一个Delegate对象，而TodoListForm作为这个Delegate对象的Target。通过上面给出的代码，我们不难想出是由于在TodoListForm实现了对TodoListManager的TotoListChanged事件注册导致了TodoListManager不能被垃圾回收。</p>
<p>&emsp;&emsp;对于GUI应用可视化树形结构来说，一个窗体被关闭，照例说它应该成为垃圾对象，GC在执行垃圾回收的时候就可以将其清楚的。但是，由于该对象注册了一个事件到一个生命周期很长的对象（在本例中，TodoManager是一个Singletone对象，具有和整个应用程序一样的生命周期），它就是被这么一个对象长期引用，进而阻止 GC对其的回收工作。</p>
<p>&emsp;&emsp;短暂生命周期注册事件到长期生命周期对象上，在该对象被Dispose的时候，应该解除事件的注册。你可以通过实现System.IDisposable接口，将解除事件注册的操作放在Dispose方法中。对于本里来说，你可以将相应的操作注册到Form的Closing、Closed或者Disposed事件中。比如在下面代码中，我为TodoListForm添加了如下一个Closing事件处理程序：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WindowsFormsApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ToDoListForm</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> SynchronizationContext SynchronizationContext &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ToDoListForm</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ToDoListForm_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SynchronizationContext = SynchronizationContext.Current;</span><br><span class="line">            TodoListManager.Instance.TodoListChanged += TodoListManager_TodoListChanged;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TodoListManager_TodoListChanged</span>(<span class="params"><span class="built_in">object</span> sender, TodoListEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SynchronizationContext.Post(</span><br><span class="line">                state =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    BindingSource bindingSource = <span class="keyword">new</span> BindingSource();</span><br><span class="line">                    bindingSource.DataSource = e.TodoList;</span><br><span class="line">                    <span class="keyword">this</span>.dataGridViewTodoList.DataSource = bindingSource;</span><br><span class="line">                &#125;, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ToDoListForm_FormClosing</span>(<span class="params"><span class="built_in">object</span> sender, FormClosingEventArgs e</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            TodoListManager.Instance.TodoListChanged -= TodoListManager_TodoListChanged;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后，按照上面的流程利用<code>ANTS Memory Profiler</code>在第二个快照中，你将再也看不到TodoListForm的身影（如下图）。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181213145711.png" alt="微信截图_20181213145711.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/artech/archive/2009/12/03/1616507.html">事件(Event)，绝大多数内存泄漏（Memory Leak）的元凶[上篇]</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/12/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9006-%E5%A7%94%E6%89%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/12/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9006-%E5%A7%94%E6%89%98/" class="post-title-link" itemprop="url">DotNet面试题解析06-委托</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-12 16:13:15" itemprop="dateCreated datePublished" datetime="2018-12-12T16:13:15+00:00">2018-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-委托是什么"><a href="#1-委托是什么" class="headerlink" title="1.委托是什么"></a>1.委托是什么</h2><p>什么是委托？简单来说，委托类似于 C 或 C++ 中的函数指针，允许将方法作为参数进行传递。</p>
<h2 id="2-为什么需要委托"><a href="#2-为什么需要委托" class="headerlink" title="2.为什么需要委托"></a>2.为什么需要委托</h2><p>在很多场景下直接调用方法是比较简单方便的，但是在某些场景下，使用委托来调用方法能达到减少代码量</p>
<h2 id="3-委托能用来做什么"><a href="#3-委托能用来做什么" class="headerlink" title="3.委托能用来做什么"></a>3.委托能用来做什么</h2><p>1,启动线程和任务</p>
<p>Thread t = new Thread(new ThreadStart(Go));//public static GO(){}</p>
<p>2,设计模式中的简单工厂模式。</p>
<p>向一个方法中传递一个子类的方法。</p>
<p>3,事件。</p>
<h2 id="4-如何自定义委托"><a href="#4-如何自定义委托" class="headerlink" title="4.如何自定义委托"></a>4.如何自定义委托</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Feedback</span>(<span class="params"><span class="built_in">int</span> num</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>.Net 的委托本质上就是指向函数的指针，只不过这种指针是经过封装后类型安全的。委托和线程是两个不同的概念，线程是动态的，委托就是一个或一组内存地址，是静态的。线程执行时如果遇到了指向函数的指针就执行这个函数。</p>
<h2 id="5-NET默认的委托类型有哪几种"><a href="#5-NET默认的委托类型有哪几种" class="headerlink" title="5..NET默认的委托类型有哪几种"></a>5..NET默认的委托类型有哪几种</h2><ul>
<li><p>1，Action<T>:无返回值</p>
</li>
<li><p>2，Func<T>:有返回值</p>
</li>
</ul>
<h2 id="6-多播委托是什么"><a href="#6-多播委托是什么" class="headerlink" title="6.多播委托是什么"></a>6.多播委托是什么</h2><p>包含多个方法的委托叫做 多播委托。</p>
<p>多播委托的签名就必须返回 void；否则，就只能得到委托调用的最后一个方法的结果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----多播委托-------</span></span><br><span class="line">Feedback fbChain = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//将feedback1添加到fbChain委托中</span></span><br><span class="line">fbChain += feedback1;</span><br><span class="line"><span class="comment">//将feedback2添加到fbChain委托中</span></span><br><span class="line">fbChain += feedback2;</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">fbChain(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="7-什么是泛型委托"><a href="#7-什么是泛型委托" class="headerlink" title="7.什么是泛型委托"></a>7.什么是泛型委托</h2><p>Action<T>,Func<T>等</p>
<h2 id="8-什么事匿名方法"><a href="#8-什么事匿名方法" class="headerlink" title="8.什么事匿名方法"></a>8.什么事匿名方法</h2><p>匿名方法是用作委托的参数的一段代码。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jackson0714/p/5111347.html">不惧面试：委托</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/11/CSharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E7%BB%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/11/CSharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6-%E7%BB%AD/" class="post-title-link" itemprop="url">CSharp中的委托与事件(续)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-11 16:32:47" itemprop="dateCreated datePublished" datetime="2018-12-11T16:32:47+00:00">2018-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">委托与事件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSharp中的委托与事件-续"><a href="#CSharp中的委托与事件-续" class="headerlink" title="CSharp中的委托与事件(续)"></a>CSharp中的委托与事件(续)</h1><p>本章内容涉及事件访问器、异常处理、超时处理和异步方法调用等内容。</p>
<h2 id="为什么要使用事件而不是委托变量？"><a href="#为什么要使用事件而不是委托变量？" class="headerlink" title="为什么要使用事件而不是委托变量？"></a>为什么要使用事件而不是委托变量？</h2><ul>
<li>1，从封装性和易用性上考虑</li>
<li>2，事件应该由事件发布者触发，而不应该由客户端（客户程序）来触发。</li>
</ul>
<p>NOTE：注意这里术语的变化，当我们单独谈论事件，我们说发布者(publisher)、订阅者(subscriber)、客户端(client)。当我们讨论Observer模式，我们说主题(subject)和观察者(observer)。客户端通常是包含Main()方法的Program类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber sub = <span class="keyword">new</span> Subscriber();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> NumberChangedEventHandler(sub.OnNumberChanged);</span><br><span class="line">        pub.DoSomething();          <span class="comment">// 应该通过DoSomething()来触发事件</span></span><br><span class="line">        pub.NumberChanged(<span class="number">100</span>);     <span class="comment">// 但可以被这样直接调用，对委托变量的不恰当使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">NumberChangedEventHandler</span>(<span class="params"><span class="built_in">int</span> count</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> NumberChangedEventHandler NumberChanged;         <span class="comment">// 声明委托变量</span></span><br><span class="line">    <span class="comment">//public event NumberChangedEventHandler NumberChanged; // 声明一个事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里完成一些工作 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NumberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 触发事件</span></span><br><span class="line">            count++;</span><br><span class="line">            NumberChanged(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnNumberChanged</span>(<span class="params"><span class="built_in">int</span> count</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber notified: count = &#123;0&#125;&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面代码定义了一个NumberChangedEventHandler委托，然后我们创建了事件的发布者Publisher和订阅者Subscriber。当使用委托变量时，客户端可以直接通过委托变量触发事件，也就是直接调用pub.NumberChanged(100)，这将会影响到所有注册了该委托的订阅者。而<font color=#0099ff size=4 face="黑体">事件的本意应该为在事件发布者在其本身的某个行为中触发，比如说在方法DoSomething()中满足某个条件后触发</font>。通过添加event关键字来发布事件，事件发布者的封装性会更好，<font color=#0099ff size=4 face="黑体">事件仅仅是供其他类型订阅，而客户端不能直接触发事件（语句pub.NumberChanged(100)无法通过编译），事件只能在事件发布者Publisher类的内部触发（比如在方法pub.DoSomething()中），换言之，就是NumberChanged(100)语句只能在Publisher内部被调用</font>。</p>
<p>&emsp;&emsp;大家可以尝试一下，将委托变量的声明那行代码注释掉，然后取消下面事件声明的注释。此时程序是无法编译的，当你使用了event关键字之后，直接在客户端触发事件这种行为，也就是直接调用pub.NumberChanged(100)，是被禁止的。事件只能通过调用DoSomething()来触发。这样才是事件的本意，事件发布者的封装才会更好。</p>
<p>&emsp;&emsp;就好像如果我们要定义一个数字类型，我们会使用int而不是使用object一样，给予对象过多的能力并不见得是一件好事，应该是越合适越好。尽管直接使用委托变量通常不会有什么问题，但它给了客户端不应具有的能力，而使用事件，可以限制这一能力，更精确地对类型进行封装。</p>
<p>NOTE：这里还有一个约定俗称的规定，就是订阅事件的方法的命名，通常为“On事件名”，比如这里的OnNumberChanged。</p>
<h2 id="为什么委托定义的返回值通常都为void？"><a href="#为什么委托定义的返回值通常都为void？" class="headerlink" title="为什么委托定义的返回值通常都为void？"></a>为什么委托定义的返回值通常都为void？</h2><p>尽管并非必需，但是我们发现很多的委托定义返回值都为void，为什么呢？这是因为委托变量可以供多个订阅者注册，如果定义了返回值，那么多个订阅者的方法都会向发布者返回数值，结果就是后面一个返回的方法值将前面的返回值覆盖掉了，因此，实际上只能获得最后一个方法调用的返回值。可以运行下面的代码测试一下。除此以外，发布者和订阅者是松耦合的，发布者根本不关心谁订阅了它的事件、为什么要订阅，更别说订阅者的返回值了，所以返回订阅者的方法返回值大多数情况下根本没有必要。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> GeneralEventHandler(sub1.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> GeneralEventHandler(sub2.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> GeneralEventHandler(sub3.OnNumberChanged);</span><br><span class="line">        pub.DoSomething();          <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">GeneralEventHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> GeneralEventHandler NumberChanged; <span class="comment">// 声明一个事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (NumberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 触发事件</span></span><br><span class="line">            <span class="built_in">string</span> rtn = NumberChanged();</span><br><span class="line">            Console.WriteLine(rtn);     <span class="comment">// 打印返回的字符串，输出为Subscriber3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">OnNumberChanged</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subscriber1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">OnNumberChanged</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subscriber2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">OnNumberChanged</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subscriber3&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何让事件只允许一个客户订阅？"><a href="#如何让事件只允许一个客户订阅？" class="headerlink" title="如何让事件只允许一个客户订阅？"></a>如何让事件只允许一个客户订阅？</h2><p>&emsp;&emsp;少数情况下，比如像上面，为了避免发生“值覆盖”的情况（更多是在异步调用方法时，后面会讨论），我们可能想限制只允许一个客户端注册。此时怎么做呢？我们可以向下面这样，将事件声明为private的，然后提供两个方法来进行注册和取消注册：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">event</span> GeneralEventHandler NumberChanged;    <span class="comment">// 声明一个私有事件</span></span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">GeneralEventHandler method</span>)</span> &#123;</span><br><span class="line">        NumberChanged = method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">GeneralEventHandler method</span>)</span> &#123;</span><br><span class="line">        NumberChanged -= method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其余的事情</span></span><br><span class="line">        <span class="keyword">if</span> (NumberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 触发事件</span></span><br><span class="line">            <span class="built_in">string</span> rtn = NumberChanged();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Return: &#123;0&#125;&quot;</span>, rtn);      <span class="comment">// 打印返回的字符串，输出为Subscriber3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NOTE：注意上面，在UnRegister()中，没有进行任何判断就使用了NumberChanged-=method语句。这是因为即使method方法没有进行过注册，此行语句也不会有任何问题，不会抛出异常，仅仅是不会产生任何效果而已。</p>
<p>注意在Register()方法中，我们使用了赋值操作符“=”，而非“+=”，通过这种方式就避免了多个方法注册。上面的代码尽管可以完成我们的需要，但是此时大家还应该注意下面两点：</p>
<ul>
<li><p>1、将NumberChanged声明为委托变量还是事件都无所谓了，因为它是私有的，即便将它声明为一个委托变量，客户端也看不到它，也就无法通过它来触发事件、调用订阅者的方法。而只能通过Register()和UnRegister()方法来注册和取消注册，通过调用DoSomething()方法触发事件（而不是NumberChanged本身，这在前面已经讨论过了）。</p>
</li>
<li><p>2、我们还应该发现，这里采用的、对NumberChanged委托变量的访问模式和C#中的属性是多么类似啊？大家知道，在C#中通常一个属性对应一个类型成员，而在类型的外部对成员的操作全部通过属性来完成。尽管这里对委托变量的处理是类似的效果，但却使用了两个方法来进行模拟，有没有办法像使用属性一样来完成上面的例子呢？答案是有的，C#中提供了一种叫<font color=#0099ff size=4 face="黑体">事件访问器（Event Accessor）</font>的东西，它用来封装委托变量。如下面例子所示：</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged -= sub1.OnNumberChanged;  <span class="comment">// 不会有任何反应</span></span><br><span class="line">        pub.NumberChanged += sub2.OnNumberChanged;  <span class="comment">// 注册了sub2</span></span><br><span class="line">        pub.NumberChanged += sub1.OnNumberChanged;  <span class="comment">// sub1将sub2的覆盖掉了</span></span><br><span class="line"></span><br><span class="line">        pub.DoSomething();          <span class="comment">// 触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">GeneralEventHandler</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个委托变量</span></span><br><span class="line">    <span class="keyword">private</span> GeneralEventHandler numberChanged;</span><br><span class="line">    <span class="comment">// 事件访问器的定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> GeneralEventHandler NumberChanged &#123;</span><br><span class="line">        <span class="keyword">add</span> &#123;</span><br><span class="line">            numberChanged = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">remove</span> &#123;</span><br><span class="line">            numberChanged -= <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        <span class="keyword">if</span> (numberChanged != <span class="literal">null</span>) &#123;    <span class="comment">// 通过委托变量触发事件</span></span><br><span class="line">            <span class="built_in">string</span> rtn = numberChanged();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Return: &#123;0&#125;&quot;</span>, rtn);      <span class="comment">// 打印返回的字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">OnNumberChanged</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber1 Invoked!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Subscriber1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;<span class="comment">/* 与上类同，略 */</span>&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;<span class="comment">/* 与上类同，略 */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面代码中类似属性的public event GeneralEventHandler NumberChanged {add{…}remove{…}}语句便是事件访问器。使用了事件访问器以后，在DoSomething方法中便只能通过numberChanged委托变量来触发事件，而不能NumberChanged事件访问器（注意它们的大小写不同）触发，它只用于注册和取消注册。下面是代码输出：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1 Invoked!</span><br><span class="line">Return: Subscriber1</span><br></pre></td></tr></table></figure>

<h2 id="获得多个返回值与异常处理"><a href="#获得多个返回值与异常处理" class="headerlink" title="获得多个返回值与异常处理"></a>获得多个返回值与异常处理</h2><p>&emsp;&emsp;现在假设我们想要获得多个订阅者的返回值，以<code>List&lt;string&gt;</code>的形式返回，该如何做呢？我们应该记得委托定义在编译时会生成一个继承自MulticastDelegate的类，而这个MulticastDelegate又继承自Delegate，在Delegate内部，维护了一个委托链表，链表上的每一个元素，为一个只包含一个目标方法的委托对象。而通过Delegate基类的GetInvocationList()静态方法，可以获得这个委托链表。随后我们遍历这个链表，通过链表中的每个委托对象来调用方法，这样就可以分别获得每个方法的返回值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program4</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publishser pub = <span class="keyword">new</span> Publishser();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub1.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub2.OnNumberChanged);</span><br><span class="line">        pub.NumberChanged += <span class="keyword">new</span> DemoEventHandler(sub3.OnNumberChanged);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; list = pub.DoSomething();  <span class="comment">//调用方法，在方法内触发事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> str <span class="keyword">in</span> list) &#123;</span><br><span class="line">            Console.WriteLine(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">DemoEventHandler</span>(<span class="params"><span class="built_in">int</span> num</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件发布者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publishser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> DemoEventHandler NumberChanged;    <span class="comment">// 声明一个事件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事</span></span><br><span class="line"></span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; strList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (NumberChanged == <span class="literal">null</span>) <span class="keyword">return</span> strList;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得委托数组</span></span><br><span class="line">        Delegate[] delArray = NumberChanged.GetInvocationList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">            <span class="comment">// 进行一个向下转换</span></span><br><span class="line">            DemoEventHandler method = (DemoEventHandler)del;</span><br><span class="line">            strList.Add(method(<span class="number">100</span>));       <span class="comment">// 调用方法并获取返回值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> strList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件订阅者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">OnNumberChanged</span>(<span class="params"><span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber1 invoked, number:&#123;0&#125;&quot;</span>, num);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[Subscriber1 returned]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;与上面类同，略&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;与上面类同，略&#125;</span><br></pre></td></tr></table></figure>

<p>如果运行上面的代码，可以得到这样的输出：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1 invoked, number:<span class="number">100</span></span><br><span class="line">Subscriber2 invoked, number:<span class="number">100</span></span><br><span class="line">Subscriber3 invoked, number:<span class="number">100</span></span><br><span class="line">[<span class="meta">Subscriber1 returned</span>]</span><br><span class="line">[<span class="meta">Subscriber2 returned</span>]</span><br><span class="line">[<span class="meta">Subscriber3 returned</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可见我们获得了三个方法的返回值。而我们前面说过，很多情况下委托的定义都不包含返回值，所以上面介绍的方法似乎没有什么实际意义。其实通过这种方式来触发事件最常见的情况应该是在异常处理中，因为很有可能在触发事件时，订阅者的方法会抛出异常，而这一异常会直接影响到发布者，使得发布者程序中止，而后面订阅者的方法将不会被执行。因此我们需要加上异常处理，考虑下面一段程序：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program5</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">        Publisher pub = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub1.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub2.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub3.OnEvent);</span><br><span class="line"></span><br><span class="line">        pub.DoSomething();</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        <span class="keyword">if</span> (NumberChanged != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                NumberChanged(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Exception: &#123;0&#125;&quot;</span>, e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber1 Invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Subscriber2 Failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;<span class="comment">/* 与Subsciber1类同，略*/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意到我们在Subscriber2中抛出了异常，同时我们在Publisher中使用了try/catch语句来处理异常。运行上面的代码，我们得到的结果是：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1 Invoked!</span><br><span class="line">Exception: Subscriber2 Failed</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，<font color=#0099ff size=4 face="黑体">尽管我们捕获了异常，使得程序没有异常结束，但是却影响到了后面的订阅者，因为Subscriber3也订阅了事件，但是却没有收到事件通知（它的方法没有被调用）</font>。此时，我们可以采用上面的办法，先获得委托链表，然后在遍历链表的循环中处理异常，我们只需要修改一下DoSomething方法就可以了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">        Delegate[] delArray = MyEvent.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">            EventHandler method = (EventHandler)del;    <span class="comment">// 强制转换为具体的委托类型</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                method(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Exception: &#123;0&#125;&quot;</span>, e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意到Delegate是EventHandler的基类，所以为了触发事件，先要进行一个向下的强制转换，之后才能在其上触发事件，调用所有注册对象的方法。除了使用这种方式以外，还有一种更灵活方式可以调用方法，它是定义在Delegate基类中的DynamicInvoke()方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">DynamicInvoke</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这可能是调用委托最通用的方法了，适用于所有类型的委托。它接受的参数为object[]，也就是说它可以将任意数量的任意类型作为参数，并返回单个object对象。上面的DoSomething()方法也可以改写成下面这种通用形式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 做某些其他的事情</span></span><br><span class="line">    <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">        Delegate[] delArray = MyEvent.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用DynamicInvoke方法触发事件</span></span><br><span class="line">                del.DynamicInvoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Exception: &#123;0&#125;&quot;</span>, e.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意现在在DoSomething()方法中，我们取消了向具体委托类型的向下转换，现在没有了任何的基于特定委托类型的代码，而DynamicInvoke又可以接受任何类型的参数，且返回一个object对象。所以我们完全可以将DoSomething()方法抽象出来，使它成为一个公共方法，然后供其他类来调用，我们将这个方法声明为静态的，然后定义在Program类中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发某个事件，以列表形式返回所有方法的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span>[] <span class="title">FireEvent</span>(<span class="params">Delegate del, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;<span class="built_in">object</span>&gt; objList = <span class="keyword">new</span> List&lt;<span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (del != <span class="literal">null</span>) &#123;</span><br><span class="line">        Delegate[] delArray = del.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (Delegate method <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用DynamicInvoke方法触发事件</span></span><br><span class="line">                <span class="built_in">object</span> obj = method.DynamicInvoke(args);</span><br><span class="line">                <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">                    objList.Add(obj);</span><br><span class="line">            &#125; catch &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objList.ToArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后，我们在DoSomething()中只要简单的调用一下这个方法就可以了：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 做某些其他的事情</span></span><br><span class="line">    Program5.FireEvent(MyEvent, <span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用泛型版本：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; <span class="title">FireEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">Delegate del, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;T&gt; objList = <span class="keyword">new</span> List&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (del != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delegate[] delArray = del.GetInvocationList();</span><br><span class="line">        <span class="keyword">foreach</span> (Delegate method <span class="keyword">in</span> delArray)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 使用DynamicInvoke方法触发事件</span></span><br><span class="line">                <span class="built_in">object</span>   obj = method.DynamicInvoke(args);</span><br><span class="line">                <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">                    objList.Add((T)obj);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Exception:&#123;0&#125;&quot;</span>, ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objList;</span><br><span class="line">&#125;</span><br><span class="line">然后調用時這樣子：</span><br><span class="line">Program.FireEvent&lt;<span class="built_in">string</span>&gt;(deg, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h2 id="委托中订阅者方法超时的处理"><a href="#委托中订阅者方法超时的处理" class="headerlink" title="委托中订阅者方法超时的处理"></a>委托中订阅者方法超时的处理</h2><p>&emsp;&emsp;订阅者除了可以通过异常的方式来影响发布者以外，还可以通过另一种方式：超时。一般说超时，指的是方法的执行超过某个指定的时间，而这里我将含义扩展了一下，凡是方法执行的时间比较长，我就认为它超时了，这个“比较长”是一个比较模糊的概念，2秒、3秒、5秒都可以视为超时。超时和异常的区别就是超时并不会影响事件的正确触发和程序的正常运行，却会导致事件触发后需要很长才能够结束。在依次执行订阅者的方法这段期间内，客户端程序会被中断，什么也不能做。因为当执行订阅者方法时（通过委托，相当于依次调用所有注册了的方法），当前线程会转去执行方法中的代码，调用方法的客户端会被中断，只有当方法执行完毕并返回时，控制权才会回到客户端，从而继续执行下面的代码。我们来看一下下面一个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program6</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Publisher pub = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub1.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub2.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub3.OnEvent);</span><br><span class="line"></span><br><span class="line">        pub.DoSomething();      <span class="comment">// 触发事件</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nControl back to client!&quot;</span>); <span class="comment">// 返回控制权</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发某个事件，以列表形式返回所有方法的返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">object</span>[] <span class="title">FireEvent</span>(<span class="params">Delegate del, <span class="keyword">params</span> <span class="built_in">object</span>[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 代码与上同，略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DoSomething invoked!&quot;</span>);</span><br><span class="line">        Program6.FireEvent(MyEvent, <span class="keyword">this</span>, EventArgs.Empty); <span class="comment">//触发事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">3</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Waited for 3 seconds, subscriber1 invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Subscriber2 immediately Invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Waited for 2 seconds, subscriber2 invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这段代码中，我们使用Thread.Sleep()静态方法模拟了方法超时的情况。其中Subscriber1.OnEvent()需要三秒钟完成，Subscriber2.OnEvent()立即执行，Subscriber3.OnEvent需要两秒完成。这段代码完全可以正常输出，也没有异常抛出（如果有，也仅仅是该订阅者被忽略掉），下面是输出的情况：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DoSomething invoked!</span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">3</span> seconds, subscriber1 invoked!</span><br><span class="line">Subscriber2 immediately Invoked!</span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">2</span> seconds, subscriber2 invoked!</span><br><span class="line"></span><br><span class="line">Control back to client!</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是这段程序在调用方法DoSomething()、打印了“DoSomething invoked”之后，触发了事件，随后必须等订阅者的三个方法全部执行完毕了之后，也就是大概5秒钟的时间，才能继续执行下面的语句，也就是打印“Control back to client”。而我们前面说过，很多情况下，尤其是远程调用的时候（比如说在Remoting中），发布者和订阅者应该是完全的松耦合，发布者不关心谁订阅了它、不关心订阅者的方法有什么返回值、不关心订阅者会不会抛出异常，当然也不关心订阅者需要多长时间才能完成订阅的方法，它只要在事件发生的那一瞬间告知订阅者事件已经发生并将相关参数传给订阅者就可以了。然后它就应该继续执行它后面的动作，在本例中就是打印“Control back to client！”。而订阅者不管失败或是超时都不应该影响到发布者，但在上面的例子中，发布者却不得不等待订阅者的方法执行完毕才能继续运行。</p>
<p>&emsp;&emsp;现在我们来看下如何解决这个问题，先回顾一下之前我在C#中的委托和事件一文中提到的内容，我说过，委托的定义会生成继承自MulticastDelegate的完整的类，其中包含Invoke()、BeginInvoke()和EndInvoke()方法。当我们直接调用委托时，实际上是调用了Invoke()方法，它会中断调用它的客户端，然后在客户端线程上执行所有订阅者的方法（客户端无法继续执行后面代码），最后将控制权返回客户端。注意到BeginInvoke()、EndInvoke()方法，在.Net中，异步执行的方法通常都会配对出现，并且以Begin和End作为方法的开头（最常见的可能就是Stream类的BeginRead()和EndRead()方法了）。它们用于方法的异步执行，即是在调用BeginInvoke()之后，客户端从线程池中抓取一个闲置线程，然后交由这个线程去执行订阅者的方法，而客户端线程则可以继续执行下面的代码。</p>
<p>&emsp;&emsp;BeginInvoke()接受“动态”的参数个数和类型，为什么说“动态”的呢？因为它的参数是在编译时根据委托的定义动态生成的，其中前面参数的个数和类型与委托定义中接受的参数个数和类型相同，最后两个参数分别是AsyncCallback和Object类型，对于它们更具体的内容，可以参见下一节委托和方法的异步调用部分。现在，我们仅需要对这两个参数传入null就可以了。另外还需要注意几点：</p>
<ul>
<li>在委托类型上调用BeginInvoke()时，此委托对象只能包含一个目标方法，所以对于多个订阅者注册的情况，必须使用GetInvocationList()获得所有委托对象，然后遍历它们，分别在其上调用BeginInvoke()方法。如果直接在委托上调用BeginInvoke()，会抛出异常，提示“委托只能包含一个目标方法”。</li>
<li>如果订阅者的方法抛出异常，.NET会捕捉到它，但是只有在调用EndInvoke()的时候，才会将异常重新抛出。而在本例中，我们不使用EndInvoke()（因为我们不关心订阅者的执行情况），所以我们无需处理异常，因为即使抛出异常，也是在另一个线程上，不会影响到客户端线程（客户端甚至不知道订阅者发生了异常，这有时是好事有时是坏事）。</li>
<li>BeginInvoke()方法属于委托定义所生成的类，它既不属于MulticastDelegate也不属于Delegate基类，所以无法继续使用可重用的FireEvent()方法，我们需要进行一个向下转换，来获取到实际的委托类型。</li>
</ul>
<p>现在我们修改一下上面的程序，使用异步调用来解决订阅者方法执行超时的情况：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program6</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Publisher pub = <span class="keyword">new</span> Publisher();</span><br><span class="line">        Subscriber1 sub1 = <span class="keyword">new</span> Subscriber1();</span><br><span class="line">        Subscriber2 sub2 = <span class="keyword">new</span> Subscriber2();</span><br><span class="line">        Subscriber3 sub3 = <span class="keyword">new</span> Subscriber3();</span><br><span class="line"></span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub1.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub2.OnEvent);</span><br><span class="line">        pub.MyEvent += <span class="keyword">new</span> EventHandler(sub3.OnEvent);</span><br><span class="line"></span><br><span class="line">        pub.DoSomething();      <span class="comment">// 触发事件</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Control back to client!\n&quot;</span>); <span class="comment">// 返回控制权</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press any thing to exit...&quot;</span>);</span><br><span class="line">        Console.ReadKey();      <span class="comment">// 暂停客户程序，提供时间供订阅者完成方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 做某些其他的事情</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;DoSomething invoked!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (MyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">            Delegate[] delArray = MyEvent.GetInvocationList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Delegate del <span class="keyword">in</span> delArray) &#123;</span><br><span class="line">                EventHandler method = (EventHandler)del;</span><br><span class="line">                method.BeginInvoke(<span class="literal">null</span>, EventArgs.Empty, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber1</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">3</span>));      <span class="comment">// 模拟耗时三秒才能完成方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Waited for 3 seconds, subscriber1 invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber2</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Subsciber2 Failed&quot;</span>);   <span class="comment">// 即使抛出异常也不会影响到客户端</span></span><br><span class="line">        <span class="comment">//Console.WriteLine(&quot;Subscriber2 immediately Invoked!&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subscriber3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEvent</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">        Thread.Sleep(TimeSpan.FromSeconds(<span class="number">2</span>));  <span class="comment">// 模拟耗时两秒才能完成方法</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Waited for 2 seconds, subscriber3 invoked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，会得到下面的输出：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DoSomething invoked!</span><br><span class="line">Control back to client!</span><br><span class="line"></span><br><span class="line">Press any thing to exit...</span><br><span class="line"></span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">2</span> seconds, subscriber3 invoked!</span><br><span class="line">Waited <span class="keyword">for</span> <span class="number">3</span> seconds, subscriber1 invoked!</span><br></pre></td></tr></table></figure>

<p>需要注意代码输出中的几个变化：</p>
<ul>
<li>1.我们需要在客户端程序中调用Console.ReadKey()方法来暂停客户端，以提供足够的时间来让异步方法去执行完代码，不然的话客户端的程序到此处便会运行结束，程序会退出，不会看到任何订阅者方法的输出，因为它们根本没来得及执行完毕。原因是这样的：客户端所在的线程我们通常称为主线程，而执行订阅者方法的线程来自线程池，属于后台线程(Background Thread），当主线程结束时，不论后台线程有没有结束，都会退出程序。（当然还有一种前台线程(Foreground Thread)，主线程结束后必须等前台线程也结束后程序才会退出，关于线程的讨论可以开辟另一个庞大的主题，这里就不讨论了）。</li>
<li>2.在打印完“Press any thing to exit…”之后，两个订阅者的方法会以2秒、1秒的间隔显示出来，且尽管我们先注册了subscirber1，但是却先执行了subscriber3，这是因为执行它需要的时间更短。除此以外，注意到这两个方法是并行执行的，所以执行它们的总时间是最长的方法所需要的时间，也就是3秒，而不是他们的累加5秒。</li>
<li>3.如同前面所提到的，尽管subscriber2抛出了异常，我们也没有针对异常进行处理，但是客户程序并没有察觉到，程序也没有因此而中断。</li>
</ul>
<h2 id="委托和方法的异步调用"><a href="#委托和方法的异步调用" class="headerlink" title="委托和方法的异步调用"></a>委托和方法的异步调用</h2><p>&emsp;&emsp;通常情况下，如果需要异步执行一个耗时的操作，我们会新起一个线程，然后让这个线程去执行代码。但是对于每一个异步调用都通过创建线程来进行操作显然会对性能产生一定的影响，同时操作也相对繁琐一些。.Net中可以通过委托进行方法的异步调用，就是说客户端在异步调用方法时，本身并不会因为方法的调用而中断，而是从线程池中抓取一个线程去执行该方法，自身线程（主线程）在完成抓取线程这一过程之后，继续执行下面的代码，这样就实现了代码的并行执行。使用线程池的好处就是避免了频繁进行异步调用时创建、销毁线程的开销。</p>
<p>&emsp;&emsp;如同上面所示，当我们在委托对象上调用BeginInvoke()时，便进行了一个异步的方法调用。上面的例子中是在事件的发布和订阅这一过程中使用了异步调用，而在事件发布者和订阅者之间往往是松耦合的，发布者通常不需要获得订阅者方法执行的情况；而当使用异步调用时，更多情况下是为了提升系统的性能，而并非专用于事件的发布和订阅这一编程模型。而在这种情况下使用异步编程时，就需要进行更多的控制，比如当异步执行方法的方法结束时通知客户端、返回异步执行方法的返回值等。本节就对BeginInvoke()方法、EndInvoke()方法和其相关的IAysncResult做一个简单的介绍。</p>
<p>我们看这样一段代码，它演示了不使用异步调用的通常情况：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program7</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Client application started!\n&quot;</span>);</span><br><span class="line">        Thread.CurrentThread.Name = <span class="string">&quot;Main Thread&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Calculator cal = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="built_in">int</span> result = cal.Add(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Result: &#123;0&#125;\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做某些其它的事情，模拟需要执行3秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;: Client executed &#123;1&#125; second(s).&quot;</span>,</span><br><span class="line">                Thread.CurrentThread.Name, i);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nPress any key to exit...&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.CurrentThread.IsThreadPoolThread) &#123;</span><br><span class="line">            Thread.CurrentThread.Name = <span class="string">&quot;Pool Thread&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Method invoked!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行某些事情，模拟需要执行2秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;: Add executed &#123;1&#125; second(s).&quot;</span>,</span><br><span class="line">                Thread.CurrentThread.Name, i);  </span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Method complete!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有几个关于对于线程的操作，如果不了解可以看一下下面的说明，如果你已经了解可以直接跳过：</p>
<ul>
<li>Thread.Sleep()，它会让执行当前代码的线程暂停一段时间（如果你对线程的概念比较陌生，可以理解为使程序的执行暂停一段时间），以毫秒为单位，比如Thread.Sleep(1000)，将会使线程暂停1秒钟。在上面我使用了它的重载方法，个人觉得使用TimeSpan.FromSeconds(1)，可读性更好一些。</li>
<li>Thread.CurrentThread.Name，通过这个属性可以设置、获取执行当前代码的线程的名称，值得注意的是这个属性只可以设置一次，如果设置两次，会抛出异常。</li>
<li>Thread.IsThreadPoolThread，可以判断执行当前代码的线程是否为线程池中的线程。</li>
</ul>
<p>运行这段程序，会产生下面的输出：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Client application started!</span><br><span class="line"></span><br><span class="line">Method invoked!</span><br><span class="line">Main Thread: Add executed <span class="number">1</span> second(s).</span><br><span class="line">Main Thread: Add executed <span class="number">2</span> second(s).</span><br><span class="line">Method complete!</span><br><span class="line">Result: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Main Thread: Client executed <span class="number">1</span> second(s).</span><br><span class="line">Main Thread: Client executed <span class="number">2</span> second(s).</span><br><span class="line">Main Thread: Client executed <span class="number">3</span> second(s).</span><br><span class="line"></span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果你确实执行了这段代码，会看到这些输出并不是一瞬间输出的，而是执行了大概5秒钟的时间，因为线程是串行执行的，所以在执行完Add()方法之后才会继续客户端剩下的代码。</p>
<p>&emsp;&emsp;接下来我们定义一个AddDelegate委托，并使用BeginInvoke()方法来异步地调用它。在上面已经介绍过，BeginInvoke()除了最后两个参数为AsyncCallback类型和Object类型以外，前面的参数类型和个数与委托定义相同。另外BeginInvoke()方法返回了一个实现了IAsyncResult接口的对象（实际上就是一个AsyncResult类型实例，注意这里IAsyncResult和AysncResult是不同的，它们均包含在.Net Framework中）。</p>
<p>&emsp;&emsp;AsyncResult的用途有这么几个：传递参数，它包含了对调用了BeginInvoke()的委托的引用；它还包含了BeginInvoke()的最后一个Object类型的参数；它可以鉴别出是哪个方法的哪一次调用，因为通过同一个委托变量可以对同一个方法调用多次。</p>
<p>&emsp;&emsp;EndInvoke()方法接受IAsyncResult类型的对象（以及ref和out类型参数，这里不讨论了，对它们的处理和返回值类似），所以在调用BeginInvoke()之后，我们需要保留IAsyncResult，以便在调用EndInvoke()时进行传递。这里最重要的就是EndInvoke()方法的返回值，它就是方法的返回值。除此以外，当客户端调用EndInvoke()时，如果异步调用的方法没有执行完毕，则会中断当前线程而去等待该方法，只有当异步方法执行完毕后才会继续执行后面的代码。所以在调用完BeginInvoke()后立即执行EndInvoke()是没有任何意义的。我们通常在尽可能早的时候调用BeginInvoke()，然后在需要方法的返回值的时候再去调用EndInvoke()，或者是根据情况在晚些时候调用。说了这么多，我们现在看一下使用异步调用改写后上面的代码吧：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">AddDelegate</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program8</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Client application started!\n&quot;</span>);</span><br><span class="line">        Thread.CurrentThread.Name = <span class="string">&quot;Main Thread&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Calculator cal = <span class="keyword">new</span> Calculator();</span><br><span class="line">        AddDelegate del = <span class="keyword">new</span> AddDelegate(cal.Add);</span><br><span class="line">        IAsyncResult asyncResult = del.BeginInvoke(<span class="number">2</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>);  <span class="comment">// 异步调用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做某些其它的事情，模拟需要执行3秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;: Client executed &#123;1&#125; second(s).&quot;</span>,</span><br><span class="line">                Thread.CurrentThread.Name, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rtn = del.EndInvoke(asyncResult);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Result: &#123;0&#125;\n&quot;</span>, rtn);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nPress any key to exit...&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span> &#123; <span class="comment">/* 与上面同，略 */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>此时的输出为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Client application started!</span><br><span class="line"></span><br><span class="line">Method invoked!</span><br><span class="line">Main Thread: Client executed <span class="number">1</span> second(s).</span><br><span class="line">Pool Thread: Add executed <span class="number">1</span> second(s).</span><br><span class="line">Main Thread: Client executed <span class="number">2</span> second(s).</span><br><span class="line">Pool Thread: Add executed <span class="number">2</span> second(s).</span><br><span class="line">Method complete!</span><br><span class="line">Main Thread: Client executed <span class="number">3</span> second(s).</span><br><span class="line">Result: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure>

<p>现在执行完这段代码只需要3秒钟时间，两个for循环所产生的输出交替进行，这也说明了这两段代码并行执行的情况。可以看到Add()方法是由线程池中的线程在执行，因为Thread.CurrentThread.IsThreadPoolThread返回了True，同时我们对该线程命名为了Pool Thread。另外我们可以看到通过EndInvoke()方法得到了返回值。</p>
<p>有时候，我们可能会将获得返回值的操作放到另一段代码或者客户端去执行，而不是向上面那样直接写在BeginInvoke()的后面。比如说我们在Program中新建一个方法GetReturn()，此时可以通过AsyncResult的AsyncDelegate获得del委托对象，然后再在其上调用EndInvoke()方法，这也说明了AsyncResult可以唯一的获取到与它相关的调用了的方法（或者也可以理解成委托对象）。所以上面获取返回值的代码也可以改写成这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetReturn</span>(<span class="params">IAsyncResult asyncResult</span>)</span> &#123;</span><br><span class="line">    AsyncResult result = (AsyncResult)asyncResult;</span><br><span class="line">    AddDelegate del = (AddDelegate)result.AsyncDelegate;</span><br><span class="line">    <span class="built_in">int</span> rtn = del.EndInvoke(asyncResult);</span><br><span class="line">    <span class="keyword">return</span> rtn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再将int rtn = del.EndInvoke(asyncResult);语句改为int rtn = GetReturn(asyncResult);。注意上面IAsyncResult要转换为实际的类型AsyncResult才能访问AsyncDelegate属性，因为它没有包含在IAsyncResult接口的定义中。</p>
<p>BeginInvoke的另外两个参数分别是AsyncCallback和Object类型，其中AsyncCallback是一个委托类型，它用于方法的回调，即是说当异步方法执行完毕时自动进行调用的方法。它的定义为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">AsyncCallback</span>(<span class="params">IAsyncResult ar</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Object类型用于传递任何你想要的数值，它可以通过IAsyncResult的AsyncState属性获得。下面我们将获取方法返回值、打印返回值的操作放到了OnAddComplete()回调方法中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">AddDelegate</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program9</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Client application started!\n&quot;</span>);</span><br><span class="line">        Thread.CurrentThread.Name = <span class="string">&quot;Main Thread&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Calculator cal = <span class="keyword">new</span> Calculator();</span><br><span class="line">        AddDelegate del = <span class="keyword">new</span> AddDelegate(cal.Add);</span><br><span class="line">        <span class="built_in">string</span> data = <span class="string">&quot;Any data you want to pass.&quot;</span>;</span><br><span class="line">        AsyncCallback callBack = <span class="keyword">new</span> AsyncCallback(OnAddComplete);</span><br><span class="line">        del.BeginInvoke(<span class="number">2</span>, <span class="number">5</span>, callBack, data);      <span class="comment">// 异步调用方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做某些其它的事情，模拟需要执行3秒钟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;: Client executed &#123;1&#125; second(s).&quot;</span>,</span><br><span class="line">                Thread.CurrentThread.Name, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nPress any key to exit...&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnAddComplete</span>(<span class="params">IAsyncResult asyncResult</span>)</span> &#123;</span><br><span class="line">        AsyncResult result = (AsyncResult)asyncResult;</span><br><span class="line">        AddDelegate del = (AddDelegate)result.AsyncDelegate;</span><br><span class="line">        <span class="built_in">string</span> data = (<span class="built_in">string</span>)asyncResult.AsyncState;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rtn = del.EndInvoke(asyncResult);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;: Result, &#123;1&#125;; Data: &#123;2&#125;\n&quot;</span>, </span><br><span class="line">            Thread.CurrentThread.Name, rtn, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span> &#123; <span class="comment">/* 与上面同，略 */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>它产生的输出为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Client application started!</span><br><span class="line"></span><br><span class="line">Method invoked!</span><br><span class="line">Main Thread: Client executed <span class="number">1</span> second(s).</span><br><span class="line">Pool Thread: Add executed <span class="number">1</span> second(s).</span><br><span class="line">Main Thread: Client executed <span class="number">2</span> second(s).</span><br><span class="line">Pool Thread: Add executed <span class="number">2</span> second(s).</span><br><span class="line">Method complete!</span><br><span class="line">Pool Thread: Result, <span class="number">7</span>; Data: Any data you want to pass.</span><br><span class="line"></span><br><span class="line">Main Thread: Client executed <span class="number">3</span> second(s).</span><br><span class="line"></span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure>

<p>这里有几个值得注意的地方：1、我们在调用BeginInvoke()后不再需要保存IAysncResult了，因为AysncCallback委托将该对象定义在了回调方法的参数列表中；2、我们在OnAddComplete()方法中获得了调用BeginInvoke()时最后一个参数传递的值，字符串“Any data you want to pass”；3、执行回调方法的线程并非客户端线程Main Thread，而是来自线程池中的线程Pool Thread。另外如前面所说，在调用EndInvoke()时有可能会抛出异常，所以在应该将它放到try/catch块中。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/JimmyZhang/archive/2008/08/22/1274342.html">C#中的委托和事件(续)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/11/Hexo-%E9%83%A8%E7%BD%B2%E5%88%B0-Github-Pages-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/11/Hexo-%E9%83%A8%E7%BD%B2%E5%88%B0-Github-Pages-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Hexo 部署到 Github Pages 文件夹大小写问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-11 15:15:52" itemprop="dateCreated datePublished" datetime="2018-12-11T15:15:52+00:00">2018-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>解决办法:</p>
<ul>
<li>1,进入到博客项目中 .deploy_git文件夹，修改 .git 下的 config 文件，将 ignorecase=true 改为 ignorecase=false</li>
</ul>
<p>可以使用以下命令行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd .deploy_git</span><br><span class="line">vim .git/config</span><br></pre></td></tr></table></figure>

<ul>
<li>2,删除博客项目中 .deploy_git 文件夹下的所有文件，并 push 到 Github 上, 这一步是清空你的 github.io 项目中所有文件。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -rf *</span><br><span class="line">git commit -m &#x27;clean all file&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<ul>
<li>3,使用 Hexo 再次生成及部署</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">hexo clean</span><br><span class="line">hexo deploy -generate</span><br></pre></td></tr></table></figure>


<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://1mhz.me/2015/hexo-deploy-case-sensitive/">Hexo 部署到 Github Pages 文件夹大小写问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/11/CSharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%EF%BC%8C%E4%BA%8B%E4%BB%B6%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/11/CSharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%EF%BC%8C%E4%BA%8B%E4%BB%B6%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">CSharp中的委托，事件与设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-11 11:10:54" itemprop="dateCreated datePublished" datetime="2018-12-11T11:10:54+00:00">2018-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">委托与事件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSharp中的委托，事件与设计模式"><a href="#CSharp中的委托，事件与设计模式" class="headerlink" title="CSharp中的委托，事件与设计模式"></a>CSharp中的委托，事件与设计模式</h1><h2 id="Observer设计模式"><a href="#Observer设计模式" class="headerlink" title="Observer设计模式"></a>Observer设计模式</h2><p>假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。</p>
<p>现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：Heater，它有代表水温的字段，叫做temperature；当然，还有必不可少的给水加热方法BoilWater()，一个发出语音警报的方法MakeAlert()，一个显示水温的方法，ShowMsg()。</p>
<p>我们先了解一下Observer设计模式，Observer设计模式中主要包括如下两类对象：</p>
<ul>
<li>1,Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。</li>
<li>2,Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。</li>
</ul>
<p>在本例中，事情发生的顺序应该是这样的：</p>
<ul>
<li>1,警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。</li>
<li>2,热水器知道后保留对警报器和显示器的引用。</li>
<li>3,热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的MakeAlert()方法、显示器的ShowMsg()方法。</li>
</ul>
<p>Observer设计模式：Observer设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。Observer模式是一种松耦合的设计模式。</p>
<h2 id="实现范例的Observer设计模式"><a href="#实现范例的Observer设计模式" class="headerlink" title="实现范例的Observer设计模式"></a>实现范例的Observer设计模式</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</span><br><span class="line">    <span class="comment">// 热水器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">int</span> temperature;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilHandler</span>(<span class="params"><span class="built_in">int</span> param</span>)</span>;   <span class="comment">//声明委托</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">event</span> BoilHandler BoilEvent;        <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 烧水</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">              temperature = i;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (BoilEvent != <span class="literal">null</span>) &#123; <span class="comment">//如果有对象注册</span></span><br><span class="line">                      BoilEvent(temperature);  <span class="comment">//调用所有注册对象的方法</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 警报器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span> &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params"><span class="built_in">int</span> param</span>)</span> &#123;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot;</span>, param);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span> &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params"><span class="built_in">int</span> param</span>)</span> &#123; <span class="comment">//静态方法</span></span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;</span>, param);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">           Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">           Alarm alarm = <span class="keyword">new</span> Alarm();</span><br><span class="line"></span><br><span class="line">           heater.BoilEvent += alarm.MakeAlert;    <span class="comment">//注册方法</span></span><br><span class="line">           heater.BoilEvent += (<span class="keyword">new</span> Alarm()).MakeAlert;   <span class="comment">//给匿名对象注册方法</span></span><br><span class="line">           heater.BoilEvent += Display.ShowMsg;       <span class="comment">//注册静态方法</span></span><br><span class="line"></span><br><span class="line">           heater.BoilWater();   <span class="comment">//烧水，会自动调用注册过对象的方法</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出为：</span><br><span class="line">Alarm：嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Alarm：嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Display：水快烧开了，当前温度：<span class="number">96</span>度。</span><br><span class="line"><span class="comment">// 省略...</span></span><br></pre></td></tr></table></figure>

<h2 id="Net-Framework中的委托与事件"><a href="#Net-Framework中的委托与事件" class="headerlink" title=".Net Framework中的委托与事件"></a>.Net Framework中的委托与事件</h2><p>尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？</p>
<p>在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：</p>
<ul>
<li>委托类型的名称都应该以EventHandler结束。</li>
<li>委托的原型定义：有一个void返回值，并接受两个输入参数：一个Object 类型，一个 EventArgs类型(或继承自EventArgs)。</li>
<li>事件的命名为 委托去掉 EventHandler之后剩余的部分。</li>
<li>继承自EventArgs的类型应该以EventArgs结尾。</li>
</ul>
<p>再做一下说明：</p>
<ul>
<li>1,委托声明原型中的Object类型的参数代表了Subject，也就是监视对象，在本例中是 Heater(热水器)。回调函数(比如Alarm的MakeAlert)可以通过它访问触发事件的对象(Heater)。</li>
<li>2,EventArgs 对象包含了Observer所感兴趣的数据，在本例中是temperature。</li>
</ul>
<p>** 上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性**。比如说，如果我们不光想获得热水器的温度，还想在Observer端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</span><br><span class="line">    <span class="comment">// 热水器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Heater</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">int</span> temperature;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span> type = <span class="string">&quot;RealFire 001&quot;</span>;       <span class="comment">// 添加型号作为演示</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span> area = <span class="string">&quot;China Xian&quot;</span>;         <span class="comment">// 添加产地作为演示</span></span><br><span class="line">       <span class="comment">//声明委托</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoiledEventHandler</span>(<span class="params">Object sender, BoiledEventArgs e</span>)</span>;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">event</span> BoiledEventHandler Boiled; <span class="comment">//声明事件</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 定义BoiledEventArgs类，传递给Observer所感兴趣的信息</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoiledEventArgs</span> : <span class="title">EventArgs</span> &#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">int</span> temperature;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">BoiledEventArgs</span>(<span class="params"><span class="built_in">int</span> temperature</span>)</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnBoiled</span>(<span class="params">BoiledEventArgs e</span>)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (Boiled != <span class="literal">null</span>) &#123; <span class="comment">// 如果有对象注册</span></span><br><span class="line">              Boiled(<span class="keyword">this</span>, e);  <span class="comment">// 调用所有注册对象的方法</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 烧水。</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoilWater</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">              temperature = i;</span><br><span class="line">              <span class="keyword">if</span> (temperature &gt; <span class="number">95</span>) &#123;</span><br><span class="line">                  <span class="comment">//建立BoiledEventArgs 对象。</span></span><br><span class="line">                  BoiledEventArgs e = <span class="keyword">new</span> BoiledEventArgs(temperature);</span><br><span class="line">                  OnBoiled(e);  <span class="comment">// 调用 OnBolied方法</span></span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 警报器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Alarm</span> &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeAlert</span>(<span class="params">Object sender, Heater.BoiledEventArgs e</span>)</span> &#123;</span><br><span class="line">           Heater heater = (Heater)sender;     <span class="comment">//这里是不是很熟悉呢？</span></span><br><span class="line">           <span class="comment">//访问 sender 中的公共字段</span></span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Alarm：&#123;0&#125; - &#123;1&#125;: &quot;</span>, heater.area, heater.type);</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Alarm: 嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot;</span>, e.temperature);</span><br><span class="line">           Console.WriteLine();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Display</span> &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>(<span class="params">Object sender, Heater.BoiledEventArgs e</span>)</span> &#123;   <span class="comment">//静态方法</span></span><br><span class="line">           Heater heater = (Heater)sender;</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Display：&#123;0&#125; - &#123;1&#125;: &quot;</span>, heater.area, heater.type);</span><br><span class="line">           Console.WriteLine(<span class="string">&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;</span>, e.temperature);</span><br><span class="line">           Console.WriteLine();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">           Heater heater = <span class="keyword">new</span> Heater();</span><br><span class="line">           Alarm alarm = <span class="keyword">new</span> Alarm();</span><br><span class="line"></span><br><span class="line">           heater.Boiled += alarm.MakeAlert;   <span class="comment">//注册方法</span></span><br><span class="line">           heater.Boiled += (<span class="keyword">new</span> Alarm()).MakeAlert;      <span class="comment">//给匿名对象注册方法</span></span><br><span class="line">           heater.Boiled += <span class="keyword">new</span> Heater.BoiledEventHandler(alarm.MakeAlert);    <span class="comment">//也可以这么注册</span></span><br><span class="line">           heater.Boiled += Display.ShowMsg;       <span class="comment">//注册静态方法</span></span><br><span class="line"></span><br><span class="line">           heater.BoilWater();   <span class="comment">//烧水，会自动调用注册过对象的方法</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">Alarm：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Alarm：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Alarm：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Alarm: 嘀嘀嘀，水已经 <span class="number">96</span> 度了：</span><br><span class="line">Display：China Xian - RealFire <span class="number">001</span>:</span><br><span class="line">Display：水快烧开了，当前温度：<span class="number">96</span>度。</span><br><span class="line"><span class="comment">// 省略 ...</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jimmyzhang/archive/2007/09/23/903360.html">C#中的委托和事件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/11/DotNet-IL%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/11/DotNet-IL%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5/" class="post-title-link" itemprop="url">DotNet IL指令速查</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-11 08:45:20" itemprop="dateCreated datePublished" datetime="2018-12-11T08:45:20+00:00">2018-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MSIL%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">MSIL指令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MSIL：Microsoft 中间语言</p>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.emit.opcodes?view=netframework-4.7.2">OpCodes Class</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Add</td>
<td>将两个值相加并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Add.Ovf</td>
<td>将两个整数相加，执行溢出检查，并且将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Add.Ovf.Un</td>
<td>将两个无符号整数值相加，执行溢出检查，并且将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>And</td>
<td>计算两个值的按位“与”并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Arglist</td>
<td>返回指向当前方法的参数列表的非托管指针。</td>
</tr>
<tr>
<td>Beq</td>
<td>如果两个值相等，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Beq.S</td>
<td>如果两个值相等，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Bge</td>
<td>如果第一个值大于或等于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Bge.S</td>
<td>如果第一个值大于或等于第二个值，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Bge.Un</td>
<td>当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Bge.Un.S</td>
<td>当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Bgt</td>
<td>如果第一个值大于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Bgt.S</td>
<td>如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Bgt.Un</td>
<td>当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Bgt.Un.S</td>
<td>当比较无符号整数值或不可排序的浮点型值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Ble</td>
<td>如果第一个值小于或等于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Ble.S</td>
<td>如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Ble.Un</td>
<td>当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Ble.Un.S</td>
<td>当比较无符号整数值或不可排序的浮点值时，如果第一个值小于或等于第二个值，则将控制权转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Blt</td>
<td>如果第一个值小于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Blt.S</td>
<td>如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Blt.Un</td>
<td>当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于第二个值，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Blt.Un.S</td>
<td>当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Bne.Un</td>
<td>当两个无符号整数值或不可排序的浮点型值不相等时，将控制转移到目标指令。</td>
</tr>
<tr>
<td>Bne.Un.S</td>
<td>当两个无符号整数值或不可排序的浮点型值不相等时，将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Box</td>
<td>将值类转换为对象引用（O 类型）。</td>
</tr>
<tr>
<td>Br</td>
<td>无条件地将控制转移到目标指令。</td>
</tr>
<tr>
<td>Br.S</td>
<td>无条件地将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Break</td>
<td>向公共语言结构 (CLI) 发出信号以通知调试器已撞上了一个断点。</td>
</tr>
<tr>
<td>Brfalse</td>
<td>如果 value 为 false、空引用（Visual Basic 中的 Nothing）或零，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Brfalse.S</td>
<td>如果 value 为 false、空引用或零，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Brtrue</td>
<td>如果 value 为 true、非空或非零，则将控制转移到目标指令。</td>
</tr>
<tr>
<td>Brtrue.S</td>
<td>如果 value 为 true、非空或非零，则将控制转移到目标指令（短格式）。</td>
</tr>
<tr>
<td>Call</td>
<td>调用由传递的方法说明符指示的方法。</td>
</tr>
<tr>
<td>Calli</td>
<td>通过调用约定描述的参数调用在计算堆栈上指示的方法（作为指向入口点的指针）。</td>
</tr>
<tr>
<td>Callvirt</td>
<td>对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。</td>
</tr>
<tr>
<td>Castclass</td>
<td>尝试将引用传递的对象转换为指定的类。</td>
</tr>
<tr>
<td>Ceq</td>
<td>比较两个值。如果这两个值相等，则将整数值 1 (int32) 推送到计算堆栈上；否则，将 0 (int32) 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Cgt</td>
<td>比较两个值。如果第一个值大于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Cgt.Un</td>
<td>比较两个无符号的或不可排序的值。如果第一个值大于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ckfinite</td>
<td>如果值不是有限数，则引发 ArithmeticException。</td>
</tr>
<tr>
<td>Clt</td>
<td>比较两个值。如果第一个值小于第二个值，则将整数值 1 (int32) 推送到计算堆栈上；反之，将 0 (int32) 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Clt.Un</td>
<td>比较无符号的或不可排序的值 value1 和 value2。如果 value1 小于 value2，则将整数值 1 (int32 ) 推送到计算堆栈上；反之，将 0 ( int32 ) 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Constrained</td>
<td>约束要对其进行虚方法调用的类型。</td>
</tr>
<tr>
<td>Conv.I</td>
<td>将位于计算堆栈顶部的值转换为 native int。</td>
</tr>
<tr>
<td>Conv.I1</td>
<td>将位于计算堆栈顶部的值转换为 int8，然后将其扩展（填充）为 int32。</td>
</tr>
<tr>
<td>Conv.I2</td>
<td>将位于计算堆栈顶部的值转换为 int16，然后将其扩展（填充）为 int32。</td>
</tr>
<tr>
<td>Conv.I4</td>
<td>将位于计算堆栈顶部的值转换为 int32。</td>
</tr>
<tr>
<td>Conv.I8</td>
<td>将位于计算堆栈顶部的值转换为 int64。</td>
</tr>
<tr>
<td>Conv.Ovf.I</td>
<td>将位于计算堆栈顶部的有符号值转换为有符号 native int，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为有符号 native int，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I1</td>
<td>将位于计算堆栈顶部的有符号值转换为有符号 int8 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I1.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为有符号 int8 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I2</td>
<td>将位于计算堆栈顶部的有符号值转换为有符号 int16 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I2.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为有符号 int16 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I4</td>
<td>将位于计算堆栈顶部的有符号值转换为有符号 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I4.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为有符号 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I8</td>
<td>将位于计算堆栈顶部的有符号值转换为有符号 int64，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.I8.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为有符号 int64，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U</td>
<td>将位于计算堆栈顶部的有符号值转换为 unsigned native int，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为 unsigned native int，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U1</td>
<td>将位于计算堆栈顶部的有符号值转换为 unsigned int8 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U1.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为 unsigned int8 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U2</td>
<td>将位于计算堆栈顶部的有符号值转换为 unsigned int16 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U2.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为 unsigned int16 并将其扩展为 int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U4</td>
<td>将位于计算堆栈顶部的有符号值转换为 unsigned int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U4.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为 unsigned int32，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U8</td>
<td>将位于计算堆栈顶部的有符号值转换为 unsigned int64，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.Ovf.U8.Un</td>
<td>将位于计算堆栈顶部的无符号值转换为 unsigned int64，并在溢出时引发 OverflowException。</td>
</tr>
<tr>
<td>Conv.R.Un</td>
<td>将位于计算堆栈顶部的无符号整数值转换为 float32。</td>
</tr>
<tr>
<td>Conv.R4</td>
<td>将位于计算堆栈顶部的值转换为 float32。</td>
</tr>
<tr>
<td>Conv.R8</td>
<td>将位于计算堆栈顶部的值转换为 float64。</td>
</tr>
<tr>
<td>Conv.U</td>
<td>将位于计算堆栈顶部的值转换为 unsigned native int，然后将其扩展为 native int。</td>
</tr>
<tr>
<td>Conv.U1</td>
<td>将位于计算堆栈顶部的值转换为 unsigned int8，然后将其扩展为 int32。</td>
</tr>
<tr>
<td>Conv.U2</td>
<td>将位于计算堆栈顶部的值转换为 unsigned int16，然后将其扩展为 int32。</td>
</tr>
<tr>
<td>Conv.U4</td>
<td>将位于计算堆栈顶部的值转换为 unsigned int32，然后将其扩展为 int32。</td>
</tr>
<tr>
<td>Conv.U8</td>
<td>将位于计算堆栈顶部的值转换为 unsigned int64，然后将其扩展为 int64。</td>
</tr>
<tr>
<td>Cpblk</td>
<td>将指定数目的字节从源地址复制到目标地址。</td>
</tr>
<tr>
<td>Cpobj</td>
<td>将位于对象（&amp;、* 或 native int 类型）地址的值类型复制到目标对象（&amp;、* 或 native int 类型）的地址。</td>
</tr>
<tr>
<td>Div</td>
<td>将两个值相除并将结果作为浮点（F 类型）或商（int32 类型）推送到计算堆栈上。</td>
</tr>
<tr>
<td>Div.Un</td>
<td>两个无符号整数值相除并将结果 ( int32 ) 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Dup</td>
<td>复制计算堆栈上当前最顶端的值，然后将副本推送到计算堆栈上。</td>
</tr>
<tr>
<td>Endfilter</td>
<td>将控制从异常的 filter 子句转移回公共语言结构 (CLI) 异常处理程序。</td>
</tr>
<tr>
<td>Endfinally</td>
<td>将控制从异常块的 fault 或 finally 子句转移回公共语言结构 (CLI) 异常处理程序。</td>
</tr>
<tr>
<td>Initblk</td>
<td>将位于特定地址的内存的指定块初始化为给定大小和初始值。</td>
</tr>
<tr>
<td>Initobj</td>
<td>将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0。</td>
</tr>
<tr>
<td>Isinst</td>
<td>测试对象引用（O 类型）是否为特定类的实例。</td>
</tr>
<tr>
<td>Jmp</td>
<td>退出当前方法并跳至指定方法。</td>
</tr>
<tr>
<td>Ldarg</td>
<td>将参数（由指定索引值引用）加载到堆栈上。</td>
</tr>
<tr>
<td>Ldarg.0</td>
<td>将索引为 0 的参数加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldarg.1</td>
<td>将索引为 1 的参数加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldarg.2</td>
<td>将索引为 2 的参数加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldarg.3</td>
<td>将索引为 3 的参数加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldarg.S</td>
<td>将参数（由指定的短格式索引引用）加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldarga</td>
<td>将参数地址加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldarga.S</td>
<td>以短格式将参数地址加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4</td>
<td>将所提供的 int32 类型的值作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.0</td>
<td>将整数值 0 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.1</td>
<td>将整数值 1 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.2</td>
<td>将整数值 2 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.3</td>
<td>将整数值 3 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.4</td>
<td>将整数值 4 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.5</td>
<td>将整数值 5 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.6</td>
<td>将整数值 6 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.7</td>
<td>将整数值 7 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.8</td>
<td>将整数值 8 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.M1</td>
<td>将整数值 -1 作为 int32 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.I4.S</td>
<td>将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。</td>
</tr>
<tr>
<td>Ldc.I8</td>
<td>将所提供的 int64 类型的值作为 int64 推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.R4</td>
<td>将所提供的 float32 类型的值作为 F (float) 类型推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldc.R8</td>
<td>将所提供的 float64 类型的值作为 F (float) 类型推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldelem</td>
<td>按照指令中指定的类型，将指定数组索引中的元素加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.I</td>
<td>将位于指定数组索引处的 native int 类型的元素作为 native int 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.I1</td>
<td>将位于指定数组索引处的 int8 类型的元素作为 int32 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.I2</td>
<td>将位于指定数组索引处的 int16 类型的元素作为 int32 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.I4</td>
<td>将位于指定数组索引处的 int32 类型的元素作为 int32 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.I8</td>
<td>将位于指定数组索引处的 int64 类型的元素作为 int64 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.R4</td>
<td>将位于指定数组索引处的 float32 类型的元素作为 F 类型（浮点型）加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.R8</td>
<td>将位于指定数组索引处的 float64 类型的元素作为 F 类型（浮点型）加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.Ref</td>
<td>将位于指定数组索引处的包含对象引用的元素作为 O 类型（对象引用）加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.U1</td>
<td>将位于指定数组索引处的 unsigned int8 类型的元素作为 int32 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.U2</td>
<td>将位于指定数组索引处的 unsigned int16 类型的元素作为 int32 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelem.U4</td>
<td>将位于指定数组索引处的 unsigned int32 类型的元素作为 int32 加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldelema</td>
<td>将位于指定数组索引的数组元素的地址作为 &amp; 类型（托管指针）加载到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldfld</td>
<td>查找对象中其引用当前位于计算堆栈的字段的值。</td>
</tr>
<tr>
<td>Ldflda</td>
<td>查找对象中其引用当前位于计算堆栈的字段的地址。</td>
</tr>
<tr>
<td>Ldftn</td>
<td>将指向实现特定方法的本机代码的非托管指针（native int 类型）推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.I</td>
<td>将 native int 类型的值作为 native int 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.I1</td>
<td>将 int8 类型的值作为 int32 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.I2</td>
<td>将 int16 类型的值作为 int32 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.I4</td>
<td>将 int32 类型的值作为 int32 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.I8</td>
<td>将 int64 类型的值作为 int64 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.R4</td>
<td>将 float32 类型的值作为 F (float) 类型间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.R8</td>
<td>将 float64 类型的值作为 F (float) 类型间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.Ref</td>
<td>将对象引用作为 O（对象引用）类型间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.U1</td>
<td>将 unsigned int8 类型的值作为 int32 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.U2</td>
<td>将 unsigned int16 类型的值作为 int32 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldind.U4</td>
<td>将 unsigned int32 类型的值作为 int32 间接加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldlen</td>
<td>将从零开始的、一维数组的元素的数目推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldloc</td>
<td>将指定索引处的局部变量加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldloc.0</td>
<td>将索引 0 处的局部变量加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldloc.1</td>
<td>将索引 1 处的局部变量加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldloc.2</td>
<td>将索引 2 处的局部变量加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldloc.3</td>
<td>将索引 3 处的局部变量加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldloc.S</td>
<td>将特定索引处的局部变量加载到计算堆栈上（短格式）。</td>
</tr>
<tr>
<td>Ldloca</td>
<td>将位于特定索引处的局部变量的地址加载到计算堆栈上。</td>
</tr>
<tr>
<td>Ldloca.S</td>
<td>将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。</td>
</tr>
<tr>
<td>Ldnull</td>
<td>将空引用（O 类型）推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldobj</td>
<td>将地址指向的值类型对象复制到计算堆栈的顶部。</td>
</tr>
<tr>
<td>Ldsfld</td>
<td>将静态字段的值推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldsflda</td>
<td>将静态字段的地址推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldstr</td>
<td>推送对元数据中存储的字符串的新对象引用。</td>
</tr>
<tr>
<td>Ldtoken</td>
<td>将元数据标记转换为其运行时表示形式，并将其推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ldvirtftn</td>
<td>将指向实现与指定对象关联的特定虚方法的本机代码的非托管指针（native int 类型）推送到计算堆栈上。</td>
</tr>
<tr>
<td>Leave</td>
<td>退出受保护的代码区域，无条件将控制转移到特定目标指令。</td>
</tr>
<tr>
<td>Leave.S</td>
<td>退出受保护的代码区域，无条件将控制转移到目标指令（缩写形式）。</td>
</tr>
<tr>
<td>Localloc</td>
<td>从本地动态内存池分配特定数目的字节并将第一个分配的字节的地址（瞬态指针，* 类型）推送到计算堆栈上。</td>
</tr>
<tr>
<td>Mkrefany</td>
<td>将对特定类型实例的类型化引用推送到计算堆栈上。</td>
</tr>
<tr>
<td>Mul</td>
<td>将两个值相乘并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Mul.Ovf</td>
<td>将两个整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Mul.Ovf.Un</td>
<td>将两个无符号整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Neg</td>
<td>对一个值执行求反并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Newarr</td>
<td>将对新的从零开始的一维数组（其元素属于特定类型）的对象引用推送到计算堆栈上。</td>
</tr>
<tr>
<td>Newobj</td>
<td>创建一个值类型的新对象或新实例，并将对象引用（O 类型）推送到计算堆栈上。</td>
</tr>
<tr>
<td>Nop</td>
<td>如果修补操作码，则填充空间。尽管可能消耗处理周期，但未执行任何有意义的操作。</td>
</tr>
<tr>
<td>Not</td>
<td>计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。</td>
</tr>
<tr>
<td>Or</td>
<td>计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Pop</td>
<td>移除当前位于计算堆栈顶部的值。</td>
</tr>
<tr>
<td>Prefix1</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Prefix2</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Prefix3</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Prefix4</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Prefix5</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Prefix6</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Prefix7</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Prefixref</td>
<td>基础结构。此指令为保留指令。</td>
</tr>
<tr>
<td>Readonly</td>
<td>指定后面的数组地址操作在运行时不执行类型检查，并且返回可变性受限的托管指针。</td>
</tr>
<tr>
<td>Refanytype</td>
<td>检索嵌入在类型化引用内的类型标记。</td>
</tr>
<tr>
<td>Refanyval</td>
<td>检索嵌入在类型化引用内的地址（&amp; 类型）。</td>
</tr>
<tr>
<td>Rem</td>
<td>将两个值相除并将余数推送到计算堆栈上。</td>
</tr>
<tr>
<td>Rem.Un</td>
<td>将两个无符号值相除并将余数推送到计算堆栈上。</td>
</tr>
<tr>
<td>Ret</td>
<td>从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。</td>
</tr>
<tr>
<td>Rethrow</td>
<td>再次引发当前异常。</td>
</tr>
<tr>
<td>Shl</td>
<td>将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Shr</td>
<td>将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Shr.Un</td>
<td>将无符号整数值右移（用零填充）指定的位数，并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Sizeof</td>
<td>将提供的值类型的大小（以字节为单位）推送到计算堆栈上。</td>
</tr>
<tr>
<td>Starg</td>
<td>将位于计算堆栈顶部的值存储到位于指定索引的参数槽中。</td>
</tr>
<tr>
<td>Starg.S</td>
<td>将位于计算堆栈顶部的值存储在参数槽中的指定索引处（短格式）。</td>
</tr>
<tr>
<td>Stelem</td>
<td>用计算堆栈中的值替换给定索引处的数组元素，其类型在指令中指定。</td>
</tr>
<tr>
<td>Stelem.I</td>
<td>用计算堆栈上的 native int 值替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stelem.I1</td>
<td>用计算堆栈上的 int8 值替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stelem.I2</td>
<td>用计算堆栈上的 int16 值替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stelem.I4</td>
<td>用计算堆栈上的 int32 值替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stelem.I8</td>
<td>用计算堆栈上的 int64 值替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stelem.R4</td>
<td>用计算堆栈上的 float32 值替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stelem.R8</td>
<td>用计算堆栈上的 float64 值替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stelem.Ref</td>
<td>用计算堆栈上的对象 ref 值（O 类型）替换给定索引处的数组元素。</td>
</tr>
<tr>
<td>Stfld</td>
<td>用新值替换在对象引用或指针的字段中存储的值。</td>
</tr>
<tr>
<td>Stind.I</td>
<td>在所提供的地址存储 native int 类型的值。</td>
</tr>
<tr>
<td>Stind.I1</td>
<td>在所提供的地址存储 int8 类型的值。</td>
</tr>
<tr>
<td>Stind.I2</td>
<td>在所提供的地址存储 int16 类型的值。</td>
</tr>
<tr>
<td>Stind.I4</td>
<td>在所提供的地址存储 int32 类型的值。</td>
</tr>
<tr>
<td>Stind.I8</td>
<td>在所提供的地址存储 int64 类型的值。</td>
</tr>
<tr>
<td>Stind.R4</td>
<td>在所提供的地址存储 float32 类型的值。</td>
</tr>
<tr>
<td>Stind.R8</td>
<td>在所提供的地址存储 float64 类型的值。</td>
</tr>
<tr>
<td>Stind.Ref</td>
<td>存储所提供地址处的对象引用值。</td>
</tr>
<tr>
<td>Stloc</td>
<td>从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。</td>
</tr>
<tr>
<td>Stloc.0</td>
<td>从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。</td>
</tr>
<tr>
<td>Stloc.1</td>
<td>从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。</td>
</tr>
<tr>
<td>Stloc.2</td>
<td>从计算堆栈的顶部弹出当前值并将其存储到索引 2 处的局部变量列表中。</td>
</tr>
<tr>
<td>Stloc.3</td>
<td>从计算堆栈的顶部弹出当前值并将其存储到索引 3 处的局部变量列表中。</td>
</tr>
<tr>
<td>Stloc.S</td>
<td>从计算堆栈的顶部弹出当前值并将其存储在局部变量列表中的 index 处（短格式）。</td>
</tr>
<tr>
<td>Stobj</td>
<td>将指定类型的值从计算堆栈复制到所提供的内存地址中。</td>
</tr>
<tr>
<td>Stsfld</td>
<td>用来自计算堆栈的值替换静态字段的值。</td>
</tr>
<tr>
<td>Sub</td>
<td>从其他值中减去一个值并将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Sub.Ovf</td>
<td>从另一值中减去一个整数值，执行溢出检查，并且将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Sub.Ovf.Un</td>
<td>从另一值中减去一个无符号整数值，执行溢出检查，并且将结果推送到计算堆栈上。</td>
</tr>
<tr>
<td>Switch</td>
<td>实现跳转表。</td>
</tr>
<tr>
<td>Tailcall</td>
<td>执行后缀的方法调用指令，以便在执行实际调用指令前移除当前方法的堆栈帧。</td>
</tr>
<tr>
<td>Throw</td>
<td>引发当前位于计算堆栈上的异常对象。</td>
</tr>
<tr>
<td>Unaligned</td>
<td>指示当前位于计算堆栈上的地址可能没有与紧接的 ldind、stind、ldfld、stfld、ldobj、stobj、initblk 或 cpblk 指令的自然大小对齐。</td>
</tr>
<tr>
<td>Unbox</td>
<td>将值类型的已装箱的表示形式转换为其未装箱的形式。</td>
</tr>
<tr>
<td>Unbox.Any</td>
<td>将指令中指定类型的已装箱的表示形式转换成未装箱形式。</td>
</tr>
<tr>
<td>Volatile</td>
<td>指定当前位于计算堆栈顶部的地址可以是易失的，并且读取该位置的结果不能被缓存，或者对该地址的多个存储区不能被取消。</td>
</tr>
<tr>
<td>Xor</td>
<td>计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/11/CSharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/11/CSharp%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">CSharp中的委托与事件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-11 08:41:21" itemprop="dateCreated datePublished" datetime="2018-12-11T08:41:21+00:00">2018-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">委托与事件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSharp中的委托与事件"><a href="#CSharp中的委托与事件" class="headerlink" title="CSharp中的委托与事件"></a>CSharp中的委托与事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="将方法作为方法的参数"><a href="#将方法作为方法的参数" class="headerlink" title="将方法作为方法的参数"></a>将方法作为方法的参数</h3><p>委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Delegate</span> &#123;</span><br><span class="line">     <span class="comment">//定义委托，它定义了可以代表的方法的类型</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnglishGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">               Console.WriteLine(<span class="string">&quot;Morning, &quot;</span> + name);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChineseGreeting</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">               Console.WriteLine(<span class="string">&quot;早上好, &quot;</span> + name);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//注意此方法，它接受一个GreetingDelegate类型的方法作为参数</span></span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name, GreetingDelegate MakeGreeting</span>)</span> &#123;</span><br><span class="line">               MakeGreeting(name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">               GreetPeople(<span class="string">&quot;Jimmy Zhang&quot;</span>, EnglishGreeting);</span><br><span class="line">               GreetPeople(<span class="string">&quot;张子阳&quot;</span>, ChineseGreeting);</span><br><span class="line">               Console.ReadKey();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure>

<p>我们现在对委托做一个总结：</p>
<font color=#0099ff size=4 face="黑体">
委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If-Else(Switch)语句，同时使得程序具有更好的可扩展性。</font>

<h3 id="将方法绑定到委托"><a href="#将方法绑定到委托" class="headerlink" title="将方法绑定到委托"></a>将方法绑定到委托</h3><font color=#0099ff size=4 face="黑体">
可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。</font>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting; <span class="comment">// 先给委托类型的变量赋值</span></span><br><span class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    GreetPeople(<span class="string">&quot;Jimmy Zhang&quot;</span>, delegate1);  </span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为：</span><br><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br></pre></td></tr></table></figure>

<p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingDelegate delegate1;</span><br><span class="line">    delegate1 = EnglishGreeting; <span class="comment">// 先给委托类型的变量赋值</span></span><br><span class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    delegate1 (<span class="string">&quot;Jimmy Zhang&quot;</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<font color=#0099ff size=4 face="黑体">
注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。</font>

<p>我们也可以使用下面的代码来这样简化这一过程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</span><br><span class="line">delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br></pre></td></tr></table></figure>

<p>如下，这样会出现编译错误： “GreetingDelegate”方法没有采用“0”个参数的重载。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：“没有0个参数的重载”再次让我们联想到了类的构造函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate();</span><br><span class="line">delegate1 += EnglishGreeting;   <span class="comment">// 这次用的是 “+=”，绑定语法。</span></span><br><span class="line">delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br></pre></td></tr></table></figure>

<p>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingDelegate delegate1 = <span class="keyword">new</span> GreetingDelegate(EnglishGreeting);</span><br><span class="line">    delegate1 += ChineseGreeting;   <span class="comment">// 给此委托变量再绑定一个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</span></span><br><span class="line">    GreetPeople(<span class="string">&quot;Jimmy Zhang&quot;</span>, delegate1);  </span><br><span class="line">    Console.WriteLine();</span><br><span class="line"></span><br><span class="line">    delegate1 -= EnglishGreeting; <span class="comment">//取消对EnglishGreeting方法的绑定</span></span><br><span class="line">    <span class="comment">// 将仅调用 ChineseGreeting </span></span><br><span class="line">    GreetPeople(<span class="string">&quot;张子阳&quot;</span>, delegate1);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line">输出为：</span><br><span class="line">Morning, Jimmy Zhang</span><br><span class="line">早上好, Jimmy Zhang</span><br><span class="line">早上好, 张子阳</span><br></pre></td></tr></table></figure>

<p>让我们再次对委托作个总结：<br><font color=#0099ff size=4 face="黑体"><br>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。</font></p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Event：在类的内部，不管你声明它是public还是protected，它总是private的。在类的外部，注册“+=”和注销“-=”的访问限定符与你在声明事件时使用的访问符相同。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GreetingManager</span>&#123;</span><br><span class="line">    <span class="comment">//这一次我们在这里声明一个事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> GreetingDelegate MakeGreet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GreetPeople</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> &#123;</span><br><span class="line">        MakeGreet(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很容易注意到：MakeGreet 事件的声明与之前委托变量delegate1的声明唯一的区别是多了一个event关键字。看到这里，在结合上面的讲解，你应该明白到：<font color=#0099ff size=4 face="黑体">事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</font></p>
<p>为了证明上面的推论，如果我们像下面这样改写Main方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    GreetingManager gm = <span class="keyword">new</span>  GreetingManager();</span><br><span class="line">    gm.MakeGreet = EnglishGreeting;         <span class="comment">// 编译错误1</span></span><br><span class="line">    gm.MakeGreet += ChineseGreeting;</span><br><span class="line"></span><br><span class="line">    gm.GreetPeople(<span class="string">&quot;Jimmy Zhang&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件和委托的编译代码"><a href="#事件和委托的编译代码" class="headerlink" title="事件和委托的编译代码"></a>事件和委托的编译代码</h2><p>这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 event的声明语句做一探究，看看为什么会发生这样的错误：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> GreetingDelegate MakeGreet;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01.gif" alt="01.gif"></p>
<p>可以看到，实际上尽管我们在GreetingManager里将 MakeGreet 声明为public，但是，实际上MakeGreet会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在GreetingManager类的外面以赋值的方式访问，从而验证了我们上面所做的推论。</p>
<p>我们再进一步看下MakeGreet所产生的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> GreetingDelegate MakeGreet; <span class="comment">//对事件的声明 实际是 声明一个私有的委托变量</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.Synchronized)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add_MakeGreet</span>(<span class="params">GreetingDelegate <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.MakeGreet = (GreetingDelegate) Delegate.Combine(<span class="keyword">this</span>.MakeGreet, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.Synchronized)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove_MakeGreet</span>(<span class="params">GreetingDelegate <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.MakeGreet = (GreetingDelegate) Delegate.Remove(<span class="keyword">this</span>.MakeGreet, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在已经很明确了：MakeGreet事件确实是一个GreetingDelegate类型的委托，只不过不管是不是声明为public，它总是被声明为private。另外，它还有两个方法，分别是add_MakeGreet和remove_MakeGreet，这两个方法分别用于注册委托类型的方法和取消注册。实际上也就是： “+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet。而这两个方法的访问限制取决于声明事件时的访问限制符。</p>
<p>在add_MakeGreet()方法内部，实际上调用了System.Delegate的Combine()静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>当编译器遇到这段代码的时候，会生成下面这样一个完整的类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">GreetingDelegate</span>:<span class="title">System.MulticastDelegate</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="built_in">object</span> @<span class="built_in">object</span>, IntPtr method</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> IAsyncResult <span class="title">BeginInvoke</span>(<span class="params"><span class="built_in">string</span> name, AsyncCallback callback, <span class="built_in">object</span> @<span class="built_in">object</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">EndInvoke</span>(<span class="params">IAsyncResult result</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Invoke</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/02.gif" alt="02.gif"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jimmyzhang/archive/2007/09/23/903360.html">C#中的委托和事件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/10/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9005-%E5%B8%B8%E9%87%8F%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E5%A7%94%E6%89%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/10/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9005-%E5%B8%B8%E9%87%8F%E3%80%81%E5%AD%97%E6%AE%B5%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E5%A7%94%E6%89%98/" class="post-title-link" itemprop="url">DotNet面试题解析05-常量、字段、属性、特性与委托</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-10 11:18:34" itemprop="dateCreated datePublished" datetime="2018-12-10T11:18:34+00:00">2018-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字段与属性"><a href="#字段与属性" class="headerlink" title="字段与属性"></a>字段与属性</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的几个特点：</p>
<ul>
<li>常量的值必须在编译时确定，简单说就是在定义是设置值，以后都不会被改变了，她是编译常量。</li>
<li>常量只能用于简单的类型，因为常量值是要被编译然后保存到程序集的元数据中，只支持基元类型，如 int、char、string、bool、double 等。</li>
<li>常量在使用时，是把常量的值内联到 IL 代码中的，常量类似一个占位符，在编译时被替换掉了。正是这个特点导致常量的一个风险，就是 <strong>不支持跨程序集版本更新</strong>；</li>
</ul>
<p>关于常量不支持跨程序集版本更新，举个简单的例子来说明：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> PORT = <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(A.PORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一段非常简单代码，其生产的 IL 代码如下，在使用常量变量的地方，把她的值拷过来了（把常量的值内联到使用的地方），与常量变量 A.PORT 没有关系了。假如 A 引用了 B 程序集（ B.dll 文件）中的一个常量，如果后面单独修改B程序集中的常量值，只是重新编译了 B，而没有编译程序集 A，就会出问题了，就是上面所说的不支持跨程序集版本更新。常量值更新后，所有使用该常量的代码都必须重新编译，这是我们在使用常量时必须要注意的一个问题。</p>
<ul>
<li>不要随意使用常量，特别是有可能变化的数据；</li>
<li>不要随便修改已定义好的常量值；</li>
</ul>
<p><img src="/img/151257-20160308203229116-399744142.png" alt="151257-20160308203229116-399744142.png"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举 enum 也有类似的问题，其根源和const一样.</p>
<p>下面的是一个简单的枚举定义，她的 IL 代码定义和 const 定义是一样一样的！枚举的成员定义和常量定义一样，因此枚举其实本质上就相当是一个常量集合。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EnumType : <span class="built_in">int</span></span><br><span class="line">&#123;</span><br><span class="line">    None=<span class="number">0</span>,</span><br><span class="line">    Int=<span class="number">1</span>,</span><br><span class="line">    String=<span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/151257-20160308203230647-581894993.png" alt="151257-20160308203230647-581894993.png"></p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>字段的内联初始化问题</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> Age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> DateTime StartTime = DateTime.Now;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> Name = <span class="string">&quot;三体&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义字段并初始化值，是一种很常见的代码编写习惯。但注意了，看看 IL 代码结构，一行代码（定义字段+赋值）被拆成了两块，最终的赋值都在构造函数里执行的。</p>
<p><img src="/img/151257-20160308203231741-1268662687.png" alt="151257-20160308203231741-1268662687.png"></p>
<p>如果有多个构造函数，就像下面这样，有多个构造函数，会造成在两个构造函数 .ctor 中重复产生对字段赋值的 IL 代码，这就造成了不必要的代码膨胀。这个其实也很好解决，在非默认构造函数后加一个 “:this()” 就OK了，或者显示的在构造函数里初始化字段。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> DateTime _startTime = DateTime.Now;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进之后：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//改进</span></span><br><span class="line">    <span class="keyword">private</span> DateTime _startTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _startTime = DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是面向对象编程的基本概念，提供了对私有字段的访问封装，在 C# 中以 get 和 set 访问器方法实现对可读可写属性的操作，提供了安全和灵活的数据访问封装。我们看看属性的本质，主要手段还是 IL 代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeType</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Index &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SomeType</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/151257-20160308203232913-500597794.png" alt="151257-20160308203232913-500597794.png"></p>
<p>上面定义的属性Index被分成了三个部分：</p>
<ul>
<li>自动生成的私有字段 <code>“&lt;Index&gt;k__BackingField”</code></li>
<li>方法：get_Index()，获取字段值；</li>
<li>方法：set_Index(int32 ‘value’)，设置字段值；</li>
</ul>
<p><font color=#0099ff size=4 face="黑体">因此可以说属性的本质还是方法，使用面向对象的思想把字段封装了一下。在定义属性时，我们可以自定义一个私有字段，也可以使用 自动属性 “{ get; set; }”的简化语法形式。</font></p>
<p>使用自动属性时需要注意一点的是，私有字段是由编译器自动命名的，是不受开发人员控制的。</p>
<h2 id="委托与事件"><a href="#委托与事件" class="headerlink" title="委托与事件"></a>委托与事件</h2><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>将方法作为参数进行传递。</p>
<ul>
<li>C# 中的委托都继承自 System.Delegate 类型；</li>
<li>委托类型的声明与方法签名类似，有返回值和参数；</li>
<li>委托是一种可以封装命名（或匿名）方法的引用类型，把方法当做指针传递，但委托是面向对象、类型安全的；</li>
</ul>
<p>委托的本质——是一个类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">ShowMessageHandler</span>(<span class="params"><span class="built_in">string</span> mes</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/151257-20160308203234335-1390533361.png" alt="151257-20160308203234335-1390533361.png"></p>
<ul>
<li>编译器自动帮我们创建了一个类 ShowMessageHandler，继承自 System.MulticastDelegate（她又继承自 System.Delegate ），这是一个多播委托；</li>
<li>委托类 ShowMessageHandler 中包含几个方法，其中最重要的就是 Invoke 方法，签名和定义的方法签名一致；</li>
<li>其他两个版本 BeginInvoke 和 EndInvoke 是异步执行版本；</li>
</ul>
<p>当我们调用委托的时候，其实就是调用委托对象的 Invoke 方法，可以验证一下，下面的调用代码会被编译为对委托对象的 Invoke 方法调用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ShowMessageHandler ShowMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">this</span>.ShowMessage(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Event 封装了委托类型的变量，使得：在类的内部，不管你声明它是 public 还是 protected ，它总是 private 的。在类的外部，注册 “+=” 和 注销“-=” 的访问限定符与你在声明事件时使用的访问符相同。</p>
<p>声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</p>
<h2 id="NET的闭包"><a href="#NET的闭包" class="headerlink" title=".NET的闭包"></a>.NET的闭包</h2><p>闭包提供了一种类似脚本语言函数式编程的便捷、可以共享数据，但也存在一些隐患。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Action&gt; acs = <span class="keyword">new</span> List&lt;Action&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    acs.Add(() =&gt; &#123; Console.WriteLine(i); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">acs.ForEach(ac =&gt; ac()); <span class="comment">// 输出了 5 5 5 5 5，全是5</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中的 Action 就是 .NET 为我们定义好的一个无参数无返回值的委托，从上一节我们知道委托实质是一个类，理解这一点是解决本题的关键。在这个地方委托方法共享使用了一个局部变量i，那生成的类会是什么样的呢？看看IL代码：</p>
<p><img src="/img/151257-20160308203236460-853216066.png" alt="151257-20160308203236460-853216066.png"></p>
<p>共享的局部变量被提升为委托类的一个字段了：</p>
<ul>
<li>变量 i 的生命周期延长了；</li>
<li>for 循环结束后字段 i 的值是 5 了；</li>
<li>后面再次调用委托方法，肯定就是输出 5 了；</li>
</ul>
<p>修改以后：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Action&gt; acss = <span class="keyword">new</span> List&lt;Action&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> m = i;</span><br><span class="line">    acss.Add(() =&gt; &#123; Console.WriteLine(m); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">acss.ForEach(ac =&gt; ac()); <span class="comment">// 输出了 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<h2 id="题目答案解析"><a href="#题目答案解析" class="headerlink" title="题目答案解析"></a>题目答案解析</h2><h3 id="1-const和readonly有什么区别？"><a href="#1-const和readonly有什么区别？" class="headerlink" title="1. const和readonly有什么区别？"></a>1. const和readonly有什么区别？</h3><p>const 关键字用来声明编译时常量，readonly 用来声明运行时常量。都可以标识一个常量，主要有以下区别：<br>1、初始化位置不同。const 必须在声明的同时赋值；readonly 即可以在声明处赋值，也可以在构造方法里赋值。<br>2、修饰对象不同。const 即可以修饰类的字段，也可以修饰局部变量；readonly 只能修饰类的字段 。<br>3、const是编译时常量，在编译时确定该值，且值在编译时被内联到代码中；readonly 是运行时常量，在运行时确定该值。<br>4、const 默认是静态的；而 readonly 如果设置成静态需要显示声明 。<br>5、支持的类型时不同，const 只能修饰基元类型或值为 null 的其他引用类型；readonly 可以是任何类型。</p>
<h3 id="2-哪些类型可以定义为常量？常量const有什么风险？"><a href="#2-哪些类型可以定义为常量？常量const有什么风险？" class="headerlink" title="2. 哪些类型可以定义为常量？常量const有什么风险？"></a>2. 哪些类型可以定义为常量？常量const有什么风险？</h3><p>基元类型或值为 null 的其他引用类型，常量的风险就是不支持跨程序集版本更新，常量值更新后，所有使用该常量的代码都必须重新编译。</p>
<h3 id="3-字段与属性有什么异同？"><a href="#3-字段与属性有什么异同？" class="headerlink" title="3. 字段与属性有什么异同？"></a>3. 字段与属性有什么异同？</h3><ul>
<li>属性提供了更为强大的，灵活的功能来操作字段</li>
<li>出于面向对象的封装性，字段一般不设计为 Public</li>
<li>属性允许在 set 和 get 中编写代码</li>
<li>属性允许控制 set 和 get 的可访问性，从而提供只读或者可读写的功能 （逻辑上只写是没有意义的）</li>
<li>属性可以使用 override 和 new</li>
</ul>
<h3 id="4-静态成员和非静态成员的区别？"><a href="#4-静态成员和非静态成员的区别？" class="headerlink" title="4. 静态成员和非静态成员的区别？"></a>4. 静态成员和非静态成员的区别？</h3><ul>
<li>静态变量使用 static 修饰符进行声明，静态成员在加类的时候就被加载（静态字段是随类型对象存放在 <code>Load Heap</code> 上），通过类进行访问。</li>
<li>不带有 static 修饰符声明的变量称做非静态变量，在对象被实例化时创建，通过对象进行访问 。</li>
<li>一个类的所有实例的同一静态变量都是同一个值，同一个类的不同实例的同一非静态变量可以是不同的值 。</li>
<li>静态函数的实现里不能使用非静态成员，如非静态变量、非静态函数等。</li>
</ul>
<h3 id="5-自动属性有什么风险？"><a href="#5-自动属性有什么风险？" class="headerlink" title="5. 自动属性有什么风险？"></a>5. 自动属性有什么风险？</h3><p>因为自动属性的私有字段是由编译器命名的，后期不宜随意修改，比如在序列化中会导致字段值丢失。</p>
<h3 id="6-特性是什么？如何使用？"><a href="#6-特性是什么？如何使用？" class="headerlink" title="6. 特性是什么？如何使用？"></a>6. 特性是什么？如何使用？</h3><p>特性与属性是完全不相同的两个概念，只是在名称上比较相近。Attribute 特性就是关联了一个目标对象的一段配置信息，本质上是一个类，其为目标元素提供关联附加信息，这段附加信息存储在 dll 内的元数据，它本身没什么意义。运行期以反射的方式来获取附加信息。</p>
<h3 id="7-下面的代码输出什么结果？为什么？"><a href="#7-下面的代码输出什么结果？为什么？" class="headerlink" title="7. 下面的代码输出什么结果？为什么？"></a>7. 下面的代码输出什么结果？为什么？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Action&gt; acs = <span class="keyword">new</span> List&lt;Action&gt;(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    acs.Add(() =&gt; &#123; Console.WriteLine(i); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">acs.ForEach(ac =&gt; ac());</span><br></pre></td></tr></table></figure>

<p>输出了 5 5 5 5 5，全是5！因为闭包中的共享变量i会被提升为委托对象的公共字段，生命周期延长了。</p>
<h3 id="8-C-中的委托是什么？事件是不是一种委托？"><a href="#8-C-中的委托是什么？事件是不是一种委托？" class="headerlink" title="8. C#中的委托是什么？事件是不是一种委托？"></a>8. C#中的委托是什么？事件是不是一种委托？</h3><p>什么是委托？简单来说，委托类似于 C 或 C++ 中的函数指针，允许将方法作为参数进行传递。</p>
<ul>
<li>C# 中的委托都继承自 System.Delegate 类型；</li>
<li>委托类型的声明与方法签名类似，有返回值和参数；</li>
<li>委托是一种可以封装命名（或匿名）方法的引用类型，把方法当做指针传递，但委托是面向对象、类型安全的；</li>
</ul>
<p>事件可以理解为一种特殊的委托，事件内部是基于委托来实现的。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5255492.html">.NET面试题解析(05)-常量、字段、属性、特性与委托</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jimmyzhang/archive/2007/09/23/903360.html">C# 中的委托和事件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/06/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9004-%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/06/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9004-%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E7%BB%A7%E6%89%BF/" class="post-title-link" itemprop="url">DotNet面试题解析04-类型、方法与继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-06 16:00:53" itemprop="dateCreated datePublished" datetime="2018-12-06T16:00:53+00:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类型基础"><a href="#类型基础" class="headerlink" title="类型基础"></a>类型基础</h2><h3 id="类型Type简述"><a href="#类型Type简述" class="headerlink" title="类型Type简述"></a>类型Type简述</h3><p>.NET 中主要的类型就是值类型和引用类型，所有类型的基类就是 System.Object ，也就是说我们使用 FCL 提供的各种类型的、自定义的所有类型都最终派生自 System.Object ，因此他们也都继承了 System.Object 提供的基本方法。</p>
<p><img src="/img/typesystem.gif" alt="typesystem.gif"></p>
<p>在 .NET 代码中，我们可以很方便的创建各种类型，一个简单的数据模型、复杂的聚合对象类型、或是对客观世界实体的抽象。类 (class) 是最基础的 C# 类型，支持继承与多态。<br>一个 c# 类 Class 主要包含两种基本成员：</p>
<ul>
<li>状态（字段、常量、属性等）</li>
<li>操作（方法、事件、索引器、构造函数等）</li>
</ul>
<p>利用创建的类型（或者系统提供的），可以很容易的创建对象的实例。使用 new 运算符创建，该运算符为新的实例分配内存，调用构造函数初始化该实例，并返回对该实例的引用，如下面的语法形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;  &lt;实例名&gt; = new &lt;类名&gt;([构造函数的参数])</span><br></pre></td></tr></table></figure>

<p>创建后的实例对象，是一个存储在内存上（在线程栈或托管堆上）的一个对象，那可以创造实例的类型在内存中又是一个什么样的存在呢？她就是 <strong>类型对象（Type Object）</strong>。</p>
<h3 id="类型对象（Type-Object）"><a href="#类型对象（Type-Object）" class="headerlink" title="类型对象（Type Object）"></a>类型对象（Type Object）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>;                                                           <span class="comment">// 创建int类型实例a</span></span><br><span class="line"><span class="built_in">int</span> b = <span class="number">20</span>;                                                            <span class="comment">// 创建int类型实例b</span></span><br><span class="line"><span class="keyword">var</span> atype = a.GetType();                                               <span class="comment">// 获取对象实例a的类型Type</span></span><br><span class="line"><span class="keyword">var</span> btype = b.GetType();                                               <span class="comment">// 获取对象实例b的类型Type</span></span><br><span class="line">Console.WriteLine(System.Object.Equals(atype,btype));                  <span class="comment">//输出：True</span></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(atype, btype));        <span class="comment">//输出：True</span></span><br></pre></td></tr></table></figure>

<p>任何对象都有一个 GetType() 方法（基类 System.Object 提供的），该方法返回一个对象的类型，类型上面包含了对象内部的详细信息，如字段、属性、方法、基类、事件等等（通过反射可以获取）。在上面的代码中两个不同的 int 变量的类型（ int.GetType() ）是同一个 Type ，说明 int 在内存中有唯一一个（类似静态的） Systen.Int32 类型。</p>
<p>上面获取到的 Type 对象（ Systen.Int32 ）就是一个类型对象，她同其他引用类型一样，也是一个引用对象，这个对象中存储了 int32 类型的所有信息（类型的所有元数据信息）。</p>
<p><strong>关于类型对象（Object Type）：</strong></p>
<ul>
<li>每一个类型（如 System.Int32 ）在内存中都会有一个唯一的类型对象，通过（int）a.GetType() 可以获取该对象；</li>
<li>类型对象（ Object Type ）存储在内存中一个独立的区域，叫 加载堆（Load Heap），加载堆是在进程创建的时候创建的，不受 GC 垃圾回收管制，因此类型对象一经创建就不会被释放的，他的生命周期从 AppDomain 创建到结束；</li>
<li>每个引用对象都包含两个附加成员：TypeHandle 和 同步块索引，其中 TypeHandle 就指向该对象对应的类型对象；</li>
<li>类型对象的加载由 class loader 负责，在第一次使用前加载；</li>
<li>类型中的静态字段就是存储在这里的（加载堆上的类型对象），所以说静态字段是全局的，而且不会释放；</li>
</ul>
<p>可以参考下面的图，第一幅图描述了对象在内存中的一个关系， 第二幅图更复杂，更准确、全面的描述了内存的结构分布。</p>
<p><img src="/img/Anytao_15_3.jpg" alt="Anytao_15_3.jpg"></p>
<p><img src="/img/image_thumb_1.png" alt="image_thumb_1.png"></p>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    B1 b1 = <span class="keyword">new</span> B1(); B2 b2 = <span class="keyword">new</span> B2();</span><br><span class="line">    b1.Print(); b2.Print();      <span class="comment">//按预期应该输出 B1、B2</span></span><br><span class="line"></span><br><span class="line">    A ab1 = <span class="keyword">new</span> B1(); A ab2 = <span class="keyword">new</span> B2();</span><br><span class="line">    ab1.Print(); ab2.Print();   <span class="comment">//这里应该B1,A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B1</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;B1&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B2</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;B2&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法表的加载：</strong></p>
<ul>
<li>方法表的加载时 父类在前，子类在后，首先加载的是固定的4个来自 System.Object 的虚方法：ToString, Equals, GetHashCode, Finalize；</li>
<li>然后加载父类 A 的虚方法；</li>
<li>加载自己的方法；</li>
<li>最后是构造方法：静态构造函数 .cctor() ，对象构造函数 .ctor() ；</li>
</ul>
<p><strong>方法的调用：</strong><br>当执行代码 b1.Print() 时（此处只关注方法调用，忽略方法的继承等因素），通过 b1 的 TypeHandel 找到对应类型对象，然后找到 方法表槽，然后是对应的 IL 代码，第一次执行的时候，JIT 编译器需要把 IL 代码编译为本地机器码，第一次执行完成后机器码会保留，下一次执行就不需要 JIT 编译了。这也是为什么说 .NET 程序启动需要预热的原因。</p>
<h3 id="NET中的继承本质"><a href="#NET中的继承本质" class="headerlink" title=".NET中的继承本质"></a>.NET中的继承本质</h3><p>方法表的创建过程是从父类到子类自上而下的，这是 .NET 中继承的很好体现，当发现有覆写父类虚方法会覆盖同名的父方法，所有类型的加载都会递归到 System.Object 类。</p>
<ul>
<li>继承是可传递的，子类是对父类的扩展，必须继承父类方法，同时可以添加新方法。</li>
<li>子类可以调用父类方法和字段，而父类不能调用子类方法和字段。</li>
<li>子类不光继承父类的公有成员，也继承了私有成员，只是不可直接访问。</li>
<li>new 关键字在虚方法继承中的阻断作用，中断某一虚方法的继承传递。</li>
</ul>
<p><strong>用基类（A）和用本身B1声明到底有什么区别呢？</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B1 b1 = <span class="keyword">new</span> B1();</span><br><span class="line">A ab1 = <span class="keyword">new</span> B1();</span><br></pre></td></tr></table></figure>

<p>无论用什么做引用声明，哪怕是 object，等号右边的[ = new 类型()]都是没有区别的，也就说说对象的创建不受影响的，b1 和 ab1 对象在内存结构上是一致的；<br>他们的的差别就在引用指针的类型不同，这种不同在编码中智能提示就直观的反应出来了，在实际方法调用上也与引用指针类型有直接关系；<br>综合来说，不同引用指针类型对于对象的创建（new操作）不影响；但对于对象的使用（如方法调用）有影响，这一点在上面代码的执行结果中体现出来了！</p>
<p>上面调用的IL代码：</p>
<p><img src="/img/151257-20160306225941018-923782671.png" alt="151257-20160306225941018-923782671.png"></p>
<p>对于虚方法的调用，在 IL 中都是使用指令 <code>callvirt</code>，该指令主要意思就是具体的方法在运行时动态确定的：</p>
<blockquote>
<p><code>callvirt</code> 使用虚拟调度，也就是根据引用类型的动态类型来调度方法，<br><code>callvirt</code> 指令根据引用变量指向的对象类型来调用方法，在运行时动态绑定，主要用于调用虚方法。</p>
</blockquote>
<p>不同的类型指针在虚拟方法表中有不同的附加信息作为标志，来区别其访问的地址区域，称为 <strong>offset</strong>。不同类型的指针只能在其特定地址区域内执行。</p>
<p>编译器在方法调用时还有一个原则：</p>
<blockquote>
<p>执行就近原则：对于同名字段或者方法，编译器是按照其顺序查找来引用的，也就是首先访问离它创建最近的字段或者方法。</p>
</blockquote>
<p><img src="/img/151257-20160306225942315-1520940493.png" alt="151257-20160306225942315-1520940493.png"></p>
<p>在 C# 中，new 关键字可用作运算符、修饰符或约束。</p>
<ul>
<li>1，new 运算符：用于创建对象和调用构造函数。</li>
<li>2，new 修饰符：在用作修饰符时，new 关键字可以显式隐藏从基类继承的成员。</li>
<li>3，new 约束：用于在泛型声明中约束可能用作类型参数的参数的类型。</li>
</ul>
<h2 id="NET中的继承"><a href="#NET中的继承" class="headerlink" title=".NET中的继承"></a>.NET中的继承</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类提供多个派生类共享基类的公共定义，它既可以提供抽象方法，也可以提供非抽象方法。抽象类不能实例化，必须通过继承由派生类实现其抽象方法，因此对抽象类不能使用 <code>new</code> 关键字，也不能被密封。</p>
<p>基本特点：</p>
<ul>
<li>抽象类使用 Abstract 声明，抽象方法也是用 Abstract 标示；</li>
<li>抽象类不能被实例化；</li>
<li>抽象方法必须定义在抽象类中；</li>
<li>抽象类可以继承一个抽象类；</li>
<li>抽象类不能被密封（不能使用 sealed）；</li>
<li>同类 Class 一样，只支持单继承；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractUser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SetName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/151257-20160306225944377-748332278.png" alt="151257-20160306225944377-748332278.png"></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口简单理解就是一种规范、契约，使得实现接口的类或结构在形式上保持一致。实现接口的类或结构必须实现接口定义中所有接口成员，以及该接口从其他接口中继承的所有接口成员。</p>
<p>基本特点：</p>
<ul>
<li>接口使用 interface 声明；</li>
<li>接口类似于抽象基类，不能直接实例化接口；</li>
<li>接口中的方法都是抽象方法，不能有实现代码，实现接口的任何非抽象类型都必须实现接口的所有成员：</li>
<li>接口成员是自动公开的，且不能包含任何访问修饰符。</li>
<li>接口自身可从多个接口继承，类和结构可继承多个接口，但接口不能继承类。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 IUser 接口定义的 IL 代码，看上去是不是和上面的抽象类 AbstractUser 的 IL 代码差不多！接口也是使用.Class ~ abstract 标记，方法定义同抽象类中的方法一样使用 abstract virtual 标记。<font color=#0099ff size=4 face="黑体">因此可以把接口看做是一种特殊的抽象类，该类只提供定义，没有实现。</font></p>
<p><img src="/img/151257-20160306225945627-434523504.png" alt="151257-20160306225945627-434523504.png"></p>
<p>另外一个小细节，上面说到接口是一个特殊的类型，不继承 System.Object，通过 IL 代码其实可以证实这一点。无论是自定义的任何类型还是抽象类，都会隐式继承 System.Object，AbstractUser 的 IL 代码中就有 “extends [mscorlib]System.Object”，而接口的 IL 代码并没有这一段代码。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在.NET中继承的主要两种方式就是类继承和接口继承，两者的主要思想是不一样的：</p>
<ul>
<li>类继承强调父子关系，是一个“IS A”的关系，因此只能单继承（就像一个人只能有一个Father）；</li>
<li>接口继承强调的是一种规范、约束，是一个“CAN DO”的关系，支持多继承，是实现多态一种重要方式。</li>
</ul>
<h2 id="题目答案解析"><a href="#题目答案解析" class="headerlink" title="题目答案解析"></a>题目答案解析</h2><h3 id="1-所有类型都继承System-Object吗？"><a href="#1-所有类型都继承System-Object吗？" class="headerlink" title="1. 所有类型都继承System.Object吗？"></a>1. 所有类型都继承System.Object吗？</h3><p>基本上是的，所有值类型和引用类型都继承自 System.Object，接口是一个特殊的类型，不继承自 System.Object。</p>
<h3 id="2-解释virtual、sealed、override和abstract的区别"><a href="#2-解释virtual、sealed、override和abstract的区别" class="headerlink" title="2. 解释virtual、sealed、override和abstract的区别"></a>2. 解释virtual、sealed、override和abstract的区别</h3><ul>
<li>virtual 申明虚方法的关键字，说明该方法可以被重写</li>
<li>sealed 说明该类不可被继承</li>
<li>override 重写基类的方法</li>
<li>abstract 申明抽象类和抽象方法的关键字，抽象方法不提供实现，由子类实现，抽象类不可实例化。</li>
</ul>
<h3 id="3-接口和类有什么异同？"><a href="#3-接口和类有什么异同？" class="headerlink" title="3. 接口和类有什么异同？"></a>3. 接口和类有什么异同？</h3><p><strong>不同点：</strong></p>
<p>1、接口不能直接实例化。</p>
<p>2、接口只包含方法或属性的<strong>声明</strong>，不包含方法的实现。</p>
<p>3、接口可以<strong>多继承</strong>，类只能单继承。</p>
<p>4、表达的含义不同，接口主要定义一种<strong>规范</strong>，统一调用方法，也就是规范类，约束类，类是方法功能的实现和集合</p>
<p><strong>相同点：</strong></p>
<p>1、接口、类和结构都可以从多个接口继承。</p>
<p>2、接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。</p>
<p>3、接口和类都可以包含事件、索引器、方法和属性。</p>
<h3 id="4-抽象类和接口有什么区别？"><a href="#4-抽象类和接口有什么区别？" class="headerlink" title="4. 抽象类和接口有什么区别？"></a>4. 抽象类和接口有什么区别？</h3><p>1、继承：接口支持多继承；抽象类不能实现多继承。</p>
<p>2、表达的概念：接口用于规范，更强调契约，抽象类用于共性，强调父子。抽象类是一类事物的高度聚合，那么对于继承抽象类的子类来说，对于抽象类来说，属于”Is A”的关系；而接口是定义行为规范，强调“Can Do”的关系，因此对于实现接口的子类来说，相对于接口来说，是”行为需要按照接口来完成”。</p>
<p>3、方法实现：对抽象类中的方法，即可以给出实现部分，也可以不给出；而接口的方法（抽象规则）都不能给出实现部分，接口中方法不能加修饰符。</p>
<p>4、子类重写：继承类对于两者所涉及方法的实现是不同的。继承类对于抽象类所定义的抽象方法，可以不用重写，也就是说，可以延用抽象类的方法；而对于接口类所定义的方法或者属性来说，在继承类中必须重写，给出相应的方法和属性实现。</p>
<p>5、新增方法的影响：在抽象类中，新增一个方法的话，继承类中可以不用作任何处理；而对于接口来说，则需要修改继承类，提供新定义的方法。</p>
<p>6、接口可以作用于值类型（枚举可以实现接口）和引用类型；抽象类只能作用于引用类型。</p>
<p>7、接口不能包含字段和已实现的方法，接口只包含方法、属性、索引器、事件的签名；抽象类可以定义字段、属性、包含有实现的方法。</p>
<h3 id="5-重载与覆盖的区别？"><a href="#5-重载与覆盖的区别？" class="headerlink" title="5. 重载与覆盖的区别？"></a>5. 重载与覆盖的区别？</h3><p>重载：当类包含两个名称相同但签名不同(方法名相同,参数列表不相同)的方法时发生方法重载。用方法重载来提供在语义上完成相同而功能不同的方法。</p>
<p>覆写：在类的继承中使用，通过覆写子类方法可以改变父类虚方法的实现。</p>
<p><strong>主要区别</strong>：</p>
<p>1、方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。<br>2、覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。<br>3、覆盖要求参数列表相同；重载要求参数列表不同。<br>4、覆盖关系中，调用那个方法体，是根据对象的类型来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。</p>
<h3 id="6-在继承中new和override相同点和区别？看下面的代码，有一个基类A，B1和B2都继承自A，并且使用不同的方式改变了父类方法Print（）的行为。测试代码输出什么？为什么？"><a href="#6-在继承中new和override相同点和区别？看下面的代码，有一个基类A，B1和B2都继承自A，并且使用不同的方式改变了父类方法Print（）的行为。测试代码输出什么？为什么？" class="headerlink" title="6. 在继承中new和override相同点和区别？看下面的代码，有一个基类A，B1和B2都继承自A，并且使用不同的方式改变了父类方法Print（）的行为。测试代码输出什么？为什么？"></a>6. 在继承中new和override相同点和区别？看下面的代码，有一个基类A，B1和B2都继承自A，并且使用不同的方式改变了父类方法Print（）的行为。测试代码输出什么？为什么？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    B1 b1 = <span class="keyword">new</span> B1(); B2 b2 = <span class="keyword">new</span> B2();</span><br><span class="line">    b1.Print(); b2.Print();      <span class="comment">//按预期应该输出 B1、B2</span></span><br><span class="line"></span><br><span class="line">    A ab1 = <span class="keyword">new</span> B1(); A ab2 = <span class="keyword">new</span> B2();</span><br><span class="line">    ab1.Print(); ab2.Print();   <span class="comment">//这里应该输出什么呢？输出B1、A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B1</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;B1&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B2</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显式隐藏从基类继承的成员,也就是说此方法被隐藏，被调用ab2.Print()时，输出基类中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>)</span> &#123; Console.WriteLine(<span class="string">&quot;B2&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-下面代码中，变量a、b都是int类型，代码输出结果是什么？"><a href="#7-下面代码中，变量a、b都是int类型，代码输出结果是什么？" class="headerlink" title="7. 下面代码中，变量a、b都是int类型，代码输出结果是什么？"></a>7. 下面代码中，变量a、b都是int类型，代码输出结果是什么？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> atype = a.GetType();</span><br><span class="line"><span class="keyword">var</span> btype = b.GetType();</span><br><span class="line">Console.WriteLine(System.Object.Equals(atype,btype));          <span class="comment">//输出True</span></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(atype,btype)); <span class="comment">//输出True</span></span><br></pre></td></tr></table></figure>

<h3 id="8-class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？"><a href="#8-class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？" class="headerlink" title="8.class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？"></a>8.class中定义的静态字段是存储在内存中的哪个地方？为什么会说她不会被GC回收？</h3><p>随类型对象存储在内存的加载堆上，因为加载堆不受GC管理，其生命周期随 AppDomain，不会被 GC 回收。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5248973.html">.NET面试题解析(04)-类型、方法与继承</a></p>
<p><a target="_blank" rel="noopener" href="https://phodal.github.io/2md/">2md</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/06/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9003-string%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/06/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9003-string%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">DotNet面试题解析03-string与字符串操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-06 14:20:09" itemprop="dateCreated datePublished" datetime="2018-12-06T14:20:09+00:00">2018-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-07 01:23:10" itemprop="dateModified" datetime="2021-06-07T01:23:10+00:00">2021-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="认识string"><a href="#认识string" class="headerlink" title="认识string"></a>认识string</h3><p>string 是一个特殊的引用类型,其对象值存储在托管堆中。string 的内部是一个 char 集合，他的长度 Length 就是字符char 数组的字符个数，一个字符两个字节。string 不允许使用 new string() 的方式创建实例，而是另一种更简单的语法，直接赋值（string aa= “000” 这一点也类似值类型）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoStringTest</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> aa = <span class="string">&quot;000&quot;</span>;</span><br><span class="line">    SetStringValue(aa);</span><br><span class="line">    Console.WriteLine(aa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStringValue</span>(<span class="params"><span class="built_in">string</span> aa</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    aa += <span class="string">&quot;111&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">上面的输出结果为“000”。</font></p>
<p>通过前面的值类型与引用类型的文章，我们知道 string 是一个引用类型，既然是一个引用类型，参数传递的是引用地址，那为什么不是输出“000111”呢？是不是很有值类型的特点呢！这一切的原因源于 string 类型的两个重要的特性：恒定性 与 驻留性。</p>
<h3 id="String的恒定性（不变性）"><a href="#String的恒定性（不变性）" class="headerlink" title="String的恒定性（不变性）"></a>String的恒定性（不变性）</h3><p><font color=#0099ff size=4 face="黑体">字符串是不可变的，字符串一经创建，就不会改变，任何改变都会产生新的字符串。</font></p>
<p><img src="/img/151257-20160303222417112-1147871973.png" alt="151257-20160303222417112-1147871973.png"></p>
<p>上文中的 任何改变都会产生新的字符串 ，包括字符串的一些操作函数，如 str1.ToLower，Trim()，Remove(int startIndex, int count)，ToUpper() 等，都会产生新的字符串，因此在很多编程实践中，对于字符串忽略大小的比较：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（str1.ToLower()==str2.ToLower()） <span class="comment">//这种方式会产生新的字符串，不推荐</span></span><br><span class="line"><span class="keyword">if</span>（<span class="built_in">string</span>. Compare(str1,str2,<span class="literal">true</span>)） <span class="comment">//这种方式性能更好</span></span><br></pre></td></tr></table></figure>

<h3 id="String的驻留性"><a href="#String的驻留性" class="headerlink" title="String的驻留性"></a>String的驻留性</h3><p>由于字符串的不变性，在大量使用字符串操作时，会导致创建大量的字符串对象，带来极大的性能损失。因此 CLR 又给 string 提供另外一个法宝，就是字符串驻留，先看看下面的代码，字符串 s1、s2 竟然是同一个对象！</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">Console.WriteLine(System.Object.Equals(s1, s2));  <span class="comment">//输出 True</span></span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(s1, s2));  <span class="comment">//输出 True</span></span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">相同的字符串在内存（堆）中只分配一次，第二次申请字符串时，发现已经有该字符串是，直接返回已有字符串的地址，这就是驻留的基本过程。</font></p>
<p>字符串驻留的基本原理：</p>
<ul>
<li>CLR 初始化时会在内存中创建一个驻留池，内部其实是一个哈希表，存储被驻留的字符串和其内存地址。</li>
<li>驻留池是进程级别的，多个 AppDomain 共享。同时她不受 GC 控制，生命周期随进程，意思就是不会被 GC 回收</li>
<li>当分配字符串时，首先会到驻留池中查找，如找到，则返回已有相同字符串的地址，不会创建新字符串对象。如果没有找到，则创建新的字符串，并把字符串添加到驻留池中。</li>
</ul>
<p>如果大量的字符串都驻留到内存里，而得不到释放，不是很容易造成内存爆炸吗，当然不会了? 因为不是任何字符串都会驻留，只有通过 IL 指令 ldstr 创建的字符串才会留用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1 + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="built_in">string</span>.Concat(s1, s2);</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="number">123.</span>ToString();</span><br><span class="line"><span class="keyword">var</span> s5 = s2.ToUpper();</span><br></pre></td></tr></table></figure>

<p>IL代码如下：<br><img src="/img/151257-20160303221217190-205612505.png" alt="151257-20160303221217190-205612505.png"></p>
<p>在上面的代码中，出现两个字符串常量，“123” 和 “abc”，这个两个常量字符串在 IL 代码中都是通过 IL 指令 ldstr 创建的，只有该指令创建的字符串才会被驻留，其他方式产生新的字符串都不会被驻留，也就不会共享字符串了，会被 GC 正常回收。</p>
<p>那该如何来验证字符串是否驻留呢，string 类提供两个静态方法：</p>
<ul>
<li>string.Intern(string str)  可以主动驻留一个字符串；</li>
<li>string.IsInterned(string str)  检测指定字符串是否驻留，如果驻留则返回字符串，否则返回NULL</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1 + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">Console.WriteLine(s2);   <span class="comment">//输出：123abc</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.IsInterned(s2) ?? <span class="string">&quot;NULL&quot;</span>);   <span class="comment">//输出：NULL。因为“123abc”没有驻留</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>.Intern(s2);   <span class="comment">//主动驻留字符串</span></span><br><span class="line">Console.WriteLine(<span class="built_in">string</span>.IsInterned(s2) ?? <span class="string">&quot;NULL&quot;</span>);   <span class="comment">//输出：123abc</span></span><br></pre></td></tr></table></figure>

<h3 id="认识StringBuilder"><a href="#认识StringBuilder" class="headerlink" title="认识StringBuilder"></a>认识StringBuilder</h3><p>大量的编程实践和意见中，都说大量字符串连接操作，应该使用 StringBuilder。相对于 string 的不可变，StringBuilder 代表可变字符串，不会像字符串，在托管堆上频繁分配新对象。</p>
<p>首先 StringBuilder 内部同 string 一样，有一个 char[] 字符数组，负责维护字符串内容。因此，与 char 数组相关，就有两个很重要的属性：</p>
<ul>
<li>public int Capacity：StringBuilder 的容量，其实就是字符数组的长度。</li>
<li>public int Length：StringBuilder 中实际字符的长度，&gt;=0，&lt;= 容量 Capacity。</li>
</ul>
<p>StringBuilder 之所以比 string 效率高，主要原因就是不会创建大量的新对象，StringBuilder 在以下两种情况下会分配新对象：</p>
<ul>
<li>追加字符串时，当字符总长度超过了当前设置的容量 Capacity，这个时候，会重新创建一个更大的字符数组，此时会涉及到分配新对象。</li>
<li>调用 StringBuilder.ToString()，创建新的字符串。</li>
</ul>
<p><strong>追加字符串的过程</strong>：</p>
<ul>
<li>StringBuilder 的默认初始容量为16；</li>
<li>使用 stringBuilder.Append() 追加一个字符串时，当字符数大于16，StringBuilder 会自动申请一个更大的字符数组，一般是倍增；</li>
<li>在新的字符数组分配完成后，将原字符数组中的字符复制到新字符数组中，原字符数组就被GC回收；</li>
<li>最后把需要追加的字符串追加到新字符数组中；</li>
</ul>
<p>简单来说，当 StringBuilder 的容量 Capacity 发生变化时，就会引起托管对象申请、内存复制等操作，带来不好的性能影响，因此设置合适的初始容量是非常必要的，尽量减少内存申请和对象创建。</p>
<p>验证代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=16; Length=0;   //初始容量为16 </span></span><br><span class="line">sb1.Append(<span class="string">&#x27;a&#x27;</span>, <span class="number">12</span>);    <span class="comment">//追加12个字符</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=16; Length=12;  </span></span><br><span class="line">sb1.Append(<span class="string">&#x27;a&#x27;</span>, <span class="number">20</span>);    <span class="comment">//继续追加20个字符，容量倍增了</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=32; Length=32;  </span></span><br><span class="line">sb1.Append(<span class="string">&#x27;a&#x27;</span>, <span class="number">41</span>);    <span class="comment">//追加41个字符，新容量=32+41=73</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb1.Capacity, sb1.Length); <span class="comment">//输出：Capacity=73; Length=73;  </span></span><br><span class="line"></span><br><span class="line">StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="number">80</span>); <span class="comment">//设置一个合适的初始容量</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=0;</span></span><br><span class="line">sb2.Append(<span class="string">&#x27;a&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=12;</span></span><br><span class="line">sb2.Append(<span class="string">&#x27;a&#x27;</span>, <span class="number">20</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=32;</span></span><br><span class="line">sb2.Append(<span class="string">&#x27;a&#x27;</span>, <span class="number">41</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Capacity=&#123;0&#125;; Length=&#123;1&#125;;&quot;</span>, sb2.Capacity, sb2.Length); <span class="comment">//输出：Capacity=80; Length=73;</span></span><br></pre></td></tr></table></figure>

<p>为什么少量字符串不推荐使用 StringBuilder 呢？因为 StringBuilder 本身是有一定的开销的，少量字符串就不推荐使用了，使用 String.Concat 和 String.Join 更合适。</p>
<h3 id="高效的使用字符串"><a href="#高效的使用字符串" class="headerlink" title="高效的使用字符串"></a>高效的使用字符串</h3><ul>
<li>在使用线程锁的时候，不要锁定一个字符串对象，因为字符串的驻留性，可能会引发不可以预料的问题；</li>
<li>理解字符串的不变性，尽量避免产生额外字符串，如：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（str1.ToLower()==str2.ToLower()） <span class="comment">//这种方式会产生新的字符串，不推荐</span></span><br><span class="line"><span class="keyword">if</span>（<span class="built_in">string</span>. Compare(str1,str2,<span class="literal">true</span>)） <span class="comment">//这种方式性能更好</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在处理大量字符串连接的时候，尽量使用 StringBuilder，在使用 StringBuilder 时，尽量设置一个合适的长度初始值；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder myStringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Hello World!&quot;</span>, <span class="number">25</span>);</span><br><span class="line">或</span><br><span class="line">myStringBuilder.Capacity = <span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>少量字符串连接建议使用 String.Concat 和 String.Join 代替。</li>
</ul>
<h2 id="题目答案解析"><a href="#题目答案解析" class="headerlink" title="题目答案解析"></a>题目答案解析</h2><h3 id="1-字符串是引用类型类型还是值类型？"><a href="#1-字符串是引用类型类型还是值类型？" class="headerlink" title="1.字符串是引用类型类型还是值类型？"></a>1.字符串是引用类型类型还是值类型？</h3><p>引用类型。</p>
<h3 id="2-在字符串连加处理中，最好采用什么方式，理由是什么？"><a href="#2-在字符串连加处理中，最好采用什么方式，理由是什么？" class="headerlink" title="2.在字符串连加处理中，最好采用什么方式，理由是什么？"></a>2.在字符串连加处理中，最好采用什么方式，理由是什么？</h3><p>少量字符串连接，使用 String.Concat，大量字符串使用 StringBuilder，因为 StringBuilder 的性能更好，如果 string 的话会创建大量字符串对象。</p>
<h3 id="3-使用-StringBuilder时，需要注意些什么问题？"><a href="#3-使用-StringBuilder时，需要注意些什么问题？" class="headerlink" title="3.使用 StringBuilder时，需要注意些什么问题？"></a>3.使用 StringBuilder时，需要注意些什么问题？</h3><ul>
<li>少量字符串时，尽量不要用，StringBuilder 本身是有一定性能开销的；</li>
<li>大量字符串连接使用 StringBuilder 时，应该设置一个合适的容量。</li>
</ul>
<h3 id="4-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><a href="#4-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？" class="headerlink" title="4.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"></a>4.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> st1 = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> st2 = <span class="string">&quot;123abc&quot;</span>;</span><br><span class="line">Console.WriteLine(st1 == st2);</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(st1, st2));</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>内存中的字符串只有一个“123abc”,第一行代码（string st1 = “123” + “abc”; ）常量字符串相加会被编译器优化。由于字符串驻留机制，两个变量st1、st2都指向同一个对象。IL代码如下：</p>
<p><img src="/img/151257-20160303221219330-60155453.png" alt="151257-20160303221219330-60155453.png"></p>
<h3 id="5-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"><a href="#5-以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？" class="headerlink" title="5.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？"></a>5.以下代码执行后内存中会存在多少个字符串？分别是什么？输出结果是什么？为什么呢？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1 + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">&quot;123abc&quot;</span>;</span><br><span class="line">Console.WriteLine(s2 == s3);</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(s2, s3));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>4个字符串。<br>分别是123，abc，123abc，123abc。</p>
<p>理由：<br>s1+abc时产生的不是可驻留的的字符串，而下句则是个驻留字符串。<br>字符串是不可变的，字符串一经创建，就不会改变，任何改变都会产生新的字符串。</p>
<h3 id="6-使用C-实现字符串反转算法，例如：输入”12345”-输出”54321”"><a href="#6-使用C-实现字符串反转算法，例如：输入”12345”-输出”54321”" class="headerlink" title="6.使用C#实现字符串反转算法，例如：输入”12345”, 输出”54321”"></a>6.使用C#实现字符串反转算法，例如：输入”12345”, 输出”54321”</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Reverse</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;参数不合法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(str.Length);  <span class="comment">//注意：设置合适的初始长度，可以显著提高效率（避免了多次内存申请）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> index = str.Length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--)</span><br><span class="line">    &#123;</span><br><span class="line">        sb.Append(str[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Reverse</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;参数不合法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">char</span>[] chars = str.ToCharArray();</span><br><span class="line">    <span class="built_in">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> end = chars.Length - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">char</span> tempChar;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        tempChar = chars[begin];</span><br><span class="line">        chars[begin] = chars[end];</span><br><span class="line">        chars[end] = tempChar;</span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> strResult = <span class="keyword">new</span> <span class="built_in">string</span>(chars);</span><br><span class="line">    <span class="keyword">return</span> strResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Reverse</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">char</span>[] arr = str.ToCharArray();</span><br><span class="line">    Array.Reverse(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">string</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-下面的代码输出结果？为什么？"><a href="#7-下面的代码输出结果？为什么？" class="headerlink" title="7.下面的代码输出结果？为什么？"></a>7.下面的代码输出结果？为什么？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">object</span> b = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">Console.WriteLine(System.Object.Equals(a,b));</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(a,b));</span><br><span class="line"><span class="built_in">string</span> sa = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">Console.WriteLine(System.Object.Equals(a, sa));</span><br><span class="line">Console.WriteLine(System.Object.ReferenceEquals(a, sa));</span><br></pre></td></tr></table></figure>

<p>输出结果全是 True，因为他们都指向同一个字符串实例，使用 object 声明和 string 声明在这里并没有区别（string是引用类型）。</p>
<h3 id="8-C-中string-Empty、””和null-之间的区别"><a href="#8-C-中string-Empty、””和null-之间的区别" class="headerlink" title="8.C#中string.Empty、””和null 之间的区别"></a>8.C#中string.Empty、””和null 之间的区别</h3><p>实际上 Empty 是 string 类中的一个静态的只读字段，他的定义是这样的：</p>
<p>public static readonly String Empty = “”;</p>
<p>也就是说 string.Empty 的内部实现是等于””的。</p>
<p>引用类型是将对象是实际数据保存在堆上, 将对象在堆上的地址保存在栈上。因此 string.Empty 与 “” 都会在栈上保存一个地址这个地址占4字节，指向内存堆中的某个长度为0的空间，这个空间保存的是 string.Empty 的实际值</p>
<p>“” 是通过 CLR 进行优化的,CLR 会维护一个字符串池,以防在堆中创建重复的字符串。<br>而 string.Empty 是一种 c# 语法级别的优化，是在 C# 编译器将代码编译为 IL (即 MSIL )时进行了优化，即所有对 string 类的静态字段 Empty 的访问都会被指向同一引用，以节省内存空间。也就是说，”” 与 string.Empty 在用法与性能上基本没区别。string.Empty 是在语法级别对 “” 的优化。</p>
<p>那就是 string.Empty 会在堆上占用一个长度为0的空间，而null不会。具体内容如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str1=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2=<span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>如刚才所说 str1 会在栈上保存一个地址,这个地址占4字节，指向内存堆中的某个长度为0的空间，这个空间保存的是 str1 的实际值。</p>
<p>str2 同样会在栈上保存一个地址,这个地址也占4字节，但是这个地址是没有明确指向的，它哪也不指，其内容为 0x00000000。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5240313.html">.NET面试题解析(03)-string与字符串操作</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/solan/archive/2012/08/06/CSharp09.html">C#基础知识梳理系列九：StringBuilder</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/artech/archive/2007/05/06/737130.html">深入理解string和如何高效地使用string</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/henulwj/article/details/7830615">C#中string.Empty、””和null 之间的区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">441</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">178</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
