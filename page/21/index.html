<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/21/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/01/02/CSharp%E5%9F%BA%E7%A1%80-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/02/CSharp%E5%9F%BA%E7%A1%80-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/" class="post-title-link" itemprop="url">CSharp基础-表达式树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-02 16:21:12" itemprop="dateCreated datePublished" datetime="2019-01-02T16:21:12+00:00">2019-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Expression-Tree/" itemprop="url" rel="index"><span itemprop="name">Expression Tree</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSharp基础-表达式树"><a href="#CSharp基础-表达式树" class="headerlink" title="CSharp基础-表达式树"></a>CSharp基础-表达式树</h1><p>表达式树(Expression Tree)是.NET 3.5推出的。<br><font color=#ff0000 size=4 face="黑体">表达式树以树形数据结构表示代码，其中每一个节点都是一种表达式，比如方法调用和 x &lt; y 这样的二元运算等。</font></p>
<p>表达式树还能用于动态语言运行时 (DLR) 以提供动态语言和 .NET Framework 之间的互操作性，同时保证编译器编写员能够发射表达式树而非 Microsoft 中间语言 (MSIL)。</p>
<h2 id="Expressions-类"><a href="#Expressions-类" class="headerlink" title="Expressions 类"></a>Expressions 类</h2><p><code>System.Linq.Expressions</code> 命名空间包含一些类、接口和枚举，它们使语言级别的代码表达式能够表示为表达式目录树形式的对象。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>BinaryExpression</td>
<td>表示具有二进制运算符的表达式。</td>
</tr>
<tr>
<td>UnaryExpression</td>
<td>表示具有一元运算符的表达式。</td>
</tr>
<tr>
<td>BlockExpression</td>
<td>表示包含一个表达式序列的块，表达式中可定义变量。</td>
</tr>
<tr>
<td>CatchBlock</td>
<td>表示 try 块中的 catch 语句。</td>
</tr>
<tr>
<td>ConditionalExpression</td>
<td>表示包含条件运算符的表达式。</td>
</tr>
<tr>
<td>ConstantExpression</td>
<td>表示具有常量值的表达式。</td>
</tr>
<tr>
<td>GotoExpression</td>
<td>表示无条件跳转。 这包括返回语句，break 和 continue 语句以及其他跳转。</td>
</tr>
<tr>
<td>IndexExpression</td>
<td>表示对一个属性或数组进行索引。</td>
</tr>
<tr>
<td>LabelTarget</td>
<td>用于表示 GotoExpression 的目标。</td>
</tr>
<tr>
<td>LambdaExpression</td>
<td>介绍 lambda 表达式。 它捕获一个类似于 .NET 方法主体的代码块。</td>
</tr>
<tr>
<td>ListInitExpression</td>
<td>表示具有集合初始值设定项的构造函数调用。</td>
</tr>
<tr>
<td>LoopExpression</td>
<td>表示无限循环。 可通过“中断”退出该循环。</td>
</tr>
<tr>
<td>MemberAssignment</td>
<td>表示对象的字段或属性的赋值操作。</td>
</tr>
<tr>
<td>MemberBinding</td>
<td>提供表示绑定的类派生自的基类，这些绑定用于对新创建对象的成员进行初始化。</td>
</tr>
<tr>
<td>MemberExpression</td>
<td>表示访问字段或属性。</td>
</tr>
<tr>
<td>MemberInitExpression</td>
<td>表示调用构造函数并初始化新对象的一个或多个成员。</td>
</tr>
<tr>
<td>MemberListBinding</td>
<td>表示初始化新创建对象的一个集合成员的元素。</td>
</tr>
<tr>
<td>MemberMemberBinding</td>
<td>表示初始化新创建对象的一个成员的成员。</td>
</tr>
<tr>
<td>MethodCallExpression</td>
<td>表示对静态方法或实例方法的调用。</td>
</tr>
<tr>
<td>NewArrayExpression</td>
<td>表示创建一个新数组，并可能初始化该新数组的元素。</td>
</tr>
<tr>
<td>NewExpression</td>
<td>表示一个构造函数调用。</td>
</tr>
<tr>
<td>ParameterExpression</td>
<td>表示一个命名的参数表达式。</td>
</tr>
<tr>
<td>TryExpression</td>
<td>表示一个 try/catch/finally/fault 块。</td>
</tr>
</tbody></table>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions?view=netframework-4.7.2">System.Linq.Expressions</a></p>
<h2 id="创建表达式树"><a href="#创建表达式树" class="headerlink" title="创建表达式树"></a>创建表达式树</h2><h3 id="Lambda-表达式创建表达式树"><a href="#Lambda-表达式创建表达式树" class="headerlink" title="Lambda 表达式创建表达式树"></a>Lambda 表达式创建表达式树</h3><p>若 lambda 表达式被分配给 <code>Expression&lt;TDelegate&gt;</code> 类型的变量，则编译器可以发射代码以创建表示该 lambda 表达式的表达式树。<br>C# 编译器只能从表达式 Lambda（或单行 Lambda）生成表达式树。 它无法解析语句 lambda （或多行 lambda）。</p>
<p>如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例展示如何通过 C# 编译器创建表示 Lambda 表达式 num =&gt; num &lt; 5 的表达式树</span></span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; lambda = num =&gt; num &lt; <span class="number">5</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码编译不通过</span></span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt; expr2 = (x, y) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">Expression&lt;Action&lt;<span class="built_in">int</span>&gt;&gt; expr3 = x =&gt; &#123;  &#125;;</span><br></pre></td></tr></table></figure>

<p><code>Expression&lt;TDelegate&gt;</code> 是直接继承自 <code>LambdaExpression</code>。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Expression</span>&lt;<span class="title">TDelegate</span>&gt; : <span class="title">LambdaExpression</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="title">Expression</span>(<span class="params">Expression body, <span class="built_in">string</span> name, <span class="built_in">bool</span> tailCall, ReadOnlyCollection&lt;ParameterExpression&gt; parameters</span>) :</span></span><br><span class="line"><span class="function">    <span class="title">base</span>(<span class="params"><span class="keyword">typeof</span>(TDelegate</span>), name, body, tailCall, parameters)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过-API-创建表达式树"><a href="#通过-API-创建表达式树" class="headerlink" title="通过 API 创建表达式树"></a>通过 API 创建表达式树</h3><p>通过 API 创建表达式树需要使用 <code>Expression</code> 类。类包含创建特定类型表达式树节点的静态工厂方法，比如表示参数变量的<code>ParameterExpression</code>，或者是表示方法调用的 <code>MethodCallExpression</code>。 <code>ParameterExpression</code> 名称空间还解释了 <code>MethodCallExpression</code>、<code>System.Linq.Expressions</code>和另一种具体表达式类型。 这些类型来源于抽象类型 <code>Expression</code>。</p>
<p>使用 API 创建表示 Lambda 表达式 num =&gt; num &lt; 5 的表达式树:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq.Expressions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manually build the expression tree for</span></span><br><span class="line"><span class="comment">// the lambda expression num =&gt; num &lt; 5.  </span></span><br><span class="line">ParameterExpression numParam = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;num&quot;</span>);  </span><br><span class="line">ConstantExpression five = Expression.Constant(<span class="number">5</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));  </span><br><span class="line">BinaryExpression numLessThanFive = Expression.LessThan(numParam, five);  </span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; lambda1 =  </span><br><span class="line">    Expression.Lambda&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt;(  </span><br><span class="line">        numLessThanFive,  </span><br><span class="line">        <span class="keyword">new</span> ParameterExpression[] &#123; numParam &#125;);  </span><br></pre></td></tr></table></figure>

<p>在 .NET Framework 4 或更高版本中，表达式树 API 还支持赋值表达式和控制流表达式，例如循环、条件块和 <code>try-catch</code> 块等。下列示例展示如何创建计算数字阶乘的表达式树。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creating a parameter expression.  </span></span><br><span class="line">ParameterExpression <span class="keyword">value</span> = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating an expression to hold a local variable.</span></span><br><span class="line">ParameterExpression result = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a label to jump to from a loop.  </span></span><br><span class="line">LabelTarget label = Expression.Label(<span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating a method body.  </span></span><br><span class="line">BlockExpression block = Expression.Block(</span><br><span class="line">    <span class="comment">// Adding a local variable.  </span></span><br><span class="line">    <span class="keyword">new</span>[] &#123; result &#125;,</span><br><span class="line">    <span class="comment">// Assigning a constant to a local variable: result = 1  </span></span><br><span class="line">    Expression.Assign(result, Expression.Constant(<span class="number">1</span>)),</span><br><span class="line">        <span class="comment">// Adding a loop.  </span></span><br><span class="line">        Expression.Loop(</span><br><span class="line">           <span class="comment">// Adding a conditional block into the loop.  </span></span><br><span class="line">           Expression.IfThenElse(</span><br><span class="line">               <span class="comment">// Condition: value &gt; 1  </span></span><br><span class="line">               Expression.GreaterThan(<span class="keyword">value</span>, Expression.Constant(<span class="number">1</span>)),</span><br><span class="line">               <span class="comment">// If true: result *= value --  </span></span><br><span class="line">               Expression.MultiplyAssign(result,</span><br><span class="line">                   Expression.PostDecrementAssign(<span class="keyword">value</span>)),</span><br><span class="line">               <span class="comment">// If false, exit the loop and go to the label.  </span></span><br><span class="line">               Expression.Break(label, result)</span><br><span class="line">           ),</span><br><span class="line">       <span class="comment">// Label to jump to.  </span></span><br><span class="line">       label</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compile and execute an expression tree.  </span></span><br><span class="line"><span class="built_in">int</span> factorial = Expression.Lambda&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt;(block, <span class="keyword">value</span>).Compile()(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(factorial);</span><br><span class="line"><span class="comment">// Prints 120.</span></span><br></pre></td></tr></table></figure>

<h3 id="解析表达式树"><a href="#解析表达式树" class="headerlink" title="解析表达式树"></a>解析表达式树</h3><p>下列代码示例展示如何分解表示 Lambda 表达式 num =&gt; num &lt; 5 的表达式树。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the following using directive to your code file:  </span></span><br><span class="line"><span class="comment">// using System.Linq.Expressions;  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Create an expression tree.  </span></span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; exprTree = num =&gt; num &lt; <span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Decompose the expression tree.  </span></span><br><span class="line">ParameterExpression param = (ParameterExpression)exprTree.Parameters[<span class="number">0</span>];  </span><br><span class="line">BinaryExpression operation = (BinaryExpression)exprTree.Body;  </span><br><span class="line">ParameterExpression left = (ParameterExpression)operation.Left;  </span><br><span class="line">ConstantExpression right = (ConstantExpression)operation.Right;  </span><br><span class="line">  </span><br><span class="line">Console.WriteLine(<span class="string">&quot;Decomposed expression: &#123;0&#125; =&gt; &#123;1&#125; &#123;2&#125; &#123;3&#125;&quot;</span>,  </span><br><span class="line">                  param.Name, left.Name, operation.NodeType, right.Value);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// This code produces the following output:  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// Decomposed expression: num =&gt; num LessThan 5</span></span><br></pre></td></tr></table></figure>

<h3 id="编译表达式树"><a href="#编译表达式树" class="headerlink" title="编译表达式树"></a>编译表达式树</h3><p><code>Expression&lt;TDelegate&gt;</code> 类型提供了 Compile 方法以将表达式树表示的代码编译成可执行委托。</p>
<p>下列代码示例展示如何编译表达式树并运行结果代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creating an expression tree.  </span></span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt;&gt; expr = num =&gt; num &lt; <span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Compiling the expression tree into a delegate.  </span></span><br><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; result = expr.Compile();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Invoking the delegate and writing the result to the console.  </span></span><br><span class="line">Console.WriteLine(result(<span class="number">4</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Prints True.  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// You can also use simplified syntax  </span></span><br><span class="line"><span class="comment">// to compile and run an expression tree.  </span></span><br><span class="line"><span class="comment">// The following line can replace two previous statements.  </span></span><br><span class="line">Console.WriteLine(expr.Compile()(<span class="number">4</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Also prints True.</span></span><br></pre></td></tr></table></figure>

<h2 id="执行表达式树"><a href="#执行表达式树" class="headerlink" title="执行表达式树"></a>执行表达式树</h2><p>Lambda 表达式的表达式树的类型为 <code>LambdaExpression</code> 或 <code>Expression&lt;TDelegate&gt;</code>。 若要执行这些表达式树，调用 Compile 方法来创建一个可执行的委托，然后调用该委托。</p>
<p>备注：</p>
<p>如果委托的类型未知，也就是说 Lambda 表达式的类型为 <code>LambdaExpression</code>，而不是 <code>Expression&lt;TDelegate&gt;</code>，则必须对委托调用 <code>DynamicInvoke</code> 方法，而不是直接调用委托。如 <code>lambdaExpr.Compile().DynamicInvoke(1)</code>;</p>
<p>下面的代码示例演示如何通过创建 lambda 表达式并执行它来执行代表幂运算的表达式树。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The expression tree to execute.  </span></span><br><span class="line">BinaryExpression be = Expression.Power(Expression.Constant(<span class="number">2</span>D), Expression.Constant(<span class="number">3</span>D));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Create a lambda expression.  </span></span><br><span class="line">Expression&lt;Func&lt;<span class="built_in">double</span>&gt;&gt; le = Expression.Lambda&lt;Func&lt;<span class="built_in">double</span>&gt;&gt;(be);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Compile the lambda expression.  </span></span><br><span class="line">Func&lt;<span class="built_in">double</span>&gt; compiledExpression = le.Compile();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Execute the lambda expression.  </span></span><br><span class="line"><span class="built_in">double</span> result = compiledExpression();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Display the result.  </span></span><br><span class="line">Console.WriteLine(result);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// This code produces the following output:  </span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h2 id="修改表达式树-C"><a href="#修改表达式树-C" class="headerlink" title="修改表达式树 (C#)"></a>修改表达式树 (C#)</h2><p>表达式树是不可变的，这意味着不能直接对它们进行修改。 若要更改表达式树，必须创建现有表达式树的副本，创建此副本后，进行必要的更改。 可以使用 <code>ExpressionVisitor</code> 类遍历现有表达式树，以及复制它访问的每个节点。</p>
<p>运算从条件 <code>AND</code> 更改为条件 <code>OR</code>。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Expression&lt;Func&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt;&gt; expr = name =&gt; name.Length &gt; <span class="number">10</span> &amp;&amp; name.StartsWith(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">    Console.WriteLine(expr);</span><br><span class="line"></span><br><span class="line">    AndAlsoModifier treeModifier = <span class="keyword">new</span> AndAlsoModifier();</span><br><span class="line">    Expression modifiedExpr = treeModifier.Modify((Expression)expr);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(modifiedExpr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        name =&gt; ((name.Length &gt; 10) &amp;&amp; name.StartsWith(&quot;G&quot;))</span></span><br><span class="line"><span class="comment">        name =&gt; ((name.Length &gt; 10) || name.StartsWith(&quot;G&quot;))</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AndAlsoModifier</span> : <span class="title">ExpressionVisitor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Expression <span class="title">Modify</span>(<span class="params">Expression expression</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Visit(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Expression <span class="title">VisitBinary</span>(<span class="params">BinaryExpression b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b.NodeType == ExpressionType.AndAlso)</span><br><span class="line">        &#123;</span><br><span class="line">            Expression left = <span class="keyword">this</span>.Visit(b.Left);</span><br><span class="line">            Expression right = <span class="keyword">this</span>.Visit(b.Right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make this binary expression an OrElse operation instead of an AndAlso operation.</span></span><br><span class="line">            <span class="keyword">return</span> Expression.MakeBinary(ExpressionType.OrElse, left, right, b.IsLiftedToNull, b.Method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.VisitBinary(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用表达式树来生成动态查询"><a href="#使用表达式树来生成动态查询" class="headerlink" title="使用表达式树来生成动态查询"></a>使用表达式树来生成动态查询</h2><p>在 LINQ 中，表达式树用于表示针对数据源的结构化查询，这些数据源可实现 <code>IQueryable&lt;T&gt;</code>。 例如，LINQ 提供程序可实现 <code>IQueryable&lt;T&gt;</code> 接口，用于查询关系数据存储。 C# 编译器将针对此类数据源的查询编译为代码，该代码在运行时会生成一个表达式树。 然后，查询提供程序可以遍历表达式树数据结构，并将其转换为适合于数据源的查询语言。</p>
<p>表达式树还可以用在 LINQ 中，用于表示分配给类型为 <code>Expression&lt;TDelegate&gt;</code> 的变量的 lambda 表达式。</p>
<p>下面的示例演示如何使用表达式树依据 <code>IQueryable</code> 数据源构造一个查询，然后执行该查询。 代码将生成一个表达式树来表示以下查询：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">companies.Where(company =&gt; (company.ToLower() == <span class="string">&quot;coho winery&quot;</span> || company.Length &gt; <span class="number">16</span>)).OrderBy(company =&gt; company)</span><br></pre></td></tr></table></figure>

<p><code>System.Linq.Expressions</code> 命名空间中的工厂方法用于创建表达式树，这些表达式树表示构成总体查询的表达式。 表示标准查询运算符方法调用的表达式将引用这些方法的 <code>Queryable</code> 实现。 最终的表达式树将传递给 <code>IQueryable</code> 数据源的提供程序的 <code>CreateQuery&lt;TElement&gt;(Expression)</code> 实现，以创建 <code>IQueryable</code> 类型的可执行查询。 通过枚举该查询变量获得结果。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a using directive for System.Linq.Expressions.</span></span><br><span class="line"><span class="built_in">string</span>[] companies = &#123; <span class="string">&quot;Consolidated Messenger&quot;</span>, <span class="string">&quot;Alpine Ski House&quot;</span>, <span class="string">&quot;Southridge Video&quot;</span>, <span class="string">&quot;City Power &amp; Light&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Coho Winery&quot;</span>, <span class="string">&quot;Wide World Importers&quot;</span>, <span class="string">&quot;Graphic Design Institute&quot;</span>, <span class="string">&quot;Adventure Works&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Humongous Insurance&quot;</span>, <span class="string">&quot;Woodgrove Bank&quot;</span>, <span class="string">&quot;Margie&#x27;s Travel&quot;</span>, <span class="string">&quot;Northwind Traders&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Blue Yonder Airlines&quot;</span>, <span class="string">&quot;Trey Research&quot;</span>, <span class="string">&quot;The Phone Company&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Wingtip Toys&quot;</span>, <span class="string">&quot;Lucerne Publishing&quot;</span>, <span class="string">&quot;Fourth Coffee&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The IQueryable data to query.</span></span><br><span class="line">IQueryable&lt;String&gt; queryableData = companies.AsQueryable&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compose the expression tree that represents the parameter to the predicate.</span></span><br><span class="line">ParameterExpression pe = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="string">&quot;company&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** Where(company =&gt; (company.ToLower() == &quot;coho winery&quot; || company.Length &gt; 16)) *****</span></span><br><span class="line"><span class="comment">// Create an expression tree that represents the expression &#x27;company.ToLower() == &quot;coho winery&quot;&#x27;.</span></span><br><span class="line">Expression left = Expression.Call(pe, <span class="keyword">typeof</span>(<span class="built_in">string</span>).GetMethod(<span class="string">&quot;ToLower&quot;</span>, System.Type.EmptyTypes));</span><br><span class="line">Expression right = Expression.Constant(<span class="string">&quot;coho winery&quot;</span>);</span><br><span class="line">Expression e1 = Expression.Equal(left, right);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an expression tree that represents the expression &#x27;company.Length &gt; 16&#x27;.</span></span><br><span class="line">left = Expression.Property(pe, <span class="keyword">typeof</span>(<span class="built_in">string</span>).GetProperty(<span class="string">&quot;Length&quot;</span>));</span><br><span class="line">right = Expression.Constant(<span class="number">16</span>, <span class="keyword">typeof</span>(<span class="built_in">int</span>));</span><br><span class="line">Expression e2 = Expression.GreaterThan(left, right);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Combine the expression trees to create an expression tree that represents the</span></span><br><span class="line"><span class="comment">// expression &#x27;(company.ToLower() == &quot;coho winery&quot; || company.Length &gt; 16)&#x27;.</span></span><br><span class="line">Expression predicateBody = Expression.OrElse(e1, e2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an expression tree that represents the expression</span></span><br><span class="line"><span class="comment">// &#x27;queryableData.Where(company =&gt; (company.ToLower() == &quot;coho winery&quot; || company.Length &gt; 16))&#x27;</span></span><br><span class="line">MethodCallExpression whereCallExpression = Expression.Call(</span><br><span class="line">    <span class="keyword">typeof</span>(Queryable),</span><br><span class="line">    <span class="string">&quot;Where&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Type[] &#123; queryableData.ElementType &#125;,</span><br><span class="line">    queryableData.Expression,</span><br><span class="line">    Expression.Lambda&lt;Func&lt;<span class="built_in">string</span>, <span class="built_in">bool</span>&gt;&gt;(predicateBody, <span class="keyword">new</span> ParameterExpression[] &#123; pe &#125;));</span><br><span class="line"><span class="comment">// ***** End Where *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ***** OrderBy(company =&gt; company) *****</span></span><br><span class="line"><span class="comment">// Create an expression tree that represents the expression</span></span><br><span class="line"><span class="comment">// &#x27;whereCallExpression.OrderBy(company =&gt; company)&#x27;</span></span><br><span class="line">MethodCallExpression orderByCallExpression = Expression.Call(</span><br><span class="line">    <span class="keyword">typeof</span>(Queryable),</span><br><span class="line">    <span class="string">&quot;OrderBy&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Type[] &#123; queryableData.ElementType, queryableData.ElementType &#125;,</span><br><span class="line">    whereCallExpression,</span><br><span class="line">    Expression.Lambda&lt;Func&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt;(pe, <span class="keyword">new</span> ParameterExpression[] &#123; pe &#125;));</span><br><span class="line"><span class="comment">// ***** End OrderBy *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an executable query from the expression tree.</span></span><br><span class="line">IQueryable&lt;<span class="built_in">string</span>&gt; results = queryableData.Provider.CreateQuery&lt;<span class="built_in">string</span>&gt;(orderByCallExpression);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enumerate the results.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> company <span class="keyword">in</span> results)</span><br><span class="line">    Console.WriteLine(company);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Blue Yonder Airlines</span></span><br><span class="line"><span class="comment">    City Power &amp; Light</span></span><br><span class="line"><span class="comment">    Coho Winery</span></span><br><span class="line"><span class="comment">    Consolidated Messenger</span></span><br><span class="line"><span class="comment">    Graphic Design Institute</span></span><br><span class="line"><span class="comment">    Humongous Insurance</span></span><br><span class="line"><span class="comment">    Lucerne Publishing</span></span><br><span class="line"><span class="comment">    Northwind Traders</span></span><br><span class="line"><span class="comment">    The Phone Company</span></span><br><span class="line"><span class="comment">    Wide World Importers</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="在-Visual-Studio-中调试表达式树"><a href="#在-Visual-Studio-中调试表达式树" class="headerlink" title="在 Visual Studio 中调试表达式树"></a>在 Visual Studio 中调试表达式树</h2><p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/debugging-expression-trees-in-visual-studio">在 Visual Studio 中调试表达式树</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.expressions?view=netframework-4.7.2">System.Linq.Expressions</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/expression-trees/">表达式树 (C#)</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jesse2013/p/expressiontree-part1.html">由浅入深表达式树（一）创建表达式树</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/29/CSharp%E5%9F%BA%E7%A1%80-LINQ%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/29/CSharp%E5%9F%BA%E7%A1%80-LINQ%E6%A0%87%E5%87%86%E6%9F%A5%E8%AF%A2%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">CSharp基础-LINQ标准查询运算符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-29 10:37:02" itemprop="dateCreated datePublished" datetime="2018-12-29T10:37:02+00:00">2018-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LINQ/" itemprop="url" rel="index"><span itemprop="name">LINQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSharp基础-LINQ标准查询运算符"><a href="#CSharp基础-LINQ标准查询运算符" class="headerlink" title="CSharp基础-LINQ标准查询运算符"></a>CSharp基础-LINQ标准查询运算符</h1><p>&emsp;&emsp;标准查询运算符是组成 LINQ 模式的方法。 这些方法中的大多数都作用于序列；其中序列指其类型实现 <code>IEnumerable&lt;T&gt;</code> 接口或 <code>IQueryable&lt;T&gt;</code> 接口的对象。 标准查询运算符提供包括筛选、投影、聚合、排序等在内的查询功能。</p>
<h2 id="查询表达式语法"><a href="#查询表达式语法" class="headerlink" title="查询表达式语法"></a>查询表达式语法</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/query-expression-syntax-for-standard-query-operators">标准查询运算符的查询表达式语法</a></p>
<h2 id="按执行方式的分类"><a href="#按执行方式的分类" class="headerlink" title="按执行方式的分类"></a>按执行方式的分类</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/classification-of-standard-query-operators-by-manner-of-execution">标准查询运算符按执行方式的分类</a></p>
<h2 id="对数据排序"><a href="#对数据排序" class="headerlink" title="对数据排序"></a>对数据排序</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>C# 查询表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>OrderBy</td>
<td>按升序对值排序。</td>
<td><code>orderby</code></td>
</tr>
<tr>
<td>OrderByDescending</td>
<td>按降序对值排序。</td>
<td><code>orderby … descending</code></td>
</tr>
<tr>
<td>ThenBy</td>
<td>按升序执行次要排序。</td>
<td><code>orderby …, …</code></td>
</tr>
<tr>
<td>ThenByDescending</td>
<td>按降序执行次要排序。</td>
<td><code>orderby …, … descending</code></td>
</tr>
<tr>
<td>Reverse</td>
<td>反转集合中元素的顺序。</td>
<td>不适用。</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/sorting-data">对数据排序</a></p>
<h2 id="集运算"><a href="#集运算" class="headerlink" title="集运算"></a>集运算</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/set-operations">集运算</a></p>
<h2 id="筛选数据"><a href="#筛选数据" class="headerlink" title="筛选数据"></a>筛选数据</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>C# 查询表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>OfType</td>
<td>根据其转换为特定类型的能力选择值。</td>
<td>不适用。</td>
</tr>
<tr>
<td>Where</td>
<td>选择基于谓词函数的值。</td>
<td><code>where</code></td>
</tr>
</tbody></table>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/filtering-data">筛选数据</a></p>
<h2 id="限定符运算"><a href="#限定符运算" class="headerlink" title="限定符运算"></a>限定符运算</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/quantifier-operations">限定符运算</a></p>
<h2 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>C# 查询表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>选择</td>
<td>投影基于转换函数的值。</td>
<td><code>select</code></td>
</tr>
<tr>
<td>SelectMany</td>
<td>投影基于转换函数的值序列，然后将它们展平为一个序列。</td>
<td>使用多个 <code>from</code> 子句</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/projection-operations">投影运算</a></p>
<h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/partitioning-data">数据分区</a></p>
<h2 id="联接运算"><a href="#联接运算" class="headerlink" title="联接运算"></a>联接运算</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>C# 查询表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>联接</td>
<td>根据键选择器函数联接两个序列并提取值对。</td>
<td><code>join … in … on … equals …</code></td>
</tr>
<tr>
<td>GroupJoin</td>
<td>根据键选择器函数联接两个序列，并对每个元素的结果匹配项进行分组。</td>
<td><code>join … in … on … equals … into …</code></td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/join-operations">联接运算</a></p>
<h2 id="对数据分组"><a href="#对数据分组" class="headerlink" title="对数据分组"></a>对数据分组</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>C# 查询表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>GroupBy</td>
<td>对共享通用属性的元素进行分组。 </br>每组由一个 IGrouping&lt;TKey,TElement&gt; 对象表示。</td>
<td>group … by 或 group … by … into …</td>
</tr>
<tr>
<td>ToLookup</td>
<td>将元素插入基于键选择器函数的</br>Lookup&lt;TKey,TElement&gt;（一种一对多字典）。</td>
<td>不适用。</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/grouping-data">对数据分组</a></p>
<h2 id="生成运算"><a href="#生成运算" class="headerlink" title="生成运算"></a>生成运算</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/generation-operations">生成运算</a></p>
<h2 id="相等运算"><a href="#相等运算" class="headerlink" title="相等运算"></a>相等运算</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/generation-operations">相等运算</a></p>
<h2 id="元素运算"><a href="#元素运算" class="headerlink" title="元素运算"></a>元素运算</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/element-operations">元素运算</a></p>
<h2 id="转换数据类型"><a href="#转换数据类型" class="headerlink" title="转换数据类型"></a>转换数据类型</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>C# 查询表达式语法</th>
</tr>
</thead>
<tbody><tr>
<td>AsEnumerable</td>
<td>返回类型化为 IEnumerable<T> 的输入。</td>
<td>不适用。</td>
</tr>
<tr>
<td>AsQueryable</td>
<td>将（泛型）IEnumerable 转换为（泛型）IQueryable。</td>
<td>不适用。</td>
</tr>
<tr>
<td>Cast</td>
<td>将集合中的元素转换为指定类型。</td>
<td>使用显式类型化的范围变量。 </br>例如:from string str in words</td>
</tr>
<tr>
<td>OfType</td>
<td>根据其转换为指定类型的能力筛选值。</td>
<td>不适用。</td>
</tr>
<tr>
<td>ToArray</td>
<td>将集合转换为数组。 此方法强制执行查询。</td>
<td>不适用。</td>
</tr>
<tr>
<td>ToDictionary</td>
<td>根据键选择器函数将元素放入 Dictionary&lt;TKey,TValue&gt;。</br> 此方法强制执行查询。</td>
<td>不适用。</td>
</tr>
<tr>
<td>ToList</td>
<td>将集合转换为 List<T>。 此方法强制执行查询。</td>
<td>不适用。</td>
</tr>
<tr>
<td>ToLookup</td>
<td>根据键选择器函数将元素放入 Lookup&lt;TKey,TElement&gt;（一对多字典）。 此方法强制执行查询。</td>
<td>不适用。</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/converting-data-types">转换数据类型</a></p>
<h2 id="串联运算"><a href="#串联运算" class="headerlink" title="串联运算"></a>串联运算</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/concatenation-operations">串联运算</a></p>
<h2 id="聚合运算"><a href="#聚合运算" class="headerlink" title="聚合运算"></a>聚合运算</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
<th>C# 查询表达式语法</th>
<th>详细信息</th>
</tr>
</thead>
<tbody><tr>
<td>聚合</td>
<td>对集合的值执行自定义聚合运算。</td>
<td>不适用。</td>
<td>Enumerable.Aggregate</br>Queryable.Aggregate</td>
</tr>
<tr>
<td>平均值</td>
<td>计算值集合的平均值。</td>
<td>不适用。</td>
<td>Enumerable.Average</br>Queryable.Average</td>
</tr>
<tr>
<td>计数</td>
<td>对集合中元素计数，可选择仅对满足</br>谓词函数的元素计数。</td>
<td>不适用。</td>
<td>Enumerable.Count</br>Queryable.Count</td>
</tr>
<tr>
<td>LongCount</td>
<td>对大型集合中元素计数，可选择仅对</br>满足谓词函数的元素计数。</td>
<td>不适用。</td>
<td>Enumerable.LongCount</br>Queryable.LongCount</td>
</tr>
<tr>
<td>最大值</td>
<td>确定集合中的最大值。</td>
<td>不适用。</td>
<td>Enumerable.Max</br>Queryable.Max</td>
</tr>
<tr>
<td>最小值</td>
<td>确定集合中的最小值。</td>
<td>不适用。</td>
<td>Enumerable.Min</br>Queryable.Min</td>
</tr>
<tr>
<td>Sum</td>
<td>对集合中的值求和。</td>
<td>不适用。</td>
<td>Enumerable.Sum</br>Queryable.Sum</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/aggregation-operations">聚合运算</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/standard-query-operators-overview">标准查询运算符概述 (C#)</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.enumerable.oftype?view=netframework-4.7.2">https://docs.microsoft.com/zh-cn/dotnet/api/system.linq.enumerable.oftype?view=netframework-4.7.2</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/28/CSharp%E5%9F%BA%E7%A1%80-LINQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/28/CSharp%E5%9F%BA%E7%A1%80-LINQ/" class="post-title-link" itemprop="url">CSharp基础-LINQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-28 14:15:20" itemprop="dateCreated datePublished" datetime="2018-12-28T14:15:20+00:00">2018-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LINQ/" itemprop="url" rel="index"><span itemprop="name">LINQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LINQ-简介"><a href="#LINQ-简介" class="headerlink" title="LINQ 简介"></a>LINQ 简介</h2><p>&emsp;&emsp;LINQ（语言集成查询，<code>Language Integrated Query</code>） 是 Visual Studio 2008 和 .NET Framework 3.5 版中引入的一项创新功能。它在对象领域和数据领域之间架起了一座桥梁。语言集成查询 (LINQ) 是一系列直接将查询功能集成到 C# 语言的技术统称。</p>
<p>&emsp;&emsp;<font color=#ff0000 size=4 face="黑体">LINQ 最明显的“语言集成”部分就是查询表达式。 查询表达式采用声明性查询语法编写而成。</font> 使用查询语法，可以用最少的代码对数据源执行筛选、排序和分组操作。 可使用相同的基本查询表达式模式来查询和转换 SQL 数据库、ADO .NET 数据集、XML 文档和流以及 .NET 集合中的数据。</p>
<h3 id="查询表达式概述"><a href="#查询表达式概述" class="headerlink" title="查询表达式概述"></a>查询表达式概述</h3><ul>
<li>查询表达式可用于查询并转换所有启用了 LINQ 的数据源中的数据。</li>
<li>查询表达式中的变量全都是强类型，尽管在许多情况下，无需显式提供类型，因为编译器可以推断出。</li>
<li>只有在循环访问查询变量后，才会执行查询（例如，在 <code>foreach</code> 语句中）</li>
<li>一些查询操作（如 <code>Count</code> 或 <code>Max</code>）没有等效的查询表达式子句，因此必须表示为方法调用。</li>
<li>查询表达式可被编译成表达式树或委托，具体视应用查询的类型而定。 <font color=#ff0000 size=4 face="黑体"><code>IEnumerable&lt;T&gt;</code> 查询编译为委托。 <code>IQueryable</code> 和 <code>IQueryable&lt;T&gt;</code> 查询编译为表达式树。</font></li>
</ul>
<h3 id="LINQ-中的查询语法和方法语法"><a href="#LINQ-中的查询语法和方法语法" class="headerlink" title="LINQ 中的查询语法和方法语法"></a>LINQ 中的查询语法和方法语法</h3><p>&emsp;&emsp;在编译代码时，查询语法必须转换为针对 .NET 公共语言运行时 (CLR) 的方法调用。 这些方法调用会调用标准查询运算符（名称为 Where、Select、GroupBy、Join、Max 和 Average 等）。 可以使用方法语法（而不查询语法）来直接调用它们。</p>
<h4 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a>查询语法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Query syntax:</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery1 =</span><br><span class="line">   <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">    <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    <span class="keyword">orderby</span> num</span><br><span class="line">    <span class="keyword">select</span> num;</span><br></pre></td></tr></table></figure>

<h4 id="方法语法"><a href="#方法语法" class="headerlink" title="方法语法"></a>方法语法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method syntax:</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery2 = numbers.Where(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>).OrderBy(n =&gt; n);</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>在 C# 中，<code>=&gt;</code> 是 <code>lambda</code> 运算符（读为“转到”）。</p>
<p><font color=#ff0000 size=4 face="黑体">当我们的Lambda表达式里面用到了外部变量的时候，编译器会为这个Lambda生成一个类，在这个类中包含了我们表达式方法。</font></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Query syntax:</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery1 =</span><br><span class="line">    <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">    <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">    <span class="keyword">orderby</span> num</span><br><span class="line">    <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method syntax:</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; numQuery2 = numbers.Where(num =&gt; num % <span class="number">2</span> == <span class="number">0</span>).OrderBy(n =&gt; n);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上面的示例中，请注意，条件表达式 (num % 2 == 0) 作为内联参数传递给 Where 方法：Where(num =&gt; num % 2 == 0). 此内联表达式称为 lambda 表达式。 可采用匿名方法、泛型委托或表达式树的形式编写原本必须以更繁琐的形式编写的代码。</p>
<p>&emsp;&emsp;Lambda 的主体与查询语法中或任何其他 C# 表达式或语句中的表达式完全相同；它可以包含方法调用和其他复杂逻辑。 “返回值”就是表达式结果。</p>
<p>某些查询只能采用方法语法进行表示，而其中一些查询需要 lambda 表达式。</p>
<h3 id="对象和集合初始值设定项"><a href="#对象和集合初始值设定项" class="headerlink" title="对象和集合初始值设定项"></a>对象和集合初始值设定项</h3><p>通过对象和集合初始值设定项，初始化对象时无需为对象显式调用构造函数。 初始值设定项通常用在将源数据投影到新数据类型的查询表达式中。 假定一个类名为 <code>Customer</code>，具有公共 <code>Name</code> 和 <code>Phone</code> 属性，可以按下列代码中所示使用对象初始值设定项：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Customer cust = <span class="keyword">new</span> Customer &#123; Name = <span class="string">&quot;Mike&quot;</span>, Phone = <span class="string">&quot;555-1212&quot;</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> newLargeOrderCustomers = <span class="keyword">from</span> o <span class="keyword">in</span> IncomingOrders</span><br><span class="line">                            <span class="keyword">where</span> o.OrderSize &gt; <span class="number">5</span></span><br><span class="line">                            <span class="keyword">select</span> <span class="keyword">new</span> Customer &#123; Name = o.Name, Phone = o.Phone &#125;;</span><br></pre></td></tr></table></figure>

<p>述代码也可以使用 LINQ 的方法语法编写:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newLargeOrderCustomers = IncomingOrders.Where(x =&gt; x.OrderSize &gt; <span class="number">5</span>).Select(y =&gt; <span class="keyword">new</span> Customer &#123; Name = y.Name, Phone = y.Phone &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="LINQ-查询"><a href="#LINQ-查询" class="headerlink" title="LINQ 查询"></a>LINQ 查询</h2><p>所有 LINQ 查询操作都由以下三个不同的操作组成：<br>获取数据源。<br>创建查询。<br>执行查询。</p>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>基本规则很简单：LINQ 数据源是支持泛型 <code>IEnumerable&lt;T&gt;</code> 接口或从中继承的接口的任意对象。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在 LINQ 中，查询变量本身不执行任何操作并且不返回任何数据。 它只是存储在以后某个时刻执行查询时为生成结果而必需的信息。</p>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>查询的实际执行将推迟到在 <code>foreach</code> 语句中循环访问查询变量之后进行。 此概念称为延迟执行，下面的示例对此进行了演示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Query execution. </span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">&quot;&#123;0,1&#125; &quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在应用程序中，可以创建一个检索最新数据的查询，并可以按某一时间间隔反复执行该查询以便每次检索不同的结果。</p>
<h4 id="强制立即执行"><a href="#强制立即执行" class="headerlink" title="强制立即执行"></a>强制立即执行</h4><p>对一系列源元素执行聚合函数的查询必须首先循环访问这些元素。 <code>Count</code>、<code>Max</code>、<code>Average</code> 和 <code>First</code> 就属于此类查询。由于查询本身必须使用 <code>foreach</code> 以便返回结果，因此这些查询在执行时不使用显式 <code>foreach</code> 语句。 另外还要注意，这些类型的查询返回单个值，而不是 <code>IEnumerable</code> 集合。 下面的查询返回源数组中偶数的计数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> evenNumQuery =</span><br><span class="line">    <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">    <span class="keyword">where</span> (num % <span class="number">2</span>) == <span class="number">0</span></span><br><span class="line">    <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> evenNumCount = evenNumQuery.Count();</span><br></pre></td></tr></table></figure>

<p>要强制立即执行任何查询并缓存其结果，可调用 <code>ToList</code> 或 <code>ToArray</code> 方法。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numQuery2 =</span><br><span class="line">    (<span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">     <span class="keyword">where</span> (num % <span class="number">2</span>) == <span class="number">0</span></span><br><span class="line">     <span class="keyword">select</span> num).ToList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// or like this:</span></span><br><span class="line"><span class="comment">// numQuery3 is still an int[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numQuery3 =</span><br><span class="line">    (<span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">     <span class="keyword">where</span> (num % <span class="number">2</span>) == <span class="number">0</span></span><br><span class="line">     <span class="keyword">select</span> num).ToArray();</span><br></pre></td></tr></table></figure>

<h2 id="基本-LINQ-查询操作"><a href="#基本-LINQ-查询操作" class="headerlink" title="基本 LINQ 查询操作"></a>基本 LINQ 查询操作</h2><h3 id="获取数据源"><a href="#获取数据源" class="headerlink" title="获取数据源"></a>获取数据源</h3><p>使用 from 子句引入数据源:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//queryAllCustomers is an IEnumerable&lt;Customer&gt;</span></span><br><span class="line"><span class="keyword">var</span> queryAllCustomers = <span class="keyword">from</span> cust <span class="keyword">in</span> customers</span><br><span class="line">                        <span class="keyword">select</span> cust;</span><br></pre></td></tr></table></figure>

<p>可通过 <code>let</code> 子句引入其他范围变量。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> earlyBirdQuery =</span><br><span class="line">     <span class="keyword">from</span> sentence <span class="keyword">in</span> strings</span><br><span class="line">     <span class="keyword">let</span> words = sentence.Split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">     <span class="keyword">from</span> word <span class="keyword">in</span> words</span><br><span class="line">     <span class="keyword">let</span> w = word.ToLower()</span><br><span class="line">     <span class="keyword">where</span> w[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span> || w[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span></span><br><span class="line">         || w[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span> || w[<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span></span><br><span class="line">         || w[<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span></span><br><span class="line">     <span class="keyword">select</span> word;</span><br></pre></td></tr></table></figure>

<h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>筛选器使查询仅返回表达式为 true 的元素。 将通过使用 <code>where</code> 子句生成结果。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryLondonCustomers = <span class="keyword">from</span> cust <span class="keyword">in</span> customers</span><br><span class="line">                           <span class="keyword">where</span> cust.City == <span class="string">&quot;London&quot;</span></span><br><span class="line">                           <span class="keyword">select</span> cust;</span><br></pre></td></tr></table></figure>

<h3 id="中间件排序"><a href="#中间件排序" class="headerlink" title="中间件排序"></a>中间件排序</h3><p><code>orderby</code> 子句根据要排序类型的默认比较器，对返回序列中的元素排序。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryLondonCustomers3 =</span><br><span class="line">    <span class="keyword">from</span> cust <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">where</span> cust.City == <span class="string">&quot;London&quot;</span></span><br><span class="line">    <span class="keyword">orderby</span> cust.Name <span class="keyword">ascending</span></span><br><span class="line">    <span class="keyword">select</span> cust;</span><br></pre></td></tr></table></figure>

<p>要对结果进行从 Z 到 A 的逆序排序，请使用 <code>orderby…descending</code> 子句。</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>group</code> 子句用于对根据指定的键所获得的结果进行分组。</p>
<p>使用 <code>group</code> 子句结束查询时，结果将以列表的形式列出。 列表中的每个元素都是具有 <code>Key</code> 成员的对象，列表中的元素根据该键被分组。 在循环访问生成组序列的查询时，必须使用嵌套 <code>foreach</code> 循环。 外层循环循环访问每个组，内层循环循环访问每个组的成员。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queryCustomersByCity is an IEnumerable&lt;IGrouping&lt;string, Customer&gt;&gt;</span></span><br><span class="line">  <span class="keyword">var</span> queryCustomersByCity =</span><br><span class="line">      <span class="keyword">from</span> cust <span class="keyword">in</span> customers</span><br><span class="line">      <span class="keyword">group</span> cust <span class="keyword">by</span> cust.City;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// customerGroup is an IGrouping&lt;string, Customer&gt;</span></span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> customerGroup <span class="keyword">in</span> queryCustomersByCity)</span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine(customerGroup.Key);</span><br><span class="line">      <span class="keyword">foreach</span> (Customer customer <span class="keyword">in</span> customerGroup)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(<span class="string">&quot;    &#123;0&#125;&quot;</span>, customer.Name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果必须引用某个组操作的结果，可使用 into 关键字创建能被进一步查询的标识符。 下列查询仅返回包含两个以上客户的组：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custQuery is an IEnumerable&lt;IGrouping&lt;string, Customer&gt;&gt;</span></span><br><span class="line"><span class="keyword">var</span> custQuery =</span><br><span class="line">    <span class="keyword">from</span> cust <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">group</span> cust <span class="keyword">by</span> cust.City <span class="keyword">into</span> custGroup</span><br><span class="line">    <span class="keyword">where</span> custGroup.Count() &gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">orderby</span> custGroup.Key</span><br><span class="line">    <span class="keyword">select</span> custGroup;</span><br></pre></td></tr></table></figure>

<h3 id="联接"><a href="#联接" class="headerlink" title="联接"></a>联接</h3><p>在 LINQ 中，join 子句始终作用于对象集合，而非直接作用于数据库表。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> innerJoinQuery =</span><br><span class="line">    <span class="keyword">from</span> cust <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">join</span> dist <span class="keyword">in</span> distributors <span class="keyword">on</span> cust.City <span class="keyword">equals</span> dist.City</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; CustomerName = cust.Name, DistributorName = dist.Name &#125;;</span><br></pre></td></tr></table></figure>

<p>在 LINQ 中，不必像在 SQL 中那样频繁使用 join，因为 LINQ 中的外键在对象模型中表示为包含项集合的属性。 例如 Customer 对象包含 Order 对象的集合。 不必执行联接，只需使用点表示法访问订单：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> order <span class="keyword">in</span> Customer.Orders...</span><br></pre></td></tr></table></figure>

<h3 id="选择（投影）"><a href="#选择（投影）" class="headerlink" title="选择（投影）"></a>选择（投影）</h3><p><font color=#0099ff size=4 face="黑体">select 子句生成查询结果并指定每个返回的元素的“形状”或类型。当 select 子句生成除源元素副本以外的内容时，该操作称为投影。</font></p>
<h2 id="使用-LINQ-进行数据转换"><a href="#使用-LINQ-进行数据转换" class="headerlink" title="使用 LINQ 进行数据转换"></a>使用 LINQ 进行数据转换</h2><p>语言集成查询 (LINQ) 不只是检索数据。 它也是用于转换数据的强大工具。 通过使用 LINQ 查询，可以使用源序列作为输入，并通过多种方式对其进行修改，以创建新的输出序列。通过排序和分组，你可以修改序列本身，而无需修改这些元素本身。</p>
<p><code>select</code> 可以执行下列任务</p>
<ul>
<li>将多个输入序列合并为具有新类型的单个输出序列。</li>
<li>创建其元素由源序列中每个元素的一个或多个属性组成的输出序列。</li>
<li>创建其元素由对源数据执行的操作结果组成的输出序列。</li>
<li>创建其他格式的输出序列。 例如，可以将数据从 SQL 行或文本文件转换为 XML。</li>
</ul>
<h3 id="将多个输入联接到一个输出序列中"><a href="#将多个输入联接到一个输出序列中" class="headerlink" title="将多个输入联接到一个输出序列中"></a>将多个输入联接到一个输出序列中</h3><p><font color=#0099ff size=4 face="黑体">可以使用 LINQ 查询创建包含元素的输出序列，这些元素来自多个输入序列。</font></p>
<p>例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> First &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Last &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Street &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; Scores;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> First &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Last &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DataTransformations</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Create the first data source.</span></span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> List&lt;Student&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Student &#123; First=<span class="string">&quot;Svetlana&quot;</span>,</span><br><span class="line">                Last=<span class="string">&quot;Omelchenko&quot;</span>,</span><br><span class="line">                ID=<span class="number">111</span>,</span><br><span class="line">                Street=<span class="string">&quot;123 Main Street&quot;</span>,</span><br><span class="line">                City=<span class="string">&quot;Seattle&quot;</span>,</span><br><span class="line">                Scores= <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">97</span>, <span class="number">92</span>, <span class="number">81</span>, <span class="number">60</span> &#125; &#125;,</span><br><span class="line">            <span class="keyword">new</span> Student &#123; First=<span class="string">&quot;Claire&quot;</span>,</span><br><span class="line">                Last=<span class="string">&quot;O’Donnell&quot;</span>,</span><br><span class="line">                ID=<span class="number">112</span>,</span><br><span class="line">                Street=<span class="string">&quot;124 Main Street&quot;</span>,</span><br><span class="line">                City=<span class="string">&quot;Redmond&quot;</span>,</span><br><span class="line">                Scores= <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">75</span>, <span class="number">84</span>, <span class="number">91</span>, <span class="number">39</span> &#125; &#125;,</span><br><span class="line">            <span class="keyword">new</span> Student &#123; First=<span class="string">&quot;Sven&quot;</span>,</span><br><span class="line">                Last=<span class="string">&quot;Mortensen&quot;</span>,</span><br><span class="line">                ID=<span class="number">113</span>,</span><br><span class="line">                Street=<span class="string">&quot;125 Main Street&quot;</span>,</span><br><span class="line">                City=<span class="string">&quot;Lake City&quot;</span>,</span><br><span class="line">                Scores= <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">88</span>, <span class="number">94</span>, <span class="number">65</span>, <span class="number">91</span> &#125; &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the second data source.</span></span><br><span class="line">        List&lt;Teacher&gt; teachers = <span class="keyword">new</span> List&lt;Teacher&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Teacher &#123; First=<span class="string">&quot;Ann&quot;</span>, Last=<span class="string">&quot;Beebe&quot;</span>, ID=<span class="number">945</span>, City=<span class="string">&quot;Seattle&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Teacher &#123; First=<span class="string">&quot;Alex&quot;</span>, Last=<span class="string">&quot;Robinson&quot;</span>, ID=<span class="number">956</span>, City=<span class="string">&quot;Redmond&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Teacher &#123; First=<span class="string">&quot;Michiyo&quot;</span>, Last=<span class="string">&quot;Sato&quot;</span>, ID=<span class="number">972</span>, City=<span class="string">&quot;Tacoma&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the query.</span></span><br><span class="line">        <span class="keyword">var</span> peopleInSeattle = (<span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">                    <span class="keyword">where</span> student.City == <span class="string">&quot;Seattle&quot;</span></span><br><span class="line">                    <span class="keyword">select</span> student.Last)</span><br><span class="line">                    .Concat(<span class="keyword">from</span> teacher <span class="keyword">in</span> teachers</span><br><span class="line">                            <span class="keyword">where</span> teacher.City == <span class="string">&quot;Seattle&quot;</span></span><br><span class="line">                            <span class="keyword">select</span> teacher.Last);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The following students and teachers live in Seattle:&quot;</span>);</span><br><span class="line">        <span class="comment">// Execute the query.</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> person <span class="keyword">in</span> peopleInSeattle)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(person);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Press any key to exit.&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    The following students and teachers live in Seattle:</span></span><br><span class="line"><span class="comment">    Omelchenko</span></span><br><span class="line"><span class="comment">    Beebe</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="选择每个源元素的子集"><a href="#选择每个源元素的子集" class="headerlink" title="选择每个源元素的子集"></a>选择每个源元素的子集</h3><p>有两种主要方法来选择源序列中每个元素的子集：</p>
<p>1，若要仅选择源元素的一个成员，请使用点操作。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> cust <span class="keyword">in</span> Customers  </span><br><span class="line">            <span class="keyword">select</span> cust.City; </span><br></pre></td></tr></table></figure>

<p>2，要创建包含多个源元素属性的元素，可以使用带有命名对象或匿名类型的对象初始值设定项。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> cust <span class="keyword">in</span> Customer  </span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123;Name = cust.Name, City = cust.City&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="将内存中对象转换为-XML"><a href="#将内存中对象转换为-XML" class="headerlink" title="将内存中对象转换为 XML"></a>将内存中对象转换为 XML</h3><p>LINQ 查询可以方便地在内存中数据结构、SQL 数据库、ADO.NET 数据集和 XML 流或文档之间转换数据。 </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Create the data source by using a collection initializer.</span></span><br><span class="line">    <span class="comment">// The Student class was defined previously in this topic.</span></span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> List&lt;Student&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Student &#123;First=<span class="string">&quot;Svetlana&quot;</span>, Last=<span class="string">&quot;Omelchenko&quot;</span>, ID=<span class="number">111</span>, Scores = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">97</span>, <span class="number">92</span>, <span class="number">81</span>, <span class="number">60</span>&#125;&#125;,</span><br><span class="line">        <span class="keyword">new</span> Student &#123;First=<span class="string">&quot;Claire&quot;</span>, Last=<span class="string">&quot;O’Donnell&quot;</span>, ID=<span class="number">112</span>, Scores = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">75</span>, <span class="number">84</span>, <span class="number">91</span>, <span class="number">39</span>&#125;&#125;,</span><br><span class="line">        <span class="keyword">new</span> Student &#123;First=<span class="string">&quot;Sven&quot;</span>, Last=<span class="string">&quot;Mortensen&quot;</span>, ID=<span class="number">113</span>, Scores = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;&#123;<span class="number">88</span>, <span class="number">94</span>, <span class="number">65</span>, <span class="number">91</span>&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the query.</span></span><br><span class="line">    <span class="keyword">var</span> studentsToXML = <span class="keyword">new</span> XElement(<span class="string">&quot;Root&quot;</span>,</span><br><span class="line">        <span class="keyword">from</span> student <span class="keyword">in</span> students</span><br><span class="line">        <span class="keyword">let</span> scores = <span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>, student.Scores)</span><br><span class="line">        <span class="function"><span class="keyword">select</span> <span class="keyword">new</span> <span class="title">XElement</span>(<span class="params"><span class="string">&quot;student&quot;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">new</span> XElement(<span class="string">&quot;First&quot;</span>, student.First</span>),</span></span><br><span class="line"><span class="function">                   <span class="keyword">new</span> <span class="title">XElement</span>(<span class="params"><span class="string">&quot;Last&quot;</span>, student.Last</span>),</span></span><br><span class="line"><span class="function">                   <span class="keyword">new</span> <span class="title">XElement</span>(<span class="params"><span class="string">&quot;Scores&quot;</span>, scores</span>)</span></span><br><span class="line"><span class="function">                ) <span class="comment">// end &quot;student&quot;</span></span></span><br><span class="line"><span class="function">            )</span>; <span class="comment">// end &quot;Root&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the query.</span></span><br><span class="line">    Console.WriteLine(studentsToXML);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the console open in debug mode.</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press any key to exit.&quot;</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;Root&gt;  </span><br><span class="line">  &lt;student&gt;  </span><br><span class="line">    &lt;First&gt;Svetlana&lt;/First&gt;  </span><br><span class="line">    &lt;Last&gt;Omelchenko&lt;/Last&gt;  </span><br><span class="line">    &lt;Scores&gt;<span class="number">97</span>,<span class="number">92</span>,<span class="number">81</span>,<span class="number">60</span>&lt;/Scores&gt;  </span><br><span class="line">  &lt;/student&gt;  </span><br><span class="line">  &lt;student&gt;  </span><br><span class="line">    &lt;First&gt;Claire&lt;/First&gt;  </span><br><span class="line">    &lt;Last&gt;O<span class="string">&#x27;Donnell&lt;/Last&gt;  </span></span><br><span class="line"><span class="string">    &lt;Scores&gt;75,84,91,39&lt;/Scores&gt;  </span></span><br><span class="line"><span class="string">  &lt;/student&gt;  </span></span><br><span class="line"><span class="string">  &lt;student&gt;  </span></span><br><span class="line"><span class="string">    &lt;First&gt;Sven&lt;/First&gt;  </span></span><br><span class="line"><span class="string">    &lt;Last&gt;Mortensen&lt;/Last&gt;  </span></span><br><span class="line"><span class="string">    &lt;Scores&gt;88,94,65,91&lt;/Scores&gt;  </span></span><br><span class="line"><span class="string">  &lt;/student&gt;  </span></span><br><span class="line"><span class="string">&lt;/Root&gt;  </span></span><br></pre></td></tr></table></figure>

<h3 id="对源元素执行操作"><a href="#对源元素执行操作" class="headerlink" title="对源元素执行操作"></a>对源元素执行操作</h3><p>&emsp;&emsp;<font color=#0099ff size=4 face="黑体">输出序列可能不包含源序列中的任何元素或元素属性。 输出可能是使用源元素作为输入参数而计算得出的值序列。</font></p>
<p>备注:<br>&emsp;&emsp;如果查询将被转换为另一个域，则不支持在查询表达式中调用方法。 例如，不能在 LINQ to SQL 中调用普通的 C# 方法，因为 SQL Server 没有用于它的上下文。 但是，可以将存储过程映射到方法并调用这些方法。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Data source.</span></span><br><span class="line">    <span class="built_in">double</span>[] radii = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query.</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">        <span class="keyword">from</span> rad <span class="keyword">in</span> radii</span><br><span class="line">        <span class="keyword">select</span> <span class="string">$&quot;Area = <span class="subst">&#123;rad * rad * Math.PI:F2&#125;</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query execution. </span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> query)</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the console open in debug mode.</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press any key to exit.&quot;</span>);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    Area = 3.14</span></span><br><span class="line"><span class="comment">    Area = 12.57</span></span><br><span class="line"><span class="comment">    Area = 28.27</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="LINQ-查询操作中的类型关系"><a href="#LINQ-查询操作中的类型关系" class="headerlink" title="LINQ 查询操作中的类型关系"></a>LINQ 查询操作中的类型关系</h2><p>&emsp;&emsp;LINQ 查询操作在数据源、查询本身及查询执行中是强类型化的。 查询中变量的类型必须与数据源中元素的类型和 foreach 语句中迭代变量的类型兼容。 此强类型保证在编译时捕获类型错误，以便可以在用户遇到这些错误之前更正它们。</p>
<h3 id="不转换源数据的查询"><a href="#不转换源数据的查询" class="headerlink" title="不转换源数据的查询"></a>不转换源数据的查询</h3><p><img src="/img/linq_flow1.png" alt="linq_flow1.png"></p>
<h3 id="转换源数据的查询"><a href="#转换源数据的查询" class="headerlink" title="转换源数据的查询"></a>转换源数据的查询</h3><p><img src="/img/linq_flow2.png" alt="linq_flow2.png"></p>
<p><img src="/img/linq_flow3.png" alt="linq_flow3.png"></p>
<h3 id="让编译器推断类型信息"><a href="#让编译器推断类型信息" class="headerlink" title="让编译器推断类型信息"></a>让编译器推断类型信息</h3><p>关键字 <code>var</code> 可用于查询操作中的任何本地变量。</p>
<p><img src="/img/linq_flow4.png" alt="linq_flow4.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/let-clause">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/let-clause</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/">语言集成查询 (LINQ)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/27/DotNet%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/27/DotNet%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/" class="post-title-link" itemprop="url">DotNet泛型中的协变和逆变</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-27 11:31:55" itemprop="dateCreated datePublished" datetime="2018-12-27T11:31:55+00:00">2018-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">集合与泛型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>协变和逆变都是术语，协变指能够使用比原始指定的派生类型的派生程度更大（更具体的）的类型，逆变指能够使用比原始指定的派生类型的派生程度更小（不太具体的）的类型。</p>
<p>规律总结：</p>
<p><font color=#ff0000 size=4 face="黑体">“子类”向“父类”转换，即协变；（可以使用的范围变大）<br>“父类”向“子类”转换，即逆变；（可以使用的范围变小）</font></p>
<h2 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h2><p><font color=#0099ff size=4 face="黑体">协变和逆变统称为“变体”（Variant）。 未标记为协变或逆变的泛型类型参数称为“固定参数” 。</font></p>
<p>规则：</p>
<p><font color=#ff0000 size=4 face="黑体">通常，协变类型参数可用作委托的返回类型，而逆变类型参数可用作参数类型。<br>对于接口，协变类型参数可用作接口的方法的返回类型，而逆变类型参数可用作接口的方法的参数类型。</font></p>
<p>有关公共语言运行时中变体的事项的简短摘要：</p>
<ul>
<li>在 .NET Framework 4中，<code>Variant</code> 类型参数仅限于泛型接口和泛型委托类型。</li>
<li>泛型接口或泛型委托类型可以同时具有协变和逆变类型参数。</li>
<li>变体仅适用于引用类型；如果为 <code>Variant</code> 类型参数指定值类型，则该类型参数对于生成的构造类型是不变的。</li>
<li>变体不适用于委托组合。 也就是说，在给定类型 <code>Action&lt;Derived&gt;</code> 和 <code>Action&lt;Base&gt;</code> 的两个委托的情况下，无法将第二个委托与第一个委托结合起来，尽管结果将是类型安全的。 变体允许将第二个委托分配给类型 Action<Derived>的变量，但只能在这两个委托的类型完全匹配的情况下对它们进行组合。</li>
</ul>
<p>** Covariance:协变 **<br>使你能够使用比原始指定的类型派生程度更大的类型。</p>
<p>** Contravariance：逆变**<br>使你能够使用比原始指定的类型更泛型（派生程度更小）的类型。</p>
<p>** Invariance：不变**<br>这意味着，你只能使用原始指定的类型；固定泛型类型参数既不是协变类型，也不是逆变类型。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>** 协变类型参数用<code>out</code>关键字 **</p>
<p>可以将协变类型参数用作属于接口的方法的返回值，或用作委托的返回类型。 但不能将协变类型参数用作接口方法的泛型类型约束。如果接口的方法具有泛型委托类型的参数，则接口类型的协变类型参数可用于指定委托类型的逆变类型参数。</p>
<p>** 逆变类型参数用 <code>in</code> 关键字**</p>
<p>可以将逆变类型参数用作属于接口的方法的参数类型，或用作委托的参数类型。 也可以将逆变类型参数用作接口方法的泛型类型约束。</p>
<p><font color=#ff0000 size=4 face="黑体">注意，只有接口类型和委托类型才能具有 变体（Variant） 类型参数。 接口或委托类型可以同时具有协变和逆变类型参数。</font></p>
<p>C# 不允许违反协变和逆变类型参数的使用规则，也不允许将协变和逆变批注添加到接口和委托类型之外的类型参数中。 MSIL 汇编程序 不执行此类检查，但如果你尝试加载违反规则的类型，则会引发 TypeLoadException 。</p>
<h3 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h3><p>利用协变类型参数，你可以执行非常类似于普通的多态性的分配</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;Derived&gt; d = <span class="keyword">new</span> List&lt;Derived&gt;();</span><br><span class="line">IEnumerable&lt;Base&gt; b = d;</span><br></pre></td></tr></table></figure>

<h3 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h3><p>由于 lambda 表达式与其自身所分配到的委托相匹配，因此它会定义一个方法，此方法采用一个类型 Base 的参数且没有返回值。 可以将结果委托分配给类型类型 <code>Action&lt;Derived&gt;</code> 的变量，因为 T 委托的类型参数 <code>Action&lt;T&gt;</code> 是逆变类型参数。 由于 T 指定了一个参数类型，因此该代码是类型安全代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Action&lt;Base&gt; b = (target) =&gt; &#123; Console.WriteLine(target.GetType().Name); &#125;;</span><br><span class="line">Action&lt;Derived&gt; d = b;</span><br><span class="line">d(<span class="keyword">new</span> Derived());</span><br></pre></td></tr></table></figure>

<h2 id="泛型接口中的变体"><a href="#泛型接口中的变体" class="headerlink" title="泛型接口中的变体"></a>泛型接口中的变体</h2><h3 id="具有协变类型参数的泛型接口"><a href="#具有协变类型参数的泛型接口" class="headerlink" title="具有协变类型参数的泛型接口"></a>具有协变类型参数的泛型接口</h3><p>从 .NET Framework 4开始，某些泛型接口具有协变类型参数；例如： <code>IEnumerable&lt;T&gt;</code>、 <code>IEnumerator&lt;T&gt;</code>、 <code>IQueryable&lt;T&gt;</code> 和 <code>IGrouping&lt;TKey,TElement&gt;</code>。 由于这些接口的所有类型参数都是协变类型参数，因此这些类型参数只用于成员的返回类型。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintBases</span>(<span class="params">IEnumerable&lt;Base&gt; bases</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(Base b <span class="keyword">in</span> bases)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="title">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        List&lt;Derived&gt; dlist = <span class="keyword">new</span> List&lt;Derived&gt;();</span><br><span class="line"></span><br><span class="line">        Derived.PrintBases(dlist);</span><br><span class="line">        IEnumerable&lt;Base&gt; bIEnum = dlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具有逆变泛型类型参数的泛型接口"><a href="#具有逆变泛型类型参数的泛型接口" class="headerlink" title="具有逆变泛型类型参数的泛型接口"></a>具有逆变泛型类型参数的泛型接口</h3><p>从 .NET Framework 4开始，某些泛型接口具有逆变类型参数；例如： <code>IComparer&lt;T&gt;</code>、 <code>IComparable&lt;T&gt;</code>和 <code>IEqualityComparer&lt;T&gt;</code>。 由于这些接口只具有逆变类型参数，因此这些类型参数只用作接口成员中的参数类型。</p>
<p><code>IComparer&lt;T&gt;.Compare</code> 方法的实现基于 Area 属性的值，所以 <code>ShapeAreaComparer</code> 可用于按区域对 Shape 对象排序。<br>该示例创建 <code>SortedSet&lt;T&gt;</code> 对象的 <code>Circle</code> ，使用采用 <code>IComparer&lt;Circle&gt;</code> 的构造函数。 但是，该对象不传递 <code>IComparer&lt;Circle&gt;</code>，而是传递一个用于实现 <code>ShapeAreaComparer</code> 的 <code>IComparer&lt;Shape&gt;</code> 对象。 当代码需要派生程度较大的类型的比较器 <code>(Shape)</code> 时，该示例可以传递派生程度较小的类型的比较器 <code>(Circle)</code>，因为 <code>IComparer&lt;T&gt;</code> 泛型接口的类型参数是逆变参数。</p>
<p>向 <code>Circle</code> 中添加新 <code>SortedSet&lt;Circle&gt;</code>对象时，每次将新元素与现有元素进行比较时，都会调用 <code>IComparer&lt;Shape&gt;.Compare</code> 对象的<code>IComparer(Of Shape).Compare</code> 方法。 方法 (Shape) 的参数类型比被传递的类型 (Circle) 的派生程度小，所以调用是类型安全的。 逆变使 <code>ShapeAreaComparer</code> 可以对派生自 Shape的任意单个类型的集合以及混合类型的集合排序。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">double</span> Area &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> r;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">double</span> radius</span>)</span> &#123; r = radius; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> r; &#125;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> Area &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> Math.PI * r * r; &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ShapeAreaComparer</span> : <span class="title">System.Collections.Generic.IComparer</span>&lt;<span class="title">Shape</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> IComparer&lt;Shape&gt;.Compare(Shape a, Shape b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) <span class="keyword">return</span> b == <span class="literal">null</span> ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="literal">null</span> ? <span class="number">1</span> : a.Area.CompareTo(b.Area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// You can pass ShapeAreaComparer, which implements IComparer&lt;Shape&gt;,</span></span><br><span class="line">        <span class="comment">// even though the constructor for SortedSet&lt;Circle&gt; expects </span></span><br><span class="line">        <span class="comment">// IComparer&lt;Circle&gt;, because type parameter T of IComparer&lt;T&gt; is</span></span><br><span class="line">        <span class="comment">// contravariant.</span></span><br><span class="line">        SortedSet&lt;Circle&gt; circlesByArea = </span><br><span class="line">            <span class="keyword">new</span> SortedSet&lt;Circle&gt;(<span class="keyword">new</span> ShapeAreaComparer()) </span><br><span class="line">                &#123; <span class="keyword">new</span> Circle(<span class="number">7.2</span>), <span class="keyword">new</span> Circle(<span class="number">100</span>), <span class="literal">null</span>, <span class="keyword">new</span> Circle(<span class="number">.01</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Circle c <span class="keyword">in</span> circlesByArea)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(c == <span class="literal">null</span> ? <span class="string">&quot;null&quot;</span> : <span class="string">&quot;Circle with area &quot;</span> + c.Area);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This code example produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">Circle with area 0.000314159265358979</span></span><br><span class="line"><span class="comment">Circle with area 162.860163162095</span></span><br><span class="line"><span class="comment">Circle with area 31415.9265358979</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型委托中的变体"><a href="#泛型委托中的变体" class="headerlink" title="泛型委托中的变体"></a>泛型委托中的变体</h2><p>在 .NET Framework 4中， <code>Func</code> 泛型委托（如 <code>Func&lt;T,TResult&gt;</code>）具有协变返回类型和逆变参数类型。 <code>Action</code> 泛型委托（如 <code>Action&lt;T1,T2&gt;</code>）具有逆变参数类型。 这意味着，可以将委托指派给具有派生程度较高的参数类型和（对于 <code>Func</code> 泛型委托）派生程度较低的返回类型的变量。</p>
<p>备注：</p>
<p><code>Func</code> 泛型委托的最后一个泛型类型参数指定委托签名中返回值的类型。 该参数是协变的（<code>out</code> 关键字），而其他泛型类型参数是逆变的（<code>in</code> 关键字）。</p>
<h2 id="Variant-泛型接口和委托类型的列表"><a href="#Variant-泛型接口和委托类型的列表" class="headerlink" title="Variant 泛型接口和委托类型的列表"></a>Variant 泛型接口和委托类型的列表</h2><p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance#list-of-variant-generic-interface-and-delegate-types">Variant 泛型接口和委托类型的列表</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance">泛型中的协变和逆变</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/27/CSharp%E9%9B%86%E5%90%88-HashSet%E4%B8%8EList%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/27/CSharp%E9%9B%86%E5%90%88-HashSet%E4%B8%8EList%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">CSharp集合-HashSet与List区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-27 09:59:34" itemprop="dateCreated datePublished" datetime="2018-12-27T09:59:34+00:00">2018-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">集合与泛型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>HashSet&lt;T&gt;</code> 是把对象保存在一个Hash表中的，查找时根据对象的Hash值直接定位对象；<br><code>List&lt;T&gt;</code> 是把对象放到数组里，查找时是一个一个元素遍历的。</p>
<p><code>List&lt;T&gt;</code> 里面是线序集，<code>HashSet&lt;T&gt;</code> 里面是散列表。与 <code>Dictionary&lt;K,V&gt;</code> 相比，<code>List&lt;T&gt;</code> 可以看成下标到值的映射，<code>HashSet&lt;T&gt;</code> 可以看成值自己到自己的映射。<br>判断一个值是否存在，<code>List&lt;T&gt;</code> 相当于是用值去找下标，要遍历一遍容器；<br><code>HashSet&lt;T&gt;</code> 相当于用映射前的值去找映射后的值，只需要计算出来值的hash，然后直接访问就可以。</p>
<p><code>HashSet&lt;T&gt;</code> 时间复杂度O(1)，<br><code>List&lt;T&gt;</code> 时间复杂度O(n)。</p>
<p>而且 <code>HashSet&lt;T&gt;</code> 无序不重，和 <code>List&lt;T&gt;</code> 完全不同。</p>
<p>按特定顺序存储项的集合 <code>List&lt;T&gt;</code>。</p>
<p>快速确定集合中是否包含某个对象 <code>HashSet&lt;T&gt;</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/27/CSharp%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/27/CSharp%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">CSharp基础-集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-27 08:59:34" itemprop="dateCreated datePublished" datetime="2018-12-27T08:59:34+00:00">2018-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">集合与泛型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>集合是.NET FCL(Framework Class Library)中很重要的一部分。.net的集合诸如（<code>System.Array</code>类以及 <code>System.Collections</code>命名空间）数组、列表、队列、堆栈、哈希表、字典甚至（<code>System.Data</code>下)<code>DataSet</code>、<code>DataTable</code>，还有2.0中加入的集合的泛型版本（<code>System.Collections.Generic</code>和 <code>System.Collections.ObjectModel</code>）。4.0中引入的有效线程安全操作的集合（<code>System.Collections.Concurrent</code>）。</p>
<h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><p><img src="/img/28211801-aeaddc8243394d34851a127aad881a29.png" alt="28211801-aeaddc8243394d34851a127aad881a29.png"></p>
<h3 id="IEnumerable-和-IEnumberator"><a href="#IEnumerable-和-IEnumberator" class="headerlink" title="IEnumerable 和 IEnumberator"></a>IEnumerable 和 IEnumberator</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="built_in">object</span> Current &#123;  <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IEnumerator定义了遍历集合的基本方法，以便实现单向向前的访问集合中的每一个元素。而IEnumerable只有一个方法GetEnumerator即得到遍历器。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：我们经常用的foreach即是一种语法糖，实际上还是调用Enumerator里面的Current和MoveNext实现的遍历功能。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">string</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;test1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test3&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test4&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test5&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate the list by using foreach</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> buddy <span class="keyword">in</span> list)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(buddy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate the list by using enumerator</span></span><br><span class="line">List&lt;<span class="built_in">string</span>&gt;.Enumerator enumerator = list.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(enumerator.Current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach和enumerator到IL中最后都会被翻译成enumerator的MoveNext和Current。</p>
<p>IEnumerable支持foreach语句。</p>
<p>通过yield来实现返回enumerator:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestList</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>[] data = <span class="keyword">new</span> <span class="built_in">string</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;test1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test5&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> str <span class="keyword">in</span> data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testLists = <span class="keyword">new</span> TestList();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> str <span class="keyword">in</span> testLists)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ICollection-lt-T-gt-和-ICollection"><a href="#ICollection-lt-T-gt-和-ICollection" class="headerlink" title="ICollection&lt;T&gt;和 ICollection"></a><code>ICollection&lt;T&gt;</code>和 <code>ICollection</code></h3><p><code>ICollection</code> 接口是 <code>System.Collections</code> 命名空间中类的基接口，<code>ICollection&lt;T&gt;</code>是所有泛型版本集合的基接口。所有的的集合类都直接或间接的继承他们。</p>
<p><code>ICollection</code> 又继承 <code>IEnumerable</code>，来提供方便的枚举功能。<code>ICollection</code> 比 <code>IEnumerable</code> 多支持一些功能，不仅仅只提供基本的遍历功能，还包括：</p>
<ul>
<li>统计集合和元素个数</li>
<li>获取元素的下标</li>
<li>判断是否存在</li>
<li>添加元素到未尾</li>
<li>移除元素等等。</li>
</ul>
<p><code>ICollection</code> 与 <code>ICollection&lt;T&gt;</code> 略有不同，<code>ICollection</code> 不提供编辑集合的功能，即Add和Remove。包括检查元素是否存在Contains也不支持。</p>
<h3 id="IList和IList"><a href="#IList和IList" class="headerlink" title="IList和IList"></a>IList<T>和IList</h3><p><code>IList</code> 则是直接继承自 <code>ICollection</code> 和 <code>IEnumerable</code>。所以它包括两者的功能。</p>
<h2 id="选择集合"><a href="#选择集合" class="headerlink" title="选择集合"></a>选择集合</h2><p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181227105636.png" alt="微信截图_20181227105636.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181227110233.png" alt="微信截图_20181227110233.png"></p>
<p>详细请参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/collections/">https://docs.microsoft.com/zh-cn/dotnet/standard/collections/</a></p>
<p>注意非泛型类集合在.NET 2.0时代被泛型类集合代替。</p>
<h3 id="Dictionary-lt-TKey-TValue-gt"><a href="#Dictionary-lt-TKey-TValue-gt" class="headerlink" title="Dictionary&lt;TKey,TValue&gt;"></a>Dictionary&lt;TKey,TValue&gt;</h3><p>注解：将项存储为键/值对以通过键进行快速查找</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">非泛型集合选项：Hashtable（根据键的哈希代码组织的键/值对的集合。）</span><br><span class="line"></span><br><span class="line">线程安全或不可变集合选项：</span><br><span class="line">ConcurrentDictionary&lt;TKey,TValue&gt;</span><br><span class="line">ReadOnlyDictionary&lt;TKey,TValue&gt;</span><br><span class="line">ImmutableDictionary&lt;TKey,TValue&gt;</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List<T></h3><p>注解：按索引访问项</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">非泛型集合选项：</span><br><span class="line">Array</span><br><span class="line">ArrayList</span><br><span class="line"></span><br><span class="line">线程安全或不可变集合选项：</span><br><span class="line">ImmutableList&lt;T&gt;</span><br><span class="line">ImmutableArray</span><br></pre></td></tr></table></figure>

<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue<T></h3><p>注解：使用项先进先出 (FIFO)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">非泛型集合选项：Queue</span><br><span class="line"></span><br><span class="line">线程安全或不可变集合选项：</span><br><span class="line">ConcurrentQueue&lt;T&gt;</span><br><span class="line">ImmutableQueue&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack<T></h3><p>注解：使用数据后进先出 (LIFO)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">非泛型集合选项：Stack</span><br><span class="line"></span><br><span class="line">线程安全或不可变集合选项：</span><br><span class="line">ConcurrentStack&lt;T&gt;</span><br><span class="line">ImmutableStack&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList<T></h3><p>注解：按顺序访问项</p>
<h3 id="SortedList-lt-TKey-TValue-gt"><a href="#SortedList-lt-TKey-TValue-gt" class="headerlink" title="SortedList&lt;TKey,TValue&gt;"></a>SortedList&lt;TKey,TValue&gt;</h3><p>注解：已排序的集合</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">非泛型集合选项：SortedList</span><br><span class="line"></span><br><span class="line">线程安全或不可变集合选项：</span><br><span class="line">ImmutableSortedDictionary&lt;TKey,TValue&gt;</span><br><span class="line">ImmutableSortedSet&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h3 id="HashSet-和-SortedSet"><a href="#HashSet-和-SortedSet" class="headerlink" title="HashSet 和 SortedSet"></a>HashSet<T> 和 SortedSet<T></h3><p>注解：数学函数的一个集</p>
<p><code>HashSet&lt;T&gt;</code>类提供高性能的设置操作。 集是不包含重复元素的集合，其元素无特定顺序。<br><code>SortedSet&lt;T&gt;</code> 对象在插入和删除元素时维护排序顺序，而不会影响性能。 不允许重复元素。 不支持更改现有项的排序值，这可能导致意外行为。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程安全或不可变集合选项：</span><br><span class="line">ImmutableHashSet&lt;T&gt;</span><br><span class="line">ImmutableSortedSet&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ObservableCollection"><a href="#ObservableCollection" class="headerlink" title="ObservableCollection"></a>ObservableCollection<T></h3><p>注解：删除集合中的项或向集合添加项时接收通知。 （实现 INotifyPropertyChanged 和 INotifyCollectionChanged）</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jesse2013/p/CollectionsInCSharp.html">C#集合类型大盘点</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/collections/">https://docs.microsoft.com/zh-cn/dotnet/standard/collections/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/forcertain/archive/2013/04/23/3038214.html">.NET集合总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/26/CSharp%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/26/CSharp%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">CSharp基础-泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-26 09:56:02" itemprop="dateCreated datePublished" datetime="2018-12-26T09:56:02+00:00">2018-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">集合与泛型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;&emsp;C# 语言和公共语言运行时 (CLR) 的 2.0 版本中添加了泛型。 泛型将类型参数的概念引入 .NET Framework，这样就可以设计具有以下特征的类和方法：<font color=##ff0000 size=4 face="黑体">在客户端代码声明并初始化这些类和方法之前，这些类和方法会延迟指定一个或多个类型。</font> 例如，通过使用泛型类型参数 T，可以编写其他客户端代码能够使用的单个类，而不会产生运行时转换或装箱操作的成本或风险。</p>
<p><font color=##ff0000 size=4 face="黑体">泛型：为所存储或使用的一个或多个类型具有占位符（类型形参）的类、结构、接口和方法。</font> 泛型集合类可以将类型形参用作其存储的对象类型的占位符；类型形参呈现为其字段的类型和其方法的参数类型。 泛型方法可将其类型形参用作其返回值的类型或用作其形参之一的类型。</p>
<p>&emsp;&emsp;泛型类和泛型方法兼具可重用性、类型安全性和效率，这是非泛型类和非泛型方法无法实现的。 <font color=##ff0000 size=4 face="黑体">泛型通常与集合以及作用于集合的方法一起使用。通过创建泛型类，可在编译时创建类型安全的集合。</font></p>
<h2 id="泛型概述（优点）"><a href="#泛型概述（优点）" class="headerlink" title="泛型概述（优点）"></a>泛型概述（优点）</h2><ul>
<li>使用泛型类型可以最大限度地重用代码、保护类型安全性以及提高性能。</li>
<li>避免了装箱和拆箱操作。</li>
<li>编译时类型检查。</li>
<li>泛型最常见的用途是创建集合类。</li>
<li>.NET Framework 类库在 <code>System.Collections.Generic</code> 命名空间中包含几个新的泛型集合类。 应尽可能使用这些类来代替某些类，如 System.Collections 命名空间中的 ArrayList。</li>
<li>可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。</li>
<li>可以对泛型类进行约束以访问特定数据类型的方法。</li>
<li>在泛型数据类型中所用类型的信息可在运行时通过使用反射来获取。</li>
</ul>
<h2 id="泛型类型参数"><a href="#泛型类型参数" class="headerlink" title="泛型类型参数"></a>泛型类型参数</h2><p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/generics/index">.NET 中的泛型</a></p>
<p>从反射的角度来说，泛型类型和普通类型之间的区别在于泛型类型具有与之关联的一组类型形参（若是泛型类型定义）或类型实参（若是构造类型）。</p>
<p>例如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericList&lt;T&gt;; <span class="comment">// T 类型形参</span></span><br><span class="line"><span class="comment">// 若要使用 GenericList&lt;T&gt;，客户端代码必须通过指定尖括号内的类型参数来声明并实例化构造类型(构造泛型类型)。</span></span><br><span class="line">GenericList&lt;<span class="built_in">float</span>&gt; list1 = <span class="keyword">new</span> GenericList&lt;<span class="built_in">float</span>&gt;();  <span class="comment">// float 类型实参</span></span><br></pre></td></tr></table></figure>

<h2 id="类型参数的约束"><a href="#类型参数的约束" class="headerlink" title="类型参数的约束"></a>类型参数的约束</h2><p>&emsp;&emsp;约束告知编译器类型参数必须具备的功能。 在没有任何约束的情况下，类型参数可以是任何类型。 编译器只能假定 Object 的成员，它是任何 .NET 类型的最终基类。 如果客户端代码尝试使用约束所不允许的类型来实例化类，则会产生编译时错误。 <font color=#0099ff size=4 face="黑体">通过使用 where 上下文关键字指定约束。</font></p>
<p>下表列出了七种类型的约束：</p>
<table>
<thead>
<tr>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>where T : struct</td>
<td>类型参数必须是值类型。 可以指定除 Nullable<T> 以外的任何值类型。</td>
</tr>
<tr>
<td>where T : class</td>
<td>类型参数必须是引用类型。 此约束还应用于任何类、接口、委托或数组类型。</td>
</tr>
<tr>
<td>where T : unmanaged</td>
<td>类型参数不能是引用类型，并且任何嵌套级别均不能包含任何引用类型成员。</td>
</tr>
<tr>
<td>where T : new()</td>
<td>类型参数必须具有公共无参数构造函数。 与其他约束一起使用时，new() 约束必须最后指定。</td>
</tr>
<tr>
<td>where T : &lt;基类名&gt;</td>
<td>类型参数必须是指定的基类或派生自指定的基类。</td>
</tr>
<tr>
<td>where T : &lt;接口名称&gt;</td>
<td>类型参数必须是指定的接口或实现指定的接口。 可指定多个接口约束。 约束接口也可以是泛型。</td>
</tr>
<tr>
<td>where T : U</td>
<td>为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;通过约束类型参数，可以增加约束类型及其继承层次结构中的所有类型所支持的允许操作和方法调用的数量。 设计泛型类或方法时，如果要对泛型成员执行除简单赋值之外的任何操作或调用 <code>System.Object</code> 不支持的任何方法，则必须对该类型参数应用约束。 例如，基类约束告诉编译器，仅此类型的对象或派生自此类型的对象可用作类型参数。 编译器有了此保证后，就能够允许在泛型类中调用该类型的方法。</p>
<p>可以对同一类型参数应用多个约束，并且约束自身可以是泛型类型，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class EmployeeList&lt;T&gt; where T : Employee, IEmployee, System.IComparable&lt;T&gt;, new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>&emsp;&emsp;在应用 where T : class 约束时，请避免对类型参数使用 == 和 != 运算符，因为这些运算符仅测试引用标识而不测试值相等性。</p>
<h3 id="约束多个参数"><a href="#约束多个参数" class="headerlink" title="约束多个参数"></a>约束多个参数</h3><p>可以对多个参数应用多个约束，对一个参数应用多个约束，如下例所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Base</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">U</span> : <span class="title">struct</span></span><br><span class="line">    where T : Base, new()</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="未绑定的类型参数"><a href="#未绑定的类型参数" class="headerlink" title="未绑定的类型参数"></a>未绑定的类型参数</h3><p>没有约束的类型参数（如公共类 <code>SampleClass&lt;T&gt;&#123;&#125;</code> 中的 T）称为未绑定的类型参数。 未绑定的类型参数具有以下规则：</p>
<ul>
<li>不能使用 != 和 == 运算符，因为无法保证具体的类型参数能支持这些运算符。</li>
<li>可以在它们与 System.Object 之间来回转换，或将它们显式转换为任何接口类型。</li>
<li>可以将它们与 null 进行比较。 将未绑定的参数与 null 进行比较时，如果类型参数为值类型，则该比较将始终返回 false。</li>
</ul>
<h3 id="类型参数作为约束"><a href="#类型参数作为约束" class="headerlink" title="类型参数作为约束"></a>类型参数作为约束</h3><p>&emsp;&emsp;在具有自己类型参数的成员函数必须将该参数约束为包含类型的类型参数时，将泛型类型参数用作约束非常有用，如下例所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>&lt;<span class="title">U</span>&gt;(<span class="params">List&lt;U&gt; items</span>) <span class="keyword">where</span> U : T</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，T 在 Add 方法的上下文中是一个类型约束，而在 List 类的上下文中是一个未绑定的类型参数。</p>
<h3 id="非托管约束"><a href="#非托管约束" class="headerlink" title="非托管约束"></a>非托管约束</h3><p>从 C# 7.3 开始，可使用 unmanaged 约束来指定类型参数必须为“非托管类型”。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters#unmanaged-constraint">非托管约束</a></p>
<h3 id="委托约束"><a href="#委托约束" class="headerlink" title="委托约束"></a>委托约束</h3><p>&emsp;&emsp;同样从 C# 7.3 开始，可将 System.Delegate 或 System.MulticastDelegate 用作基类约束。 CLR 始终允许此约束，但 C# 语言不允许。 使用 System.Delegate 约束，用户能够以类型安全的方式编写使用委托的代码。以下代码定义了合并两个同类型委托的扩展方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TDelegate <span class="title">TypeSafeCombine</span>&lt;<span class="title">TDelegate</span>&gt;(<span class="params"><span class="keyword">this</span> TDelegate source, TDelegate target</span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">where</span> TDelegate : System.Delegate</span></span><br><span class="line"><span class="function"></span>    =&gt; Delegate.Combine(source, target) <span class="keyword">as</span> TDelegate;</span><br></pre></td></tr></table></figure>

<p>可使用上述方法来合并相同类型的委托：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Action first = () =&gt; Console.WriteLine(<span class="string">&quot;this&quot;</span>);</span><br><span class="line">Action second = () =&gt; Console.WriteLine(<span class="string">&quot;that&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> combined = first.TypeSafeCombine(second);</span><br><span class="line">combined();</span><br><span class="line"></span><br><span class="line">Func&lt;<span class="built_in">bool</span>&gt; test = () =&gt; <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// Combine signature ensures combined delegates must</span></span><br><span class="line"><span class="comment">// have the same type.</span></span><br><span class="line"><span class="comment">//var badCombined = first.TypeSafeCombine(test);</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举约束"><a href="#枚举约束" class="headerlink" title="枚举约束"></a>枚举约束</h3><p>从 C# 7.3 开始，还可指定 System.Enum 类型作为基类约束。 CLR 始终允许此约束，但 C# 语言不允许。 使用 System.Enum 的泛型提供类型安全的编程，缓存使用 System.Enum 中静态方法的结果。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters#enum-constraints">枚举约束</a></p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>封闭式构造类型 (<code>Node&lt;int&gt;</code>)：客户端代码指定类型参数；<br>创建开放式构造类型 (<code>Node&lt;T&gt;</code>)：不指定类型参数（例如指定泛型基类时）</p>
<p>泛型类可继承自具体的封闭式构造或开放式构造基类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BaseNode</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">BaseNodeGeneric</span>&lt;<span class="title">T</span>&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// concrete type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">NodeConcrete</span>&lt;<span class="title">T</span>&gt; : <span class="title">BaseNode</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//closed constructed type</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">NodeClosed</span>&lt;<span class="title">T</span>&gt; : <span class="title">BaseNodeGeneric</span>&lt;<span class="title">int</span>&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//open constructed type </span></span><br><span class="line"><span class="keyword">class</span> <span class="title">NodeOpen</span>&lt;<span class="title">T</span>&gt; : <span class="title">BaseNodeGeneric</span>&lt;<span class="title">T</span>&gt; &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>1,非泛型类（即，具体类）可继承自封闭式构造基类，但不可继承自开放式构造类或类型参数，因为运行时客户端代码无法提供实例化基类所需的类型参数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//No error</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Node1</span> : <span class="title">BaseNodeGeneric</span>&lt;<span class="title">int</span>&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Generates an error</span></span><br><span class="line"><span class="comment">//class Node2 : BaseNodeGeneric&lt;T&gt; &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Generates an error</span></span><br><span class="line"><span class="comment">//class Node3 : T &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>2,继承自开放式构造类型的泛型类必须对非此继承类共享的任何基类类型参数提供类型参数，如下方代码所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BaseNodeMultiple</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//No error</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Node4</span>&lt;<span class="title">T</span>&gt; : <span class="title">BaseNodeMultiple</span>&lt;<span class="title">T</span>, <span class="title">int</span>&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//No error</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Node5</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; : <span class="title">BaseNodeMultiple</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Generates an error</span></span><br><span class="line"><span class="comment">//class Node6&lt;T&gt; : BaseNodeMultiple&lt;T, U&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>3,继承自开放式构造类型的泛型类必须指定作为基类型上约束超集或表示这些约束的约束：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class NodeItem&lt;T&gt; where T : System.IComparable&lt;T&gt;, new() &#123; &#125;</span><br><span class="line">class SpecialNodeItem&lt;T&gt; : NodeItem&lt;T&gt; where T : System.IComparable&lt;T&gt;, new() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>4,泛型类型可使用多个类型参数和约束，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SuperKeyType</span>&lt;<span class="title">K</span>, <span class="title">V</span>, <span class="title">U</span>&gt;</span><br><span class="line">    <span class="keyword">where</span> <span class="title">U</span> : <span class="title">System.IComparable</span>&lt;<span class="title">U</span>&gt;</span><br><span class="line">    where V : new()</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>如果一个泛型类实现一个接口，则该类的所有实例均可强制转换为该接口。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generic-interfaces">泛型接口</a></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generic-methods">泛型方法</a></p>
<h2 id="泛型和数组"><a href="#泛型和数组" class="headerlink" title="泛型和数组"></a>泛型和数组</h2><p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generics-and-arrays">泛型和数组</a></p>
<h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/generic-delegates">泛型委托</a></p>
<p>委托可以定义它自己的类型参数。 引用泛型委托的代码可以指定类型参数以创建封闭式构造类型，就像实例化泛型类或调用泛型方法一样，如以下示例中所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Del</span>&lt;<span class="title">T</span>&gt;(<span class="params">T item</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">Del&lt;<span class="built_in">int</span>&gt; m1 = <span class="keyword">new</span> Del&lt;<span class="built_in">int</span>&gt;(Notify);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C# 2.0 版具有一种称为方法组转换的新功能，适用于具体委托类型和泛型委托类型,使你能够使用此简化语法编写上一行：</span></span><br><span class="line">Del&lt;<span class="built_in">int</span>&gt; m2 = Notify;</span><br></pre></td></tr></table></figure>

<p>在泛型类中定义的委托可以用类方法使用的相同方式来使用泛型类类型参数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    T[] items;</span><br><span class="line">    <span class="built_in">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">StackDelegate</span>(<span class="params">T[] items</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用委托的代码必须指定包含类的类型参数，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params"><span class="built_in">float</span>[] items</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TestStack</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="built_in">float</span>&gt; s = <span class="keyword">new</span> Stack&lt;<span class="built_in">float</span>&gt;();</span><br><span class="line">    Stack&lt;<span class="built_in">float</span>&gt;.StackDelegate d = DoWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据典型设计模式定义事件时，泛型委托特别有用，因为发件人参数可以为强类型，无需在它和 Object 之间强制转换。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">StackEventHandler</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">T sender, U eventArgs</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StackEventArgs</span> : <span class="title">System.EventArgs</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> StackEventHandler&lt;Stack&lt;T&gt;, StackEventArgs&gt; stackEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnStackChanged</span>(<span class="params">StackEventArgs a</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        stackEvent(<span class="keyword">this</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SampleClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HandleStackChange</span>&lt;<span class="title">T</span>&gt;(<span class="params">Stack&lt;T&gt; stack, Stack&lt;T&gt;.StackEventArgs args</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="built_in">double</span>&gt; s = <span class="keyword">new</span> Stack&lt;<span class="built_in">double</span>&gt;();</span><br><span class="line">    SampleClass o = <span class="keyword">new</span> SampleClass();</span><br><span class="line">    s.stackEvent += o.HandleStackChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/25/DotNet%E5%9F%BA%E7%A1%80-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/25/DotNet%E5%9F%BA%E7%A1%80-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%A1%8C/" class="post-title-link" itemprop="url">DotNet基础-并行编程之数据并行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-25 08:23:01" itemprop="dateCreated datePublished" datetime="2018-12-25T08:23:01+00:00">2018-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C/" itemprop="url" rel="index"><span itemprop="name">.net异步与并行</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>任务并行主要处理任务，而数据并行是要从直观上移除任务，用一种更高级的抽象–并行循环，来替代任务。也就是说，并行的源不是算法的代码，而是算法所操作的数据。</p>
<h2 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h2><h3 id="Parallel-For"><a href="#Parallel-For" class="headerlink" title="Parallel.For"></a>Parallel.For</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\n第&#123;0&#125;次比较&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">    ConcurrentBag&lt;<span class="built_in">int</span>&gt; bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> watch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">    watch.Start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bag.Add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;串行计算：集合有:&#123;0&#125;,总共耗时：&#123;1&#125;&quot;</span>, bag.Count, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    GC.Collect();</span><br><span class="line"></span><br><span class="line">    bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    watch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">    watch.Start();</span><br><span class="line"></span><br><span class="line">    Parallel.For(<span class="number">0</span>, <span class="number">20000000</span>, i =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        bag.Add(i);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;并行计算：集合有:&#123;0&#125;,总共耗时：&#123;1&#125;&quot;</span>, bag.Count, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较结果：<br><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181225092626.png" alt="微信截图_20181225092626.png"></p>
<p>注意：</p>
<ul>
<li>Parallel.For不支持浮点数的步进，使用的是Int32或Int64，每一次迭代的时候加1</li>
<li>使用Parallel.For所迭代的顺序是无法保证的</li>
</ul>
<h3 id="Parallel-ForEach"><a href="#Parallel-ForEach" class="headerlink" title="Parallel.ForEach"></a>Parallel.ForEach</h3><p>forEach的独到之处就是可以将数据进行分区，每一个小区内实现串行计算，分区采用Partitioner.Create实现。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\n第&#123;0&#125;次比较&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">    ConcurrentBag&lt;<span class="built_in">int</span>&gt; bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> watch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">    watch.Start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30000000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bag.Add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;串行计算：集合有:&#123;0&#125;,总共耗时：&#123;1&#125;&quot;</span>, bag.Count, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    GC.Collect();</span><br><span class="line"></span><br><span class="line">    bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    watch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">    watch.Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建分区的范围是0-3000000</span></span><br><span class="line">    <span class="comment">// Partitioner.Create(0, 3000000, Environment.ProcessorCount)</span></span><br><span class="line">    <span class="comment">//  Environment.ProcessorCount能够获取到当前的硬件线程数</span></span><br><span class="line">    Parallel.ForEach(Partitioner.Create(<span class="number">0</span>, <span class="number">30000000</span>), i =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> m = i.Item1; m &lt; i.Item2; m++)</span><br><span class="line">        &#123;</span><br><span class="line">            bag.Add(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;并行计算：集合有:&#123;0&#125;,总共耗时：&#123;1&#125;&quot;</span>, bag.Count, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181225093224.png" alt="微信截图_20181225093224.png"></p>
<h3 id="Parallel-Invoke"><a href="#Parallel-Invoke" class="headerlink" title="Parallel.Invoke"></a>Parallel.Invoke</h3><p>试图将很多方法并行运行，如果传入的是4个方法，则至少需要4个逻辑内核才能足以让这4个方法并发运行。</p>
<p>注意：</p>
<p>1.即使拥有4个逻辑内核，也不一定能够保证所需要运行的4个方法能够同时启动运行，如果其中的一个内核处于繁忙状态，那么底层的调度逻辑可能会延迟某些方法的初始化执行。</p>
<p>2.通过Parallel.Invoke编写的并发执行代码一定不能依赖与特定的执行顺序，因为它的并发执行顺序也是不定的。</p>
<p>3.使用Parallel.Invoke方法一定要测量运行结果、实现加速比以及逻辑内核的使用率，这点很重要。</p>
<p>4.使用Parallel.Invoke，在运行并行方法前都会产生一些额外的开销，如分配硬件线程等。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> watch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">    watch.Start();</span><br><span class="line"></span><br><span class="line">    Run1();</span><br><span class="line"></span><br><span class="line">    Run2();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是串行开发，总共耗时:&#123;0&#125;\n&quot;</span>, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    watch.Restart();</span><br><span class="line"></span><br><span class="line">    Parallel.Invoke(Run1, Run2);</span><br><span class="line"></span><br><span class="line">    watch.Stop();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是并行开发，总共耗时:&#123;0&#125;&quot;</span>, watch.ElapsedMilliseconds);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是任务一,我跑了3s&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是任务二，我跑了5s&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181225094750.png" alt="微信截图_20181225094750.png"></p>
<h3 id="中途退出并行循环"><a href="#中途退出并行循环" class="headerlink" title="中途退出并行循环"></a>中途退出并行循环</h3><p>ParallelLoopState，该实例提供了Break和Stop方法来帮我们实现。</p>
<p>Break: 通知并行计算尽快的退出循环，比如并行计算正在迭代100，那么break后程序还会迭代所有小于100的。</p>
<p>Stop：并行循环应该尽快停止执行，如果调用Stop时迭代100正在被处理，那么循环无法保证处理完所有小于100的迭代。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> watch = Stopwatch.StartNew();</span><br><span class="line"></span><br><span class="line">watch.Start();</span><br><span class="line"></span><br><span class="line">ConcurrentBag&lt;<span class="built_in">int</span>&gt; bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">20000000</span>, (i, state) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bag.Count == <span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        state.Break();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bag.Add(i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;当前集合有&#123;0&#125;个元素。&quot;</span>, bag.Count);</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181225100015.png" alt="微信截图_20181225100015.png"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Parallel.Invoke(Run1, Run2);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (AggregateException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> single <span class="keyword">in</span> ex.InnerExceptions)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(single.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;我是任务1抛出的异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;我是任务2抛出的异常&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181225100207.png" alt="微信截图_20181225100207.png"></p>
<h3 id="指定硬件线程数量"><a href="#指定硬件线程数量" class="headerlink" title="指定硬件线程数量"></a>指定硬件线程数量</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bag = <span class="keyword">new</span> ConcurrentBag&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">ParallelOptions options = <span class="keyword">new</span> ParallelOptions();</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定使用的硬件线程数为1</span></span><br><span class="line">options.MaxDegreeOfParallelism = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Parallel.For(<span class="number">0</span>, <span class="number">300000</span>, options, i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    bag.Add(i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;并行计算：集合有:&#123;0&#125;&quot;</span>, bag.Count);</span><br><span class="line"></span><br><span class="line">Console.Read();</span><br></pre></td></tr></table></figure>

<h2 id="并行Linq（PLINQ）"><a href="#并行Linq（PLINQ）" class="headerlink" title="并行Linq（PLINQ）"></a>并行Linq（PLINQ）</h2><p>通过 AsParallel() 扩展方法，将集合从普通的 IEnumerable<T> 改为ParallelQuery<T>。</p>
<p>PLINQ优于Parallel.ForEach的原因在于，PLINQ可以自动将执行查询的线程内部的临时处理结果聚合起来。</p>
<p>PLINQ使用3级处理管道来执行并行查询：</p>
<ul>
<li>1，首先，PLINQ决定需要多少线程来执行并行查询；</li>
<li>2，其次，工作站线程从源集合中获取工作块，确保在有锁的情况下访问该工作块。每个线程独立的执行其工作项，并将结果压入本地队列。</li>
<li>3，最终，所有本地结果会缓存到单个结果集合中。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = Enumerable.Range(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Opt in to PLINQ with AsParallel.</span></span><br><span class="line"><span class="keyword">var</span> evenNums = <span class="keyword">from</span> num <span class="keyword">in</span> source.AsParallel()</span><br><span class="line">               <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">               <span class="keyword">select</span> num;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; even numbers out of &#123;1&#125; total&quot;</span>,</span><br><span class="line">                  evenNums.Count(), source.Count());</span><br><span class="line"><span class="comment">// The example displays the following output:</span></span><br><span class="line"><span class="comment">//       5000 even numbers out of 10000 total</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/huangxincheng/archive/2012/04/02/2429543.html">8天玩转并行开发——第一天 Parallel的使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/woxpp/p/3925094.html">C#并行编程-Parallel</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/woxpp/p/3924476.html">C#并行编程-相关概念</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.parallel?view=netframework-4.7.2">https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.parallel?view=netframework-4.7.2</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq">https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/24/TaskCompletionSource%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/24/TaskCompletionSource%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">TaskCompletionSource使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-24 15:35:43" itemprop="dateCreated datePublished" datetime="2018-12-24T15:35:43+00:00">2018-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C/" itemprop="url" rel="index"><span itemprop="name">.net异步与并行</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在目标方法要调用基于事件API，又要返回Task的时候使用。</p>
<p>比如下面的ApiWrapper方法，该方法要返回Task<string>,又要调用EventClass对象的Do方法，并且等到Do方法触发Done事件后，Task才能得到结果并返回。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = ApiWrapper();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Test CurrentThread：&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(task.Result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">ApiWrapper</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> api = <span class="keyword">new</span> EventClass();</span><br><span class="line">    api.Done += (args) =&gt; &#123; tcs.TrySetResult(args); &#125;;</span><br><span class="line">    api.Do();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tcs.Task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;<span class="built_in">string</span>&gt; Done = (args) =&gt; &#123;; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;EventClass&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">        Done(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcompletionsource-1?view=netframework-4.7.2">TaskCompletionSource<TResult> Class</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/72340">什么时候应该使用TaskCompletionSource<T></a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/1zhk/p/5399538.html">TaskCompletionSource的使用场景</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/23/DotNet%E5%9F%BA%E7%A1%80-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/23/DotNet%E5%9F%BA%E7%A1%80-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">DotNet基础-异步编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-23 11:00:37" itemprop="dateCreated datePublished" datetime="2018-12-23T11:00:37+00:00">2018-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C/" itemprop="url" rel="index"><span itemprop="name">.net异步与并行</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>.NET Framework 1.0 引进了 IAsyncResult 模式，也称为 Asynchronous Programming Model (APM)或 Begin/End 模式。 .NET Framework 2.0 增加了 Event-based Asynchronous Pattern (EAP)。 从.NET Framework 4 开始， Task-based Asynchronous Pattern (TAP) 取代了 APM 和 EAP，但能够轻松构建从早期模式中迁移的例程。</p>
<p><font color=#0099ff size=4 face="黑体">APM异步编程模式下，callback是执行在另一个线程中，不能随易的去更新UI。EAP这种异步编程模式下，事件绑定的方法也是在调用的那个线程中执行的。也就是说解决了异步编程的时候UI交互的问题，而且是在同一个线程中执行。</font></p>
<p>APM,EAP模式请参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm">https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm</a></p>
<h2 id="异步编程准则"><a href="#异步编程准则" class="headerlink" title="异步编程准则"></a>异步编程准则</h2><p>异步编程的准则是确定所需执行的操作是I/O-Bound还是 CPU-Bound。因为这会极大影响代码性能，并可能导致某些构造的误用。</p>
<ul>
<li>如果代码会“等待”某些内容，例如数据库中的数据或web资源等,则你的工作是 I/O-Bound。</li>
<li>如果代码要执行开销巨大的计算，则你的工作是 CPU-Bound。</li>
</ul>
<p><font color=#0099ff size=4 face="黑体">如果你的工作为 I/O-Bound，请使用 async 和 await（而不使用 Task.Run）。 不应使用任务并行库。<br>如果你的工作为 CPU-Bound，并且你重视响应能力，请使用 async 和 await，并在另一个线程上使用 Task.Run 生成工作。 如果该工作同时适用于并发和并行，则应考虑使用任务并行库。</font></p>
<h2 id="基于任务的异步模式-TAP"><a href="#基于任务的异步模式-TAP" class="headerlink" title="基于任务的异步模式 (TAP)"></a>基于任务的异步模式 (TAP)</h2><p>基于任务的异步模式 (TAP) 以 <code>System.Threading.Tasks.Task</code> 命名空间中的 <code>System.Threading.Tasks.Task&lt;TResult&gt;</code> 和 <code>System.Threading.Tasks</code> 类型为基础，这些类型用于表示任意异步操作。 对于新的开发项目，建议采用 TAP 作为异步设计模式。</p>
<p>C# 5.0引入了2个新关键词：async和await。然而它大大简化了异步方法的编程。async和await关键字只是编译器功能。编译器会用Task类创建代码。</p>
<h3 id="认识async和await"><a href="#认识async和await" class="headerlink" title="认识async和await"></a>认识async和await</h3><p>使用async和await关键词编写异步代码，具有与同步代码相当的结构和简单性，并且摒弃了异步编程的复杂结构。</p>
<p>await 不会开启新的线程，当前线程会一直往下走直到遇到真正的Async方法（比如说HttpClient.GetStringAsync），这个方法的内部会用Task.Run或者Task.Factory.StartNew 去开启线程。如果方法不是.NET为我们提供的Async方法，我们需要自己创建Task，才会真正的去创建线程。</p>
<p>如果另一个线程已经执行完毕（即name.IsCompleted=true），主线程仍然不用挂起，直接可以拿结果。<br>如果另一个线程还没有执行完毕（即name.IsCompleted=false），那么主线程会挂起等待，直到返回结果为止。</p>
<h3 id="解析async和await"><a href="#解析async和await" class="headerlink" title="解析async和await"></a>解析async和await</h3><h4 id="异步（async）"><a href="#异步（async）" class="headerlink" title="异步（async）"></a>异步（async）</h4><p>使用async修饰符标记的方法称为异步方法，异步方法只可以具有以下返回类型：</p>
<ul>
<li>1.Task</li>
<li>2.<code>Task&lt;TResult&gt;</code></li>
<li>3.void</li>
<li>4.从C# 7.0开始，任何具有可访问的GetAwaiter方法的类型。System.Threading.Tasks.ValueTask<TResult> 类型属于此类实现（需向项目添加System.Threading.Tasks.Extensions NuGet 包）。</li>
</ul>
<p>&emsp;&emsp;异步方法通常包含 await 运算符的一个或多个实例，但缺少 await 表达式也不会导致生成编译器错误。 如果异步方法未使用 await 运算符标记暂停点，那么异步方法会作为同步方法执行，即使有 async 修饰符也不例外，编译器将为此类方法发布一个警告。</p>
<h4 id="等待（await）"><a href="#等待（await）" class="headerlink" title="等待（await）"></a>等待（await）</h4><p>await 表达式只能在由 async 修饰符标记的封闭方法体、lambda 表达式或异步方法中出现。在其他位置，它会解释为标识符。</p>
<p>使用await运算符的任务只可用于返回 <code>Task</code>、<code>Task&lt;TResult&gt;</code> 和 <code>System.Threading.Tasks.ValueType&lt;TResult&gt;</code> 对象的方法。</p>
<p><font color=#0099ff size=4 face="黑体">异步方法同步运行，直至到达其第一个 await 表达式，此时await在方法的执行中插入挂起点，会将方法挂起直到所等待的任务完成，然后继续执行await后面的代码区域。</font><br><font color=#ff0000 size=4 face="黑体">await 表达式并不阻止正在执行它的线程。 而是使编译器将剩下的异步方法注册为等待任务的延续任务。 控制权随后会返回给异步方法的调用方。 任务完成时，它会调用其延续任务，异步方法的执行会在暂停的位置处恢复。</font></p>
<p>注意：</p>
<ul>
<li><p>1.无法等待具有 void 返回类型的异步方法，并且无效返回方法的调用方捕获不到异步方法抛出的任何异常。</p>
</li>
<li><p>2.异步方法无法声明 in、ref 或 out 参数，但可以调用包含此类参数的方法。 同样，异步方法无法通过引用返回值，但可以调用包含 ref 返回值的方法。</p>
</li>
</ul>
<p><font color=#ff0000 size=4 face="黑体">await并不是针对于async的方法，而是针对async方法所返回给我们的Task。</font></p>
<h5 id="不用await关键字，确认Task执行完毕"><a href="#不用await关键字，确认Task执行完毕" class="headerlink" title="不用await关键字，确认Task执行完毕"></a>不用await关键字，确认Task执行完毕</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = Task.Run(() =&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> GetName();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    task.GetAwaiter().OnCompleted(() =&gt;&#123;</span><br><span class="line">        <span class="comment">// 2 秒之后才会执行这里</span></span><br><span class="line">        <span class="keyword">var</span> name = task.Result;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;My name is: &quot;</span> + name);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;另外一个线程在获取名称&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Task-GetAwaiter-和await-Task-的区别"><a href="#Task-GetAwaiter-和await-Task-的区别" class="headerlink" title="Task.GetAwaiter()和await Task 的区别"></a>Task.GetAwaiter()和await Task 的区别</h5><ul>
<li>加上await关键字之后，后面的代码会被挂起等待，直到task执行完毕有返回值的时候才会继续向下执行，这一段时间主线程会处于挂起状态。</li>
<li>GetAwaiter方法会返回一个awaitable的对象（继承了<code>INotifyCompletion.OnCompleted</code>方法）我们只是传递了一个委托进去，等task完成了就会执行这个委托，但是并不会影响主线程，下面的代码会立即执行。这也是为什么我们结果里面第一句话会是 “主线程执行完毕”！</li>
</ul>
<h5 id="Task如何让主线程挂起等待"><a href="#Task如何让主线程挂起等待" class="headerlink" title="Task如何让主线程挂起等待"></a>Task如何让主线程挂起等待</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> task = Task.Run(() =&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> GetName();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = task.GetAwaiter().GetResult();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;My name is:&#123;0&#125;&quot;</span>,name);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程执行完毕&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;另外一个线程在获取名称&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Task.GetAwait()</code>方法会给我们返回一个awaitable的对象，通过调用这个对象的<code>GetResult</code>方法就会挂起主线程，当然也不是所有的情况都会挂起。在一开始的时候就启动了另一个线程去执行这个Task，当我们调用它的结果的时候,如果这个Task已经执行完毕，主线程是不用等待可以直接拿其结果的，如果没有执行完毕那主线程就得挂起等待了。</p>
<h5 id="await的实质"><a href="#await的实质" class="headerlink" title="await的实质"></a>await的实质</h5><p>await的实质是在调用<code>awaitable</code>对象的<code>GetResult</code>方法</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt; task = Task.Run(() =&gt;&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;另一个线程在运行！&quot;</span>);  <span class="comment">// 这句话只会被执行一次</span></span><br><span class="line">        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里主线程会挂起等待，直到task执行完毕我们拿到返回结果</span></span><br><span class="line">    <span class="keyword">var</span> result = task.GetAwaiter().GetResult();</span><br><span class="line">    <span class="comment">// 这里不会挂起等待，因为task已经执行完了，我们可以直接拿到结果</span></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">await</span> task;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="async和await使用建议"><a href="#async和await使用建议" class="headerlink" title="async和await使用建议"></a>async和await使用建议</h4><ul>
<li>async方法需在其主体中具有await 关键字，否则它们将永不暂停。同时C# 编译器将生成一个警告，此代码将会以类似普通方法的方式进行编译和运行。 请注意这会导致效率低下，因为由 C# 编译器为异步方法生成的状态机将不会完成任何任务。</li>
<li>应将“Async”作为后缀添加到所编写的每个异步方法名称中。这是 .NET 中的惯例，以便更轻松区分同步和异步方法。</li>
<li>async void 应仅用于事件处理程序。因为事件不具有返回类型（因此无法返回 Task 和 Task<T>）。 其他任何对 async void 的使用都不遵循 TAP 模型，且可能存在一定使用难度。</li>
<li>避免上下文，调用ConfigureAwait并且传递false不要捕捉当前上下文。</li>
</ul>
<p>例如：async void 方法中引发的异常无法在该方法外部被捕获或十分难以测试 async void 方法。</p>
<h4 id="async和await总结"><a href="#async和await总结" class="headerlink" title="async和await总结"></a>async和await总结</h4><p>async/await 本质上只是一个语法糖，它并不产生线程，只是在编译时把语句的执行逻辑改了，相当于过去我们用callback，这里编译器自动实现了。</p>
<p>线程的转换是通过SynchronizationContext来实现，如果做了Task.ConfigureAwait(false)操作，运行MoveNext时就只是在线程池中拿个空闲线程出来执行；如果Task.ConfigureAwait(true)-(默认)，则会在异步操作前Capture当前线程的SynchronizationContext，异步操作之后运行MoveNext时通过SynchronizationContext转到目标之前的线程。</p>
<p>一般是想更新UI则需要用到 SynchronizationContext，如果异步操作完成还需要做大量运算，则可以考虑Task.ConfigureAwait(false)把计算放到后台算，防止UI卡死。</p>
<p>另外还有在异步操作前做的ExecutionContext.FastCapture，获取当前线程的执行上下文，注意，如果Task.ConfigureAwait(false)，会有个IgnoreSynctx的标记，表示在ExecutionContext.Capture里不做SynchronizationContext.Capture操作，Capture到的执行上下文用来在awaiter completed后给MoveNext用，使MoveNext可以有和前面线程同样的上下文。</p>
<p>通过SynchronizationContext.Post操作，可以使异步异常在最开始的try..catch块中轻松捕获。</p>
<h3 id="调用异步方法"><a href="#调用异步方法" class="headerlink" title="调用异步方法"></a>调用异步方法</h3><p>在一个异步方法里，可以调用一个或多个异步方法，如何编码取决于异步方法间结果是否相互依赖。</p>
<h4 id="1-顺序调用异步方法"><a href="#1-顺序调用异步方法" class="headerlink" title="1.顺序调用异步方法"></a>1.顺序调用异步方法</h4><p>使用await关键词可以调用每个异步方法，如果一个异步方法需要使用另一个异步方法的结果，await关键词就非常必要。</p>
<h4 id="2-使用组合器"><a href="#2-使用组合器" class="headerlink" title="2.使用组合器"></a>2.使用组合器</h4><p>如果异步方法间相互不依赖，则每个异步方法都不使用await，而是把每个异步方法的结果赋值给Task变量，就会运行得更快。</p>
<ul>
<li><p>WhenAll是在所有传入的任务都完成时才返回Task。</p>
</li>
<li><p>WhenAny是在传入的任务其中一个完成就会返回Task。</p>
</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="单个异步方法处理"><a href="#单个异步方法处理" class="headerlink" title="单个异步方法处理"></a>单个异步方法处理</h4><p>异步方法的一个较好异常处理方式，是使用await关键字，将其放在try/catch中。</p>
<p>返回void的异步方法不会等待。这是因为从async void方法抛出的异常无法捕获。因此异步方法最好返回一个Task类型。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步方法错误处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">HandleError</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> ThrowAfter(<span class="number">2000</span>, <span class="string">&quot;HandleError Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在延迟后抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">ThrowAfter</span>(<span class="params"><span class="built_in">int</span> ms, <span class="built_in">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(ms);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多个异步方法"><a href="#多个异步方法" class="headerlink" title="多个异步方法"></a>多个异步方法</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task.WhenAll，在catch块内可以访问，再使用IsFaulted属性检查任务的状态，</span></span><br><span class="line"><span class="comment">// 以确认它们是否出现错误，然后再进行处理。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">HandleError</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task t1 = <span class="literal">null</span>;</span><br><span class="line">    Task t2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        t1 = ThrowAfter(<span class="number">1000</span>, <span class="string">&quot;HandleError-One-Error&quot;</span>);</span><br><span class="line">        t2 = ThrowAfter(<span class="number">2000</span>, <span class="string">&quot;HandleError-Two-Error&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> Task.WhenAll(t1, t2);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1.IsFaulted)</span><br><span class="line">            Console.WriteLine(t1.Exception.InnerException.Message);</span><br><span class="line">        <span class="keyword">if</span> (t2.IsFaulted)</span><br><span class="line">            Console.WriteLine(t2.Exception.InnerException.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用AggregateException处理方式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">HandleError</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Task taskResult = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task t1 = ThrowAfter(<span class="number">1000</span>, <span class="string">&quot;HandleError-One-Error&quot;</span>);</span><br><span class="line">        Task t2 = ThrowAfter(<span class="number">2000</span>, <span class="string">&quot;HandleError-Two-Error&quot;</span>);</span><br><span class="line">        <span class="keyword">await</span> (taskResult = Task.WhenAll(t1, t2));</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> ex <span class="keyword">in</span> taskResult.Exception.InnerExceptions)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在延迟后抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">ThrowAfter</span>(<span class="params"><span class="built_in">int</span> ms, <span class="built_in">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(ms);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jesse2013/p/Asynchronous-Programming-In-DotNet.html">异步编程 In .NET</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CrabMan/p/5436083.html">async/await IL翻译</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/jesse2013/p/async-and-await.html">async &amp; await 的前世今生（Updated）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jonins/p/9558275.html">异步编程（async&amp;await）</a></p>
<p><a target="_blank" rel="noopener" href="http://www.xyting.org/2017/02/28/understand-async-await-in-depth.html">深入理解Async/Await</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.51cto.com/cnn237111/1103029">async 和 await 关键字</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/1zhk/p/5269279.html">使用Nito.AsyncEx实现异步锁</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/">使用 Async 和 Await 的异步编程 (C#)</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/async">https://docs.microsoft.com/zh-cn/dotnet/csharp/async</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm">https://docs.microsoft.com/zh-cn/dotnet/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/22/DotNet%E5%9F%BA%E7%A1%80-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8BTask/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/22/DotNet%E5%9F%BA%E7%A1%80-%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E4%B9%8BTask/" class="post-title-link" itemprop="url">DotNet基础-并行编程之Task</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-22 13:52:20" itemprop="dateCreated datePublished" datetime="2018-12-22T13:52:20+00:00">2018-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C/" itemprop="url" rel="index"><span itemprop="name">.net异步与并行</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&emsp;&emsp;在.NET 4中的并行编程是依赖Task Parallel Library(后面简称为TPL) 实现的。在TPL中，最基本的执行单元是task(中文可以理解为”任务”),一个task就代表了你要执行的一个操作。你可以为你所要执行的每一个操作定义一个task,TPL就负责创建线程来执行你所定义的task，并且管理线程。TPL是面向task的，自动的；而传统的多线程是以人工为导向的。</p>
<p>&emsp;&emsp;Task机制使得我们把注意力关注在我们要解决的问题上面。如果之前的多线程技术使得我们放弃了一些并行编程的使用，那么.NET 4中的新的并行编程技术可以让我们重新建立信心。虽然有了新的并行技术，但是传统的多线程的技术还是很有用的。任务并行（TPL）是一种范式，也是一组API，可以将大任务分割为多个小任务，并在多个线程中执行。当我们使用TPL中的并行技术的时候来执行多个task的时候，我们不用在关心底层创建线程，管理线程等。</p>
<h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><p>多核处理器带有一个以上的物理内核，每个物理内核都可能会提供多个硬件线程，也称之为逻辑内核或者逻辑处理器。</p>
<p>Windows将每一个硬件线程识别为一个可调度的逻辑处理器，每一个逻辑处理器可以运行软件线程代码，运行多个软件线程的进程可以充分发挥硬件线程和物理内核的优势，并行地运行指令。Windows会给每一个可用的硬件线程分配一块块的处理时间，并通过这种方式运行上百个千个软件线程。</p>
<h3 id="硬件线程"><a href="#硬件线程" class="headerlink" title="硬件线程"></a>硬件线程</h3><p>物理内核：计算机实际内核数量；<br>硬件线程又叫做逻辑内核，可以在”任务管理器“中查看”性能“标签页</p>
<p>一般情况下，一个物理内核对应一个逻辑内核。当然如果你的cpu采用的是超线程技术，那么可能就会有4个物理内核对应。</p>
<h3 id="软件线程"><a href="#软件线程" class="headerlink" title="软件线程"></a>软件线程</h3><p>传统的代码都是串行的，就一个主线程，当我们为了实现加速而开了很多工作线程，这些工作线程也就是软件线程。</p>
<h2 id="Task的基本使用"><a href="#Task的基本使用" class="headerlink" title="Task的基本使用"></a>Task的基本使用</h2><h3 id="创建任务Task"><a href="#创建任务Task" class="headerlink" title="创建任务Task"></a>创建任务Task</h3><p>开启task有两种方式:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一种方式开启</span></span><br><span class="line">    <span class="keyword">var</span> task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Run1();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式开启</span></span><br><span class="line">    <span class="keyword">var</span> task2 = Task.Factory.StartNew(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Run2();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用start之前****************************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用start之前的“任务状态”</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;task1的状态:&#123;0&#125;&quot;</span>, task1.Status);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;task2的状态:&#123;0&#125;&quot;</span>, task2.Status);</span><br><span class="line"></span><br><span class="line">    task1.Start();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\n调用start之后****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用start之前的“任务状态”</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\ntask1的状态:&#123;0&#125;&quot;</span>, task1.Status);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;task2的状态:&#123;0&#125;&quot;</span>, task2.Status);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程等待任务执行完</span></span><br><span class="line">    Task.WaitAll(task1, task2);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\n任务执行完后的状态****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用start之前的“任务状态”</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\ntask1的状态:&#123;0&#125;&quot;</span>, task1.Status);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;task2的状态:&#123;0&#125;&quot;</span>, task2.Status);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\n我是任务1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我是任务2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** Task.Run 和 Task.Factory.StartNew 区别**</p>
<p>&emsp;&emsp;可以认为 <code>Task.Run</code> 是简化的 <code>Task.Factory.StartNew</code> 的使用，除了需要指定一个线程是长时间占用的，否则就使用 <code>Task.Run</code>； <code>Task.Factory.StartNew</code> 可以设置线程是长时间运行，这时线程池就不会等待这个线程回收。</p>
<h3 id="为创建的Task传入参数"><a href="#为创建的Task传入参数" class="headerlink" title="为创建的Task传入参数"></a>为创建的Task传入参数</h3><p>想向 <code>Task</code> 传入参数，只能用<code>System.Action&lt;object&gt;</code>;</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span>[] messages = &#123; <span class="string">&quot;First task&quot;</span>, <span class="string">&quot;Second task&quot;</span>, <span class="string">&quot;Third task&quot;</span>, <span class="string">&quot;Fourth task&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> msg <span class="keyword">in</span> messages)</span><br><span class="line">    &#123;</span><br><span class="line">        Task myTask = <span class="keyword">new</span> Task(obj =&gt; printMessage((<span class="built_in">string</span>)obj), msg);</span><br><span class="line">        myTask.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建Task的时候，Task有很多的构造函数的重载，一个主要的重载就是传入TaskCreateOptions的枚举：</p>
<ul>
<li>TaskCreateOptions.None:用默认的方式创建一个Task</li>
<li>TaskCreateOptions.PreferFairness:请求scheduler尽量公平的执行Task(Task和线程一样，有优先级的)</li>
<li>TaskCreateOptions.LongRunning:声明Task将会长时间的运行。</li>
<li>TaskCreateOptions.AttachToParent:因为Task是可以嵌套的，所以这个枚举就是把一个子task附加到一个父task中。</li>
</ul>
<p>&emsp;&emsp;最后要提到的一点就是，我们可以在Task的执行体中用Task.CurrentId来返回Task的唯一表示ID(int)。如果在Task执行体外使用这个属性就会得到null。</p>
<h3 id="Task执行"><a href="#Task执行" class="headerlink" title="Task执行"></a>Task执行</h3><h4 id="等待Task执行完成"><a href="#等待Task执行完成" class="headerlink" title="等待Task执行完成"></a>等待Task执行完成</h4><p>用Wait()方法来一直等待一个Task执行完成。当task执行完成，或者被cancel，或者抛出异常，这个方法才会返回。可以使用Wait()方法的不同重载。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Task task = createTask(token);</span><br><span class="line">task.Start();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Waiting for task to complete.&quot;</span>);</span><br><span class="line">task.Wait();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Task Completed.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create and start another task</span></span><br><span class="line">task = createTask(token);</span><br><span class="line">task.Start();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Waiting 2 secs for task to complete.&quot;</span>);</span><br><span class="line"><span class="built_in">bool</span> completed = task.Wait(<span class="number">6000</span>);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Wait ended - task completed: &#123;0&#125;&quot;</span>, completed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create and start another task</span></span><br><span class="line">task = createTask(token);</span><br><span class="line">task.Start();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Waiting 2 secs for task to complete.&quot;</span>);</span><br><span class="line">completed = task.Wait(<span class="number">2000</span>, token);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Wait ended - task completed: &#123;0&#125; task cancelled &#123;1&#125;&quot;</span>,</span><br><span class="line">completed, task.IsCanceled);</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">wait方法子task执行完成之后会返回true。</font></p>
<h4 id="等待多个task"><a href="#等待多个task" class="headerlink" title="等待多个task"></a>等待多个task</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Task.WaitAll(task1, task2);</span><br></pre></td></tr></table></figure>

<h4 id="等待多个task中的一个task执行完成"><a href="#等待多个task中的一个task执行完成" class="headerlink" title="等待多个task中的一个task执行完成"></a>等待多个task中的一个task执行完成</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> taskIndex = Task.WaitAny(task1, task2);</span><br></pre></td></tr></table></figure>

<h3 id="懒加载的Task-Lazily-Task"><a href="#懒加载的Task-Lazily-Task" class="headerlink" title="懒加载的Task(Lazily Task)"></a>懒加载的Task(Lazily Task)</h3><p>延迟初始化，主要的好处就是避免不必要的系统开销。</p>
<p>Lazy变量只有在用到的时候才会被初始化。所以我们可以把Lazy变量和task的创建结合：只有这个task要被执行的时候才去初始化。现在如果用了Lazy的task，那么现在我们初始化的就是那个Lazy变量了，而没有初始化task，(初始化Lazy变量的开销小于初始化task)，只有当调用了lazyData.Value时，Lazy变量中包含的那个task才会初始化。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// define the function</span></span><br><span class="line">    Func&lt;<span class="built_in">string</span>&gt; taskBody = <span class="keyword">new</span> Func&lt;<span class="built_in">string</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Task body working...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Task Result&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the lazy variable</span></span><br><span class="line">    Lazy&lt;Task&lt;<span class="built_in">string</span>&gt;&gt; lazyData = <span class="keyword">new</span> Lazy&lt;Task&lt;<span class="built_in">string</span>&gt;&gt;(() =&gt;</span><br><span class="line">    Task&lt;<span class="built_in">string</span>&gt;.Factory.StartNew(taskBody));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Calling lazy variable&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Result from task: &#123;0&#125;&quot;</span>, lazyData.Value.Result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do the same thing in a single statement</span></span><br><span class="line">    Lazy&lt;Task&lt;<span class="built_in">string</span>&gt;&gt; lazyData2 = <span class="keyword">new</span> Lazy&lt;Task&lt;<span class="built_in">string</span>&gt;&gt;(</span><br><span class="line">    () =&gt; Task&lt;<span class="built_in">string</span>&gt;.Factory.StartNew(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Task body working...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Task Result&quot;</span>;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Calling second lazy variable&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Result from task: &#123;0&#125;&quot;</span>, lazyData2.Value.Result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Task-死锁"><a href="#Task-死锁" class="headerlink" title="Task 死锁"></a>Task 死锁</h3><p>描述：如果有两个或者多个task(简称TaskA)等待其他的task（TaskB）执行完成才开始执行，但是TaskB也在等待TaskA执行完成才开始执行，这样死锁就产生了。</p>
<p>解决方案：避免这个问题最好的方法就是：不要使的task来依赖其他的task。也就是说，最好不要在你定义的task的执行体内包含其他的task。</p>
<h3 id="Task异常处理"><a href="#Task异常处理" class="headerlink" title="Task异常处理"></a>Task异常处理</h3><p>在执行 <code>Task.Wait()</code>,<code>Task.WaitAll()</code>,<code>Task.WaitAny()</code>,<code>Task.Result</code>.不管那里出现了异常，最后抛出的就是一个 <code>System.AggregateException</code>。</p>
<h4 id="处理基本的异常"><a href="#处理基本的异常" class="headerlink" title="处理基本的异常"></a>处理基本的异常</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create the tasks</span></span><br><span class="line">Task task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ArgumentOutOfRangeException exception = <span class="keyword">new</span> ArgumentOutOfRangeException();</span><br><span class="line">    exception.Source = <span class="string">&quot;task1&quot;</span>;</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line">&#125;);</span><br><span class="line">Task task2 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullReferenceException();</span><br><span class="line">&#125;);</span><br><span class="line">Task task3 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello from Task 3&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// start the tasks</span></span><br><span class="line">task1.Start(); task2.Start(); task3.Start();</span><br><span class="line"><span class="comment">// wait for all of the tasks to complete</span></span><br><span class="line"><span class="comment">// and wrap the method in a try...catch block</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Task.WaitAll(task1, task2, task3);</span><br><span class="line">&#125;</span><br><span class="line">catch (AggregateException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// enumerate the exceptions that have been aggregated</span></span><br><span class="line">    <span class="keyword">foreach</span> (Exception inner <span class="keyword">in</span> ex.InnerExceptions)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Exception type &#123;0&#125; from &#123;1&#125;&quot;</span>,</span><br><span class="line">        inner.GetType(), inner.Source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait for input before exiting</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h4 id="使用迭代的异常处理Handler"><a href="#使用迭代的异常处理Handler" class="headerlink" title="使用迭代的异常处理Handler"></a>使用迭代的异常处理Handler</h4><p>一般情况下，我们需要区分哪些异常需要处理，而哪些异常需要继续往上传递。<code>AggregateException</code>类提供了一个<code>Handle()</code>方法，我们可以用这个方法来处理</p>
<p>AggregateException中的每一个异常。在这个 <code>Handle()</code> 方法中，返回true就表明，这个异常我们已经处理了，不用抛出，反之。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create the cancellation token source and the token</span></span><br><span class="line">CancellationTokenSource tokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">CancellationToken token = tokenSource.Token;</span><br><span class="line"><span class="comment">// create a task that waits on the cancellation token</span></span><br><span class="line">Task task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// wait forever or until the token is cancelled</span></span><br><span class="line">    token.WaitHandle.WaitOne(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// throw an exception to acknowledge the cancellation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> OperationCanceledException(token);</span><br><span class="line">&#125;, token);</span><br><span class="line"><span class="comment">// create a task that throws an exception</span></span><br><span class="line">Task task2 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullReferenceException();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// start the tasks</span></span><br><span class="line">task1.Start(); task2.Start();</span><br><span class="line"><span class="comment">// cancel the token</span></span><br><span class="line">tokenSource.Cancel();</span><br><span class="line"><span class="comment">// wait on the tasks and catch any exceptions</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Task.WaitAll(task1, task2);</span><br><span class="line">&#125;</span><br><span class="line">catch (AggregateException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// iterate through the inner exceptions using</span></span><br><span class="line">    <span class="comment">// the handle method</span></span><br><span class="line">    ex.Handle((inner) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inner <span class="keyword">is</span> OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...handle task cancellation...</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// this is an exception we don&#x27;t know how</span></span><br><span class="line">            <span class="comment">// to handle, so return false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// wait for input before exiting</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>

<h3 id="获取Task的执行结果"><a href="#获取Task的执行结果" class="headerlink" title="获取Task的执行结果"></a>获取Task的执行结果</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the task</span></span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task1 = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    task1.Start();</span><br><span class="line">    <span class="comment">// write out the result</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Result 1: &#123;0&#125;&quot;</span>, task1.Result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the task</span></span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task2 = Task.Factory.StartNew&lt;<span class="built_in">int</span>&gt;(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write out the result</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Result 1: &#123;0&#125;&quot;</span>, task2.Result);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Task的状态"><a href="#获取Task的状态" class="headerlink" title="获取Task的状态"></a>获取Task的状态</h3><p>在.NET并行编程还有一个已经标准化的操作就是可以获取task的状态，通过 <code>Task.Status</code> 属性来得到的，这个属性返回一个 <code>System.Threading.Tasks.TaskStatus</code> 的枚举值。</p>
<p>如下：</p>
<ul>
<li>Created:表明task已经被初始化了，但是还没有加入到Scheduler中。</li>
<li>WatingForActivation：task正在等待被加入到Scheduler中。</li>
<li>WaitingToRun:已经被加入到了Scheduler，等待执行。</li>
<li>Running：task正在运行</li>
<li>WaitingForChildrenToComplete:表明父task正在等待子task运行结束。</li>
<li>RanToCompletion:表明task已经执行完了，但是还没有被cancel，而且也这个task也没有抛出异常。</li>
<li>Canceled:表明task已经被cancel了。（大家可以参看之前讲述取消task的文章）</li>
<li>Faulted:表明task在运行的时候已经抛出了异常。</li>
</ul>
<h3 id="取消任务（Task）"><a href="#取消任务（Task）" class="headerlink" title="取消任务（Task）"></a>取消任务（Task）</h3><h4 id="通过轮询的方式检测Task是否被取消"><a href="#通过轮询的方式检测Task是否被取消" class="headerlink" title="通过轮询的方式检测Task是否被取消"></a>通过轮询的方式检测Task是否被取消</h4><p>&emsp;&emsp;在很多Task内部都包含了循环，用来处理数据。我们可以在循环中通过 <code>CancellationToken</code> 的<code>IsCancellationRequest</code> 属性来检测task是否被取消了。如果这个属性为true，那么我们就得跳出循环，并且释放task所占用的资源(如数据库资源，文件资源等)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the cancellation token source</span></span><br><span class="line">    CancellationTokenSource tokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the cancellation token</span></span><br><span class="line">    CancellationToken token = tokenSource.Token;</span><br><span class="line">    <span class="comment">// create the task</span></span><br><span class="line"></span><br><span class="line">    Task task = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>.MaxValue; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Task cancel detected&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OperationCanceledException(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Int value &#123;0&#125;&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before we start the task</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter to start task&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter again to cancel task&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the task</span></span><br><span class="line">    task.Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a line from the console.</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cancel the task</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Cancelling task&quot;</span>);</span><br><span class="line">    tokenSource.Cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用委托delegate来检测Task是否被取消"><a href="#用委托delegate来检测Task是否被取消" class="headerlink" title="用委托delegate来检测Task是否被取消"></a>用委托delegate来检测Task是否被取消</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the cancellation token source</span></span><br><span class="line">    CancellationTokenSource tokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the cancellation token</span></span><br><span class="line">    CancellationToken token = tokenSource.Token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the task</span></span><br><span class="line">    Task task = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>.MaxValue; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Task cancel detected&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OperationCanceledException(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Int value &#123;0&#125;&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register a cancellation delegate</span></span><br><span class="line">    token.Register(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; Delegate Invoked\n&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before we start the task</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter to start task&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter again to cancel task&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the task</span></span><br><span class="line">    task.Start();</span><br><span class="line">    <span class="comment">// read a line from the console.</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cancel the task</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Cancelling task&quot;</span>);</span><br><span class="line">    tokenSource.Cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用Wait-Handle还检测Task是否被取消"><a href="#用Wait-Handle还检测Task是否被取消" class="headerlink" title="用Wait Handle还检测Task是否被取消"></a>用Wait Handle还检测Task是否被取消</h4><p>&emsp;&emsp;检测task是否被cancel就是调用CancellationToken.WaitHandle属性。对于这个属性的详细使用，在后续的文章中会深入的讲述，在这里主要知道一点就行了：CancellationToken的WaitOne()方法会阻止task的运行，只有CancellationToken的cancel()方法被调用后，这种阻止才会释放。</p>
<p>&emsp;&emsp;在下面的例子中，创建了两个task，其中task2调用了WaitOne()方法，所以task2一直不会运行，除非调用了CancellationToken的Cancel()方法，所以WaitOne()方法也算是检测task是否被cancel的一种方法了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the cancellation token source</span></span><br><span class="line">    CancellationTokenSource tokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the cancellation token</span></span><br><span class="line">    CancellationToken token = tokenSource.Token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the task</span></span><br><span class="line">    Task task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>.MaxValue; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Task cancel detected&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OperationCanceledException(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Int value &#123;0&#125;&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a second task that will use the wait handle</span></span><br><span class="line">    Task task2 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// wait on the handle</span></span><br><span class="line">        token.WaitHandle.WaitOne();</span><br><span class="line">        <span class="comment">// write out a message</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Wait handle released&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before we start the task</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter to start task&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter again to cancel task&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    <span class="comment">// start the tasks</span></span><br><span class="line">    task1.Start();</span><br><span class="line">    task2.Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a line from the console.</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cancel the task</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Cancelling task&quot;</span>);</span><br><span class="line">    tokenSource.Cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取消多个Task"><a href="#取消多个Task" class="headerlink" title="取消多个Task"></a>取消多个Task</h4><p>&emsp;&emsp;我们可以使用一个CancellationToken来创建多个不同的Tasks，当这个CancellationToken的Cancel()方法调用的时候，使用了这个token的多个task都会被取消。</p>
<h4 id="创建组合的取消Task的Token"><a href="#创建组合的取消Task的Token" class="headerlink" title="创建组合的取消Task的Token"></a>创建组合的取消Task的Token</h4><p>&emsp;&emsp;我们可以用CancellationTokenSource.CreateLinkedTokenSource()方法来创建一个组合的token，这个组合的token有很多的CancellationToken组成。主要组合token中的任意一个token调用了Cancel()方法，那么使用这个组合token的所有task就会被取消。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the cancellation token sources</span></span><br><span class="line">    CancellationTokenSource tokenSource1 = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    CancellationTokenSource tokenSource2 = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">    CancellationTokenSource tokenSource3 = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a composite token source using multiple tokens</span></span><br><span class="line">    CancellationTokenSource compositeSource =</span><br><span class="line">        CancellationTokenSource.CreateLinkedTokenSource(</span><br><span class="line">    tokenSource1.Token, tokenSource2.Token, tokenSource3.Token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a cancellable task using the composite token</span></span><br><span class="line">    Task task = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// wait until the token has been cancelled</span></span><br><span class="line">        compositeSource.Token.WaitHandle.WaitOne();</span><br><span class="line">        <span class="comment">// throw a cancellation exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OperationCanceledException(compositeSource.Token);</span><br><span class="line">    &#125;, compositeSource.Token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the task</span></span><br><span class="line">    task.Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cancel one of the original tokens</span></span><br><span class="line">    tokenSource2.Cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断一个Task是否已经被取消了"><a href="#判断一个Task是否已经被取消了" class="headerlink" title="判断一个Task是否已经被取消了"></a>判断一个Task是否已经被取消了</h4><p>可以使用Task的IsCancelled属性来判断task是否被取消了。</p>
<h3 id="Task的休眠"><a href="#Task的休眠" class="headerlink" title="Task的休眠"></a>Task的休眠</h3><h4 id="使用CancellationToken的Wait-Handle"><a href="#使用CancellationToken的Wait-Handle" class="headerlink" title="使用CancellationToken的Wait Handle"></a>使用CancellationToken的Wait Handle</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the cancellation token source</span></span><br><span class="line">    CancellationTokenSource tokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the cancellation token</span></span><br><span class="line">    CancellationToken token = tokenSource.Token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the first task, which we will let run fully</span></span><br><span class="line">    Task task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Int32.MaxValue; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// put the task to sleep for 10 seconds</span></span><br><span class="line">            <span class="built_in">bool</span> cancelled = token.WaitHandle.WaitOne(<span class="number">10000</span>);</span><br><span class="line">            <span class="comment">// print out a message</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Task 1 - Int value &#123;0&#125;. Cancelled? &#123;1&#125;&quot;</span>,</span><br><span class="line">            i, cancelled);</span><br><span class="line">            <span class="comment">// check to see if we have been cancelled</span></span><br><span class="line">            <span class="keyword">if</span> (cancelled)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OperationCanceledException(token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, token);</span><br><span class="line">    <span class="comment">// start task</span></span><br><span class="line">    task1.Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter to cancel token.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cancel the token</span></span><br><span class="line">    tokenSource.Cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有一点要注意：WaitOne()方法只有在设定的时间间隔到了，或者Cancel方法被调用，此时task才会被唤醒。如果如果cancel()方法被调用而导致task被唤醒，那么CancellationToken.WaitHandle.WaitOne()方法就会返回true，如果是因为设定的时间到了而导致task唤醒，那么CancellationToken.WaitHandle.WaitOne()方法返回false。</p>
<h4 id="Task-Delay"><a href="#Task-Delay" class="headerlink" title="Task.Delay"></a>Task.Delay</h4><p>Task.Delay在不阻塞当前线程的情况下使用逻辑延迟时使用。Task.Delay旨在异步运行。</p>
<h4 id="使用传统的Sleep"><a href="#使用传统的Sleep" class="headerlink" title="使用传统的Sleep"></a>使用传统的Sleep</h4><p>Thread.Sleep时要阻止当前线程。</p>
<p>注意：Thread.Sleep在同步代码中使用，不能在异步代码中使用；</p>
<p><code>Thread.Sleep(10000);</code></p>
<p>&emsp;&emsp;使用Thread.Sleep()之后，然后再调用token的cancel方法，task不会立即就被cancel，这主要是因为Thread.Sleep()将会一直阻塞线程，直到达到了设定的时间，这之后，再去check task时候被cancel了。举个例子，假设再task方法体内调用Thread.Sleep(100000)方法来休眠task，然后再后面的代码中调用token.Cancel()方法，此时处于并行编程内部机制不会去检测task是否已经发出了cancel请求，而是一直休眠，直到时间超过了100000微秒。如果采用的是之前的第一种休眠方法，那么不管WaitOne（）中设置了多长的时间，只要token.Cancel()被调用，那么task就像内部的Scheduler发出了cancel的请求，而且task会被cancel。</p>
<h4 id="自旋等待"><a href="#自旋等待" class="headerlink" title="自旋等待"></a>自旋等待</h4><p>推荐的方法。</p>
<p>之前的两种方法，当他们使得task休眠的时候，这些task已经从Scheduler的管理中退出来了，不被再内部的Scheduler管理(Scheduler是负责管理线程的)，因为休眠的task已经不被Scheduler管理了，所以Scheduler必须做一些工作去决定下一步是哪个线程要运行，并且启动它。为了避免Scheduler做那些工作，我们可以采用自旋等待：此时这个休眠的task所对应的线程不会从Scheduler中退出，这个task会把自己和CPU的轮转关联起来。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// create the cancellation token source</span></span><br><span class="line">    CancellationTokenSource tokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the cancellation token</span></span><br><span class="line">    CancellationToken token = tokenSource.Token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the first task, which we will let run fully</span></span><br><span class="line">    Task task1 = <span class="keyword">new</span> Task(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; Int32.MaxValue; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// put the task to sleep for 10 seconds</span></span><br><span class="line">            Thread.SpinWait(<span class="number">10000</span>);</span><br><span class="line">            <span class="comment">// print out a message</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Task 1 - Int value &#123;0&#125;&quot;</span>, i);</span><br><span class="line">            <span class="comment">// check for task cancellation</span></span><br><span class="line">            token.ThrowIfCancellationRequested();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start task</span></span><br><span class="line">    task1.Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Press enter to cancel token.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    <span class="comment">// cancel the token</span></span><br><span class="line">    tokenSource.Cancel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for input before exiting</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Main method complete. Press enter to finish.&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;代码中我们在Thread.SpinWait()方法中传入一个整数，这个整数就表示CPU时间片轮转的次数，至于要等待多长的时间，这个就和计算机有关了，不同的计算机，CPU的轮转时间不一样。自旋等待的方法常常于获得同步锁，后续会讲解。使用自旋等待会一直占用CPU，而且也会消耗CPU的资源，更大的问题就是这个方法会影响Scheduler的运作。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanyangtian/category/246954.html">.NET 4 并行(多核)编程系列</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangxincheng/archive/2012/04/03/2430638.html">8天玩转并行开发——第二天 Task的使用</a></p>
<p><a target="_blank" rel="noopener" href="https://lindexi.github.io/lindexi/post/C-Task.Run-%E5%92%8C-Task.Factory.StartNew-%E5%8C%BA%E5%88%AB.html">C# Task.Run 和 Task.Factory.StartNew 区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9008-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9008-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">DotNet面试题解析08-多线程与线程同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-20 16:29:55" itemprop="dateCreated datePublished" datetime="2018-12-20T16:29:55+00:00">2018-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>我们运行一个exe，就是一个进程实例，系统中有很多个进程。每一个进程都有自己的内存地址空间，每个进程相当于一个独立的边界，有自己的独占的资源，进程之间不能共享代码和数据空间。</p>
<p><img src="/img/151257-20160321141549448-1325816759.png" alt="151257-20160321141549448-1325816759.png"></p>
<p>每一个进程有一个或多个线程，进程内多个线程可以共享所属进程的资源和数据，线程是操作系统调度的基本单元。线程是由操作系统来调度和执行的，她的基本状态如下图。</p>
<p><img src="/img/151257-20160321141550120-2131692214.png" alt="151257-20160321141550120-2131692214.png"></p>
<h3 id="线程的开销及调度"><a href="#线程的开销及调度" class="headerlink" title="线程的开销及调度"></a>线程的开销及调度</h3><p>创建一个线程,主要包括线程内核对象、线程环境块、1M大小的用户模式栈、内核模式栈。其中用户模式栈对于普通的系统线程那1M是预留的，在需要的时候才会分配，但是对于CLR线程，那1M是一开始就分类了内存空间的。</p>
<p><img src="/img/151257-20160321141550589-1339297361.png" alt="151257-20160321141550589-1339297361.png"></p>
<p>操作系统中那么多线程（一般都有上千个线程，大部分都处于休眠状态），对于单核CPU，一次只能有一个线程被调度执行，那么多线程怎么分配的呢？Windows系统采用时间轮询机制，CPU计算资源以时间片(大约30ms)的形式分配给执行线程。</p>
<p>计算机资源（CPU核心和CPU寄存器）一次只能调度一个线程，具体的调度流程：</p>
<ul>
<li>把CPU寄存器内的数据保存到当前线程内部（线程上下文等地方），给下一个线程腾地方；</li>
<li>线程调度：在线程集合里取出一个需要执行的线程；</li>
<li>加载新线程的上下文数据到CPU寄存器；</li>
<li>新线程执行，享受她自己的CPU时间片（大约30ms），完了之后继续回到第一步，继续轮回；</li>
</ul>
<p>上面线程调度的过程，就是一次线程切换，一次切换就涉及到线程上下文等数据的搬入搬出，性能开销是很大的。因此线程不可滥用，线程的创建和消费也是很昂贵的，这也是为什么建议尽量使用线程池的一个主要原因。</p>
<p>线程的主要几点性能影响：</p>
<ul>
<li>线程的创建、销毁都是很昂贵的；</li>
<li>线程上下文切换有极大的性能开销，当然假如需要调度的新线程与当前是同一线程的话，就不需要线程上下文切换了，效率要快很多；</li>
<li>GC执行回收时，首先要（安全的）挂起所有线程，遍历所有线程栈（根），GC回收后更新所有线程的根地址，再恢复线程调用，线程越多，GC要干的活就越多；</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池(ThreadPool)"></a>线程池(ThreadPool)</h3><p>将任务添加进线程池:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(方法名));</span><br><span class="line"><span class="comment">//重载</span></span><br><span class="line">ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(方法名), 参数);</span><br></pre></td></tr></table></figure>

<p>因为ThreadPool是静态类 所以不需要实例化.</p>
<p>每个CLR都有一个线程池，线程池在CLR内可以多个AppDomain共享，线程池是CLR内部管理的一个线程集合，初始是没有线程的，在需要的时候才会创建。</p>
<p>基本流程如下：</p>
<ul>
<li>线程池内部维护一个请求列队，用于缓存用户请求需要执行的代码任务，就是ThreadPool.QueueUserWorkItem提交的请求；</li>
<li>有新任务后，线程池使用空闲线程或新线程来执行队列请求；</li>
<li>任务执行完后线程不会销毁，留着重复使用；</li>
<li>线程池自己负责维护线程的创建和销毁，当线程池中有大量闲置的线程时，线程池会自动结束一部分多余的线程来释放资源；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line">namespace 多线程池试验</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//新建ManualResetEvent对象并且初始化为无信号状态</span></span><br><span class="line">            ManualResetEvent eventX = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line">            ThreadPool.SetMaxThreads(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">            thr t = <span class="keyword">new</span> thr(<span class="number">15</span>, eventX);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ThreadPool.QueueUserWorkItem(<span class="keyword">new</span> WaitCallback(t.ThreadProc), i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//等待事件的完成，即线程调用ManualResetEvent.Set()方法</span></span><br><span class="line">            <span class="comment">//eventX.WaitOne  阻止当前线程，直到当前 WaitHandle 收到信号为止。 </span></span><br><span class="line">            eventX.WaitOne(Timeout.Infinite, <span class="literal">true</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;断点测试&quot;</span>);</span><br><span class="line">            Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">thr</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">thr</span>(<span class="params"><span class="built_in">int</span> count,ManualResetEvent mre</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                iMaxCount = count;</span><br><span class="line">                eventX = mre;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> iCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> iMaxCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">public</span> ManualResetEvent eventX;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThreadProc</span>(<span class="params"><span class="built_in">object</span> i</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Thread[&quot;</span> + i.ToString() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">                <span class="comment">//Interlocked.Increment()操作是一个原子操作，作用是:iCount++ 具体请看下面说明 </span></span><br><span class="line">                <span class="comment">//原子操作，就是不能被更高等级中断抢夺优先的操作。你既然提这个问题，我就说深一点。</span></span><br><span class="line">                <span class="comment">//由于操作系统大部分时间处于开中断状态，</span></span><br><span class="line">                <span class="comment">//所以，一个程序在执行的时候可能被优先级更高的线程中断。</span></span><br><span class="line">                <span class="comment">//而有些操作是不能被中断的，不然会出现无法还原的后果，这时候，这些操作就需要原子操作。</span></span><br><span class="line">                <span class="comment">//就是不能被中断的操作。</span></span><br><span class="line">                Interlocked.Increment(<span class="keyword">ref</span> iCount);</span><br><span class="line">                <span class="keyword">if</span> (iCount == iMaxCount)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;发出结束信号!&quot;</span>);</span><br><span class="line">                    <span class="comment">//将事件状态设置为终止状态，允许一个或多个等待线程继续。</span></span><br><span class="line">                    eventX.Set();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AutoResetEvent和ManualResetEvent区别：</strong><br><font color=#0099ff size=4 face="黑体">AutoResetEvent的WaitOne()方法执行后会自动又将信号置为不发送状态也就是阻塞状态，当再次遇到WaitOne()方法是又会被阻塞，而ManualResetEvent则不会，只要线程处于非阻塞状态则无论遇到多少次WaitOne()方法都不会被阻塞，除非调用ReSet()方法来手动阻塞线程。</font></p>
<p>线程池是有一个容量的，可以设置线程池的最大活跃线程数，调用方法ThreadPool.SetMaxThreads可以设置相关参数。但很多编程实践里都不建议程序猿们自己去设置这些参数，其实微软为了提高线程池性能，做了大量的优化，线程池可以很智能的确定是否要创建或是消费线程，大多数情况都可以满足需求了。</p>
<p>线程池使得线程可以充分有效地被利用，减少了任务启动的延迟，也不用大量的去创建线程，避免了大量线程的创建和销毁对性能的极大影响。</p>
<p>线程池的不足：</p>
<ul>
<li>线程池内的线程不支持线程的挂起、取消等操作，如想要取消线程里的任务，.NET支持一种协作式方式取消，使用起来也不很方便，而且有些场景并不满足需求；</li>
<li>线程内的任务没有返回值，也不知道何时执行完成；</li>
<li>不支持设置线程的优先级，还包括其他类似需要对线程有更多的控制的需求都不支持；</li>
</ul>
<h3 id="任务Task与并行Parallel"><a href="#任务Task与并行Parallel" class="headerlink" title="任务Task与并行Parallel"></a>任务Task与并行Parallel</h3><p>任务Task与并行Parallel本质上内部都是使用的线程池，提供了更丰富的并行编程的方式。任务Task基于线程池，可支持返回值，支持比较强大的任务执行计划定制等功能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个任务</span></span><br><span class="line">Task&lt;<span class="built_in">int</span>&gt; t1 = <span class="keyword">new</span> Task&lt;<span class="built_in">int</span>&gt;(n =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    System.Threading.Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span>)n;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//定制一个延续任务计划</span></span><br><span class="line">t1.ContinueWith(task =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;end&quot;</span> + t1.Result);</span><br><span class="line">&#125;, TaskContinuationOptions.AttachedToParent);</span><br><span class="line">t1.Start();</span><br><span class="line"><span class="comment">//使用Task.Factory创建并启动一个任务</span></span><br><span class="line"><span class="keyword">var</span> t2 = System.Threading.Tasks.Task.Factory.StartNew(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;t1:&quot;</span> + t1.Status);</span><br><span class="line">&#125;);</span><br><span class="line">Task.WaitAll();</span><br><span class="line">Console.WriteLine(t1.Result);</span><br></pre></td></tr></table></figure>

<p>并行Parallel内部其实使用的是Task对象（TPL会在内部创建System.Threading.Tasks.Task的实例），所有并行任务完成后才会返回。少量短时间任务建议就不要使用并行Parallel了，并行Parallel本身也是有性能开销的，而且还要进行并行任务调度、创建调用方法的委托等等。</p>
<p><img src="/img/221025576742743.png" alt="221025576742743.png"></p>
<h3 id="GUI线程处理模型"><a href="#GUI线程处理模型" class="headerlink" title="GUI线程处理模型"></a>GUI线程处理模型</h3><p>这是很多开发C/S客户端应用程序会遇到的问题，GUI程序的界面控件不允许跨线程访问，如果在其他线程中访问了界面控件，运行时就会抛出一个异常，就像下面的图示，是不是很熟悉！这其中的罪魁祸首就是，就是“GUI的线程处理模型”。</p>
<p><img src="/img/151257-20160321141551714-1827445547.png" alt="151257-20160321141551714-1827445547.png"></p>
<p>.NET支持多种不同应用程序模型，大多数的线程都是可以做任何事情（他们可能没有引入线程模型），但GUI应用程序（主要是Winform、WPF）引入了一个特殊线程处理模型，<font color=#0099ff size=4 face="黑体">UI控件元素只能由创建它的线程访问或修改，微软这样处理是为了保证UI控件的线程安全。</font></p>
<p>为什么在UI线程中执行一个耗时的计算操作，会导致UI假死呢？这个问题要追溯到Windows的消息机制了。</p>
<p>因为Windows是基于消息机制的，我们在UI上所有的键盘、鼠标操作都是以消息的形式发送给各个应用程序的。GUI线程内部就有一个消息队列，GUI线程不断的循环处理这些消息，并根据消息更新UI的呈现。如果这个时候，你让GUI线程去处理一个耗时的操作（比如花10秒去下载一个文件），那GUI线程就没办法处理消息队列了，UI界面就处于假死的状态。</p>
<p><img src="/img/151257-20160321141552292-299214517.png" alt="151257-20160321141552292-299214517.png"></p>
<p>在线程里处理事件完成后，需要更新UI控件的状态:</p>
<p><font color=#0099ff size=4 face="黑体">（1）使用GUI控件提供的方法，Winform是控件的Invoke方法，WPF中是控件的Dispatcher.Invoke方法</font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Winform：Invoke方法和BeginInvoke</span></span><br><span class="line"> <span class="keyword">this</span>.label.Invoke(method, <span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.WPF：Dispatcher.Invoke</span></span><br><span class="line"><span class="keyword">this</span>.label.Dispatcher.Invoke(method, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">（2）使用.NET中提供的BackgroundWorker执行耗时计算操作，在其任务完成事件RunWorkerCompleted 中更新UI控件</font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (BackgroundWorker bw = <span class="keyword">new</span> BackgroundWorker())</span><br><span class="line">&#123;</span><br><span class="line">    bw.RunWorkerCompleted += <span class="keyword">new</span> RunWorkerCompletedEventHandler((ojb,arg) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.label.Text = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    bw.RunWorkerAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=#0099ff size=4 face="黑体">（3）使用GUI线程处理模型的同步上下文来送封UI控件修改操作，这样可以不需要调用UI控件元素</font></p>
<p>.NET中提供一个用于同步上下文的类SynchronizationContext，利用它可以把应用程序模型链接到他的线程处理模型，其实它的本质还是调用的第一步（1）中的方法。</p>
<p>实现代码分为三步，第一步定义一个静态类，用于GUI线程的UI元素访问封装：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GUIThreadHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> System.Threading.SynchronizationContext GUISyncContext</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _GUISyncContext; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _GUISyncContext = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> System.Threading.SynchronizationContext _GUISyncContext =</span><br><span class="line">        System.Threading.SynchronizationContext.Current;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 主要用于GUI线程的同步回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SyncContextCallback</span>(<span class="params">Action callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (GUISyncContext == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            callback();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        GUISyncContext.Post(result =&gt; callback(), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 支持APM异步编程模型的GUI线程的同步回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncCallback <span class="title">SyncContextCallback</span>(<span class="params">AsyncCallback callback</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="literal">null</span>) <span class="keyword">return</span> callback;</span><br><span class="line">        <span class="keyword">if</span> (GUISyncContext == <span class="literal">null</span>) <span class="keyword">return</span> callback;</span><br><span class="line">        <span class="keyword">return</span> asynresult =&gt; GUISyncContext.Post(result =&gt; callback(result <span class="keyword">as</span> IAsyncResult), asynresult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，在主窗口注册当前SynchronizationContext：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">            CLRTest.ConsoleTest.GUIThreadHelper.GUISyncContext = System.Threading.SynchronizationContext.Current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第三步，就是使用了，可以在任何地方使用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GUIThreadHelper.SyncContextCallback(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.txtMessage.Text = res.ToString();</span><br><span class="line">    <span class="keyword">this</span>.btnTest.Content = <span class="string">&quot;DoTest&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>.btnTest.IsEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="线程同步构造"><a href="#线程同步构造" class="headerlink" title="线程同步构造"></a>线程同步构造</h2><p>基元线程同步构造分为：基元用户模式构造和基元内核模式构造，两种同步构造方式各有优缺点，而混合构造（如lock）就是综合两种构造模式的优点。</p>
<h3 id="用户模式构造"><a href="#用户模式构造" class="headerlink" title="用户模式构造"></a>用户模式构造</h3><p>基元用户模式比基元内核模式速度要快，她使用特殊的cpu指令来协调线程，在硬件中发生，速度很快。但也因此Windows操作系统永远检测不到一个线程在一个用户模式构造上阻塞了。举个例子来模拟一下用户模式构造的同步方式：</p>
<ul>
<li>线程1请求了临界资源，并在资源门口使用了用户模式构造的锁；</li>
<li>线程2请求临界资源时，发现有锁，因此就在门口等待，并不停的去询问资源是否可用；</li>
<li>线程1如果使用资源时间较长，则线程2会一直运行，并且占用CPU时间。占用CPU干什么呢？她会不停的轮询锁的状态，直到资源可用，这就是所谓的活锁；</li>
</ul>
<p>缺点：<font color=#0099ff size=4 face="黑体">线程2会一直使用CPU时间（假如当前系统只有这两个线程在运行），也就意味着不仅浪费了CPU时间，而且还会有频繁的线程上下文切换，对性能影响是很严重的。</font></p>
<p><font color=#0099ff size=4 face="黑体">当然她的优点是效率高，适合哪种对资源占用时间很短的线程同步。</font></p>
<p>.NET中为我们提供了两种原子性操作，利用原子操作可以实现一些简单的用户模式锁（如自旋锁）。</p>
<ul>
<li>System.Threading.Interlocked：易失构造，它在包含一个简单数据类型的变量上执行原子性的读或写操作。</li>
<li>Thread.VolatileRead 和 Thread.VolatileWrite：互锁构造，它在包含一个简单数据类型的变量上执行原子性的读和写操作。</li>
</ul>
<h3 id="内核模式构造"><a href="#内核模式构造" class="headerlink" title="内核模式构造"></a>内核模式构造</h3><p>这是针对用户模式的一个补充，先模拟一个内核模式构造的同步流程来理解她的工作方式：</p>
<ul>
<li>线程1请求了临界资源，并在资源门口使用了内核模式构造的锁；</li>
<li>线程2请求临界资源时，发现有锁，就会被系统要求睡眠（阻塞），线程2就不会被执行了，也就不会浪费CPU和线程上下文切换了；</li>
<li>等待线程1使用完资源后，解锁后会发送一个通知，然后操作系统会把线程2唤醒。假如有多个线程在临界资源门口等待，则会挑选一个唤醒；</li>
</ul>
<p>看上去是不是非常棒！彻底解决了用户模式构造的缺点，但内核模式也有缺点的：将线程从用户模式切换到内核模式（或相反）导致巨大性能损失。调用线程将从托管代码转换为内核代码，再转回来，会浪费大量CPU时间，同时还伴随着线程上下文切换，因此尽量不要让线程从用户模式转到内核模式。</p>
<p><font color=#0099ff size=4 face="黑体">它的优点就是阻塞线程，不浪费CPU时间，适合那种需要长时间占用资源的线程同步。</font></p>
<p>内核模式构造的主要有两种方式，以及基于这两种方式的常见的锁：</p>
<ul>
<li>基于事件：如AutoResetEvent、ManualResetEvent</li>
<li>基于信号量：如Semaphore</li>
</ul>
<h3 id="混合线程同步"><a href="#混合线程同步" class="headerlink" title="混合线程同步"></a>混合线程同步</h3><p>Lock、SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim</p>
<p>lock的本质就是使用的Monitor，lock只是一种简化的语法形式，实质的语法形式如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    Monitor.Enter(obj, <span class="keyword">ref</span> lockTaken);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockTaken) Monitor.Exit(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Semaphore 信号量</strong></p>
<p>它可以控制对某一段代码或者对某个资源访问的线程的数量，超过这个数量之后，其它的线程就得等待，只有等现在有线程释放了之后，下面的线程才能访问。这个跟锁有相似的功能，只不过不是独占的，它允许一定数量的线程同时访问。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SemaphoreSlim _sem = <span class="keyword">new</span> SemaphoreSlim(<span class="number">3</span>);    <span class="comment">// 我们限制能同时访问的线程数量是3</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) <span class="keyword">new</span> Thread(Enter).Start(i);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Enter</span>(<span class="params"><span class="built_in">object</span> id</span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(id + <span class="string">&quot; 开始排队...&quot;</span>);</span><br><span class="line">    _sem.Wait();</span><br><span class="line">    Console.WriteLine(id + <span class="string">&quot; 开始执行！&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span> * (<span class="built_in">int</span>)id);</span><br><span class="line">    Console.WriteLine(id + <span class="string">&quot; 执行完毕，离开！&quot;</span>);</span><br><span class="line">    _sem.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/222030017324376.png" alt="222030017324376.png"></p>
<p>同步索引块是.NET中解决对象同步问题的基本机制，该机制为每个堆内的对象（即引用类型对象实例）分配一个同步索引，她其实是一个地址指针，初始值为-1不指向任何地址。</p>
<ul>
<li>创建一个锁对象Object obj，obj的同步索引块（地址）为-1，不指向任何地址；</li>
<li>Monitor.Enter（obj），创建或使用一个空闲的同步索引块（如下图中的同步块1），这个才是真正的同步索引块，其内部结构就是一个混合锁的结构，包含线程ID、递归计数、等待线程统计、内核对象等，类似一个混合锁AnotherHybridLock。obj对象（同步索引块AsynBlockIndex）指向该同步块1；</li>
<li>Exit时，重置为-1，那个同步索引块1可以被重复利用；</li>
</ul>
<h3 id="Lock关键字"><a href="#Lock关键字" class="headerlink" title="Lock关键字"></a>Lock关键字</h3><p>lock 确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</p>
<p>通常，应避免锁定 public 类型，否则实例将超出代码的控制范围。常见的结构 lock (this)、lock (typeof (MyType)) 和 lock (“myLock”) 违反此准则：</p>
<ul>
<li>如果实例可以被公共访问，将出现 lock (this) 问题。</li>
<li>如果 MyType 可以被公共访问，将出现 lock (typeof (MyType)) 问题。</li>
<li>由于进程中使用同一字符串的任何其他代码将共享同一个锁，所以出现lock(“myLock”) 问题。</li>
</ul>
<p>最佳做法是定义 private 对象来锁定, 或 private static 对象变量来保护所有实例所共有的数据。</p>
<p><font color=#0099ff size=4 face="黑体">不要Lock值类型,不要Lock(this),不要Lock(null对象),推荐Lock只读静态对象。</font></p>
<p><img src="/img/151257-20160321141553854-448927161.jpg" alt="151257-20160321141553854-448927161.jpg"></p>
<p>因此，锁对象要求必须为一个引用对象（在堆上）。</p>
<h3 id="多线程使用及线程同步总结"><a href="#多线程使用及线程同步总结" class="headerlink" title="多线程使用及线程同步总结"></a>多线程使用及线程同步总结</h3><p>在使用Lock时，关键点就是锁对象了，需要注意以下几个方面：</p>
<ul>
<li>这个对象肯定要是引用类型，值类型可不可呢？值类型可以装箱啊！你觉得可不可以？但也不要用值类型，因为值类型多次装箱后的对象是不同的，会导致无法锁定；</li>
<li>不要锁定this，尽量使用一个没有意义的Object对象来锁；</li>
<li>不要锁定一个类型对象，因类型对象是全局的；</li>
<li>不要锁定一个字符串，因为字符串可能被驻留，不同字符对象可能指向同一个字符串；</li>
<li>不要使用[System.Runtime.CompilerServices.MethodImpl(MethodImplOptions.Synchronized)]，这个可以使用在方法上面，保证方法同一时刻只能被一个线程调用。她实质上是使用lock的，如果是实例方法，会锁定this，如果是静态方法，则会锁定类型对象</li>
</ul>
<h2 id="题目答案解析"><a href="#题目答案解析" class="headerlink" title="题目答案解析"></a>题目答案解析</h2><h3 id="1-描述线程与进程的区别？"><a href="#1-描述线程与进程的区别？" class="headerlink" title="1. 描述线程与进程的区别？"></a>1. 描述线程与进程的区别？</h3><ul>
<li>一个应用程序实例是一个进程，一个进程内包含一个或多个线程，线程是进程的一部分；</li>
<li>进程之间是相互独立的，他们有各自的私有内存空间和资源，进程内的线程可以共享其所属进程的所有资源；</li>
</ul>
<h3 id="2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"><a href="#2-为什么GUI不支持跨线程访问控件？一般如何解决这个问题？" class="headerlink" title="2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？"></a>2. 为什么GUI不支持跨线程访问控件？一般如何解决这个问题？</h3><p>因为GUI应用程序引入了一个特殊的线程处理模型，为了保证UI控件的线程安全，这个线程处理模型不允许其他子线程跨线程访问UI元素。解决方法还是比较多的，如：</p>
<ul>
<li>利用UI控件提供的方法，Winform是控件的Invoke方法，WPF中是控件的Dispatcher.Invoke方法；</li>
<li>使用BackgroundWorker；</li>
<li>使用GUI线程处理模型的同步上下文SynchronizationContext来提交UI更新操作</li>
</ul>
<p>上面几个方式在文中已详细给出。</p>
<h3 id="3-简述后台线程和前台线程的区别？"><a href="#3-简述后台线程和前台线程的区别？" class="headerlink" title="3. 简述后台线程和前台线程的区别？"></a>3. 简述后台线程和前台线程的区别？</h3><p>应用程序必须运行完所有的前台线程才可以退出，或者主动结束前台线程，不管后台线程是否还在运行，应用程序都会结束；而对于后台线程，应用程序则可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时都会自动结束。</p>
<p>通过将 Thread.IsBackground 设置为 true，就可以将线程指定为后台线程，主线程就是一个前台线程。</p>
<h3 id="4-说说常用的锁，lock是一种什么样的锁？"><a href="#4-说说常用的锁，lock是一种什么样的锁？" class="headerlink" title="4. 说说常用的锁，lock是一种什么样的锁？"></a>4. 说说常用的锁，lock是一种什么样的锁？</h3><p>常用的如如SemaphoreSlim、ManualResetEventSlim、Monitor、ReadWriteLockSlim，lock是一个混合锁，其实质是Monitor[‘mɒnɪtə]。</p>
<h3 id="5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"><a href="#5-lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？" class="headerlink" title="5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？"></a>5. lock为什么要锁定一个参数，可不可锁定一个值类型？这个参数有什么要求？</h3><p>lock的锁对象要求为一个引用类型。她可以锁定值类型，但值类型会被装箱，每次装箱后的对象都不一样，会导致锁定无效。</p>
<p>对于lock锁，锁定的这个对象参数才是关键，这个参数的同步索引块指针会指向一个真正的锁（同步块），这个锁（同步块）会被复用。</p>
<h3 id="6-多线程和异步有什么关系和区别？"><a href="#6-多线程和异步有什么关系和区别？" class="headerlink" title="6. 多线程和异步有什么关系和区别？"></a>6. 多线程和异步有什么关系和区别？</h3><p>多线程是实现异步的主要方式之一，异步并不等同于多线程。实现异步的方式还有很多，比如利用硬件的特性、使用进程或纤程等。在.NET中就有很多的异步编程支持，比如很多地方都有Begin、End的方法，就是一种异步编程支持，她内部有些是利用多线程，有些是利用硬件的特性来实现的异步编程。</p>
<h3 id="7-线程池的优点有哪些？又有哪些不足？"><a href="#7-线程池的优点有哪些？又有哪些不足？" class="headerlink" title="7. 线程池的优点有哪些？又有哪些不足？"></a>7. 线程池的优点有哪些？又有哪些不足？</h3><p>优点：减小线程创建和销毁的开销，可以复用线程；也从而减少了线程上下文切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。</p>
<p>缺点：线程池无法对一个线程有更多的精确的控制，如了解其运行状态等；不能设置线程的优先级；加入到线程池的任务（方法）不能有返回值；对于需要长期运行的任务就不适合线程池。</p>
<h3 id="8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？"><a href="#8-Mutex和lock有何不同？一般用哪一个作为锁使用更好？" class="headerlink" title="8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？"></a>8. Mutex和lock有何不同？一般用哪一个作为锁使用更好？</h3><p>Mutex是一个基于内核模式的互斥锁，支持锁的递归调用，而Lock是一个混合锁，一般建议使用Lock更好，因为lock的性能更好。</p>
<h3 id="9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"><a href="#9-下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。" class="headerlink" title="9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。"></a>9. 下面的代码，调用方法DeadLockTest（20），是否会引起死锁？并说明理由。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeadLockTest</span>(<span class="params"><span class="built_in">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (<span class="keyword">this</span>)   <span class="comment">//或者lock一个静态object变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i--);</span><br><span class="line">            DeadLockTest(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会的，因为lock是一个混合锁，支持锁的递归调用，如果你使用一个ManualResetEvent或AutoResetEvent可能就会发生死锁。</p>
<h3 id="10-用双检锁实现一个单例模式Singleton。"><a href="#10-用双检锁实现一个单例模式Singleton。" class="headerlink" title="10. 用双检锁实现一个单例模式Singleton。"></a>10. 用双检锁实现一个单例模式Singleton。</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static class Singleton&lt;T&gt; where T : class,new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T _Instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> _lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取单例对象的实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_Instance != <span class="literal">null</span>) <span class="keyword">return</span> _Instance;</span><br><span class="line">        <span class="keyword">lock</span> (_lockObj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_Instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = Activator.CreateInstance&lt;T&gt;();</span><br><span class="line">                System.Threading.Interlocked.Exchange(<span class="keyword">ref</span> _Instance, temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-下面代码输出结果是什么？为什么？如何改进她？"><a href="#11-下面代码输出结果是什么？为什么？如何改进她？" class="headerlink" title="11.下面代码输出结果是什么？为什么？如何改进她？"></a>11.下面代码输出结果是什么？为什么？如何改进她？</h3><p>int a = 0;<br>System.Threading.Tasks.Parallel.For(0, 100000, (i) =&gt;<br>{<br>    a++;<br>});<br>Console.Write(a);</p>
<p>输出结果不稳定，小于等于100000。因为多线程访问，没有使用锁机制，会导致有更新丢失。</p>
<p>改进：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Threading.Interlocked.Add(<span class="keyword">ref</span> a, <span class="number">1</span>);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5301754.html">.NET面试题解析(07)-多线程编程与线程同步</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=netframework-4.7.2">https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.autoresetevent?view=netframework-4.7.2</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yifengjianbai/p/5499493.html">C#多线程–线程池（ThreadPool）</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/henw/archive/2012/01/06/2314870.html">C#多线程学习 之 线程池[ThreadPool]</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/chengqscjh/archive/2010/12/12/1903784.html">C#深入学习笔记—Lock</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9007-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/20/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%9007-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">DotNet面试题解析07-GC与内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-20 11:28:04" itemprop="dateCreated datePublished" datetime="2018-12-20T11:28:04+00:00">2018-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DotNet%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">DotNet面试题解析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析</h2><h3 id="1-简述一下一个引用对象的生命周期？"><a href="#1-简述一下一个引用对象的生命周期？" class="headerlink" title="1. 简述一下一个引用对象的生命周期？"></a>1. 简述一下一个引用对象的生命周期？</h3><ul>
<li>new 创建对象并分配内存</li>
<li>对象初始化</li>
<li>对象操作、使用</li>
<li>资源清理（非托管资源）</li>
<li>GC 垃圾回收</li>
</ul>
<h3 id="2-创建下面对象实例，需要申请多少内存空间？"><a href="#2-创建下面对象实例，需要申请多少内存空间？" class="headerlink" title="2. 创建下面对象实例，需要申请多少内存空间？"></a>2. 创建下面对象实例，需要申请多少内存空间？</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _Name = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; _Names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>40字节内存空间。</p>
<p>详细信息参考：<a target="_blank" rel="noopener" href="https://syxdevcode.github.io/2018/12/14/DotNet%E5%9F%BA%E7%A1%80-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">DotNet基础-GC与内存管理</a></p>
<h3 id="3-什么是垃圾？"><a href="#3-什么是垃圾？" class="headerlink" title="3. 什么是垃圾？"></a>3. 什么是垃圾？</h3><p>一个变量如果在其生存期内的某一时刻已经不再被引用，那么，这个对象就有可能成为垃圾</p>
<h3 id="4-GC是什么，简述一下GC的工作方式？"><a href="#4-GC是什么，简述一下GC的工作方式？" class="headerlink" title="4. GC是什么，简述一下GC的工作方式？"></a>4. GC是什么，简述一下GC的工作方式？</h3><p>GC 是<strong>垃圾回收（Garbage Collect）</strong>的缩写，是 .NET 核心机制的重要部分。她的基本工作原理就是遍历托管堆中的对象，标记哪些被使用对象（哪些没人使用的就是所谓的垃圾），然后把可达对象转移到一个连续的地址空间（也叫压缩），其余的所有没用的对象内存被回收掉。</p>
<h3 id="5-GC进行垃圾回收时的主要流程是？"><a href="#5-GC进行垃圾回收时的主要流程是？" class="headerlink" title="5. GC进行垃圾回收时的主要流程是？"></a>5. GC进行垃圾回收时的主要流程是？</h3><p><strong>(1)标记：</strong>先假设所有对象都是垃圾，根据应用程序根Root遍历堆上的每一个引用对象，生成可达对象图，对于还在使用的对象（可达对象）进行标记（其实就是在对象同步索引块中开启一个标示位）。</p>
<p><strong>(2)清除</strong>：针对所有不可达对象进行清除操作，针对普通对象直接回收内存，而对于实现了终结器的对象（实现了析构函数的对象）需要单独回收处理。清除之后，内存就会变得不连续了，就是步骤3的工作了。</p>
<p><strong>(3)压缩</strong>：把剩下的对象转移到一个连续的内存，因为这些对象地址变了，还需要把那些 Root 跟指针的地址修改为移动后的新地址。</p>
<h3 id="6-GC在哪些情况下回进行回收工作？"><a href="#6-GC在哪些情况下回进行回收工作？" class="headerlink" title="6. GC在哪些情况下回进行回收工作？"></a>6. GC在哪些情况下回进行回收工作？</h3><ul>
<li>内存不足溢出时（0代对象充满时）</li>
<li>Windwos 报告内存不足时，CLR 会强制执行垃圾回收</li>
<li>CLR 卸载 AppDomian，GC 回收所有</li>
<li>调用 GC.Collect</li>
<li>其他情况，如主机拒绝分配内存，物理内存不足，超出短期存活代的存段门限</li>
</ul>
<h3 id="7-using-语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？"><a href="#7-using-语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？" class="headerlink" title="7. using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？"></a>7. using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？</h3><p>using() 只是一种语法形式，其本质还是 try…finally 的结构，可以保证 Dispose 始终会被执行。</p>
<h3 id="8-解释一下C-里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？"><a href="#8-解释一下C-里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？" class="headerlink" title="8. 解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？"></a>8. 解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？</h3><p>C# 里的析构函数其实就是终结器 Finalize，因为长得像 C++ 里的析构函数而已。</p>
<p>有些编程建议里不推荐使用析构函数要原因在于：第一是 Finalize 本身性能并不好；其次很多人搞不清楚 Finalize 的原理，可能会滥用，导致内存泄露，因此就干脆别用了</p>
<h3 id="9-Finalize-和-Dispose-之间的区别？"><a href="#9-Finalize-和-Dispose-之间的区别？" class="headerlink" title="9. Finalize() 和 Dispose() 之间的区别？"></a>9. Finalize() 和 Dispose() 之间的区别？</h3><p>Finalize() 和 Dispose() 都是 .NET 中提供释放非托管资源的方式，他们的主要区别在于执行者和执行时间不同：</p>
<ul>
<li>finalize 由垃圾回收器调用；dispose 由对象调用。</li>
<li>finalize 无需担心因为没有调用 finalize 而使非托管资源得不到释放，而 dispose 必须手动调用。</li>
<li>finalize 不能保证立即释放非托管资源，Finalizer 被执行的时间是在对象不再被引用后的某个不确定的时间；而 dispose 一调用便释放非托管资源。</li>
<li>只有 class 类型才能重写 finalize ，而结构不能；类和结构都能实现 IDispose 。</li>
</ul>
<p>另外一个重点区别就是终结器会导致对象复活一次，也就说会被 GC 回收两次才最终完成回收工作，这也是不建议开发人员使用终结器的主要原因。</p>
<h3 id="10-Dispose和Finalize方法在何时被调用？"><a href="#10-Dispose和Finalize方法在何时被调用？" class="headerlink" title="10. Dispose和Finalize方法在何时被调用？"></a>10. Dispose和Finalize方法在何时被调用？</h3><ul>
<li>Dispose 一调用便释放非托管资源；</li>
<li>Finalize 不能保证立即释放非托管资源，Finalizer 被执行的时间是在对象不再被引用后的某个不确定的时间；</li>
</ul>
<h3 id="11-NET中的托管堆中是否可能出现内存泄露的现象？"><a href="#11-NET中的托管堆中是否可能出现内存泄露的现象？" class="headerlink" title="11. .NET中的托管堆中是否可能出现内存泄露的现象？"></a>11. .NET中的托管堆中是否可能出现内存泄露的现象？</h3><p>是的，可能会。比如：</p>
<ul>
<li>不正确的使用静态字段，导致大量数据无法被GC释放；</li>
<li>没有正确执行 Dispose()，非托管资源没有得到释放；</li>
<li>不正确的使用终结器 Finalize()，导致无法正常释放资源；</li>
<li>其他不正确的引用，导致大量托管对象无法被 GC 释放；</li>
</ul>
<h3 id="12-在托管堆上创建新对象有哪几种常见方式？"><a href="#12-在托管堆上创建新对象有哪几种常见方式？" class="headerlink" title="12. 在托管堆上创建新对象有哪几种常见方式？"></a>12. 在托管堆上创建新对象有哪几种常见方式？</h3><ul>
<li>new 一个对象；</li>
<li>字符串赋值，如 string s1=”abc”；</li>
<li>值类型装箱；</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5260319.html">.NET面试题解析(06)-GC与内存管理</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/14/DotNet%E5%9F%BA%E7%A1%80-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/14/DotNet%E5%9F%BA%E7%A1%80-GC%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">DotNet基础-GC与内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-14 14:33:47" itemprop="dateCreated datePublished" datetime="2018-12-14T14:33:47+00:00">2018-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">CSharp基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>GC的内存管理的目标主要都是引用类型对象。</p>
<h3 id="对象创建及生命周期"><a href="#对象创建及生命周期" class="headerlink" title="对象创建及生命周期"></a>对象创建及生命周期</h3><p>一个对象的生命周期简单概括就是：创建 &gt; 使用 &gt; 释放，在.NET中一个对象的生命周期：</p>
<ul>
<li>new创建对象并分配内存</li>
<li>对象初始化</li>
<li>对象操作、使用</li>
<li>资源清理（非托管资源）</li>
<li>GC垃圾回收</li>
</ul>
<p>大部分的对象创建都是开始于关键字 new,有个别引用类型是由专门 IL 指令的，比如 string 有 ldstr 指令。</p>
<p>引用对象都是分配在托管堆上的， 先来看看托管堆的基本结构，如下图，托管堆中的对象是顺序存放的，托管堆维护着一个指针 NextObjPtr，它指向下一个对象在堆中的分配位置。</p>
<p><img src="/img/82a2b4be6318aebc0dc9b7b29c2a7599.png" alt="82a2b4be6318aebc0dc9b7b29c2a7599.png"></p>
<p>创建一个新对象的主要流程:</p>
<p><img src="/img/151257-20160309235623241-1001221060.png" alt="151257-20160309235623241-1001221060.png"></p>
<p>模拟一个对象的创建过程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _Name = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; _Names;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1，对象大小估算，共计40个字节：<br>  (1) 属性 Age 值类型 Int，4字节；<br>  (2) 属性 Name，引用类型，初始为 NULL，4个字节，指向空地址；<br>  (3) 字段 _Name 初始赋值了，代码会被编译器优化为 _Name=”123abc” 。一个字符两个字节，字符串占用 2×6+8（附加成员：4字节 TypeHandle 地址，4字节 同步索引块 ）= 20 字节，总共 内存大小 = 字符串对象20字节 + _Name 指向字符串的内存地址4字节=24字节；<br>  (4) 引用类型字段 List<string> _Names 初始默认为 NULL，4个字节；<br>  (5) User对象的初始附加成员（4字节 TypeHandle 地址，4字节同步索引块）8个字节；</li>
<li>2，内存申请： 申请 44 个字节的内存块，从指针 NextObjPtr 开始验证，空间是否足够，若不够则触发垃圾回收。</li>
<li>3，内存分配： 从指针 NextObjPtr 处开始划分 44 个字节内存块。</li>
<li>4，对象初始化： 首先初始化对象附加成员，再调用User对象的构造函数，对成员初始化，值类型默认初始为0，引用类型默认初始化为 NULL；</li>
<li>5，托管堆指针后移： 指针 NextObjPtr 后移44个字节。</li>
<li>6，返回内存地址： 返回对象的内存地址给引用变量。</li>
</ul>
<h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><p>GC是垃圾回收（ Garbage Collect）的缩写，是 .NET 核心机制的重要部分。她的基本工作原理就是遍历托管堆中的对象，标记哪些被使用对象（那些没人使用的就是所谓的垃圾），然后把可达对象转移到一个连续的地址空间（也叫压缩），其余的所有没用的对象内存被回收掉。</p>
<p><img src="/img/151257-20160309235624382-1396676769.png" alt="151257-20160309235624382-1396676769.png"></p>
<h3 id="垃圾回收基本流程"><a href="#垃圾回收基本流程" class="headerlink" title="垃圾回收基本流程"></a>垃圾回收基本流程</h3><h4 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h4><p>先假设所有对象都是垃圾，根据应用程序根指针 Root 遍历堆上的每一个引用对象，生成可达对象图，对于还在使用的对象（可达对象）进行标记（其实就是在对象同步索引块中开启一个标示位）。</p>
<p>其中 Root 根指针保存了当前所有需要使用的对象引用，他其实只是一个统称，意思就是这些对象当前还在使用，主要包含：静态对象/静态字段的引用；线程栈引用（局部变量、方法参数、栈帧）；任何引用对象的 CPU 寄存器；根引用对象中引用的对象；GC Handle table；Freachable 队列等。</p>
<p><strong>对性能的影响</strong></p>
<p>标记阶段是一个 “几乎仅有只读操作” 的阶段。这个阶段中没有任何对象被移动，也没有任何内存被回收。</p>
<ul>
<li>1，当进行一次完整的标记时，垃圾回收器几乎遍历了每一个被引用的对象。若这部分数据并不存在于程序工作区（working set）中就会造成页面错误，从而导致重新加载对象时缓存丢失（cache miss）与缓存抖动(cache thrashing)。</li>
<li>2，在一个多处理器系统中，当垃圾回收器在对象的头部进行位标记操作时，若相应的对象已被加载至其他处理器的缓存中，则会造成缓存失效。</li>
<li>3，标记阶段的性能取决于引用图中对象的数目，但是和对象占用的内存大小并无关系。</li>
</ul>
<h5 id="根"><a href="#根" class="headerlink" title="根"></a>根</h5><p>垃圾回收器遍历对象图中所有被应用程序引用的对象。为了正确的遍历图中的对象，需要选定一系列起点保证引用对象的遍历，这些起点称为 <strong>根</strong>。</p>
<p><strong>1.局部根</strong></p>
<p>局部变量是一种最显而易见的根。</p>
<p><strong>2.静态根</strong></p>
<p>另一种类型的根是 <strong>静态变量</strong>。静态成员类型在类型加载时被创建，并且可以在整个应用程序域（ application domain ）的生命周期内作为潜藏根。</p>
<p>例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">event</span> EventHandler ButtonClick;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Button button = <span class="keyword">new</span> Button();</span><br><span class="line">            ButtonClick += button.OnClick;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Button</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnClick</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码会造成内存泄漏。因为静态事件包含一个委托列表，而这个委托列表引用了我们创建的对象。<br><font color=#0099ff size=4 face="黑体">事实上，.NET 内存泄漏的最普遍原因是静态变量引用了对象。</font></p>
<p>可以使用 SOS.DLL 查看根，!gcroot 命令提供跟得类型和引用链的简明信息。</p>
<h4 id="清理阶段与压缩阶段"><a href="#清理阶段与压缩阶段" class="headerlink" title="清理阶段与压缩阶段"></a>清理阶段与压缩阶段</h4><p><strong>清理</strong></p>
<p>针对所有不可达对象进行清除操作，针对普通对象直接回收内存，而对于实现了终结器的对象（实现了析构函数的对象）需要单独回收处理。清除之后，内存就会变得不连续了，这时就需要压缩阶段了。</p>
<p>建议不要随意手动调用垃圾回收 GC.Collect()，GC 会选择合适的时机、合适的方式进行内存回收的。</p>
<p><strong>压缩</strong></p>
<p>把剩下的对象转移到一个连续的内存，因为这些对象地址变了，还需要把那些 Root 根指针的地址修改为移动后的新地址。</p>
<p><img src="/img/net-mem-02-mark-compact.png" alt="net-mem-02-mark-compact.png"></p>
<p><strong>性能影响</strong></p>
<ul>
<li>1，移动对象意味着内存复制，这对于内存占用多的对象来说是昂贵的开销。</li>
<li>2，对象被移动之后，所有的引用的值必须更新其地址。对于频繁引用的对象来说，这种分散的内存操作势必造成性能影响。</li>
</ul>
<p><strong>固定</strong></p>
<p>该场景涉及到托管对象传递给非托管代码。</p>
<h3 id="垃圾回收器的特性"><a href="#垃圾回收器的特性" class="headerlink" title="垃圾回收器的特性"></a>垃圾回收器的特性</h3><p>垃圾回收器是如何和其他应用程序线程（通常称为赋值线程，mutator thread）进行交互的。</p>
<h4 id="垃圾回收时暂停线程"><a href="#垃圾回收时暂停线程" class="headerlink" title="垃圾回收时暂停线程"></a>垃圾回收时暂停线程</h4><p>垃圾回收器和其他应用程序线程并发执行可以产生的问题：</p>
<ul>
<li>假阴性（false negative）:一个对象满足垃圾回收的条件，但被标记为活动的。</li>
<li>假阳性（false positive）:一个对象被认为是可回收对象，但它依然被应用程序所引用。尽量避免该情况发生。</li>
</ul>
<h4 id="在垃圾回收时挂起线程"><a href="#在垃圾回收时挂起线程" class="headerlink" title="在垃圾回收时挂起线程"></a>在垃圾回收时挂起线程</h4><p>垃圾回收时会在安全点（safe point）出挂起线程，JIT 编译器通过生成额外的信息确保只有安全的时候才挂起线程进行垃圾回收。而 CLR 也会尝试安全的挂起线程。</p>
<p>非托管线程并不会由于托管线程的挂起而受到影响，除非它已经切换回了托管线程，这一过程有平台调用转换器负责的。</p>
<h5 id="在标记阶段挂起线程"><a href="#在标记阶段挂起线程" class="headerlink" title="在标记阶段挂起线程"></a>在标记阶段挂起线程</h5><p><strong>出现假阳性</strong><br>如果垃圾回收器在对象创建之前，已经完成了相关部分引用图更新，那么一个刚刚被创建的对象，即使已经被应用程序引用，也可能判断为未引用。</p>
<p><strong>出现假阴性</strong><br>对于一个已经被标记的对象，如果它的最后一个引用在标记阶段被移除，那么这个本该被回收的对象就会继续存活。<br>如果对象真的不可达，那就不可能重新变成可达状态，它将在下一轮垃圾回收周期中被回收。</p>
<h5 id="在清理阶段挂起线程"><a href="#在清理阶段挂起线程" class="headerlink" title="在清理阶段挂起线程"></a>在清理阶段挂起线程</h5><p>CLR 禁止应用程序和垃圾回收过程并发执行。</p>
<h4 id="工作站垃圾回收"><a href="#工作站垃圾回收" class="headerlink" title="工作站垃圾回收"></a>工作站垃圾回收</h4><p>工作站垃圾回收（workstation GC）,分为<strong>并发工作站垃圾回收</strong> 与 <strong>非并发工作站垃圾回收</strong></p>
<p><strong>并发工作站垃圾回收</strong></p>
<p>并发工作站垃圾回收 是默认的特征。在并发工作站垃圾回收下，有一个独立的专门的垃圾回收线程。该线程在执行垃圾回收的过程时，始终具有 THRAD_PRIORITY_HIGHEST 优先级。CRL 可以决定是否允许某些垃圾回收阶段与应用程序线程并发执行。<br>图形界面应用程序应该尽量避免从 UI 线程触发垃圾回收，即在后台线程进行资源分配，且不要显示的从 UI 线程调用 GC.Collect 方法。因为UI线程被垃圾回收阻塞的同时，其它应用程序线程却在和垃圾回收过程争抢资源。</p>
<p><strong>非并发工作站垃圾回收</strong></p>
<p>非并发工作站垃圾回收特征在标记和清理阶段均会挂起应用程序线程。适用于从 UI 线程触发垃圾回收的情形。<br>由于在 UI 线程等待垃圾回收时，其它的后台线程不会和垃圾回收器争夺资源，一次 UI 线程可以即可恢复响应。</p>
<h4 id="服务器垃圾回收"><a href="#服务器垃圾回收" class="headerlink" title="服务器垃圾回收"></a>服务器垃圾回收</h4><p>服务器垃圾回收专门针对服务器应用程序进行了优化。</p>
<p>使用服务器垃圾回收特征的唯一限制是物理处理器的数目。如果仅有一个处理器，则只能够选择工作站垃圾回收特征。</p>
<p>由于并发工作站垃圾回收是默认的垃圾回收特征，一般运行于默认的 CLR 宿主下的命令行，windonws 应用程序，windows 服务都使用默认的垃圾回收特征；不在默认的 CLR 宿主运行的应用程序则可以选择其他的垃圾回收特征。由于 IIS 大多安装在服务器上，在 IIS ASP.NET 宿主下运行的应用程序使用的就是服务器垃圾回收特征（可以通过 web.config 修改这个定义）</p>
<h4 id="切换垃圾回收特征"><a href="#切换垃圾回收特征" class="headerlink" title="切换垃圾回收特征"></a>切换垃圾回收特征</h4><p>在默认的宿主下，可以通过应用程序配置文件( app.config )修改垃圾回收特征及其子特征。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;runtime&gt;</span><br><span class="line">    &lt;gcServer enabled&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;gcConcurrent enabled&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;runtime&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p><strong>安全的使用低延迟垃圾回收</strong></p>
<p>安全的使用低延迟垃圾回收的唯一途径是将其放在受限执行区域（constrained execution region,CER）内。</p>
<p>需要引用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Runtime;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"></span><br><span class="line">GCLatencyMode oldModel = GCSettings.LatencyMode;</span><br><span class="line">RuntimeHelpers.PrepareConstrainedRegions();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    GCSettings.LatencyMode = GCLatencyMode.LowLatency;</span><br><span class="line">    <span class="comment">// Perform time-sensitive work here (执行时间敏感操作)</span></span><br><span class="line">&#125;<span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    GCSettings.LatencyMode = oldModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代龄（Generation）"><a href="#代龄（Generation）" class="headerlink" title="代龄（Generation）"></a>代龄（Generation）</h3><p>.NET 垃圾回收器的“代”模型（generational model）使用局部垃圾回收进行性能优化。</p>
<p>和真实世界的人和动物不同，.NET 认为年轻的对象更容易死亡，而年老的对象更倾向于存货。<br>年轻和年老的定义取决于应用程序垃圾回收的频率。在大多数应用程序中，临时对象（在一个方法张中分配的对象）大多是年轻的，而随着应用程序初始化的对象大多是年老的。</p>
<p>分代(Generation)算法 是 CLR 垃圾回收器采用的一种机制，它唯一的目的就是提升应用程序的性能。分代回收，速度显然快于回收整个堆。分代( Generation )算法的假设前提条件：</p>
<ul>
<li>1、大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长</li>
<li>2、对部分内存进行回收比基于全部内存的回收操作要快</li>
<li>3、新创建的对象之间关联程度通常较强。heap 分配的对象是连续的，关联度较强有利于提高 CPU cache 的命中率</li>
</ul>
<p>在 “代”模型 中，托管堆被划分为三个区域：第0代，第1代和第2代。</p>
<ul>
<li>第0代，最新分配在堆上的对象，从来没有被垃圾收集过。任何一个新对象，当它第一次被分配在托管堆上时，就是第0代（大于85000的大对象除外）。 </li>
<li>第1代，0代满了会触发0代的垃圾回收，0代垃圾回收后，剩下的对象会搬到1代。 </li>
<li>第2代，当0代、1代满了，会触发0代、1代的垃圾回收，第0代升为第1代，第1代升为第2代。</li>
</ul>
<p><img src="/img/net-mem-06-generation.png" alt="net-mem-06-generation.png"></p>
<p>大部分情况，GC 只需要回收0代即可，这样可以显著提高 GC 的效率，而且 GC 使用启发式内存优化算法，自动优化内存负载，自动调整各代的内存大小。</p>
<p>如果 Gen 0 heap 内存达到阀值，则触发0代GC，0代GC后Gen 0中幸存的对象进入Gen1。如果Gen 1的内存达到阀值，则进行1代GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，幸存的对象进入Gen2。</p>
<p>　　2代 GC 将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收，Gen 0和Gen 1比较小，这两个代龄加起来总是保持在16M左右；Gen2的大小由应用程序确定，可能达到几G，因此0代和1代GC的成本非常低，2代GC称为full GC，通常成本很高。粗略的计算0代和1代GC应当能在几毫秒到几十毫秒之间完成，Gen 2 heap比较大时，full GC可能需要花费几秒时间。大致上来讲 .NET 应用运行期间，2代、1代和0代GC的频率应当大致为1:10:100。</p>
<h4 id="第0代"><a href="#第0代" class="headerlink" title="第0代"></a>第0代</h4><p>第0代通常以 256KB-4MB 起步，根据使用情况缓慢增长。当第0代已满而不能完成一个新的内存分配请求时，第0代就会发起一次垃圾回收。<br>由于第0代的大小受高速缓存大小的影响，因此很可能在高速缓存中就可以找到第0代的所有对象。<font color=#0099ff size=4 face="黑体">第0代的所有对象几乎都在一次垃圾回收结束之后清理殆尽。</font><br>但是，仍然有一些对象会出于各种原因得以存活。</p>
<ul>
<li>应用程序具有糟糕的行为，分配的临时对象在一次垃圾回收之后仍然存活。</li>
<li>应用程序处于初始化阶段，这个阶段分配的对象多是长生命周期对象。</li>
<li>应用程序创建的是短期临时对象，但是在垃圾回收触发时这些对象恰巧正在被使用。</li>
</ul>
<p>这些撑过一次垃圾回收的对象不会被排列在第0代的起始位置。它们会被提升到第1代。</p>
<p><strong>跨代移动固定对象</strong></p>
<p>垃圾回收器无法移动固定的对象。但是 CLR 用一种非常巧妙的方法完成了固定对象的代升级：如果第0代由于固定对象的原因严重碎片化了，则 CLR 可以将整个第0代声明为更高代，并将一块新的内存声明为第0代，在这块内存中处理新的分配请求。</p>
<h4 id="第1代"><a href="#第1代" class="headerlink" title="第1代"></a>第1代</h4><p>第1代是第0代和第2代之间的缓冲区域。第1代典型的初始长度为 512KB-4MB。当第1代被填满时，会在第1代触发垃圾回收。只有第1代中的对象会被垃圾回收器标记和清除。自然触发第1代垃圾回收的唯一时机是在第0代垃圾回收后，存活的对象被提升至第1级时（另一种是手动触发垃圾回收）。</p>
<h4 id="第2代"><a href="#第2代" class="headerlink" title="第2代"></a>第2代</h4><p>第2代是在至少两次垃圾回收过程后存活对象的终极区域（还有大对象），在“代”模型中，这些对象属于老年对象，这些对象不太可能在短期内回收。<font color=#0099ff size=4 face="黑体">第2代区域不会人为的进行大小限制，它可以扩展到整个系统进程的专用内存空间，在32位系统中为2GB，在64位系统中最多为8TB。第2代中设定了动态阈值（水印）以触发垃圾回收操作。</font></p>
<p>若垃圾回收发生在第二代，则这是一个完全的垃圾回收。这是昂贵的，需要消耗最多的时间。</p>
<h4 id="大对象堆"><a href="#大对象堆" class="headerlink" title="大对象堆"></a>大对象堆</h4><p>大对象堆（large object heap,LOH）是一个专门容纳大对象的特殊区域。指内存占用大于85KB（85000字节）的对象。这个区域的主要特点就是：不会轻易被回收；就是回收了也不会被压缩（因为对象太大，移动复制的成本太高了）。</p>
<p><font color=#0099ff size=4 face="黑体">这个大小指对象本身的大小而非以该对象为根的整个对象树的大小。</font>因此，包含1000个字符串（每个字符串含有100个字符）的数组不是一个大对象，但是一个长度为50000的整数数组是一个大对象。</p>
<p>大对象从 LOH 中直接分配而不会放在第0代，第1代或者第2代中。</p>
<p>垃圾回收在 LOH 上进行回收时，并不会清理大对象并进行数据复制。LOH 维护了一个未使用内存的链表，新的内存分配请求可以从链表中进行。</p>
<p><font color=#0099ff size=4 face="黑体">当第2代对象占用的内存达到阈值时，则 LOH 就会进行垃圾回收。类似的，若 LOH 占用的内存达到阈值，也会触发第2代垃圾回收。因此，创建太多大型的临时对象也会造成类似 “中年危机” –必须进行完全回收以释放这些对象。LOH 中的碎片是另一个潜在问题，因为 LOH 中对象之间的空洞无法在清理阶段被移除并达到对堆进行碎片整理的效果。一个有效的策略是缓存并重用大对象，或者是（如果数组中对象的类型是一致的）分配一个大对象，然后在需要时手动将其分成小块。</font></p>
<h2 id="GC-Collect-方法"><a href="#GC-Collect-方法" class="headerlink" title="GC.Collect() 方法"></a>GC.Collect() 方法</h2><p>作用：强制进行垃圾回收。</p>
<p>Collect()：强制对所有代进行即时垃圾回收。</p>
<p>Collect(Int32)：强制对零代到指定代进行即时垃圾回收。</p>
<p>Collect(Int32, GCCollectionMode)：强制在 GCCollectionMode 值所指定的时间对零代到指定代进行垃圾回收</p>
<p>GC注意事项：</p>
<ul>
<li>1、只管理内存，非托管资源，如文件句柄，GDI 资源，数据库连接等还需要用户去管理。</li>
<li>2、循环引用，网状结构等的实现会变得简单。GC 的标志-压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除。</li>
<li>3、GC 通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于 COM 中的引用计数方法。</li>
<li>4、GC 在一个独立的线程中运行来删除不再被引用的内存。</li>
<li>5、GC 每次运行时会压缩托管堆。</li>
<li>6、你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。</li>
<li>7、对象的 Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数</li>
<li>8、Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer，不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer，而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。</li>
<li>9、.NET GC使用”代”(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。成员变量和全局变量很快变成第1代对象并最终成为第2代对象。</li>
<li>10、GC 对不同代的对象执行不同的检查策略以优化性能。每个 GC 周期都会检查第0代对象。大约1/10的 GC 周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。重新思考Finalization的代价：需要Finalization的对象可能比不需要 Finalization 在内存中停留额外9个GC周期。如果此时它还没有被Finalize，就变成第2代对象，从而在内存中停留更长时间。</li>
</ul>
<h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><p>一个高代对象引用一个低代对象的情形只会在一种类型的语句中出现：将一个非空引用类型对象赋值给一个引用类型的实例的成员变量（或者复制给一个数组的元素）。</p>
<h2 id="非托管资源回收"><a href="#非托管资源回收" class="headerlink" title="非托管资源回收"></a>非托管资源回收</h2><p>&emsp;&emsp;非托管资源不受 CLR 或者垃圾回收器的管理（如内核对象句柄，数据库连接和非托管内存等）。释放非托管资源需要使用 终结化特性，即一个对象与一段特定的代码关联起来。这段代码必须在该对象（代表一个非托管资源）不再需要时执行。</p>
<p>常见的有：ApplicationContext, Brush, Component, ComponentDesigner, Container, Context, Cursor, FileStream, Font, Icon, Image, Matrix, Object, OdbcDataReader, OleDBDataReader, Pen, Regex, Socket, StreamWriter, Timer, Tooltip, 文件句柄, GDI资源, 数据库连接等等资源。</p>
<p>.NET 中提供释放非托管资源的方式主要是：Finalize() 和 Dispose()。</p>
<p>.NET的GC机制有这样两个问题：</p>
<ul>
<li>GC并不是能释放所有的资源。它不能自动释放非托管资源。</li>
<li>GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。</li>
</ul>
<p>　　GC 并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了 IDisposable 接口，IDisposable 接口定义了 Dispose 方法，这个方法用来供程序员显式调用以释放非托管资源。使用 using 语句可以简化资源管理。</p>
<p>当你用 Dispose 方法释放未托管对象的时候，应该调用 GC.SuppressFinalize。如果对象正在终结队列( finalization queue ), GC.SuppressFinalize 会阻止 GC 调用 Finalize 方法。因为 Finalize 方法的调用会牺牲部分性能。如果你的 Dispose 方法已经对委托管资源作了清理，就没必要让 GC 再调用对象的 Finalize 方法。</p>
<h3 id="终结器"><a href="#终结器" class="headerlink" title="终结器"></a>终结器</h3><p>所有实现了终结器（析构函数）的对象，会被 GC 特殊照顾，GC 的终止化队列跟踪所有实现了 Finalize 方法（析构函数）的对象。</p>
<ul>
<li>当 CLR 在托管堆上分配对象时，GC 检查该对象是否实现了自定义的 Finalize 方法（析构函数）。如果是，对象会被标记为可终结的，同时这个对象的指针被保存在名为终结队列的内部队列中。终结队列是一个由垃圾回收器维护的表，它指向每一个在从堆上删除之前必须被终结的对象。</li>
<li>当 GC 执行并且检测到一个不被使用的对象时，需要进一步检查“终结队列”来查询该对象类型是否含有 Finalize 方法，如果没有则将该对象视为垃圾，如果存在则将该对象的引用移动到另外一张 Freachable 列表，此时对象会被复活一次。</li>
<li>CLR 将有一个单独的高优先级线程负责处理 Freachable 列表，就是依次调用其中每个对象的 Finalize 方法，然后删除引用，这时对象实例就被视为不再被使用，对象再次变成垃圾。</li>
<li>下一个 GC 执行时，将释放已经被调用 Finalize 方法的那些对象实例。</li>
</ul>
<p>简单总结：Finalize() 可以确保非托管资源会被释放，但需要很多额外的工作（比如终结对象特殊管理），而且 GC 需要执行两次才会真正释放资源。唯一的优点就是不需要显示调用。</p>
<h3 id="Finalization-Queue-和-Freachable-Queue"><a href="#Finalization-Queue-和-Freachable-Queue" class="headerlink" title="Finalization Queue 和 Freachable Queue"></a>Finalization Queue 和 Freachable Queue</h3><p>　　这两个队列和 .NET 对象所提供的 Finalize 方法有关。这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了 new 操作符在 Managed Heap 上分配空间时，GC 会对其进行分析，如果该对象含有 Finalize 方法则在 Finalization Queue 中添加一个指向该对象的指针。</p>
<p>　　在 GC 被启动以后，经过 Mark 阶段分辨出哪些是垃圾。再在垃圾中搜索，如果发现垃圾中有被 Finalization Queue 中的指针所指向的对象，则将这个对象从垃圾中分离出来，并将指向它的指针移动到 Freachable Queue 中。这个过程被称为是对象的复生（Resurrection），本来死去的对象就这样被救活了。为什么要救活它呢？因为这个对象的 Finalize 方法还没有被执行，所以不能让它死去。Freachable Queue 平时不做什么事，但是一旦里面被添加了指针之后，它就会去触发所指对象的 Finalize 方法执行，之后将这个指针从队列中剔除，这是对象就可以安静的死去了。</p>
<p>　　.NET Framework 的 System.GC 类提供了控制Finalize的两个方法，ReRegisterForFinalize 和 SuppressFinalize。前者是请求系统完成对象的 Finalize 方法，后者是请求系统不要完成对象的 Finalize 方法。ReRegisterForFinalize 方法其实就是将指向对象的指针重新添加到 Finalization Queue 中。这就出现了一个很有趣的现象，因为在 Finalization Queue 中的对象可以复生，如果在对象的 Finalize 方法中调用 ReRegisterForFinalize 方法，这样就形成了一个在堆上永远不会死去的对象，像凤凰涅槃一样每次死的时候都可以复生。</p>
<h3 id="手动确定性终结化"><a href="#手动确定性终结化" class="headerlink" title="手动确定性终结化"></a>手动确定性终结化</h3><p>手动确定性终结化，需要客户端释放资源。</p>
<h3 id="自动非确定性终结化"><a href="#自动非确定性终结化" class="headerlink" title="自动非确定性终结化"></a>自动非确定性终结化</h3><p>Finalize 来自 System.Object 中受保护的虚方法 Finalize，无法被子类显示重写，也无法显示调用。她的作用就是用来释放非托管资源，由 GC 来执行回收，因此可以保证非托管资源可以被释放。</p>
<ul>
<li>无法被子类显示重写：.NET 提供类似 C++ 析构函数的形式来实现重写，因此也有称之为析构函数，但其实她只是外表和C++ 里的析构函数像而已。</li>
<li>无法显示调用：由 GC 来管理和执行释放，不需要手动执行了，不用担心忘记调用Dispose。</li>
</ul>
<p>&emsp;&emsp;任何一种类型都可以通过重写 System.Object 定义的（protected）Finalize 方法表明该类型需要进行自动化终结。例如在 File 类中自动终结化方法 ~File（终结器,析构函数）。在对象将被销毁时，该方法必须得到执行。值类型只有在装箱的情况下才有垃圾回收的必要。</p>
<p>&emsp;&emsp;当一个拥有终结器的对象被创建时，他的一个引用将被添加到一个特殊的运行时队列上，成为终结队列（finalization queue）。这个队列被垃圾回收器界定为根。这意味着即使应用程序没有针对这个引用对象的引用，它仍然会子啊终结队列上保持活动状态。</p>
<p>&emsp;&emsp;当这个对象不再被应用程序引用，并开始垃圾回收时，若垃圾回收发现唯一一个针对该对象的引用来自于终结队列，则它会将这个对象的引用移动到另一个运行时管理的队列上，成为终结可达队列（freacheable queue）。该队列仍然被界定为根，因而，该对象仍然在被引用并保持存活。</p>
<p>&emsp;&emsp;<font color=#0099ff size=4 face="黑体">对象的终结器不会在垃圾回收的过程中执行。</font>在 CLR 初始化的过程会创建一个特殊的线程，称为 终结器线程（finalizaer thread）(每一个进程只会有一个终结器线程，这和垃圾回收器特征无关，该线程运行在 THREAD_PRIORITY_HIGHEST 优先级上)。这个线程会反复等待终结化事件（finalization event）的触发。在垃圾回收器完成垃圾回收并触发该事件后，如果终结可达队列中有对象放入，则终结器线程就会被激活。终结器线程将对象的引用从终结可达队列中移除，同时同步执行对象上的终结器方法。而当下一次垃圾回收开始时，由于该对象再无引用，因此垃圾回收可以将其内存回收。</p>
<h3 id="非确定性终结的缺点"><a href="#非确定性终结的缺点" class="headerlink" title="非确定性终结的缺点"></a>非确定性终结的缺点</h3><ul>
<li>有终结器的对象将至少位于第1代，更容易经历“中年危机”，从而更容易进行多次完整回收。</li>
<li>终结器线程的压力（有很多对象需要进行终结化）可能导致内存泄漏。如果应用程序线程分配对象的频率比终结器线程终结化对象的频率更高，那么应用程序将从等待终结化的对象中持续的泄漏内存。</li>
<li>自动非确定性终结化还是很多难以发现或调试错误的来源。因为终结化是异步的，因此多个对象的终结顺序是难以保证的。</li>
</ul>
<p><strong>终结器也许永远不会被调用</strong></p>
<p>&emsp;&emsp;终结器无法在进程被野蛮的关闭时执行。如用户通过任务管理器或者 TerminateProcess API 终止线程的执行，则终结器将无法进行资源回收。</p>
<p><strong>对象的复活</strong></p>
<p>终结化为对象提供了一个在其不被应用程序引用的情况下执行任意代码的机会。这种机会可以用于创建一个应用程序到该对象的引用，在对象即将失效时，另其起死回生，这种能力称为复活（resurrection）。主要的风险是，该对象引用的其它对象有可能已经被终结化而处于无效状态，此时，只能重新初始化该对象所有引用的对象；另一个问题是该对象的终结器不会被执行，因此你需要将该对象的引用作为参数传递个 GC.ReRegisterForFinnalize 方法。</p>
<p>适用于复活机制的场景之一就是对象池（object pooling）。</p>
<h3 id="Dispose模式"><a href="#Dispose模式" class="headerlink" title="Dispose模式"></a>Dispose模式</h3><p>.Net 规定所有需要进行确定终结化的对象都必须实现 IDisposable 接口。而该接口仅有一个方法，即 Dispose 方法。这个方法会释放非托管资源，进行确定终结化。</p>
<p>Dispose 需要手动调用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1：显示接口调用</span></span><br><span class="line">SomeType st1=<span class="keyword">new</span> SomeType();</span><br><span class="line"><span class="comment">//do sth</span></span><br><span class="line">st1.Dispose();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：using()语法调用，自动执行Dispose接口</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> st2 = <span class="keyword">new</span> SomeType())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一种方式，显示调用，缺点显而易见，如果程序猿忘了调用接口，则会造成资源得不到释放。或者调用前出现异常，当然这一点可以使用 try…finally 避免。</p>
</li>
<li><p>建议使用第二种实现方式，他可以保证无论如何 Dispose 接口都可以得到调用，原理其实很简单，using() 的 IL 代码如下图，因为 using 只是一种语法形式，本质上还是 try…finally 的结构。</p>
</li>
</ul>
<p><img src="/img/151257-20160309235625475-414934067.png" alt="151257-20160309235625475-414934067.png"></p>
<p>微软是推荐同时实现 IDisposable 接口和 Finalize （析构函数），其实 FCL 中很多类库都是这样实现的，这样可以兼具两者的优点：</p>
<ul>
<li>如果调用了 Dispose，则可以忽略对象的终结器，对象一次就回收了；</li>
<li>如果忘了调用 Dispose，则还有一层保障，终结器会负责对象资源的释放；</li>
</ul>
<h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h2><p>尽量不要手动执行垃圾回收的方法：GC.Collect()</p>
<p>垃圾回收的运行成本较高（涉及到了对象块的移动、遍历找到不再被使用的对象、很多状态变量的设置以及 Finalize 方法的调用等等），对性能影响也较大，因此我们在编写程序时，应该避免不必要的内存分配，也尽量减少或避免使用 GC.Collect() 来执行垃圾回收，一般 GC 会在最适合的时间进行垃圾回收。</p>
<p>需要注意，在执行垃圾回收的时候，所有线程都是要被挂起的（如果回收的时候，代码还在执行，那对象状态就不稳定了，也没办法回收了）。</p>
<p>推荐 Dispose 代替 Finalize</p>
<p>如果你了解 GC 内存管理以及 Finalize 的原理，可以同时使用 Dispose 和 Finalize 双保险，否则尽量使用 Dispose。</p>
<p>选择合适的垃圾回收机制：工作站模式、服务器模式。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用（weak reference）是用于管理托管对象引用的附加机制。典型的对象引用（通常为强引用（strong reference））是明确的：只要还拥有一个对象的引用，那么这个对象就会存活。这种行为的正确性是有垃圾回收器保证的。</p>
<p>但在某些情况下，我们还希望有一种隐形的 “绳索”，即能够绑在对象上，又不影响垃圾回收器回收它占用的内存。如果垃圾回收器回收了这个对象，那么我们可以探测到绳索的一端和对象断开了。如果垃圾回收器还没有处理这个对象，我们可以牵动“绳索”来获得这个对象的一个强引用并在此使用这个对象。</p>
<p>常见的场景：</p>
<ul>
<li>在不保持对象的存活的情况下提供外部服务。例如，定时器和事件服务可以为对象所用，但并不需要维持对象的引用。这可以避免很多典型的内存泄漏问题。</li>
<li>可以自动管理缓存或池策略。一个缓存可以保有最近使用对象的弱引用而不妨碍他们被回收。一个池可以划分为一个非常小的部分用以维持一小部分对象的强引用，以及另外一个可选部分对象的弱引用。</li>
<li>用以保存一个大对象的引用，并寄希望于它不会被回收。应用程序可以持有一个需要长时间才能初始化的大对象的弱引用。若这个对象被回收，则重新初始化该对象，否则可以在需要时直接复用该对象。</li>
</ul>
<p>引用程序代码可以通过 <code>System.WeakReference</code> 类来使用弱引用。可以基于 <code>System.WeakReference</code> 实现事件，这样可以规避.NET内存泄漏的元凶–忘记反注册事件。</p>
<p>弱引用默认不会跟踪对象的复活。若想允许复活追踪功能，就使用重载的构造函数并将第二个参数传参为true。</p>
<p><font color=#0099ff size=4 face="黑体">允许追踪对象复活状态的弱引用称为长弱引用（long weak reference）；不追踪对象复活状态的弱引用称为短弱引用（short weak reference）。</font></p>
<p><strong>垃圾回收句柄</strong></p>
<p>弱引用是一类特殊的垃圾回收句柄（ GC handle ）。一个垃圾回收句柄是一个特殊的底层值类型，它为对象引用提供了如下的功能。</p>
<ul>
<li>维持一个对象的标准的（强）引用，防止对象被回收。以 GCHandleType.Normal 表示。</li>
<li>维持一个对象的短弱引用。以 GCHandleType.Weak 表示。</li>
<li>维持一个对象的长弱引用。以 GCHandleType.WeakTrackResurrection 表示。</li>
<li>维持一个对象的引用，并进行固定，以防止它在内存中被移动。如果需要还可以获得该对象的地址。以 GCHandleType.Pinned 表示。</li>
</ul>
<p>实际开发中，我们几乎没有直接使用垃圾回收句柄的需要。但是它们，作为另一种可以保持对象的根，经常出现在诊断结果中。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/anding/p/5260319.html">.NET面试题解析(06)-GC与内存管理</a></p>
<p><a target="_blank" rel="noopener" href="https://kb.cnblogs.com/page/106720/">C#技术漫谈之垃圾回收机制(GC)</a></p>
<p>[.Net性能优化]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/12/14/CSharp%E8%BD%AC%E6%8D%A2%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/14/CSharp%E8%BD%AC%E6%8D%A2%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">CSharp转换关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-14 10:39:56" itemprop="dateCreated datePublished" datetime="2018-12-14T10:39:56+00:00">2018-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 14:44:28" itemprop="dateModified" datetime="2021-04-29T14:44:28+00:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">CSharp基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSharp转换关键字"><a href="#CSharp转换关键字" class="headerlink" title="CSharp转换关键字"></a>CSharp转换关键字</h1><h2 id="explicit-显示转换"><a href="#explicit-显示转换" class="headerlink" title="explicit(显示转换)"></a>explicit(显示转换)</h2><p><code>explicit</code>:必须通过转换来调用的用户定义的类型转换运算符。</p>
<p>&emsp;&emsp;此转换运算符从源类型转换为目标类型。 源类型提供转换运算符。 不同于隐式转换，显式转换运算符必须通过转换的方式来调用。 如果转换操作会导致异常或丢失信息，则应将其标记为 explicit。 这可阻止编译器静默调用可能产生意外后果的转换操作。<br>省略转换将导致编译时错误 CS0266。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Digit</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span> <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">byte</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define explicit byte-to-Digit conversion operator:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">byte</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Digit d = <span class="keyword">new</span> Digit(b);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;conversion occurred&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ExplicitTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span> b = <span class="number">3</span>;</span><br><span class="line">            Digit d = (Digit)b; <span class="comment">// explicit conversion</span></span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; Exception caught.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">conversion occurred</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="implicit-隐式转换"><a href="#implicit-隐式转换" class="headerlink" title="implicit(隐式转换)"></a>implicit(隐式转换)</h2><p><code>implicit</code> 关键字用于声明隐式的用户定义类型转换运算符。 如果可以确保转换过程不会造成数据丢失，则可使用该关键字在用户定义类型和其他类型之间进行隐式转换。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Digit</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">double</span> d</span>)</span> &#123; val = d; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> val;</span><br><span class="line">    <span class="comment">// ...other members</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// User-defined conversion from Digit to double</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">double</span>(<span class="params">Digit d</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> d.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  User-defined conversion from double to Digit</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">double</span> d</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Digit(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Digit dig = <span class="keyword">new</span> Digit(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//This call invokes the implicit &quot;double&quot; operator</span></span><br><span class="line">        <span class="built_in">double</span> num = dig;</span><br><span class="line">        <span class="comment">//This call invokes the implicit &quot;Digit&quot; operator</span></span><br><span class="line">        Digit dig2 = <span class="number">12</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;num = &#123;0&#125; dig2 = &#123;1&#125;&quot;</span>, num, dig2.val);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">num = 7 dig2 = 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="operator-运算符"><a href="#operator-运算符" class="headerlink" title="operator(运算符)"></a>operator(运算符)</h2><p>operator作用：</p>
<ul>
<li>1, 重载内置运算符</li>
<li>2, 在类或结构声明中提供用户定义的转换</li>
</ul>
<p>若要在自定义类或结构上重载运算符，可以在相应的类型中创建运算符声明。 重载内置 C# 运算符的运算符声明必须满足以下规则：</p>
<ul>
<li>同时包含 public 和 static 修饰符。</li>
<li>包含 operator X，其中 X 是被重载运算符的名称或符号。</li>
<li>一元运算符具有一个参数，二元运算符具有两个参数。 在每种情况下，都必须至少有一个参数与声明运算符的类或结构的类型相同。</li>
</ul>
<p>注：<font color=#0099ff size=4 face="黑体"><br>1,一元运算符：++，–，!;<br>2,二元运算符：+，-，* /;<br>3,三元运算符：a=3&gt;4?3:4<br></font></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> num, den;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fraction</span>(<span class="params"><span class="built_in">int</span> num, <span class="built_in">int</span> den</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.den = den;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload operator +</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> +(Fraction a, Fraction b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction(a.num * b.den + b.num * a.den,</span><br><span class="line">           a.den * b.den);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload operator *</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> *(Fraction a, Fraction b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction(a.num * b.num, a.den * b.den);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user-defined conversion from Fraction to double</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">double</span>(<span class="params">Fraction f</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">double</span>)f.num / f.den;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Fraction a = <span class="keyword">new</span> Fraction(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Fraction b = <span class="keyword">new</span> Fraction(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        Fraction c = <span class="keyword">new</span> Fraction(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        Console.WriteLine((<span class="built_in">double</span>)(a * b + c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">0.880952380952381</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/explicit">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/explicit</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">407</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">173</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
