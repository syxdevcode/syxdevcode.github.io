<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/5/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">网络数据包发送和接收过程解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 10:34:08" itemprop="dateCreated datePublished" datetime="2021-03-01T10:34:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h2><p><img src="/img/651016-20190403213253371-112748496.png" alt="651016-20190403213253371-112748496.png"></p>
<h2 id="数据包名称简介"><a href="#数据包名称简介" class="headerlink" title="数据包名称简介"></a>数据包名称简介</h2><ul>
<li>包：可以说是全能性术语；</li>
<li>帧：用于表示数据链路层中包的单位；</li>
<li>数据包：是 IP 和 UDP 等网络层以上的分层中包的单位；</li>
<li>段：则表示 TCP 数据流中的信息；</li>
<li>消息：是指应用协议中数据的单位。</li>
</ul>
<p>&emsp;&emsp;每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="/img/651016-20190403213115559-1163198356.jpg" alt="651016-20190403213115559-1163198356.jpg"></p>
<h2 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h2><p>用户 a 向用户 b 发送邮件为例子：</p>
<p><img src="/img/1c7ddca5e0e0415c8b4c69047e680fc7.jpeg" alt="1c7ddca5e0e0415c8b4c69047e680fc7.jpeg"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090819.png" alt="微信截图_20210330090819.png"></p>
<p><strong>1，应用程序处理</strong></p>
<p>&emsp;&emsp;首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>
<p><strong>2，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>
<p><strong>3，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>
<p><strong>4，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<p><strong>5，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>
<p><strong>6，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>
<p><strong>7，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<p><strong>8，应用程序的处理</strong></p>
<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
<h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>
<p><strong>(1) TCP</strong> 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p>
<p><strong>(2) UDP</strong> 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
<p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>&emsp;&emsp;数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>
<p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p><img src="/img/3f35fe4b91bb4a27b4ab30f84639d32a.jpeg" alt="3f35fe4b91bb4a27b4ab30f84639d32a.jpeg"><br><img src="/img/65b24665096545c089a7a18300218c6d.jpeg" alt="65b24665096545c089a7a18300218c6d.jpeg"></p>
<ul>
<li>(1) 和 (2) 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</li>
<li>(3) 和 (1) 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li>
<li>当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li>
</ul>
<h4 id="端口号的确定"><a href="#端口号的确定" class="headerlink" title="端口号的确定"></a>端口号的确定</h4><ul>
<li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 <code>0~1023</code> 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 <code>1024~49151</code> 之间，不过这些端口号可用于任何通信用途。</li>
<li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 <code>49152~65535</code> 之间。</li>
</ul>
<h4 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h4><p>&emsp;&emsp;端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li>
<li>UDP 将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>
<li>传输途中出现丢包，UDP 也不负责重发。</li>
<li>当包的到达顺序出现乱序时也没有纠正的功能。</li>
<li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li>
</ul>
<p>UDP 常用于一下几个方面：</p>
<ul>
<li>1.包总量较少的通信（DNS、SNMP等）；</li>
<li>2.视频、音频等多媒体通信（即时通信）；</li>
<li>3.限定于 LAN 等特定网络中的应用通信；</li>
<li>4.广播通信（广播、多播）。</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>&emsp;&emsp;TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
<p>&emsp;&emsp;根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>&emsp;&emsp;TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。三次握手是指建立一个 TCP 连接时,需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p>
<p><img src="/img/3148139034514574a74a055e2a35b6fd.jpeg" alt="3148139034514574a74a055e2a35b6fd.jpeg"></p>
<ul>
<li><strong>第一次握手</strong>：客户端将标志位 <code>SYN</code> 置为1，随机产生一个值 <code>seq=J</code>，并将该数据包发送给服务器端，客户端进入 <code>SYN_SENT</code> 状态，等待服务器端确认。</li>
<li><strong>第二次握手</strong>：服务器端收到数据包后由标志位 <code>SYN=1</code>,知道客户端请求建立连接，服务器端将标志位 <code>SYN</code> 和 <code>ACK</code> 都置为1，<code>ack=J+1</code>，随机产生一个值 <code>seq=K</code> ，并将该数据包发送给客户端以确认连接请求，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
<li><strong>第三次握手</strong>：客户端收到确认后，检查 <code>ack</code> 是否为 <code>J+1</code>，<code>ACK</code> 是否为1，如果正确,则将标志位 <code>ACK</code>置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查 <code>ack</code> 是否为 <code>K+1</code>， <code>ACK</code> 是否为1，如果正确则连接建立成功，客户端和服务器端进入 <code>ESTABLISHED</code> 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>&emsp;&emsp;四次挥手即终止 TCP 连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在 <code>socket</code> 编程中，这一过程由 客户端 或 服务端 任一方执行 <code>close</code> 来触发。</p>
<p>&emsp;&emsp;由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 <code>FIN</code> 来终止这一方向的连接，收到一个 <code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了 <code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><img src="/img/3e49dad546ba48eca6777783a8456a97.jpeg" alt="3e49dad546ba48eca6777783a8456a97.jpeg"></p>
<p>中断连接端可以是客户端，也可以是服务器端。</p>
<ul>
<li><strong>第一次挥手</strong>：客户端发送一个 <code>FIN=M</code>，用来关闭客户端到服务器端的数据传送，客户端进入 <code>FIN_WAIT_1</code> 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li><strong>第二次挥手</strong>：服务器端收到 <code>FIN</code> 后，先发送 <code>ack=M+1</code>，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 <code>FIN_WAIT_2</code> 状态，继续等待服务器端的 <code>FIN</code> 报文。</li>
<li><em>第三次挥手*</em>：当服务器端确定数据已发送完成，则向客户端发送 <code>FIN=N</code> 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 <code>LAST_ACK</code> 状态。</li>
<li><em>第四次挥手*</em>：客户端收到 <code>FIN=N</code> 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 <code>ack=N+1</code> 后进入 <code>TIME_WAIT</code> 状态，如果 <code>Server</code> 端没有收到 <code>ACK</code> 则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了 <code>2MSL</code> 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，</p>
<p><img src="/img/4c5ab6ed942c431bbed30009959783c0.jpeg" alt="4c5ab6ed942c431bbed30009959783c0.jpeg"></p>
<h4 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h4><p>&emsp;&emsp;在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。 反之，则数据丢失的可能性很大。</p>
<p>&emsp;&emsp;在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>
<p>&emsp;&emsp;未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>
<p>&emsp;&emsp;此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>
<p>&emsp;&emsp;对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此引入了序列号。</p>
<p>&emsp;&emsp;序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p>
<h4 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h4><p>&emsp;&emsp;重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证 “确认应答一定能在这个时间内返回”。</p>
<p>&emsp;&emsp;TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</p>
<p>&emsp;&emsp;在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>
<p>&emsp;&emsp;此外， 数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>
<h4 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h4><p>&emsp;&emsp;在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，<font color=#ff0000 size=4 face="黑体">最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</font></p>
<p>&emsp;&emsp;TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</p>
<p>&emsp;&emsp;MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</p>
<h4 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h4><p>&emsp;&emsp;TCP 以 1 个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长,通信性能就越低。</p>
<p>&emsp;&emsp;为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p>
<p><img src="/img/8c6eab31573940a5bc369ea648d45591.jpeg" alt="8c6eab31573940a5bc369ea648d45591.jpeg"></p>
<p>&emsp;&emsp;窗口大小就是指：无需等待确认应答，而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段，同时进行确认应答的功能。</p>
<h4 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h4><p><img src="/img/0f015679fbef46deb30d6669d5e28ddf.jpeg" alt="0f015679fbef46deb30d6669d5e28ddf.jpeg"></p>
<p>&emsp;&emsp;上图中的窗口内的数据，即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>
<p>&emsp;&emsp;在滑动窗口以外的部分，包括未发送的数据，以及已经确认对端已收到的数据。当数据发出后，若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>
<p>&emsp;&emsp;收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为 <code>滑动窗口控制</code>。</p>
<h4 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h4><p>&emsp;&emsp;在使用窗口控制中， 出现丢包一般分为两种情况：</p>
<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>
<p><img src="/img/f665dba5def44bb8a9ae13848602442c.jpeg" alt="f665dba5def44bb8a9ae13848602442c.jpeg"></p>
<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为 <code>高速重发控制</code>。</p>
<p><img src="/img/1a1667fade0340998a1879a9f06d8511.jpeg" alt="1a1667fade0340998a1879a9f06d8511.jpeg"></p>
<h2 id="网络层中的-IP-协议"><a href="#网络层中的-IP-协议" class="headerlink" title="网络层中的 IP 协议"></a>网络层中的 IP 协议</h2><p>&emsp;&emsp;IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是 “实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点通信”。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090750.png" alt="微信截图_20210330090750.png"></p>
<ul>
<li>主机：配置有 IP 地址，不进行路由控制的设备。</li>
<li>路由器：既有 IP 地址又具有路由控制功能的设备。</li>
<li>节点：主机和路由器的统称。</li>
</ul>
<p>&emsp;&emsp;网络的下一层—数据链路层 的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上，也能实现两端节点之间的数据包传输。</p>
<p>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）、IP 分包与组包。</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>&emsp;&emsp;在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</p>
<p>&emsp;&emsp;作为网络层的 IP,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在 “连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</p>
<p>&emsp;&emsp;不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</p>
<p>&emsp;&emsp;IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</p>
<p><img src="/img/902f8a4e03a242ecb6e16e3f718371e6.jpeg" alt="902f8a4e03a242ecb6e16e3f718371e6.jpeg"></p>
<p>将 IP 地址的32位二进制进行计算，得出约 43 亿个 IP 地址。</p>
<p>实际上，网络的发展超乎想象，互联网上的设备远超 43 亿， 2019 年 11 月 25 日全球的 IPv4 地址已经彻底耗尽，但是直到现在大家仍然还在用 IPv4 ，并没有因为地址没了而无法上网。是因为除了 IPv6 之外，我们使用 NAT 技术缓解了地址不足的问题。</p>
<h4 id="IP-地址组成"><a href="#IP-地址组成" class="headerlink" title="IP 地址组成"></a>IP 地址组成</h4><p>IP 地址由网络号（网段地址）和主机号（主机地址）两部分组成。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330090934.png" alt="微信截图_20210330090934.png"></p>
<p><strong>IP地址的主机标识</strong></p>
<p>&emsp;&emsp;如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的 “主机标识” 则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠，即 IP 地址具有了唯一性。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091419.png" alt="微信截图_20210330091419.png"></p>
<p><strong>IP地址的网络标识</strong></p>
<p>&emsp;&emsp;如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091204.png" alt="微信截图_20210330091204.png"></p>
<h4 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h4><p>&emsp;&emsp;IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091531.png" alt="微信截图_20210330091531.png"></p>
<ul>
<li>A 类 IP 地址是首位以 <code>0</code> 开头的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 8 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>0.0.0.0~127.0.0.0</code> 是 A 类的网络地址。<font color=#ff0000 size=4 face="黑体">A 类地址的后 24 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为 <code>16,777,214</code>(2的24次方-2) 个。其中 0 和 127 属于保留地址，减去两个保留地址，因此有 126 个可用的 A 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091724.png" alt="微信截图_20210330091724.png"><br><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091808.png" alt="微信截图_20210330091808.png"></p>
<ul>
<li>B 类 IP 地址是前两位 <code>10</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 16 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>128.0.0.0~191.255.0.0</code> 是 B 类的网络地址。<font color=#ff0000 size=4 face="黑体">B 类地址的后 16 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为<code>65,534</code> (2的16次方-2)个。其中 <code>128.0</code> 和 <code>191.255</code> 属于保留地址，减去两个保留地址，因此有 16382 个可用的 B 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330091932.png" alt="微信截图_20210330091932.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092058.png" alt="微信截图_20210330092058.png"></p>
<ul>
<li>C 类 IP 地址是前三位为 <code>110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 24 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>192.0.0.0~223.255.255.0</code> 是 C 类的网络地址。<font color=#ff0000 size=4 face="黑体">C 类地址的后 8 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为 <code>254</code> (2的8次方-2)个。其中 <code>192.0.0</code> 和 <code>223.255.255</code> 属于保留地址，减去两个保留地址，因此有 <code>2097150</code> 个可用的 C 类地址。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092208.png" alt="微信截图_20210330092208.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330092307.png" alt="微信截图_20210330092307.png"></p>
<ul>
<li>D 类 IP 地址是前四位为 <code>1110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 32 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>224.0.0.0~239.255.255.255</code> 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li>
</ul>
<p><code>127.x.x.x</code> 段地址空间是被保留的回环地址。</p>
<p>&emsp;&emsp;在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 2的8次方- 2 = 254）个主机地址的原因。</p>
<h4 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h4><p>&emsp;&emsp;广播地址(<code>Broadcast Address</code>) 是专门用于同时向网络中所有工作站进行发送的一个地址。在使用 <code>TCP/IP</code> 协议的网络中，主机标识段 <code>host ID</code>为全1 (11111111，即十进制的255) 的IP 地址为广播地址，广播的分组传送给<code>host ID</code>段所涉及的所有计算机。例如，对于 <code>10.1.1.0</code> （255.0.0.0 ）网段，其直播广播地址为 <code>10.255.255.255</code> （255 即为 2 进制的11111111），当发出一个目的地址为 <code>10.255.255.255</code> 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<p>广播地址应用于网络内的所有主机,广播分为受限广播(本地广播)和直接广播两种。在本网络内的广播叫做受限广播(本地广播)；在不同网络之间的广播叫做直接广播。</p>
<ul>
<li>（1）受限广播(本地广播)<br>它不被路由发送，但会被送到相同物理网络段上的所有主机<br>IP地址的网络字段和主机字段全为1就是地址 <code>255.255.255.255</code></li>
<li>（2）直接广播<br>网络广播会被路由，并会发送到专门网络上的每台主机<br>IP地址的网络字段定义这个网络，主机字段通常全为1，如 <code>192.168.10.255</code></li>
</ul>
<h5 id="受限地址"><a href="#受限地址" class="headerlink" title="受限地址"></a>受限地址</h5><p>&emsp;&emsp;受限的广播地址是 <code>255.255.255.255</code>。该地址用于主机配置过程中IP数据包的目的地址，此时，主机可能还不知道它所在网络的网络掩码，甚至连它的IP地址也不知道。在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出本地网络中。</p>
<h5 id="指向网络"><a href="#指向网络" class="headerlink" title="指向网络"></a>指向网络</h5><p>&emsp;&emsp;指向网络的广播地址是主机号为全1(11111111)的地址。A类网络广播地址为 netid.255.255.255，其中netid为A类网络的网络号。一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p>
<h5 id="指向子网"><a href="#指向子网" class="headerlink" title="指向子网"></a>指向子网</h5><p>&emsp;&emsp;指向子网的广播地址为主机号为全1(11111111)且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。例如，如果路由器收到发往 <code>128.1.2.255</code> 的数据报，当B类网络 <code>128.1</code> 的子网掩码为 <code>255.255.255.0</code>时，该地址就是指向子网的广播地址；但如果该子网的掩码为 <code>255.255.254.0</code>，该地址就不是指向子网的广播地址。</p>
<h5 id="指向所有子网"><a href="#指向所有子网" class="headerlink" title="指向所有子网"></a>指向所有子网</h5><p>&emsp;&emsp;指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。指向所有子网的广播地址的子网号及主机号为全1。例如，如果目的子网掩码为 <code>255.255.255.0</code> ，那么IP地址 <code>128.1.255.255</code> 是一个指向所有子网的广播地址。然而，如果网络没有划分子网，这就是一个指向网络的广播。</p>
<h4 id="IP多播-组播"><a href="#IP多播-组播" class="headerlink" title="IP多播(组播)"></a>IP多播(组播)</h4><p>&emsp;&emsp;<code>IP多播</code>（也称 <code>多址广播</code> 或 <code>组播</code>）技术，是一种允许一台或多台主机（多播源）发送单一数据包到多台主机（一次的，同时的）的TCP/IP网络技术。多播作为一点对多点的通信，是节省网络带宽的有效方法之一。在网络音频/视频广播的应用中，当需要将一个节点的信号传送到多个节点时，无论是采用重复点对点通信方式，还是采用广播方式，都会严重浪费网络带宽，只有多播才是最好的选择。多播能使一个或多个多播源只把数据包发送给特定的多播组，而只有加入该多播组的主机才能接收到数据包。目前，IP多播技术被广泛应用在 网络音频/视频广播、AOD/VOD、网络视频会议、多媒体远程教育、”push”技术（如股票行情等）和虚拟现实游戏等方面。</p>
<p>&emsp;&emsp;有些应用会有这样的要求：一些分布在各处的进程需要以组的方式协同工作，组中的进程通常要给其他所有的成员发送消息。即有这样的一种方法能够给一些明确定义的组发送消息，这些组的成员数量虽然很多，但是与整个网络规模相比却很小。给这样一个组发送消息称为多点点播送，简称多播。需要注意的是多播数据包的目的ip地址实际上不可能对应某一台真实存在的主机的ip地址，也就是说该目的ip地址永远不可能作为源地址，即多播ip地址只能用于目的ip地址，不能用于源ip地址。</p>
<p>组播使用 D 类地址。因此 IP 地址前四位是 “1110” 开头的，就是组播地址。剩下的 28 位就是组播的组编号。组播的地址范围是 <code>224.0.0.0 ~ 239.255.255.255</code> ，其中 <code>224.0.0.0 ~ 224.0.0.255</code> 既可以在同一个网段内实现组播，又可以跨网段给全网所有组员发送组播包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093819.png" alt="微信截图_20210330093819.png"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330093945.png" alt="微信截图_20210330093945.png"></p>
<h5 id="1．多播地址和多播组"><a href="#1．多播地址和多播组" class="headerlink" title="1．多播地址和多播组"></a>1．多播地址和多播组</h5><p>&emsp;&emsp;IP多播通信必须依赖于IP多播地址，在 IPv4 中它是一个D类IP地址，并且ip首部中的协议字段为2，表明采用的是IGMP网际组管理协议。范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类。因此，如果从首位开始到第 4 位是 <code>1110</code> ，就可以认为是多播地址，而剩下的 28 位可以成为多播的组编号。所有的主机（路由器以外的主机和终端主机）必须属于 <code>224.0.0.1</code> 的组，所有的路由器必须属于 <code>224.0.0.2</code> 的组。</p>
<ul>
<li>局部链接多播地址范围在 <code>224.0.0.0~224.0.0.255</code>，这是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包；</li>
<li>预留多播地址为 <code>224.0.1.0~238.255.255.255</code>，可用于全球范围（如Internet）或网络协议；</li>
<li>管理权限多播地址为 <code>239.0.0.0~239.255.255.255</code>，可供组织内部使用，类似于私有IP地址，不能用于 Internet，可限制多播范围。</li>
</ul>
<p>&emsp;&emsp;使用同一个IP多播地址接收多播数据包的所有主机构成了一个主机组，也称为多播组。一个多播组的成员是随时变动的，一台主机可以随时加入或离开多播组，多播组成员的数目和所在的地理位置也不受限制，一台主机也可以属于几个多播组。此外，不属于某一个多播组的主机也可以向该多播组发送数据包。</p>
<h5 id="2-多播技术硬件支持"><a href="#2-多播技术硬件支持" class="headerlink" title="2. 多播技术硬件支持"></a>2. 多播技术硬件支持</h5><p>要实现IP多播通信，要求介于多播源和接收者之间的路由器、集线器、交换机以及主机均需支持IP多播。目前，IP多播技术已得到硬件、软件厂商的广泛支持。</p>
<ul>
<li>（1）主机<br>支持IP多播通信的平台包括 Windows CE 2.1、Windows 95、Windows 98、Windows NT 4 和 Windows 2000 等，运行这些操作系统的主机都可以进行IP多播通信。此外，新生产的网卡也几乎都提供了对IP多播的支持。</li>
<li>（2）集线器和交换机<br>目前大多数集线器、交换机只是简单地把多播数据当成广播来发送接收，但一些中、高档交换机提供了对IP多播的支持。例如，在 3COM SuperStack 3 Swith 3300 交换机上可启用 802.1p 或 IGMP 多播过滤功能，只为已侦测到IGMP 数据包的端口转发多播数据包。</li>
<li>（3）路由器<br>多播通信要求多播源节点和目的节点之间的所有路由器必须提供对 Internet组管理协议（IGMP）、多播路由协议（如PIM、DVMRP等）的支持。</li>
</ul>
<p>&emsp;&emsp;多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p>
<p><img src="/img/71e3a03024f04d32954f591d6e1edb43.jpeg" alt="71e3a03024f04d32954f591d6e1edb43.jpeg"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>&emsp;&emsp;子网掩码是在IPv4地址资源紧缺的背景下为了解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面。如果是都是使用的IPV6的话是没有子网掩码的概念。IPV6是端到端的连接通信，不需要子网了。</p>
<p>&emsp;&emsp;子网掩码用 32 位的二进制表示， IP 地址的网段地址部分设置为 1 ， IP 地址的主机地址部分设置为 0 。换句话说， IP 地址有多少位网段地址，子网掩码就有多少位取 1 ，其余都取 0 。为了方便记录，每 8 位为一组，以 <code>.</code> 隔开，再转换为十进制数。</p>
<p>将子网掩码和 IP 地址进行与（ AND ）运算，可得到这个 IP 地址的网段地址。</p>
<p>详情参考：<a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" title="IP4-子网掩码">IP4-子网掩码</a></p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">特征</th>
<th align="left">网络范围</th>
<th align="left">默认掩码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类地址</td>
<td align="left">第1个8位中的第1位始终为0</td>
<td align="left">0-127.x.x.x</td>
<td align="left">255.0.0.0/8</td>
</tr>
<tr>
<td align="left">B类地址</td>
<td align="left">第1个8位中的第1、2位始终为10</td>
<td align="left">128-191.x.x.x</td>
<td align="left">255.255.0.0/16</td>
</tr>
<tr>
<td align="left">C类地址</td>
<td align="left">第1个8位中的第1、2、3位始终为110</td>
<td align="left">192-y.x.x.x</td>
<td align="left">255.255.255.0/24</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</p>
<p><img src="/img/bb3cd3458dc94871a4a68f3fdd4897eb.jpeg" alt="bb3cd3458dc94871a4a68f3fdd4897eb.jpeg"></p>
<p>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用  <code>/</code> 隔开，如下：</p>
<p><img src="/img/050f0e2d38554dd89fdc4427226cc688.jpeg" alt="050f0e2d38554dd89fdc4427226cc688.jpeg"></p>
<h5 id="CIDR-与-VLSM"><a href="#CIDR-与-VLSM" class="headerlink" title="CIDR 与 VLSM"></a>CIDR 与 VLSM</h5><p>解决 IP 地址浪费问题，除了使用子网掩码，还使用了 CIDR 和 VLSM 技术。</p>
<p><strong>CIDR</strong> ，即无类域间路由，采用任意长度分割 IP 地址的网络号和主机号。它有两个作用：</p>
<ul>
<li>把多个网段聚合到一起，生成一个更大的网段；</li>
<li>汇总路由表 IP 地址，分担路由表压力。</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330094830.png" alt="微信截图_20210330094830.png"></p>
<p><strong>VLSM</strong> ，即可变长子网掩码，它可以对 A 、 B 、 C 类地址再进行子网划分，以达到充分利用 IP 地址的目的。</p>
<p>假如一家企业有 100 台电脑，按以前的办法，只能分配一个 C 类地址 <code>222.222.222.0</code> 。但是 VLSM 可以在一个 C 类地址上划分出多个子网地址，再分配其中一个容纳主机数量与稍大于企业需求数量的子网地址给企业，这样就可以实现 IP 地址的合理使用。</p>
<p>计算容纳 100 台电脑的子网：使用主机号的位数计算出子网的主机地址数量。当主机号有 7 位时，有 126 个可用主机地址，可容纳 100 台电脑。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095148.png" alt="微信截图_20210330095148.png"></p>
<p>计算子网地址：当主机号有 7 位时，网络号有 32 - 7 = 25 位，也就是 <code>222.222.222.0/24</code> 向主机位借了一位作为子网位，那么子网掩码也就是 <code>255.255.255.128</code>。可分配 <code>222.222.222.0/25</code> 使用。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095237.png" alt="微信截图_20210330095237.png"></p>
<p>222.222.222.0/25子网详情：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095312.png" alt="微信截图_20210330095312.png"></p>
<p><strong>CIDR 和 VLSM 的区别</strong></p>
<p>CIDR 是主机号向网络号借位，目的是把几个网络汇总成一个大的网络，增加子网主机数量；</p>
<p>VLSM 是网络号向主机号借位，目的是把一个标准的网络划分成几个子网，减少子网主机数量。</p>
<h4 id="公网地址与私有地址"><a href="#公网地址与私有地址" class="headerlink" title="公网地址与私有地址"></a>公网地址与私有地址</h4><p>IP 地址分为公网地址和私有地址。公网地址是在互联网上使用的，私有地址是在局域网中使用的。</p>
<p>公网地址由 Internet NIC 负责分配，通过它直接访问互联网。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095612.png" alt="微信截图_20210330095612.png"></p>
<p>私有地址是一段保留的 IP 地址。只在局域网中使用，无法在互联网上使用。但是私有地址可以通过 NAT 技术，将私有地址转换为公网地址接入互联网。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330095637.png" alt="微信截图_20210330095637.png"></p>
<p>公网 IP 地址在互联网范围内是唯一的，私有 IP 地址只要在同一个局域网内唯一即可。在不同局域网内出现相同的私有 IP 不会影响使用。</p>
<h3 id="IP路由"><a href="#IP路由" class="headerlink" title="IP路由"></a>IP路由</h3><p>&emsp;&emsp;发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于 <code>指明路由器或主机</code> 的信息，以便真正发往目标地址。保存这种信息的就是 <code>路由控制表</code>。</p>
<p>&emsp;&emsp;IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做 <code>路由协议</code> 的协议制作而成。</p>
<p>当一个数据包到达路由器时，路由器根据数据包的目的地址查询路由表，根据查询结果将数据包转发出去，这个过程就是 IP路由。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101202.png" alt="微信截图_20210330101202.png"></p>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>&emsp;&emsp;为了将数据包发给目的节点，所有节点都维护着一张路由表。路由表记录 IP 数据在下一跳应该发给哪个路由器。IP 包将根据这个路由表在各个数据链路上传输。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101335.png" alt="微信截图_20210330101335.png"></p>
<p>&emsp;&emsp;路由控制表的形成方式有两种：一种是管理员手动设置，也叫做 <strong>静态路由控制</strong>；另一种是路由器与其他路由器相互交换信息时自动刷新，叫做 <strong>动态路由控制</strong>。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101457.png" alt="微信截图_20210330101457.png"></p>
<h4 id="下一跳"><a href="#下一跳" class="headerlink" title="下一跳"></a>下一跳</h4><p>Hop ，中文叫 “跳”。它是指网络中的一个区间。IP 包就是在网络中一跳一跳的转发，在每一个区间内决定 IP 包下一跳的路径。</p>
<p>一跳是指数据链路中广播域的区间，也就是说不经过路由器而能直接到达的相连主机或路由器网卡的一个区间。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101607.png" alt="微信截图_20210330101607.png"></p>
<p>IP 数据包就像包裹，而送货车就像数据链路。包裹不可能自己移动，必须有送货车承载转运。而一辆送货车只能将包裹送到某个区间范围内。每个不同区间的包裹将由对应的送货车承载、运输。IP 的工作原理也是如此。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330101639.png" alt="微信截图_20210330101639.png"></p>
<h4 id="路由条目类型"><a href="#路由条目类型" class="headerlink" title="路由条目类型"></a>路由条目类型</h4><h5 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h5><p>默认路由是指路由表中任何一个地址都能与之匹配的条目。所有数据包都可以使用默认路由进行数据转发。默认路由为 <code>0.0.0.0/0</code> 或 <code>default</code> 。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102027.png" alt="微信截图_20210330102027.png"></p>
<h5 id="主机路由"><a href="#主机路由" class="headerlink" title="主机路由"></a>主机路由</h5><p><code>IP地址/32</code> 被称为主机路由，它是路由表中指向单个 IP 地址或主机名的路由条目。例如：<code>192.168.153.15/32</code> 就是一条主机路由，表示整个 IP 地址的所有位都将参与路由。</p>
<h5 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h5><p>以 127 开头的 IP 地址都是环回地址，其所在的回环接口可以理解为虚拟网卡。使用回环地址时，数据包会直接被主机的 IP 层获取，而不经过链路层，也不会流向网络。一般用来检查主机上运行的网络服务是否正常。</p>
<h4 id="路由汇总"><a href="#路由汇总" class="headerlink" title="路由汇总"></a>路由汇总</h4><p>路由汇总主要是为了减少路由条目，把可以聚合的路由汇聚为一个大网络。</p>
<p>路由表越大，查找路由表所需的内存和 CPU 也就越多，时间也会越长，导致转发 IP 数据包的性能下降。如果想要搭建大规模、高性能的网络，就需要尽可能的路由表的大小。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102240.png" alt="微信截图_20210330102240.png"><br><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102302.png" alt="微信截图_20210330102302.png"></p>
<h4 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h4><p>IP 地址的网络地址部分用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</p>
<p>&emsp;&emsp;在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p>
<p><img src="/img/97e1e1332e5445c5b3da354f7cf407f9.jpeg" alt="97e1e1332e5445c5b3da354f7cf407f9.jpeg"></p>
<h3 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h3><h4 id="数据链路与MTU"><a href="#数据链路与MTU" class="headerlink" title="数据链路与MTU"></a>数据链路与MTU</h4><p>数据链路不同， MTU 则不同。</p>
<p>&emsp;&emsp;每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同，网络层的 IP 是数据链路的上一层， IP 通过分片屏蔽数据链路的差异，实现不同数据链路互通。从 IP 的上一层看，它完全可以忽略各个数据链路上的 MTU ，只需要按照源 IP 地址发送的长度接收数据包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330102721.png" alt="微信截图_20210330102721.png"></p>
<h4 id="IP报文的分片与重组"><a href="#IP报文的分片与重组" class="headerlink" title="IP报文的分片与重组"></a>IP报文的分片与重组</h4><p>&emsp;&emsp;任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104125.png" alt="微信截图_20210330104125.png"></p>
<h4 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h4><p>分片机制有两点不足：</p>
<ul>
<li>加重路由器的处理性能；</li>
<li>在分片传输中，一旦某个分片丢失，会造成整个 IP 数据包作废。</li>
</ul>
<p>因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</p>
<p>为了应对分片机制的不足，<code>路径MTU发现</code>(Path MTU Discovery) 技术应运而生。</p>
<p>&emsp;&emsp;路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的值。即路径中存在的所有数据链路中最小的 MTU 。进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104310.png" alt="微信截图_20210330104310.png"></p>
<p>路径 MTU 发现的工作原理如下：</p>
<ul>
<li><p>1，发送端主机发送 IP 数据包时将其头部的分片禁止标志位设置为 1 。根据这个标志位，途中的路由器即使收到需要分片的大包，也不会分片，而是直接将包丢弃。之后通过一个 ICMP 不可达消息将数据链路上 MTU 值给发送端主机。</p>
</li>
<li><p>2，发送端主机根据收到的 MTU 值对数据包进行分片处理，再把 IP 数据包发送给相同的目的主机。如此重复，直到数据包被发送到目标主机为止没有再收到任何 ICMP ，就认为最后一次 ICMP 所通知的 MTU 即是一个合适的 MTU 值。MTU 值至少可以缓存约 10 分钟，在这 10 分钟内使用刚得到的 MTU ，过了 10 分钟后就重新做一次路径 MTU 发现。</p>
</li>
</ul>
<p>上面的例子是 UDP ，如果是在 TCP 的情况下，根据路径 MTU 的大小计算出最大段长度（ MSS ），然后再根据这些信息进行数据包的发送。因此，在 TCP 中如果使用路径 MTU 发现， IP 层则不会再分片。</p>
<h3 id="路由器三层转发原理"><a href="#路由器三层转发原理" class="headerlink" title="路由器三层转发原理"></a>路由器三层转发原理</h3><p>&emsp;&emsp;路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的网络号，再根据路由表进行转发，路由表中有匹配的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。</p>
<h4 id="路由器如何进行三层转发"><a href="#路由器如何进行三层转发" class="headerlink" title="路由器如何进行三层转发"></a>路由器如何进行三层转发</h4><p>当一台路由器收到一个数据包时，会执行如下步骤：</p>
<p>1，对数据包进行解封装。<br>    通过解封装，查看网络层头部信息的 目的 IP 地址。</p>
<p>2，在路由表中查找匹配的路由条目。</p>
<p>查找匹配的路由条目，就需要将数据包的目的 IP 地址与各个路由条目的网段地址先进行二进制与（ AND ）运算，再将运算结果与路由条目的网段地址进行比较，若一致则该条目与目的 IP 地址相匹配。最后，与所有路由条目完成运算和比较，可得到一条或多条相匹配的路由条目。也可能没有匹配的路由条目，那么丢弃数据包。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104705.png" alt="微信截图_20210330104705.png"></p>
<p>3，从多个匹配项中选择掩码最长的路由条目。</p>
<p>如果路由表中有多条路由条目都匹配数据包的目的 IP 地址，则路由器会选择掩码长度最长的路由条目，这种匹配方式称为最长匹配原则。</p>
<p>例如：<code>10.1.3.10</code> 的网络地址与 <code>10.1.3.0/16</code> 和 <code>10.1.3.0/24</code> 两项都匹配，这时应该选择匹配度最长的 <code>10.1.3.0/24</code>。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104813.png" alt="微信截图_20210330104813.png"></p>
<p>4，将数据包按照相应路由条目进行转发。</p>
<p>路由条目中包含下一跳和出接口。当路由器找到相应的路由条目后，它就会根据对应的下一跳和出接口，将数据包从出接口发送数据给下一跳设备。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330104927.png" alt="微信截图_20210330104927.png"></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>&emsp;&emsp;IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节</p>
<h4 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h4><ul>
<li>IP 地址的扩大与路由控制表的聚合。</li>
<li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li>
<li>支持即插即用功能。即使没有 <code>DHCP服务器</code> 也可以实现自动分配 IP 地址。</li>
<li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li>
<li>多播、Mobile IP 成为扩展功能。</li>
</ul>
<h4 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h4><p>&emsp;&emsp;一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（ <code>:</code> ）隔开进行标记。而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（<code>::</code>）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
<h4 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h4><p>&emsp;&emsp;IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</p>
<p><img src="/img/be1bff3dd05c4f999c7836ca26598c7d.jpeg" alt="be1bff3dd05c4f999c7836ca26598c7d.jpeg"></p>
<h4 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h4><p>&emsp;&emsp;全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</p>
<p>&emsp;&emsp;格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</p>
<p><img src="/img/478cf4cd8c2b43339b80d7b667a6520a.jpeg" alt="478cf4cd8c2b43339b80d7b667a6520a.jpeg"></p>
<h4 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h4><p>&emsp;&emsp;链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p>
<p><img src="/img/d9e6580e7ce245aa9116004055f69b8b.jpeg" alt="d9e6580e7ce245aa9116004055f69b8b.jpeg"></p>
<h4 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h4><p>&emsp;&emsp;唯一本地地址是不进行互联网通信时所用的地址。唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</p>
<ul>
<li>L 通常被置为 1</li>
<li>全局 ID 的值随机决定</li>
<li>子网 ID 是指该域子网地址</li>
<li>接口 ID 即为接口的 ID</li>
</ul>
<p><img src="/img/8efd0df062b049978546f10dc3895af5.jpeg" alt="8efd0df062b049978546f10dc3895af5.jpeg"></p>
<h4 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h4><p>&emsp;&emsp;IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</p>
<p>&emsp;&emsp;IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行 <code>路径MTU发现</code>，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</p>
<h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><p>&emsp;&emsp;IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>&emsp;&emsp;我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</p>
<p>&emsp;&emsp;这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>&emsp;&emsp;地址解析协议，即 <code>ARP（Address Resolution Protocol）</code>，是根据IP地址获取物理地址的一个 <code>TCP/IP</code> 协议。主机发送信息时将包含目标IP地址的 <code>ARP</code> 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机 <code>ARP缓存</code> 中，并保留一定时间，下次请求时直接查询 <code>ARP缓存</code> 以节约资源。</p>
<p>&emsp;&emsp;地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送 <code>ARP</code> 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 <code>ARP缓存</code>；由此攻击者就可以向某一主机发送伪 <code>ARP</code> 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 <code>ARP欺骗</code>。ARP命令可用于查询本机 <code>ARP缓存</code> 中 IP 地址和 MAC 地址的对应关系、添加或删除静态对应关系等。相关协议有 <code>RARP</code>、<code>代理ARP</code>。NDP用于在IPv6中代替地址解析协议。</p>
<p>&emsp;&emsp;只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时，还要知道每个 IP 地址所对应的 MAC 地址。</p>
<p>&emsp;&emsp;ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</p>
<p>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</p>
<h5 id="ARP-的工作原理"><a href="#ARP-的工作原理" class="headerlink" title="ARP 的工作原理"></a>ARP 的工作原理</h5><p><strong>当主机 A 向同一个网段内的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。</strong></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105123.png" alt="微信截图_20210330105123.png"></p>
<p>1，ARP 请求：主机 A 以主机 C 的 IP 地址为目的 IP 地址，以广播 MAC 地址为目的 MAC 地址，在同网段内发送这个广播报文，这个报文就叫 ARP 请求报文。</p>
<p>二层交换机不查看 IP 地址，根据目的 MAC 地址将报文除接收端口外的所有端口发送。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105217.png" alt="微信截图_20210330105217.png"></p>
<p>2，ARP 响应：主机 C 发现目的 IP 地址是自己的 IP 地址，于是主机 C 以自己 MAC 地址和 IP 地址作为源 MAC 地址和源 IP 地址，以主机 A 的 MAC 地址和 IP 地址作为目的 MAC 地址和目的 IP 地址，发送响应报文给主机 A ，这个报文就叫 ARP 响应报文。其它主机收到主机 A 的 ARP 请求报文，因为目的 IP 地址不是自己的 IP 地址，因此不会进行响应。</p>
<p>当主机 A 在发送 ARP 广播请求报文时，二层交换机已经有主机 A 的 MAC 地址表条目。当收到主机 C 发送的单播 ARP 响应报文时，二层交换机将报文从相应端口发送出去。并将主机 C 的 MAC 地址和对应端口记录到 MAC 地址表中。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105326.png" alt="微信截图_20210330105326.png"></p>
<p>3，更新 ARP 缓存表：主机 A 收到 ARP 响应报文后，将主机 C 的 IP 地址和 MAC 地址记录到 ARP 缓存表中。下次再向主机 C 发送数据时，直接将缓存的目的 MAC 地址进行封装。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105401.png" alt="微信截图_20210330105401.png"></p>
<p><strong>当主机 A 向不同网段的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。</strong></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105435.png" alt="微信截图_20210330105435.png"></p>
<p>1，主机 A 使用主机 C 的 IP 地址查询 ARP ，ARP 发现主机 C 不在同一个网段，需要通过默认网关（即默认路由的下一跳地址），但是没有网关 MAC 地址；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105523.png" alt="微信截图_20210330105523.png"></p>
<p>2，主机 A 先将发送给主机 C 的数据放入缓存中，然后发送 ARP 请求报文，主机 A 以网关 IP 地址为目的 IP 地址发送 ARP 广播请求报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105548.png" alt="微信截图_20210330105548.png"></p>
<p>3，路由器收到 ARP 广播请求报文后，将主机 A 的 MAC 地址和对应端口添加到自己的 MAC 表中，然后查看目的 IP 地址发现是请求自己的 MAC 地址，于是单播发送 ARP 响应报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105612.png" alt="微信截图_20210330105612.png"></p>
<p>4，主机 A 收到 ARP 响应报文后，将发送给主机 C 的数据封装网关 MAC 地址为目的 MAC 地址进行发送；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105634.png" alt="微信截图_20210330105634.png"></p>
<p>5，路由器收到报文后，查看目的 IP 地址，是发送给主机 C 的，于是查询路由表从相应端口发送数据。由于没有主机 C 的 MAC 地址，路由器发送 ARP 请求报文，源 MAC 地址和源 IP 地址替换为发送端口的MAC 地址和 IP 地址；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105656.png" alt="微信截图_20210330105656.png"></p>
<p>6，主机 C 收到 ARP 请求报文后，添加路由器的端口和 MAC 地址到 MAC 地址表，单播发送 ARP 响应报文；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105715.png" alt="微信截图_20210330105715.png"></p>
<p>7，路由器收到主机 C 的 MAC 地址后，将其添加到 MAC 地址表中。将主机 A 发送给主机 C 的报文重新封装，以自己的 MAC 地址为源 MAC 地址，以主机 C 的 MAC 地址为目的 MAC 地址，发送给主机 C ；</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330105737.png" alt="微信截图_20210330105737.png"></p>
<p>8，主机 C 收到主机 A 发送的数据，发送过程结束。</p>
<p>当主机 C 向主机 A 发送回复报文时，同主机 A 向主机 C 发送数据的步骤一致。</p>
<h5 id="ARP-代理"><a href="#ARP-代理" class="headerlink" title="ARP 代理"></a>ARP 代理</h5><p>如果 ARP 请求是从一个网络的主机发往同一网段却不在同一物理网络上的另一台主机，那么连接它们的具有代理 ARP 功能的设备就可以回答该请求，这个过程称作 代理ARP 。</p>
<p>代理 ARP 功能屏蔽了分离的物理网络，让用户使用起来，跟在同一个物理网络上一样。</p>
<h5 id="免费-ARP"><a href="#免费-ARP" class="headerlink" title="免费 ARP"></a>免费 ARP</h5><p>免费 ARP 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。</p>
<p>与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，目标 IP 地址是自己的 IP 地址。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110049.png" alt="微信截图_20210330110049.png"></p>
<p>免费 ARP 的作用：</p>
<ul>
<li>起到一个宣告作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。</li>
<li>可用于检测 IP 地址冲突。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。</li>
<li>可用于更新其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。</li>
</ul>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>IP 提供尽力而为的服务，指为了把数据包发送到目的地址尽最大努力。它并不做对端目的主机是否收到数据包的验证，无法保证服务质量。</p>
<p>&emsp;&emsp;<code>ICMP（Internet Control Message Protocol）</code> Internet控制报文协议。它是 <code>TCP/IP</code> 协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>&emsp;&emsp;<code>ICMP</code> 使用 IP 的基本支持，就像它是一个更高级别的协议，但是，<code>ICMP</code> 实际上是IP的一个组成部分，必须由每个IP模块实现。</p>
<p>&emsp;&emsp;<code>ICMP</code> 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>
<p>&emsp;&emsp;IPv4 中 <code>ICMP</code> 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 <code>ICMP</code>，仍然可以实现 IP 通信。然而，在 IPv6 中，<code>ICMP</code> 的作用被扩大，如果没有 <code>ICMPv6</code>，IPv6 就无法进行正常通信。</p>
<p>ICMP 报文像 TCP/UDP 一样通过 IP 进行传输，但是 ICMP 的功能不是传输层的补充，应该把它当做网络层协议。’</p>
<p>ICMP 头部封装字段如:</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110618.png" alt="微信截图_20210330110618.png"></p>
<p>通过类型字段和编码字段的取值判断这个 ICMP 消息的类型。常见的 ICMP 消息所对应的类型和编码值如下图。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110640.png" alt="微信截图_20210330110640.png"></p>
<p>从功能上，ICMP 的消息分为两类：一类是通知出错原因的错误消息，另一类是用于诊断的查询消息。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110700.png" alt="微信截图_20210330110700.png"></p>
<h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>我们常用的 ping 工具就是通过 ICMP 消息测试网络层连通性的。源主机发出 Echo request 消息，目的主机回应 Echo reply 消息，则两台主机间的网络层通信正常。也可以通过 ping 命令来判断目标主机是否启用。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330110752.png" alt="微信截图_20210330110752.png"></p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>&emsp;&emsp;如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</p>
<p>&emsp;&emsp;于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</p>
<p>&emsp;&emsp;<code>DHCP</code> (Dynamic Host Configuration Protocol，动态主机配置协议) 是一个局域网的网络协议，使用UDP协议工作，指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为 <code>Windows Server</code> 的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。</p>
<p>&emsp;&emsp;主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<p>&emsp;&emsp;在RFC 2131中有详细的描述，DHCP有3个端口，其中 <code>UDP67</code> 和 <code>UDP68</code> 为正常的 <code>DHCP</code> 服务端口，分别作为 <code>DHCP Server</code> 和 <code>DHCP Client</code> 的服务端口；546号端口用于 <code>DHCPv6 Client</code>，而不用于 <code>DHCPv4</code> ，是为 <code>DHCP failover</code> 服务，这是需要特别开启的服务，<code>DHCP failover</code> 是用来做双机热备的。</p>
<p>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>&emsp;&emsp;<code>NAT</code>（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</p>
<p>&emsp;&emsp;除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 <code>NAPT</code>（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</p>
<p>&emsp;&emsp;<code>NAT（NAPT）</code>实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 <code>NAT-PT</code>。</p>
<h4 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h4><p><img src="/img/e11421fc61d14423adab54661884f497.jpeg" alt="e11421fc61d14423adab54661884f497.jpeg"></p>
<p>夹着 IPv4 网络的两个 IPv6 网络</p>
<p>&emsp;&emsp;如上图的网络环境中，网络A 网络B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</p>
<p>&emsp;&emsp;IP 隧道可以将那网络A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发网络C。</p>
<p>&emsp;&emsp;一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中 “IP首部的后面还是 IP首部” 或者 “IP首部 的后面是 IPv6的首部” 等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做 “IP隧道”。</p>
<h2 id="扩展：运行在传输层中的-TCP-和-UDP-的协议"><a href="#扩展：运行在传输层中的-TCP-和-UDP-的协议" class="headerlink" title="扩展：运行在传输层中的 TCP 和 UDP 的协议"></a>扩展：运行在传输层中的 TCP 和 UDP 的协议</h2><p>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</p>
<p><strong>运行在 TCP协议上的协议：</strong></p>
<ul>
<li>HTTP（HypertextTransferProtocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）, HTTP协议的安全版本。</li>
<li>FTP（FileTransferProtocol，文件传输协议），用于文件传输。</li>
<li>POP3（PostOfficeProtocol,version3，邮局协议），收邮件用。</li>
<li>SMTP（SimpleMailTransferProtocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletypeover theNetwork，网络电传），通过一个 终端（terminal）登陆到网络。</li>
<li>SSH（SecureShell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p><strong>运行在 UDP协议上的协议：</strong></p>
<ul>
<li>BOOTP（BootProtocol，启动协议），应用于无盘设备。</li>
<li>NTP（NetworkTimeProtocol，网络时间协议），用于网络同步。</li>
<li>DHCP（DynamicHostConfigurationProtocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p><strong>运行在 TCP和 UDP协议上：</strong></p>
<ul>
<li>DNS（DomainNameService，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/339068354_774177">https://www.sohu.com/a/339068354_774177</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jbjrR-7EGQ1vMgAdTT450A">71张图详解IP 地址、IP 路由、分片和重组、三层转发、ARP、ICMP</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44630560/article/details/108100907">https://blog.csdn.net/weixin_44630560/article/details/108100907</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" class="post-title-link" itemprop="url">IP4-子网掩码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 10:33:08" itemprop="dateCreated datePublished" datetime="2021-03-01T10:33:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">子网掩码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络掩码"><a href="#网络掩码" class="headerlink" title="网络掩码"></a>网络掩码</h2><p>&emsp;&emsp;子网掩码是在IPv4地址资源紧缺的背景下为了解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面。如果是都是使用的IPV6的话是没有子网掩码的概念。IPV6是端到端的连接通信，不需要子网了。</p>
<p>&emsp;&emsp;网络掩码做为一个辅助工具，可以帮助主机区分以上三种情况，所以网络掩码是必不可少的，和IP地址如影相随。最初的网络掩码长度为8的整数倍，8、16、24、32，这里的长度为二进制的长度，即一个字节长度的整数倍。</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">特征</th>
<th align="left">网络范围</th>
<th align="left">默认掩码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类地址</td>
<td align="left">第1个8位中的第1位始终为0</td>
<td align="left">0-127.x.x.x</td>
<td align="left">255.0.0.0/8</td>
</tr>
<tr>
<td align="left">B类地址</td>
<td align="left">第1个8位中的第1、2位始终为10</td>
<td align="left">128-191.x.x.x</td>
<td align="left">255.255.0.0/16</td>
</tr>
<tr>
<td align="left">C类地址</td>
<td align="left">第1个8位中的第1、2、3位始终为110</td>
<td align="left">192-y.x.x.x</td>
<td align="left">255.255.255.0/24</td>
</tr>
</tbody></table>
<p><strong>1.1.1.1/8</strong><br>这个组合经常出现的路由器的配置里，其中 <code>1.1.1.1</code> 为IP地址。 <code>/8</code> 表示网络掩码的长度，8个二进制长度。</p>
<p><strong>172.16.1.1/16</strong><br><code>172.16.1.1</code> 为IP地址。<code>/16</code> 表示网络掩码的长度，16个二进制长度。</p>
<p><strong>192.168.1.1/24</strong><br><code>192.168.1.1</code> 为IP地址。<code>/24</code>表示网络掩码的长度，24个二进制长度。</p>
<p><strong>127.0.0.1/32</strong><br><code>127.0.0.1</code> 为IP地址。<code>/32</code> 表示网络掩码的长度，32个二进制长度。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>如果不对掩码长度是8的整数倍做强制要求，那么就实现精细化的子网掩码。</p>
<p><code>CIDR</code> :( Classless Inter-Domain Routing，元类域间路由选择).我们需要了解这种网络表示法。形式如：192.168.10.32/28。前面的数字是我们的网络地址，后面的28表示用28位来表示网络位，用32-28=4位来表示主机位。通过这种记法，我们能明确两个信息：<br>网络地址：<code>192.168.10.32</code><br>子网掩码：<code>255.255.255.240</code></p>
<p>通过下表我们能明确 <code>子网掩码</code> 和 <code>斜杠表示法</code> 之间的关系:</p>
<p><img src="/img/1679092-20190709175902328-586874586.png" alt="1679092-20190709175902328-586874586.png"><br><img src="/img/1679092-20190709175913957-2145237488.png" alt="1679092-20190709175913957-2145237488.png"></p>
<p>其中 <code>/8-/15</code> 只能用于A类网络，<code>/16-/23</code> 可用于A类和B类网络，而 <code>/24-/30</code> 可用于A类、B类和C类网络。这就是大多数公司都使用A类网络地址的一大原因，因为它们可使用所有的子网掩码，进行网络设计时的灵活性最大。</p>
<p>假设现有一IP地址 <code>180.210.242.131</code>，即 <code>10110100.11010010.11110010.10000011</code><br>同时指定子网掩码为 <code>255.255.248.0</code>  即 <code>11111111.11111111.11111000.00000000</code>，则</p>
<p>网络号：两者进行与运算，即 <code>10110100.11010010.11110000.00000000（180.210.240.0）</code><br>主机号：子网掩码取反再和IP做与运算，即 <code>00000000.00000000.00000010.10000011（0.0.2.131）</code><br>子网号：这个IP本来是B类地址，默认的子网掩码是 <code>255.255.0.0</code>，所以本来的网络号是16位，但它实际网络号是21位，就是借了5位网络位，所以可以划分 <code>2^5</code> 个子网，即32个，实际使用30个，这个网段可以容纳主机 <code>2^11</code> 个，即2048个，有效2046个一头一尾分别做网络号和广播。</p>
<p>从前有一个地主，有256间房子，地主家的门牌号码是 <code>192.168.1</code>，那么他家第一间房子的门牌号码是 <code>192.168.1.0</code> ，第二间是 <code>192.168.1.1</code>,……第256间的编号是 <code>192.168.1.255</code>。</p>
<p>地主老了，需要把256间房子分给4个儿子，平均分配，每个儿子可以分64间。</p>
<p>请来一位先生主持公道，先生这么来操作：</p>
<p><code>192.168.1.0-192.168.1.63</code> 分给大儿子<br><code>192.168.1.64-192.168.1.127</code> 分给二儿子<br><code>192.168.1.128 -192.168.1.191</code> 分给三儿子<br><code>192.168.1.192-192.168.1.255</code> 分给四儿子</p>
<p>如何来描述四个儿子的子网网段呢?</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0/26</span><br><span class="line">192.168.1.64/26</span><br><span class="line">192.168.1.128/26</span><br><span class="line">192.168.1.192/26</span><br></pre></td></tr></table></figure>

<p><strong>/26 解析</strong></p>
<p><code>255.255.255.192</code> 的二进制是：<code>11111111-11111111-11111111-11</code> 总共是26个1，为了简化子网掩码的表示，用 <code>/26</code> 代替 <code>255.255.255.192</code>。</p>
<p>按位与运算我们来看大儿子的网段 <code>192.168.1.0/26</code> 是如何得到的？</p>
<p>以大儿子的房间为例：<code>192.168.1.0-192.168.1.63</code></p>
<p>二进制表示：</p>
<p><code>192.168.1.0</code> 对于二进制：<code>11000000.10101000.00000001.00000000</code></p>
<p><code>192.168.1.63</code> 对于二进制：<code>11000000.10101000.00000001.00111111</code></p>
<p>首尾地址完全相同的是: <code>11000000.10101000.00000001.00</code>，总共26位！那么用这个 <code>192.168.1.0/26</code> 就可以表示大儿子所有房间。</p>
<p>对照房间的门牌号码 <code>192.168.1.199</code>，很显然属于四儿子的。</p>
<p>Q1：一个主机 <code>192.168.1.199/26</code> 能否和直连主机 <code>192.168.1.200/24</code> 通信？</p>
<p>可以的，因为都是四儿子的房间。</p>
<p>Q2：一个主机 <code>192.168.1.199/26</code> 能否和直连主机 <code>192.168.1.1/24</code> 通信？</p>
<p>不可以，因为一个是大儿子的房间，一个是四儿子的房间，无法直连通信！</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jAITB4o1nnO5M2wt0hDqjw">子网掩码有那么难吗？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/02/28/MSS-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E9%95%BF%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/MSS-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E9%95%BF%E5%BA%A6/" class="post-title-link" itemprop="url">MSS-最大报文段长度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 17:40:07" itemprop="dateCreated datePublished" datetime="2021-02-28T17:40:07+00:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最大报文段长度（MSS）是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）。</p>
<h2 id="开放式互联网模型"><a href="#开放式互联网模型" class="headerlink" title="开放式互联网模型"></a>开放式互联网模型</h2><p>开放式系统互联模型（OpenSystemInterconnection Model，简称为OSI模型）是一种互联网概念化模型，由国际标准化组织(InternationalOrganization forStandardization，简称为ISO)提出，定义于ISO/IEC 7498-1。OSI模型将互联网分为七层，由最高层（用户端）到最底层（物理层面）排列为：</p>
<ul>
<li>第7层 应用层（Application Layer）;</li>
<li>第6层 表达层（Presentation Layer）；</li>
<li>第5层 会话层（Session Layer）；</li>
<li>第4层 传输层（Transport Layer）；</li>
<li>第3层 网络层（Network Layer）；</li>
<li>第2层 数据链接层（Data Link Layer）；</li>
<li>第1层 物理层（Physical Layer）；</li>
</ul>
<p>MSS是第四层传输层中的一种协议（TCP）的选项之一。</p>
<p><img src="/img/503d269759ee3d6d55fbf8fa925e7a224f4a20a470e3.png" alt="503d269759ee3d6d55fbf8fa925e7a224f4a20a470e3.png"></p>
<h2 id="区分MSS与MTU"><a href="#区分MSS与MTU" class="headerlink" title="区分MSS与MTU"></a>区分MSS与MTU</h2><p>最大报文段长度（MSS）与最大传输单元（Maximum Transmission Unit, MTU）均是协议用来定义最大长度的。不同的是，MTU应用于OSI模型的第二层数据链接层，并无具体针对的协议。MTU限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小。例如，如果已知某局域网的MTU为1500字节，则在网络层的因特网协议（Internet Protocol, IP）里，最大的数据包大小为1500字节（包含IP协议头）。MSS针对的是OSI模型里第四层传输层的TCP协议。因为MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制。</p>
<p><img src="/img/d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png" alt="d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/02/28/IPv4%20Header%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/IPv4%20Header%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">IPv4 Header结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 15:57:12" itemprop="dateCreated datePublished" datetime="2021-02-28T15:57:12+00:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IPv4-Header结构"><a href="#IPv4-Header结构" class="headerlink" title="IPv4 Header结构"></a>IPv4 Header结构</h2><p>P 提供最简单的服务：实现从源到目的的数据转发。不会在传输数据前先与接收方建立连接，也不保证传输的可靠性，它只提供尽力而为的服务。</p>
<p>IP 通信时传输的是 IP 报文， IP 报文由 IP 头部和数据两部分组成。IP 头部包含控制报文转发的必要信息。通过 IP 头部的结构，可以对 IP 的功能有一个详细的了解。</p>
<p><img src="/img/2015-04-14-3.jpg" alt="2015-04-14-3.jpg"></p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330111145.png" alt="微信截图_20210330111145.png"></p>
<h3 id="版本（-Version-）"><a href="#版本（-Version-）" class="headerlink" title="版本（ Version ）"></a>版本（ Version ）</h3><p>字段长度为 4 比特，表示 IP 的版本号。IPv4 的版本号是 4 ，所以这个字段的值也是 4 。常见的版本号有 IPv4 和 IPv6 。</p>
<h3 id="头部长度（-IHL：Internet-Header-Length-）"><a href="#头部长度（-IHL：Internet-Header-Length-）" class="headerlink" title="头部长度（ IHL：Internet Header Length ）"></a>头部长度（ IHL：Internet Header Length ）</h3><p>字段长度为 4 比特，表示 IP 头部大小，单位是 4 字节（ 32 比特）。没有可选项的 IP 包，头部长度为 5 ，即 20 字节（ 4 × 5 = 20 ）。</p>
<h3 id="区分服务（-TOS：Type-Of-Service-）"><a href="#区分服务（-TOS：Type-Of-Service-）" class="headerlink" title="区分服务（ TOS：Type Of Service ）"></a>区分服务（ TOS：Type Of Service ）</h3><p>字段长度为 8 比特，用来说明数据是要加速传输还是精确传输，以及数据在传输过程中是否遇到了拥塞。</p>
<h3 id="总长度（-Total-Length-）"><a href="#总长度（-Total-Length-）" class="headerlink" title="总长度（ Total Length ）"></a>总长度（ Total Length ）</h3><p>字段长度为 16 比特，表示 IP 头部和数据加起来的总字节数。IP 包的最大长度为 65535 字节。</p>
<h3 id="标识（-ID：Identification-）"><a href="#标识（-ID：Identification-）" class="headerlink" title="标识（ ID：Identification ）"></a>标识（ ID：Identification ）</h3><p>字段长度为 16 比特，用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。通常，每发送一个 IP 包，它的值也逐渐递增。另外，即使 ID 相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。</p>
<h3 id="标志（-Flags-）"><a href="#标志（-Flags-）" class="headerlink" title="标志（ Flags ）"></a>标志（ Flags ）</h3><p>字段长度为 3 比特，表示分片信息。每比特的具体含义如下表。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330111238.png" alt="微信截图_20210330111238.png"></p>
<h3 id="分片偏移（-FO：Fragment-Offset-）"><a href="#分片偏移（-FO：Fragment-Offset-）" class="headerlink" title="分片偏移（ FO：Fragment Offset ）"></a>分片偏移（ FO：Fragment Offset ）</h3><p>字段长度为 13 比特，表示分片在整个数据包中的位置。作用是告诉重组分片的设备，应该按照什么样的顺序重组数据包。</p>
<h3 id="生存时间（-TTL：Time-To-Live-）"><a href="#生存时间（-TTL：Time-To-Live-）" class="headerlink" title="生存时间（ TTL：Time To Live ）"></a>生存时间（ TTL：Time To Live ）</h3><p>字段长度为 8 比特，表示数据包可以经过的中转路由器数量。每经过一个路由器， TTL 会减少 1 ，直到变成 0 则丢弃改包，避免数据包在网络中无限传递。</p>
<h3 id="协议（-Protocol-）"><a href="#协议（-Protocol-）" class="headerlink" title="协议（ Protocol ）"></a>协议（ Protocol ）</h3><p>字段长度为 8 比特，表示 IP 上一层所使用的协议。常见的 IP 上层协议有 TCP 和 UDP 。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330111316.png" alt="微信截图_20210330111316.png"></p>
<h3 id="头部校验和（-Header-Checksum-）"><a href="#头部校验和（-Header-Checksum-）" class="headerlink" title="头部校验和（ Header Checksum ）"></a>头部校验和（ Header Checksum ）</h3><p>字段长度为 16 比特，用来校验数据包的头部是否被破坏。设备会丢弃校验失败的数据包。IPv6 以取消头部校验和字段，通过上层的 TCP 或 UDP 校验协议是否正确。</p>
<h3 id="源地址（-Source-Address-）"><a href="#源地址（-Source-Address-）" class="headerlink" title="源地址（ Source Address ）"></a>源地址（ Source Address ）</h3><p>字段长度为 32 比特（ 4 字节），表示发送端 IP 地址。</p>
<h3 id="目的地址（-Destination-Address-）"><a href="#目的地址（-Destination-Address-）" class="headerlink" title="目的地址（ Destination Address ）"></a>目的地址（ Destination Address ）</h3><p>字段长度为 32 比特（ 4 字节），表示接收端 IP 地址。</p>
<h3 id="可选项（-Options-）"><a href="#可选项（-Options-）" class="headerlink" title="可选项（ Options ）"></a>可选项（ Options ）</h3><p>这个字段很少使用，在 IPv6 协议中已经取消。</p>
<h3 id="填充（-Padding-）"><a href="#填充（-Padding-）" class="headerlink" title="填充（ Padding ）"></a>填充（ Padding ）</h3><p>在有可选项的情况下， 头部长度不是 32 比特的整数倍时，通过向字段填充 0 ，调整为 32 比特的整数倍。</p>
<h3 id="数据（-Data-）"><a href="#数据（-Data-）" class="headerlink" title="数据（ Data ）"></a>数据（ Data ）</h3><p>IP 数据字段，用于存放数据。把 IP 上一层协议的头部也作为数据进行处理。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://abcdxyzk.github.io/blog/2015/04/14/kernel-net-sock-raw/">https://abcdxyzk.github.io/blog/2015/04/14/kernel-net-sock-raw/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7-Ethernet-Frame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7-Ethernet-Frame/" class="post-title-link" itemprop="url">以太网帧-Ethernet Frame</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 17:10:06" itemprop="dateCreated datePublished" datetime="2021-01-29T17:10:06+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/img/ethernet-frame.gif" alt="ethernet-frame.gif"></p>
<p>octets：（Bytes）字节<br>Frame：帧</p>
<p><img src="/img/d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png" alt="d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png"></p>
<p><img src="/img/20210127194819642.png" alt="20210127194819642.png"></p>
<h2 id="Ethernet帧格式历史"><a href="#Ethernet帧格式历史" class="headerlink" title="Ethernet帧格式历史"></a>Ethernet帧格式历史</h2><p>1980 DEC,Intel,Xerox 制订了 Ethernet I 的标准</p>
<p>1982 DEC,Intel,Xerox 又制订了 Ehternet II 的标准</p>
<p>1982 IEEE 开始研究 Ethernet 的国际标准 802.3</p>
<p>1983 迫不及待的 Novell 基于 IEEE 802.3 的原始版开发了专用的 Ethernet 帧格式 (因此 802.3 Raw 先于 IEEE 802.3 出台.)</p>
<p>1985 IEEE 推出 IEEE 802.3 规范,</p>
<p>后来为解决 Ethernet II 与 802.3 帧格式 的兼容问题,推出折衷的 Ethernet SNAP 格式</p>
<p>(其中早期的 Ethernet I 已经完全被其他帧格式取代了 ,所以现在 Ethernet 只能见到后面几种 Ethernet的帧格式,现在大部分的网络设备都支持这几种 Ethernet 的帧格式,如:cisco 的路由器再设定 Ethernet 接口时可以指定不同的以太网的帧格式:arpa,sap,snap,novell-ether)</p>
<p>今天的实际环境中大多数TCP/IP设备都使用Ethernet V2格式的帧。<br>这是因为第一种大规模使用的TCP/IP系统(4.2/3 BSD UNIX)的出现时间介于RFC 894和RFC 1042之间，<br>它为了避免不能和别的主机互操作的风险而采用了RFC 894的实现；<br>也由于大家都抱着这种想法，所以 802.3 标准并没有如预期那样得到普及；</p>
<p>CISCO设备的Ethernet Interface默认封装格式是ARPA(Ethernet V2)</p>
<p><strong>不同厂商对这几种帧格式不同的叫法</strong></p>
<table>
<thead>
<tr>
<th align="left">Frame Type</th>
<th align="left">Novell公司</th>
<th align="left">Cisco 公司</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ethernet Version 2</td>
<td align="left">Ethernet_II</td>
<td align="left">arpa</td>
</tr>
<tr>
<td align="left">802.3 Raw</td>
<td align="left">Ethernet_802.3</td>
<td align="left">novell_ether</td>
</tr>
<tr>
<td align="left">IEEE 802.3/802.2</td>
<td align="left">Ethernet_802.2</td>
<td align="left">sap</td>
</tr>
<tr>
<td align="left">IEEE 802.3/802.2 SNAP</td>
<td align="left">ETHERNET_SNAP</td>
<td align="left">snap</td>
</tr>
</tbody></table>
<h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><h3 id="Ethernet-I-V1"><a href="#Ethernet-I-V1" class="headerlink" title="Ethernet I (V1)"></a>Ethernet I (V1)</h3><p>这是最原始的一种格式，是由 Xerox PARC 提出的 3Mbps CSMA/CD 以太网标准的封装格式，<br>后来在1980年由 DEC，Intel 和 Xerox 标准化形成 Ethernet V1 标准；</p>
<h3 id="Ethernet-II-V2-ARPA"><a href="#Ethernet-II-V2-ARPA" class="headerlink" title="Ethernet II (V2) (ARPA)"></a>Ethernet II (V2) (ARPA)</h3><p>这是最常见的一种以太网帧格式，也是今天以太网的事实标准，由DEC，Intel 和Xerox [简称 DIX以太网联盟] 在1982年公布其标准，主要更改了Ethernet V1 的电气特性和物理接口， 在帧格式上并无变化；Ethernet V2 出现后迅速取代 Ethernet V1 成为以太网事实标准；</p>
<p>Ethernet V2 帧头（Frame Header）结构为： 6bytes的源地址（源MAC） + 6bytes的目标地址（目标MAC） + 2Bytes协议类型字段（用于标示封装在这个 Frame 里面数据的类型)，<br>数据长度 46–1500 Bytes，4Bytes的帧校验。</p>
<p>Ethernet V2 类型以太网帧的最小长度为64字节（6＋6＋2＋46＋4），最大长度为1518字节（6＋6＋2＋1500＋4）。</p>
<p>常见协议类型如下：</p>
<p>0x0800 　　IP协议数据，<br>0x86dd 　　IPv6协议数据，<br>0x809B 　　AppleTalk协议数据，<br>0x8138 　　Novell类型协议数据等。<br>0x0806 　　ARP<br>0x0600 　　XNS (Xerox)<br>0x6003 　　DECNET</p>
<p>如果协议类型字段取值为0000-05dc(十进制的0-1500)，则该帧就不是 Ethernet V2(ARPA) 类型了，而是下面的三种 802.3帧 类型之一；</p>
<p>Ethernet V2 可以支持 TCP/IP，Novell IPX/SPX，Apple Talk Phase I 等协议；RFC 894 定义了IP报文在Ethernet V2 上的封装格式；</p>
<h3 id="Novell-Ethernet-（802-3-Raw）-novell-ether"><a href="#Novell-Ethernet-（802-3-Raw）-novell-ether" class="headerlink" title="Novell Ethernet （802.3 Raw） novell_ether"></a>Novell Ethernet （802.3 Raw） novell_ether</h3><p>这是1983年 Novell 发布其划时代的 Netware/86 网络套件时，采用的私有以太网帧格式，该格式以当时尚未正式发布的 802.3 标准为基础；</p>
<p>但是当两年以后 IEEE正式发布 802.3 标准时情况发生了变化 — IEEE 在802.3帧头中又加入了802.2 LLC(Logical Link Control)头，这使得 Novell 的 802.3 RAW 格式跟正式的 IEEE 802.3 标准互不兼容；可以看到在 Novell 的 RAW 802.3 帧结构中并没有标志协议类型的字段，而只有 Length 字段(2bytes,取值为0000-05dc，即十进制的0-1500)，因为 RAW 802.3帧 只支持 IPX/SPX 一种协议；</p>
<p>802.3 Raw 帧头与 Ethernet 帧头有所不同，其中 Ethernet II 帧头中的类型域变成了长度域，后面接着的两个字节为 0xFFFF,用于标示这个帧是 Novell Ether 类型的 Frame,由于前面的 0xFFFF 站掉了两个字节所以数据域缩小为 44-1498 个字节,帧校验不变。</p>
<p><img src="/img/802.3_Raw.png" alt="802.3Raw.png"></p>
<ul>
<li>目标地址：此数据包的目标MAC地址。</li>
<li>源地址：此数据包的源MAC地址。</li>
<li>长度：帧包含的数量必须或等于 1500。(在 Ethernet 802.3 raw 类型以太网帧中，原来 Ethernet II 类型以太网帧中的类型字段被”总长度”字段所取代，它指明其后数据域的长度，其取值范围为：46-1500。)</li>
<li>数据：高层协议（IPX/SPX）、数据和填充符，范围在46～1500字节。(长度紧跟着的接下来的2个字节是固定不变的16进制数 0xFFFF，它标识此帧为 Novell 以太类型数据帧。)</li>
<li>FCS：数据帧校验序列，用于确定数据包在传输过程中是否损坏。</li>
</ul>
<h3 id="IEEE-802-3-802-2-LLC-Logical-Link-Control-sap"><a href="#IEEE-802-3-802-2-LLC-Logical-Link-Control-sap" class="headerlink" title="IEEE 802.3/802.2 LLC (Logical Link Control),sap"></a>IEEE 802.3/802.2 LLC (Logical Link Control),sap</h3><p>这是IEEE 正式的 802.3 标准，它由 Ethernet V2 发展而来。</p>
<p>IEEE 802.3 的 Frame Header 和 Ethernet II 的帧头有所不同,IEEE 802.3 将 Ethernet V2 帧头的协议类型字段替换为帧长度字段(取值为0000-05dc;十进制的1500)。</p>
<p>其中又引入 802.2 协议(LLC,Logical Link Control) 在 802.3 帧头后面添加了一个 LLC 首部,LLC头包含目的 服务访问点(DSAP,Destination Service Access Point)、源服务访问点（SSAP,Source Service Access Point）和 控制（Control）字段。</p>
<p>IEEE 802.3 把 DLC (数据链路控制，Digital Loop Carrier) 层分隔成明显的两个子层：MAC 层和 LLC 层，其中 MAC 层主要是指示硬件目的地址和源地址，LLC层用来提供一些服务：</p>
<ul>
<li>通过SAP地址来辨别接收和发送方法</li>
<li>兼容无连接和面向连接服务</li>
<li>提供子网访问协议（Sub-network Access Protocol，SNAP），类型字段即由它的首部给出。</li>
</ul>
<p>MAC层要保证最小帧长度不小于64字节，如果数据不满足64字节长度就必须进行填充。</p>
<p>利用 Sniffer 等协议分析工具去捕获的 IEEE 802.3 帧的解码，可以看到在 DLC 层源地址后紧跟着就是 802.3 的长度（Length）字段 0026，它小于 05FF（二进制1535），可以肯定它不是 Ethernet V2 的帧，而接下来的 Offset 0E 处的值 4242 （代表DSAP和SSAP），既不是 Novell 802.3 Raw 的特征值 FFFF ，也不是 IEEE 802.3 SNAP 的特征值 AAAA ，因此它肯定是一个 IEEE 802.3 的帧。</p>
<p>以太网类型码：</p>
<p><img src="/img/ETHERNET_type_code.png" alt="ETHERNET_type_code.png"></p>
<p>decimal：十进制<br>octal：八进制</p>
<p><strong>802.2 SAP (Service Access Point) 介绍</strong></p>
<p>为了区别 802.3 数据帧中所封装的数据类型，IEEE 引入了 802.2 SAP 和 SNAP 的标准。它们工作在数据链路层的 LLC（逻辑链路控制）子层。</p>
<p>通过在802.3帧的数据字段中划分出被称为服务访问点（SAP）的新区域来解决识别上层协议的问题，这就是 802.2 SAP。</p>
<p><strong>LLC标准 介绍</strong></p>
<p>LLC 标准包括两个服务访问点，源服务访问点（SSAP）和目标服务访问点（DSAP）。每个SAP只有1字节长，而其中仅保留了6比特用于标识上层协议，所能标识的协议数有限。</p>
<p>因此，又开发出另外一种解决方案，在 802.2 SAP 的基础上又新添加了一个 2字节长的类型域（同时将SAP的值置为AA），使其可以标识更多的上层协议类型，这就是 802.2 SNAP。</p>
<p>常见SAP值：</p>
<ul>
<li>0：Null LSAP[IEEE] </li>
<li>4：SNA Path Control[IEEE] </li>
<li>6：DOD IP[79,JBP] </li>
<li>AA：SNAP[IEEE] </li>
<li>FE：ISO DIS 8473[52,JXJ] </li>
<li>FF：Global DSAP[IEEE]</li>
</ul>
<p><img src="/img/IEEE_802.3.png" alt="IEEE_802.3.png"></p>
<ul>
<li>目标地址：此数据包的目标mac地址；</li>
<li>源地址：此数据包的源mac地址；</li>
<li>长度：帧包含的数据量必须小于或等于1500（16进制的05DC）；</li>
<li>DSAP：目标服务存取点（Destination  Service Access Point）；</li>
<li>SSAP：源服务存取点（Source Service Access  Point）；</li>
<li>控制：无连接或面向连接的C；</li>
<li>数据：高层协议、数据和填充符;</li>
<li>FCS：数据帧校验序列，用于确定数据包在传输过程中是否损坏。</li>
</ul>
<h3 id="Ethernet-SNAP-IEEE-802-3-802-2-SNAP-ETHERNET-SNAP-snap"><a href="#Ethernet-SNAP-IEEE-802-3-802-2-SNAP-ETHERNET-SNAP-snap" class="headerlink" title="Ethernet SNAP (IEEE 802.3/802.2 SNAP, ETHERNET_SNAP, snap)"></a>Ethernet SNAP (IEEE 802.3/802.2 SNAP, ETHERNET_SNAP, snap)</h3><p>SNAP (Sub-Network Access Protocol)子网访问协议，是逻辑链路控制（Logical Link Control）的一个子集，它允许协议不用通过 服务访问点（SAP）即可实现 IEEE 兼容的 MAC 层功能，因此它在 DSAP 和 SSAP域里的值是固定的 （AAAA）。也正源于此，它需要额外提供5个字节的头来指定接收方法，3个字节标识厂商代码，2个字节标识上层协议。</p>
<p>其 MAC 层保证数据帧长度不小于64字节，不足的话需要进行数据填充。</p>
<p>Sniffer 捕获的 IEEE 802.3 SNAP 帧的解码，可以看到在 DLC 层源地址后紧跟着就是 802.3 的长度（Length）字段 0175，它小于 05FF，可以肯定它不是 Ethernet V2 的帧，而接下来的 Offset 0E 处的值 AAAA （代表DSAP和SSAP），这是 IEEE 802.3 SNAP 的特征值 AAAA ，因此可以断定它是一个 IEEE 802.3 SNAP 的帧。</p>
<p>SNAP Frame 与 802.3/802.2 Frame 的最大区别是增加了一个 5 Bytes 的 SNAP ID，其中前面3个byte通常与源mac地址的前三个bytes相同为厂商代码，有时也可设为0,后2 bytes 与 Ethernet II 的类型域相同。</p>
<p><img src="/img/ETHERNET_SNAP.png" alt="ETHERNET_SNAP.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th align="left">Frame Type</th>
<th align="left">Header &amp; CRC</th>
<th align="left">Data Min</th>
<th align="left">Data Max</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ethernet II (DIX)</td>
<td align="left">18</td>
<td align="left">46</td>
<td align="left">1500</td>
</tr>
<tr>
<td align="left">802.3 (IEEE)</td>
<td align="left">21</td>
<td align="left">43</td>
<td align="left">1497</td>
</tr>
<tr>
<td align="left">SNAP</td>
<td align="left">26</td>
<td align="left">38</td>
<td align="left">1492</td>
</tr>
</tbody></table>
<ul>
<li>Ethernet II 和 IEEE 802.3 是局域网里最常见的帧</li>
<li>Ethernet II 可以装载的数据长度是46—1500;  </li>
<li>IEEE802.3 SAP 可以装装的数据长度是43—1497; </li>
<li>IEEE 802.3 SNAP 可以装载的数据长度是38—1492；</li>
<li>Ethernet II 不提供 MAC 层的数据填充功能;</li>
<li>IEEE802.3 SAP 和 SNAP 都提供数据填充功能.</li>
</ul>
<p><strong>Ethernet V2 帧与IEEE 802.3 帧的比较</strong></p>
<p>Ethernet V2 可以装载的最大数据长度是1500字节，而 IEEE 802.3 可以装载的最大数据是1492字节（SNAP）或是1497字节; Ethernet V2 不提供 MAC层 的数据填充功能，而 IEEE 802.3 不仅提供该功能，还具备服务访问点（SAP）和 SNAP 层，能够提供更有效的数据链路层控制和更好的传输保证。那么我们可以得出这样的结 论：Ethernet V2 比 IEEE 802.3 更适合于传输大量的数据，但 Ethernet V2 缺乏数据链路层的控制，不利于传输需要严格传输控制的数据，这也正是 IEEE 802.3 的优势所在，越需要严格传输控制的应用，越需要用 IEEE 802.3或 SNAP 来封装，但 IEEE 802.3 也不可避免的带来数据装载量的损失，因此该格式的封装往往用在较少数据量承载但又需要严格控制 传输的应用中。</p>
<p>在实际应用中，我们会发现，大多数应用的以太网数据包是 Ethernet V2 的帧（如HTTP、FTP、SMTP、POP3等应用），而交换机之间的BPDU（桥协议数据单元）数据包则是IEEE 802.3的帧，VLAN Trunk 协议如 802.1Q 和Cisco的CDP（思科发现协议）等则是采用 IEEE 802.3 SNAP 的帧。可以利用Sniffer等协议分析工具去捕捉数据包。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guoshaobei/article/details/4768514">以太网帧与ieee 802.3帧</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yshe_xun/article/details/7636078">以太网类型码(Ethernet type codes)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xlmeng1988/articles/2445619.html">Ethernet frame</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mylinux/p/5553242.html">ETHERNET帧结构</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21318925">车小胖谈网络：Ethernet Frame</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%EF%BC%88CRC%EF%BC%89%E4%B8%8E%E5%B8%A7%E6%A3%80%E9%AA%8C%E5%BA%8F%E5%88%97-FCS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%EF%BC%88CRC%EF%BC%89%E4%B8%8E%E5%B8%A7%E6%A3%80%E9%AA%8C%E5%BA%8F%E5%88%97-FCS/" class="post-title-link" itemprop="url">循环冗余检验算法（CRC）与帧检验序列(FCS)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 16:38:55" itemprop="dateCreated datePublished" datetime="2021-01-29T16:38:55+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>循环冗余检验CRC是一种检验方法，而FCS是添加在数据后面的帧检验序列。CRC 检验只能保证接收端接收到的帧没有差错，至于有没有出现帧丢失，帧重复，帧失序，是无法判断的。</p>
<h2 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h2><p>循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术（算法），主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p>
<h2 id="FCS"><a href="#FCS" class="headerlink" title="FCS"></a>FCS</h2><p>帧校验序列码 FCS ( Frame Check Sequences) 是为提高通信的可靠性设置的。将每一帧中的第一个字符@到该帧中正文的最后一个ASCII 字符作“异或”运算, 并将异或的结果转换为两个ASCII码, 便得到了FCS , 它作为帧的一部分发送到接收端。接收端计算出收到的帧的FCS , 如果与发送端传送过来的FCS 不同, 可以判定通信有误。</p>
<p>帧校验序列（FCS）是指特别的检测码字符被添加到在一个通信协议中的帧中进行检错和纠错。发送主机在整个帧中有一个检测码随着发送。接收主机在整个帧中的检测码使用相同的运算法则，并将它与接收到的 FCS 相比较。这样，它能够探测是否任何数据在运输中丢失或被改变。它可能当时丢失这个数据，和请求错误帧的重传。一个循环冗余码校验常被用来估算 FCS。</p>
<p>FCS 字段：包含帧的 32 位循环冗余校验 (CRC), 数据链路层帧方式接入协议（LAPF）中的字段，是一个16比特的序列。它具有很强的检错能力，它能检测出在任何位置上的 3 个以内的错误、所有的奇数个错误、16个比特之内的连续错误以及大部分的大量突发错误。</p>
<p><img src="/img/ethernet-frame.gif" alt="ethernet-frame.gif"></p>
<p>octets：（Bytes）字节<br>Frame：帧</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/loveCC_orange/article/details/79127809">循环冗余检验算法（CRC）与帧检验序列(FCS)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lxm920714/article/details/103274092">帧检验序列(FCS)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/MTU-%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/MTU-%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83/" class="post-title-link" itemprop="url">MTU-最大传输单元</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 14:24:29" itemprop="dateCreated datePublished" datetime="2021-01-29T14:24:29+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>最大传输单元</strong>（Maximum Transmission Unit，MTU）用来通知对方所能接受数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小。<br>是包或帧的最大长度，一般以字节记。如果MTU过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包(或帧)上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500字节和1492字节。链路层的这个特性称为MTU，即最大传输单元。不同类型网络的数帧长度大多数都有一个上限。如果IP层有一个数据报要传，而且数据帧的长度比链路层的MTU还大，那么IP层就需要进行分片( fragmentation)，即把数据报分成干片，这样每一片就都小于MTU。 </p>
<p>当同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要。但是如果两台主机之间的通信要通过多个网络，每个网络的链路层可能有不同的MTU，那么这时重要的不是两台主机所在网络的MTU的值，而是两台主机通信路径中的最小MTU，称为 路径 MTU( Path mtu，PMTU)。</p>
<p>两台主机之间的PMTU不一定是个常数，它取决于当时所选择的路径，而且路由选择也不一定是对称的(从A到B的路由可能与从B到A的路由不同)，因此，PMTU在两个方向上不一定是一致的。<br>RFC1191描述了PMTU的发现机制，即确定路径MTU的方法。ICMP的不可到达错误采用的就是这种方法， traceroute程序也是用这种方法来确定到达目的节点的PMT的。</p>
<h2 id="MTU字节"><a href="#MTU字节" class="headerlink" title="MTU字节"></a>MTU字节</h2><p>在远端节点的配置响应中将包含在该信道使用的实际的MTU大小，信道的方向是流向本地节点，MTU值取在configReq中的MTU和远端节点的输出MTU能力中最小值。该MTU只能用于这个信道，不能用于相反方向的信道。<br>MTU字段：2个字节。</p>
<p>MTU字段表示发起请求方可以接受的最大的L2CAP分组净荷(按字节计)。MTU是非对称的，请求的发送方指定在该信道上它可以接收的MTU值。L2CAP的实现必须支持最小的48字节的MTU值。缺省值是672字节。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>MTU是网络调节的重要因素，因为包中的额外开销量相当高。高的MTU减少了头信息浪费的字节数。对大量数据传输尤其重要，而对小于MTU的传输没有影响。因此，注意配置传输大量数据流的服务器(如文件服务器和FTPH&amp;．务器)上的MTU。</p>
<p>选择MTU时，规则是选择传输中不需分段的最大MTU。如果网络使用一种媒体类型，缺省的设置就可以。选择比媒体最大值更小的MTU并没有好处，整个数据报会因为每个包的错误而重发。换言之，不能重发单个段。</p>
<h2 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h2><p>数据链路不同，最大传输单元( Maximum transmission Unit，MTU)也不同，由于IP协议是数据链路的上一层，所以它必须不受数据链路的MTU大小的影响能够加以利用。当IP数据报太大时，就要采用分片技术，以保证数据帧不大于要过的网络的MTU。</p>
<p>IP协议除了具有路由寻址功能外，另一个重要的功能就是IP数据报的分片处理。每个数据链路层能够确定发送的一个帧的最大长度称为最大传输单元。在Ethernet中，MTU为1500字节;在FDDI中，MTU为4352字节;在 IP over ATM中，MTU为9180字节。</p>
<p>如果要发送的IP数据报比数据链路层的MTU大，则无法发送该数据报。对于来自于上一层的IP协议，当要求发送的IP数据报比数据链路层的MTU大时，必把该数据报分割成多个IP数据报才能发送。另外，在进行通信的各台主机之间，存在着MTU不同的数据链路;在发送的过程中，也有MTU缩小的情况发生。当出现上述情况时，在发送过程中必须有一台能够进行分片处理的路由器。</p>
<p>接收端主机必须对经过分片处理后的IP数据报进行还原处理。在中继路由器中，虽然路由器进行了分片处理，但并不进行还原处理。另外，经分片处理的IP数据报只有经过还原处理后才能还原成原来的IP数据报，才可以向上一层的模块传递数据。</p>
<p><img src="/img/d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png" alt="d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83/9730690?fromtitle=mtu&fromid=508920">最大传输单元</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/" class="post-title-link" itemprop="url">查看Linux系统版本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 13:57:29" itemprop="dateCreated datePublished" datetime="2021-01-29T13:57:29+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查看Linux内核版本"><a href="#查看Linux内核版本" class="headerlink" title="查看Linux内核版本"></a>查看Linux内核版本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h2 id="查看Linux系统版本"><a href="#查看Linux系统版本" class="headerlink" title="查看Linux系统版本"></a>查看Linux系统版本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版。</span></span><br><span class="line"><span class="comment"># 如果未安装，需要命令：yum install redhat-lsb -y</span></span><br><span class="line">lsb_release -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只适合Redhat系的Linux</span></span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">file /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 适用于所有的Linux发行版</span></span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/18/Git%E5%8F%96%E6%B6%88%E6%96%87%E4%BB%B6%E8%B7%9F%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/Git%E5%8F%96%E6%B6%88%E6%96%87%E4%BB%B6%E8%B7%9F%E8%B8%AA/" class="post-title-link" itemprop="url">Git取消文件跟踪</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-18 10:05:02" itemprop="dateCreated datePublished" datetime="2021-01-18T10:05:02+00:00">2021-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .  <span class="comment"># 不删除本地文件</span></span><br><span class="line">git rm -r --f . 　　  <span class="comment"># 删除本地文件</span></span><br><span class="line">git rm --cached 1.txt  <span class="comment"># 删除readme1.txt的跟踪，并保留在本地。</span></span><br><span class="line">git rm --f 1.txt    <span class="comment"># 删除readme1.txt的跟踪，并且删除本地文件。</span></span><br></pre></td></tr></table></figure>

<p>已经被纳入了版本管理中，则修改 <code>.gitignore</code> 是无效的。</p>
<p>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区到本地仓库中</span></span><br><span class="line">git commit -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Python3学习-函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-16 15:22:55" itemprop="dateCreated datePublished" datetime="2021-01-16T15:22:55+00:00">2021-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python3/" itemprop="url" rel="index"><span itemprop="name">Python3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>自定义函数规则：</p>
<ul>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号 : 起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">Python3学习-基本语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-16 11:35:24" itemprop="dateCreated datePublished" datetime="2021-01-16T11:35:24+00:00">2021-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python3/" itemprop="url" rel="index"><span itemprop="name">Python3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>if、elif、else 来进行逻辑判断</p>
<p>格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2.</span>..</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3.</span>..</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句<span class="number">4.</span>..</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/13/MySQL-GRANT%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/MySQL-GRANT%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83/" class="post-title-link" itemprop="url">MySQL GRANT命令-用户授权</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-13 15:20:34" itemprop="dateCreated datePublished" datetime="2021-01-13T15:20:34+00:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GRANT语法"><a href="#GRANT语法" class="headerlink" title="GRANT语法"></a>GRANT语法</h2><p>在 MySQL 中，拥有 GRANT 权限的用户才可以执行 GRANT 语句，其语法格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type [(column_list)] ON database.table</span><br><span class="line">TO user [IDENTIFIED BY [PASSWORD] <span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">[, user[IDENTIFIED BY [PASSWORD] <span class="string">&#x27;password&#x27;</span>]] ...</span><br><span class="line">[WITH with_option [with_option]...]</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT,INSERT,DELETE,UPDATE ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;192.125.30.123&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>取消权限：</p>
<p><code>revoke all on *.* from root@localhost;</code></p>
<ul>
<li>priv_type 参数表示权限类型；</li>
<li>columns_list 参数表示权限作用于哪些列上，省略该参数时，表示作用于整个表；</li>
<li>database.table 用于指定权限的级别；</li>
<li>user 参数表示用户账户，由用户名和主机名构成，格式是“‘username’@’hostname’”；</li>
<li>IDENTIFIED BY 参数用来为用户设置密码；</li>
<li>password 参数是用户的新密码。</li>
</ul>
<p>WITH 关键字后面带有一个或多个 with_option 参数。这个参数有 5 个选项，详细介绍如下：</p>
<ul>
<li>GRANT OPTION：被授权的用户可以将这些权限赋予给别的用户；</li>
<li>MAX_QUERIES_PER_HOUR count：设置每个小时可以允许执行 count 次查询；</li>
<li>MAX_UPDATES_PER_HOUR count：设置每个小时可以允许执行 count 次更新；</li>
<li>MAX_CONNECTIONS_PER_HOUR count：设置每小时可以建立 count 个连接;</li>
<li>MAX_USER_CONNECTIONS count：设置单个用户可以同时具有的 count 个连接。</li>
</ul>
<p>GRANT 语句中可用于指定权限级别的值有以下几类格式：</p>
<ul>
<li>*：表示当前数据库中的所有表。</li>
<li><em>.</em>：表示所有数据库中的所有表。</li>
<li>db_name.*：表示某个数据库中的所有表，db_name 指定数据库名。</li>
<li>db_name.tbl_name：表示某个数据库中的某个表或视图，db_name 指定数据库名，tbl_name 指定表名或视图名。</li>
<li>db_name.routine_name：表示某个数据库中的某个存储过程或函数，routine_name 指定存储过程名或函数名。</li>
<li>TO 子句：如果权限被授予给一个不存在的用户，MySQL 会自动执行一条 CREATE USER 语句来创建这个用户，但同时必须为该用户设置密码。</li>
</ul>
<h2 id="数据库权限的权限类型"><a href="#数据库权限的权限类型" class="headerlink" title="数据库权限的权限类型"></a>数据库权限的权限类型</h2><table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="center">对应user表中的字段</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SELECT</td>
<td align="center">Select_priv</td>
<td align="center">表示授予用户可以使用 SELECT 语句访问特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td align="left">INSERT</td>
<td align="center">Insert_priv</td>
<td align="center">表示授予用户可以使用 INSERT 语句向特定数据库中所有表添加数据行的权限。</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="center">Delete_priv</td>
<td align="center">表示授予用户可以使用 DELETE 语句删除特定数据库中所有表的数据行的权限。</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="center">Update_priv</td>
<td align="center">表示授予用户可以使用 UPDATE 语句更新特定数据库中所有数据表的值的权限。</td>
</tr>
<tr>
<td align="left">REFERENCES</td>
<td align="center">References_priv</td>
<td align="center">表示授予用户可以创建指向特定的数据库中的表外键的权限。</td>
</tr>
<tr>
<td align="left">CREATE</td>
<td align="center">Create_priv</td>
<td align="center">表示授权用户可以使用 CREATE TABLE 语句在特定数据库中创建新表的权限。</td>
</tr>
<tr>
<td align="left">ALTER</td>
<td align="center">Alter_priv</td>
<td align="center">表示授予用户可以使用 ALTER TABLE 语句修改特定数据库中所有数据表的权限。</td>
</tr>
<tr>
<td align="left">SHOW VIEW</td>
<td align="center">Show_view_priv</td>
<td align="center">表示授予用户可以查看特定数据库中已有视图的视图定义的权限。</td>
</tr>
<tr>
<td align="left">CREATE ROUTINE</td>
<td align="center">Create_routine_priv</td>
<td align="center">表示授予用户可以为特定的数据库创建存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="left">ALTER ROUTINE</td>
<td align="center">Alter_routine_priv</td>
<td align="center">表示授予用户可以更新和删除数据库中已有的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="left">INDEX</td>
<td align="center">Index_priv</td>
<td align="center">表示授予用户可以在特定数据库中的所有数据表上定义和删除索引的权限。</td>
</tr>
<tr>
<td align="left">DROP</td>
<td align="center">Drop_priv</td>
<td align="center">表示授予用户可以删除特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td align="left">CREATE TEMPORARY TABLES</td>
<td align="center">Create_tmp_table_priv</td>
<td align="center">表示授予用户可以在特定数据库中创建临时表的权限。</td>
</tr>
<tr>
<td align="left">CREATE VIEW</td>
<td align="center">Create_view_priv</td>
<td align="center">表示授予用户可以在特定数据库中创建新的视图的权限。</td>
</tr>
<tr>
<td align="left">EXECUTE ROUTINE</td>
<td align="center">Execute_priv</td>
<td align="center">表示授予用户可以调用特定数据库的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="left">LOCK TABLES</td>
<td align="center">Lock_tables_priv</td>
<td align="center">表示授予用户可以锁定特定数据库的已有数据表的权限。</td>
</tr>
<tr>
<td align="left">ALL 或 ALL PRIVILEGES 或 SUPER</td>
<td align="center">Super_priv</td>
<td align="center">表示以上所有权限/超级权限</td>
</tr>
</tbody></table>
<h2 id="表权限的权限类型"><a href="#表权限的权限类型" class="headerlink" title="表权限的权限类型"></a>表权限的权限类型</h2><table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="center">对应user表中的字段</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SELECT</td>
<td align="center">Select_priv</td>
<td align="center">授予用户可以使用 SELECT 语句进行访问特定表的权限</td>
</tr>
<tr>
<td align="left">INSERT</td>
<td align="center">Insert_priv</td>
<td align="center">授予用户可以使用 INSERT 语句向一个特定表中添加数据行的权限</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="center">Delete_priv</td>
<td align="center">授予用户可以使用 DELETE 语句从一个特定表中删除数据行的权限</td>
</tr>
<tr>
<td align="left">DROP</td>
<td align="center">Drop_priv</td>
<td align="center">授予用户可以删除数据表的权限</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="center">Update_priv</td>
<td align="center">授予用户可以使用 UPDATE 语句更新特定数据表的权限</td>
</tr>
<tr>
<td align="left">ALTER</td>
<td align="center">Alter_priv</td>
<td align="center">授予用户可以使用 ALTER TABLE 语句修改数据表的权限</td>
</tr>
<tr>
<td align="left">REFERENCES</td>
<td align="center">References_priv</td>
<td align="center">授予用户可以创建一个外键来参照特定数据表的权限</td>
</tr>
<tr>
<td align="left">CREATE</td>
<td align="center">Create_priv</td>
<td align="center">授予用户可以使用特定的名字创建一个数据表的权限</td>
</tr>
<tr>
<td align="left">INDEX</td>
<td align="center">Index_priv</td>
<td align="center">授予用户可以在表上定义索引的权限</td>
</tr>
<tr>
<td align="left">ALL 或 ALL PRIVILEGES 或 SUPER</td>
<td align="center">Super_priv</td>
<td align="center">所有的权限名</td>
</tr>
</tbody></table>
<h2 id="列权限的权限类型"><a href="#列权限的权限类型" class="headerlink" title="列权限的权限类型"></a>列权限的权限类型</h2><p>值只能指定为 SELECT、INSERT 和 UPDATE，同时权限的后面需要加上 列名 列表 column-list</p>
<h2 id="用户权限类型"><a href="#用户权限类型" class="headerlink" title="用户权限类型"></a>用户权限类型</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的用户，并授予 数据有查询、插入权限，并授予 GRANT 权限</span></span><br><span class="line">GRANT SELECT,INSERT SLAVE ON *.*  TO  <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户权限</span></span><br><span class="line">SHOW GRANTS FOR <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/13/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%ADsocket%E7%8A%B6%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%ADsocket%E7%8A%B6%E6%80%81/" class="post-title-link" itemprop="url">Linux查看系统中socket状态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-13 11:03:05" itemprop="dateCreated datePublished" datetime="2021-01-13T11:03:05+00:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IPv4查看"><a href="#IPv4查看" class="headerlink" title="IPv4查看"></a>IPv4查看</h2><p><code>cat /proc/net/sockstat</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockets: used 230</span><br><span class="line">TCP: inuse 30 orphan 0 tw 2 alloc 36 mem 2</span><br><span class="line">UDP: inuse 3 mem 0</span><br><span class="line">UDPLITE: inuse 0</span><br><span class="line">RAW: inuse 0</span><br><span class="line">FRAG: inuse 0 memory 0</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>sockets: used：已使用的所有协议套接字总量</li>
<li>TCP: inuse：正在使用（正在侦听）的TCP套接字数量。其值≤ netstat –lnt | grep ^tcp | wc –l</li>
<li>TCP: orphan：无主（不属于任何进程）的TCP连接数（无用、待销毁的TCP socket数）</li>
<li>TCP: tw：等待关闭的TCP连接数。其值等于netstat –ant | grep TIME_WAIT | wc –l</li>
<li>TCP：alloc(allocated)：已分配（已建立、已申请到sk_buff）的TCP套接字数量。其值等于netstat –ant | grep ^tcp | wc –l</li>
<li>TCP：mem：套接字缓冲区使用量（单位不详。用scp实测，速度在4803.9kB/s时：其值=11，netstat –ant 中相应的22端口的Recv-Q＝0，Send-Q≈400）</li>
<li>UDP：inuse：正在使用的UDP套接字数量</li>
<li>RAW：</li>
<li>FRAG：使用的IP段数量</li>
</ul>
<h2 id="IPv6查看"><a href="#IPv6查看" class="headerlink" title="IPv6查看"></a>IPv6查看</h2><p><code>cat /proc/net/sockstat6</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/11/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">TCP传输控制协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-11 15:05:11" itemprop="dateCreated datePublished" datetime="2021-01-11T15:05:11+00:00">2021-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP-报文格式简介"><a href="#TCP-报文格式简介" class="headerlink" title="TCP 报文格式简介"></a>TCP 报文格式简介</h2><ul>
<li>TCP 报文由 <code>TCP Header</code> 和 <code>TCP</code> 数据组成。</li>
<li><strong>TCP Header 的最大长度为 60 字节(byte)</strong>，而<strong>必须要有的固定长度</strong>也就是图一的前5层的<strong>20字节(byte)</strong>，每层占有 <code>32bit</code>，也就是 <code>32/8=4</code> 字节，5层，<code>5*4 = 20</code> 字节，那么第六层的可选项和填充也就是<strong>Tcp Options字段最大为60-20=40字节(byte)</strong>。填充是为了使TCP首部为4字节（32bit）的整数倍。</li>
</ul>
<h2 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h2><p><img src="/img/2964446-ab077ff3902529a3.webp" alt="2964446-ab077ff3902529a3.webp"></p>
<p><strong>Source Port</strong>：源端口，16位(bit)，2个字节(byte)。<br><strong>Destination Port</strong>：目的端口，16位，2个字节。<br><strong>Sequence Number</strong>：序号，发送数据包中的第一个字节的序列号，32位。<br><strong>Acknowledgment Number</strong>：确认序列号，32位。<br><strong>Data Offset</strong>：数据偏移，4位，该字段的值是TCP首部（包括选项）长度除以4。<br><strong>标志位</strong>：6位，共6个标志位<br><code>URG</code> 表示 <code>Urgent Pointer</code> 字段有意义<br><code>ACK</code> 表示 <code>Acknowledgment Number</code> 字段有意义<br><code>PSH</code> 表示 <code>Push</code> 功能，RST 表示复位 TCP 连接<br><code>RST</code> 表示连接复位请求<br><code>SYN</code> 表示 <code>SYN</code> 报文（在建立 TCP 连接的时候使用）<br><code>FIN</code> 表示没有数据需要发送了（在关闭 TCP 连接的时候使用）<br><strong>Window</strong>：窗口，表示接收缓冲区的空闲空间，16位，2个字节，用来告诉TCP连接对端自己能够接收的最大数据长度。<br><strong>Checksum</strong>：校验和，16位，2个字节。<br><strong>Urgent Pointers</strong>：紧急指针，16位,2个字节，只有 URG 标志位被设置时该字段才有意义，表示紧急数据相对序列号（Sequence Number字段的值）的偏移。<br><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为 MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。<br><strong>数据</strong>：TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p>
<h2 id="TCP-Options字段"><a href="#TCP-Options字段" class="headerlink" title="TCP Options字段"></a>TCP Options字段</h2><p>Tcp Options 字段的最大长度为40字节。Tcp Options 字段的一般数据结构如图所示：</p>
<ul>
<li>Kind(1字节)</li>
<li>Length(1字节)</li>
<li>Info(n字节)</li>
</ul>
<p>选项的第一个字段 kind 说明选项的类型。有的 TCP 选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段 info（如果有的话）是选项的具体信息。</p>
<p><img src="/img/tcpoptions.png" alt="tcpoptions.png"></p>
<ul>
<li>第一个kind= 2，表示最大报文段长度（Max Segment Size，MSS），TCP 模块通常将 MSS 设置为（MTU-40, MTU[Maximum Transmission Unit，缩写 MTU，中文名是：最大传输单元]）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带 TCP 报文段的IP数据报的长度就不会超过 MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS 值是1460（1500-40）字节。</li>
<li>kind= 4，表示支持 SACK，SACK Block（收到乱序数据）。</li>
<li>kind = 8，代表 Timestamps，即时间戳，启用 Timestamp Option 后，每个 TCP Segment 中都会带有 Timestamp Option，其中包含了两个 32bit 的 Timestamp 也就是各四个字节的 Timestamp Value（TSval）和 Timestamp Echo Reply（TSecr）。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确计算出RTT。</li>
</ul>
<h2 id="TCP标志位"><a href="#TCP标志位" class="headerlink" title="TCP标志位"></a>TCP标志位</h2><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG。其中，对于我们日常的分析有用的就是前面的五个字段。</p>
<p>SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。</p>
<p>ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。<br>TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为SYN表示的是建立连接，而FIN表示的是断开连接。<br>RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。<br>一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。<br>PSH为1的情况，一般只出现在DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。</p>
<h3 id="SYN：同步标志"><a href="#SYN：同步标志" class="headerlink" title="SYN：同步标志"></a>SYN：同步标志</h3><p>同步序列编号(Synchronize Sequence Numbers)栏有效，表示同步序号，用来建立连接。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。TCP序列编号是一个范围从 <code>0~4294967295</code> (2^32-1) 的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。</p>
<p>SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK= 1；</p>
<p>这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求-连接-严格进行的TCP三次握手；</p>
<p><strong>初始化序列号生成过程：</strong></p>
<p>RFC1948中提出了一个较好的初始化序列号ISN随机生成算法。</p>
<p>ISN = M + F(localhost, localport, remotehost, remoteport).<br>M是一个计时器，这个计时器每隔4毫秒加1。<br>F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出，用MD5算法是一个比较好的选择。<br>ISN会和一个假的时钟绑在一起，这个时钟M会在每4微秒对ISN做加一操作，直到超过 2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</p>
<h3 id="ACK：确认标志"><a href="#ACK：确认标志" class="headerlink" title="ACK：确认标志"></a>ACK：确认标志</h3><p>确认编号(Acknowledgement Number)栏有效。此标志表示应答域有效；有两个取值：0和1，为1的时候表示应答域有效，反之为0。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。</p>
<h3 id="RST：复位标志"><a href="#RST：复位标志" class="headerlink" title="RST：复位标志"></a>RST：复位标志</h3><p>这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</p>
<h3 id="URG：紧急标志"><a href="#URG：紧急标志" class="headerlink" title="URG：紧急标志"></a>URG：紧急标志</h3><p>此标志表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</p>
<h3 id="PSH：推标志"><a href="#PSH：推标志" class="headerlink" title="PSH：推标志"></a>PSH：推标志</h3><p>这个标志位表示Push操作，该标志置位时，指在数据包到达接收端以后，接收端不将该数据进行队列处理，立即传送给应用程序，而不是在缓冲区中排队。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。</p>
<h3 id="FIN：结束标志"><a href="#FIN：结束标志" class="headerlink" title="FIN：结束标志"></a>FIN：结束标志</h3><p>表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。当一个FIN标志的TCP数据包发送到一台计算机的特定端口，如果这台计算机响应了这个数据，并且反馈回来一个RST标志 的TCP包，就表明这台计算机上没有打开这个端口，但是这台计算机是存在的；如果这台计算机没有反馈回来任何数据包，这就表明，这台被扫描的计算机存在这个端口。</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p><img src="/img/tcp1.gif" alt="tcp1"></p>
<p>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出 <code>SYN</code> 连接请求后，等待对方回答 <code>SYN+ACK</code>，并最终对对方的 <code>SYN</code> 执行 <code>ACK</code> 确认。</p>
<p>TCP三次握手的过程如下：</p>
<ul>
<li>客户端发送 <code>SYN（SEQ=x）</code> 报文给服务器端，进入 <code>SYN_SEND</code> 状态。</li>
<li>服务器端收到 <code>SYN</code> 报文，回应一个 <code>SYN （SEQ=y）ACK（ACK=x+1）</code> 报文，进入 <code>SYN_RECV</code> 状态。</li>
<li>客户端收到服务器端的 <code>SYN</code> 报文，回应一个 <code>ACK（ACK=y+1）</code> 报文，进入 <code>Established(已获确认的)</code> 状态。</li>
</ul>
<p>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</p>
<h3 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h3><p><img src="/img/tcp3.gif" alt="tcp3.gif"></p>
<p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的 <code>半关闭</code>（<code>half-close</code>）造成的。</p>
<ul>
<li>（1）某个应用进程首先调用 <code>close</code>，称该端执行 <code>主动关闭（active close）</code>。该端的TCP于是发送一个 <code>FIN</code> 分节，表示数据发送完毕。</li>
<li>（2） 接收到这个 <code>FIN</code> 的对端执行 <code>被动关闭（passive close）</code>，这个 <code>FIN</code> 由TCP确认。</li>
</ul>
<p>注意：<code>FIN</code> 的接收也作为一个文件结束符（<code>end-of-file</code>）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，<code>FIN</code> 的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</p>
<ul>
<li>（3） 一段时间后，接收到这个文件结束符的应用进程将调用 <code>close</code> 关闭它的套接字。这导致它的 <code>TCP</code> 也发送一个 <code>FIN</code>。</li>
<li>（4） 接收这个最终 <code>FIN</code> 的原发送端TCP（即执行主动关闭的那一端）确认这个 <code>FIN</code>。</li>
</ul>
<p>既然每个方向都需要一个<code>FIN</code>和一个 <code>ACK</code> ，因此通常需要4个分节。</p>
<p>注意：<br>（1） <code>通常</code> 是指，某些情况下，步骤1的 <code>FIN</code> 随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。<br>（2） 在 步骤2 与 步骤3 之间，从执行 被动关闭一端 到 执行主动关闭一端 流动数据是可能的，这称为 <code>半关闭</code>（half-close）。<br>（3） 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个<code>FIN</code>。<br>无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。</p>
<h3 id="TCP重连"><a href="#TCP重连" class="headerlink" title="TCP重连"></a>TCP重连</h3><p><img src="/img/tcp%E9%87%8D%E8%BF%9E.png" alt="tcp重连.png"></p>
<p>四元组：源IP地址、目的IP地址、源端口、目的端口<br>五元组：源IP地址、目的IP地址、协议号、源端口、目的端口<br>七元组：源IP地址、目的IP地址、协议号、源端口、目的端口、服务类型、接口索引</p>
<h2 id="状态详解"><a href="#状态详解" class="headerlink" title="状态详解"></a>状态详解</h2><ol>
<li><p>CLOSED：表示初始状态。</p>
</li>
<li><p>LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</p>
</li>
<li><p>SYN_RCVD： 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</p>
</li>
<li><p>SYN_SENT： 这个状态与SYN_RCVD呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p>
</li>
<li><p>ESTABLISHED：表示连接已经建立了。</p>
</li>
<li><p>FIN_WAIT_1： FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</p>
</li>
<li><p>FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</p>
</li>
<li><p>TIME_WAIT： 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p>
</li>
<li><p>CLOSING： 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK 报文，再收到对方的 FIN 报文。但是 CLOSING 状态表示你发送 FIN 报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</p>
</li>
<li><p>LAST_ACK：它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</p>
</li>
</ol>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Hollake/article/details/89327474">Tcp报文简介以及头部选项字段(Tcp Options字段)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/blakegao/article/details/19419237">常用的TCP Option</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alifpga/p/7675799.html">TCP协议中的序列号</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/wuhaoshu/429027">TCP标志位详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mary19920410/article/details/77255967">浅析TCP中时间戳选项timestamp</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/08/Linux-TcpDump%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/08/Linux-TcpDump%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">Linux TcpDump工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-08 17:40:49" itemprop="dateCreated datePublished" datetime="2021-01-08T17:40:49+00:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-14 09:14:58" itemprop="dateModified" datetime="2021-05-14T09:14:58+00:00">2021-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TcpDump/" itemprop="url" rel="index"><span itemprop="name">TcpDump</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TcpDump 使用了独立于系统的 libpcap 的接口。libpcap 是linux平台下的网络数据包捕获函数包，大多数网络监控软件都以它为基础。tcpdump 调用libpcap 的接口在 linux 系统链路层抓包。而linux本身指定的许多访问控制规则都是基于三层或三层以上的过滤规则，所以 tcpdump 可以抓取过滤规则之前的数据包。使用tcpdump 需要有root权限。</p>
<h2 id="网卡基础知识"><a href="#网卡基础知识" class="headerlink" title="网卡基础知识"></a>网卡基础知识</h2><h3 id="网卡的不同接受模式"><a href="#网卡的不同接受模式" class="headerlink" title="网卡的不同接受模式"></a>网卡的不同接受模式</h3><ul>
<li>广播模式：该模式下网卡能接收网络中的广播信息。</li>
<li>组播模式：该模式下网卡能接收网络中的组播信息。</li>
<li>直接模式：该模式下网卡能接收网络中目的地址为自己的数据包。</li>
<li>混杂模式：该模式下网卡能接收网络中一切通过该网卡的数据包。</li>
</ul>
<p>注：网卡混杂模式：是网卡的一种工作模式，一般在抓取网卡数据包时使用。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">device eth0 entered promiscuous mode <span class="comment"># 是指网卡 eth0 进入了混杂模式。</span></span><br><span class="line">device eth0 left promiscuous mode <span class="comment"># 网卡 eth0 离开了混杂模式。</span></span><br><span class="line">ifconfig eth0 promisc <span class="comment"># 设置网卡eth0为混杂模式</span></span><br><span class="line">ifconfig eth0 -promisc <span class="comment"># 取消网卡eth0的混杂模式</span></span><br></pre></td></tr></table></figure>

<h3 id="网络中数据包的分类"><a href="#网络中数据包的分类" class="headerlink" title="网络中数据包的分类"></a>网络中数据包的分类</h3><ul>
<li>广播包：指IP子网内广播的数据包。适用范围较小只在本地子网有效。通过路由器和网络设备控制传输。</li>
<li>单播包：发送者和每一接受者中点对点的网络连接。</li>
<li>组播包：借助组播路由协议建立树形路由，在尽可能远的分岔路口才开始复制和奋发。（224.0.0.0~224.0.0.255是预留的组播地址）</li>
</ul>
<h3 id="数据包接收流程"><a href="#数据包接收流程" class="headerlink" title="数据包接收流程"></a>数据包接收流程</h3><ul>
<li>网卡收到数据包，获取数据包中的目的MAC地址。</li>
<li>根据网卡驱动设置的网卡接受模式去判断是否接受该数据。</li>
<li>若接受该数据：发出中断信号通知CPU；CPU收到中断信号后根据发出该中断信号的网卡驱动程序的网卡驱动程序地址调用网卡驱动程序；网卡驱动程序处理数据；驱动程序将数据放入信号堆栈；系统接触到数据。</li>
<li>若不接受该数据：网卡直接丢弃该数据；系统不会接触到数据。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解锁</span></span><br><span class="line"><span class="comment"># 如果不解锁，可能造成错误：Couldn&#x27;t find user &#x27;tcpdump&#x27;</span></span><br><span class="line">chattr -i /etc/passwd /etc/shadow /etc/group /etc/gshadow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum install tcpdump</span><br></pre></td></tr></table></figure>

<h2 id="tcpdump命令格式"><a href="#tcpdump命令格式" class="headerlink" title="tcpdump命令格式"></a>tcpdump命令格式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ]</span><br><span class="line">        [ -s snaplen ] [ -w file ] [ expression ]</span><br></pre></td></tr></table></figure>

<ul>
<li>-a 尝试将网络和广播地址转换成名称。</li>
<li>-c&lt;数据包数目&gt; 收到指定的数据包数目后，就停止进行倾倒操作。</li>
<li>-d 把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出。</li>
<li>-dd 把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出。</li>
<li>-ddd 把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出。</li>
<li>-e 在每列倾倒资料上显示连接层级的文件头。</li>
<li>-f 用数字显示网际网络地址。</li>
<li>-F&lt;表达文件&gt; 指定内含表达方式的文件。</li>
<li>-i&lt;网络界面&gt; 使用指定的网络截面送出数据包。</li>
<li>-l 使用标准输出列的缓冲区。</li>
<li>-n 不把主机的网络地址转换成名字。</li>
<li>-N 不列出域名。</li>
<li>-O 不将数据包编码最佳化。</li>
<li>-p 不让网络界面进入混杂模式。</li>
<li>-q 快速输出，仅列出少数的传输协议信息。</li>
<li>-r&lt;数据包文件&gt; 从指定的文件读取数据包数据。</li>
<li>-s&lt;数据包大小&gt; 设置每个数据包的大小。</li>
<li>-S 用绝对而非相对数值列出TCP关联数。</li>
<li>-t 在每列倾倒资料上不显示时间戳记。</li>
<li>-tt 在每列倾倒资料上显示未经格式化的时间戳记。</li>
<li>-T&lt;数据包类型&gt; 强制将表达方式所指定的数据包转译成设置的数据包类型。</li>
<li>-v 详细显示指令执行过程。</li>
<li>-vv 更详细显示指令执行过程。</li>
<li>-vvv：产生比-vv更详细的输出。</li>
<li>-x 用十六进制字码列出数据包资料。</li>
<li>-w&lt;数据包文件&gt; 把数据包数据写入指定的文件。</li>
</ul>
<h2 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听特定主机</span></span><br><span class="line">tcpdump host 182.254.38.55</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定来源</span></span><br><span class="line">tcpdump src host hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定目标地址</span></span><br><span class="line">tcpdump dst host hostname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 特定端口</span></span><br><span class="line">tcpdump port 3000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听TCP/UDP</span></span><br><span class="line">tcpdump tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 来源主机+端口+TCP</span></span><br><span class="line"><span class="comment"># 监听来自主机 10.207.22.254 在端口 8011 上的TCP数据包</span></span><br><span class="line">tcpdump tcp port 8011 and src host 10.207.22.254</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听特定主机之间的通信</span></span><br><span class="line">tcpdump ip host 210.27.48.1 and 210.27.48.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存到本地</span></span><br><span class="line"><span class="comment"># 备注：tcpdump 默认会将输出写到缓冲区，只有缓冲区内容达到一定的大小，或者tcpdump退出时，才会将输出写到本地磁盘</span></span><br><span class="line">tcpdump -n -vvv -c 1000 -w /ldjc/data.pcap</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>TCP协议行的典型格式如下：</p>
<p>[Timestamp] [Protocol] [Src IP].[Src Port] &gt; [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]</p>
<p>让我们逐个字段进行说明，并解释以下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">21:53:20.460144 IP 192.168.182.166.57494 &gt; 35.222.85.5.80: Flags [P.], seq 1:88, ack 1, win 29200,  </span><br><span class="line">options [nop,nop,TS val 1067794587 ecr 2600218930], length 87</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">21:53:20.460144 - 捕获的数据包的时间戳为本地时间，并使用以下格式：hours：minutes：seconds.frac，</span><br><span class="line">        其中frac是自午夜以来的几分之一秒。</span><br><span class="line">IP - 分组协议。 在这种情况下，IP表示Internet协议版本4（IPv4）。</span><br><span class="line">192.168.182.166.57494 - 源IP地址和端口，以点（.）分隔。</span><br><span class="line">35.222.85.5.80 - 目的IP地址和端口，以点号（.）分隔。</span><br></pre></td></tr></table></figure>

<p>TCP 标志字段。 在此示例中，[P.] 表示推送确认数据包，用于确认前一个数据包并发送数据。 其他典型标志字段值如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[.] - ACK (Acknowledgment)</span><br><span class="line">[S] - SYN (Start Connection)</span><br><span class="line">[P] - PSH (Push Data)</span><br><span class="line">[F] - FIN (Finish Connection)</span><br><span class="line">[R] - RST (Reset Connection)</span><br><span class="line">[S.] - SYN-ACK (SynAcK Packet)</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seq 1:88 - 序列号在first：last表示法中。 它显示了数据包中包含的数据数量。 </span><br><span class="line">        除了数据流中的第一个数据包（其中这些数字是绝对的）以外，所有后续数据包均用作相对字节位置。 </span><br><span class="line">        在此示例中，数字为1:88，表示此数据包包含数据流的字节1至88。 使用-S选项可打印绝对序列号。</span><br><span class="line">ack 1 - 确认号（acknowledgment number）是此连接另一端所期望的下一个数据的序列号。</span><br><span class="line">win 29200 - 窗口号是接收缓冲区中可用字节的数目。</span><br><span class="line">options [nop,nop,TS val 1067794587 ecr 2600218930] - TCP选项。 </span><br><span class="line">        使用 nop 或 “ no operation” 填充使TCP报头为4字节的倍数。 </span><br><span class="line">        TS val 是TCP时间戳，而 ecr 表示回显应答。 请访问 IANA 文档以获取有关 TCP 选项的更多信息。</span><br><span class="line">length 87 - 有效载荷数据的长度</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/godop/article/details/80986966">tcpdump抓包wireshark分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chinaltx/article/details/87469933">一文搞定tcpdump基本用法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2020-02/162226.htm">Linux下抓包命令tcpdump详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chyingp/p/linux-command-tcpdump.html">Linux基础：用tcpdump抓包</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8d9accf1d2f1">聊聊 tcpdump 与 Wireshark 抓包分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">414</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">178</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
