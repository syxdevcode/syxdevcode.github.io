<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/26/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/07/06/Openssl%E7%94%9F%E6%88%90SSL-TLS%E8%AF%81%E4%B9%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/06/Openssl%E7%94%9F%E6%88%90SSL-TLS%E8%AF%81%E4%B9%A6/" class="post-title-link" itemprop="url">Openssl生成SSL/TLS证书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-06 08:42:38" itemprop="dateCreated datePublished" datetime="2018-07-06T08:42:38+00:00">2018-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Openssl/" itemprop="url" rel="index"><span itemprop="name">Openssl</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="openssl生成SSL-TLS证书"><a href="#openssl生成SSL-TLS证书" class="headerlink" title="openssl生成SSL/TLS证书"></a>openssl生成SSL/TLS证书</h1><p>官网：<a target="_blank" rel="noopener" href="https://www.openssl.org/">https://www.openssl.org/</a></p>
<p>github:<a target="_blank" rel="noopener" href="https://github.com/openssl/openssl">https://github.com/openssl/openssl</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://www.openssl.org/docs/manmaster/man1/">https://www.openssl.org/docs/manmaster/man1/</a></p>
<h2 id="证书相关概念"><a href="#证书相关概念" class="headerlink" title="证书相关概念"></a>证书相关概念</h2><h3 id="CA根证书"><a href="#CA根证书" class="headerlink" title="CA根证书"></a>CA根证书</h3><p>首先要有一个CA根证书，然后用CA根证书来签发用户证书。<br>用户进行证书申请：一般先生成一个私钥，然后用私钥生成证书请求(证书请求里应含有公钥信息)，再利用证书服务器的CA根证书来签发证书。</p>
<p>** 特别说明:**</p>
<ul>
<li>（1）自签名证书(一般用于顶级证书、根证书): 证书的名称和认证机构的名称相同.</li>
<li>（2）根证书：根证书是CA认证中心给自己颁发的证书,是信任链的起始点。任何安装CA根证书的服务器都意味着对这个CA认证中心是信任的。</li>
</ul>
<p>数字证书则是由证书认证机构（CA）对证书申请者真实身份验证之后，用CA的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机构的公章）后形成的一个数字文件。数字证书包含证书中所标识的实体的公钥（就是说你的证书里有你的公钥），由于证书将公钥与特定的个人匹配，并且该证书的真实性由颁发机构保证（就是说可以让大家相信你的证书是真的），因此，数字证书为如何找到用户的公钥并知道它是否有效这一问题提供了解决方案。</p>
<h3 id="PKCS的15个标准"><a href="#PKCS的15个标准" class="headerlink" title="PKCS的15个标准"></a>PKCS的15个标准</h3><p>PKCS 全称是 Public-Key Cryptography Standards ，是由 RSA 实验室与其它安全系统开发商为促进公钥密码的发展而制订的一系列标准。</p>
<ul>
<li><p>** PKCS#1 **：RSA加密标准。PKCS#1定义了RSA公钥函数的基本格式标准，特别是数字签名。它定义了数字签名如何计算，包括待签名数据和签名本身的格式；它也定义了PSA公/私钥的语法。</p>
</li>
<li><p>** PKCS#2 **：涉及了RSA的消息摘要加密，这已被并入PKCS#1中。</p>
</li>
<li><p>** PKCS#3 **：Diffie-Hellman密钥协议标准。PKCS#3描述了一种实现Diffie- Hellman密钥协议的方法。</p>
</li>
<li><p>** PKCS#4 **：最初是规定RSA密钥语法的，现已经被包含进PKCS#1中。</p>
</li>
<li><p>** PKCS#5 **：基于口令的加密标准。PKCS#5描述了使用由口令生成的密钥来加密8位位组串并产生一个加密的8位位组串的方法。PKCS#5可以用于加密私钥，以便于密钥的安全传输（这在PKCS#8中描述）。</p>
</li>
<li><p>** PKCS#6 **：扩展证书语法标准。PKCS#6定义了提供附加实体信息的X.509证书属性扩展的语法（当PKCS#6第一次发布时，X.509还不支持扩展。这些扩展因此被包括在X.509中）。</p>
</li>
<li><p>** PKCS#7 **：密码消息语法标准。PKCS#7为使用密码算法的数据规定了通用语法，比如数字签名和数字信封。PKCS#7提供了许多格式选项，包括未加密或签名的格式化消息、已封装（加密）消息、已签名消息和既经过签名又经过加密的消息。</p>
</li>
<li><p>** PKCS#8 **：私钥信息语法标准。PKCS#8定义了私钥信息语法和加密私钥语法，其中私钥加密使用了PKCS#5标准。</p>
</li>
<li><p>** PKCS#9 **：可选属性类型。PKCS#9定义了PKCS#6扩展证书、PKCS#7数字签名消息、PKCS#8私钥信息和PKCS#10证书签名请求中要用到的可选属性类型。已定义的证书属性包括E-mail地址、无格式姓名、内容类型、消息摘要、签名时间、签名副本（counter signature）、质询口令字和扩展证书属性。</p>
</li>
<li><p>** PKCS#10 **：证书请求语法标准。PKCS#10定义了证书请求的语法。证书请求包含了一个唯一识别名、公钥和可选的一组属性，它们一起被请求证书的实体签名（证书管理协议中的PKIX证书请求消息就是一个PKCS#10）。</p>
</li>
<li><p>** PKCS#11 **：密码令牌接口标准。PKCS#11或“Cryptoki”为拥有密码信息（如加密密钥和证书）和执行密码学函数的单用户设备定义了一个应用程序接口（API）。智能卡就是实现Cryptoki的典型设备。注意：Cryptoki定义了密码函数接口，但并未指明设备具体如何实现这些函数。而且Cryptoki只说明了密码接口，并未定义对设备来说可能有用的其他接口，如访问设备的文件系统接口。</p>
</li>
<li><p>** PKCS#12 **：个人信息交换语法标准。PKCS#12定义了个人身份信息（包括私钥、证书、各种秘密和扩展字段）的格式。PKCS#12有助于传输证书及对应的私钥，于是用户可以在不同设备间移动他们的个人身份信息。</p>
</li>
<li><p>** PDCS#13 **：椭圆曲线密码标准。PKCS#13标准当前正在完善之中。它包括椭圆曲线参数的生成和验证、密钥生成和验证、数字签名和公钥加密，还有密钥协定，以及参数、密钥和方案标识的ASN.1语法。</p>
</li>
<li><p>** PKCS#14 **：伪随机数产生标准。PKCS#14标准当前正在完善之中。为什么随机数生成也需要建立自己的标准呢？PKI中用到的许多基本的密码学函数，如密钥生成和Diffie-Hellman共享密钥协商，都需要使用随机数。然而，如果“随机数”不是随机的，而是取自一个可预测的取值集合，那么密码学函数就不再是绝对安全了，因为它的取值被限于一个缩小了的值域中。因此，安全伪随机数的生成对于PKI的安全极为关键。</p>
</li>
<li><p>** PKCS#15 **：密码令牌信息语法标准。PKCS#15通过定义令牌上存储的密码对象的通用格式来增进密码令牌的互操作性。在实现PKCS#15的设备上存储的数据对于使用该设备的所有应用程序来说都是一样的，尽管实际上在内部实现时可能所用的格式不同。PKCS#15的实现扮演了翻译家的角色，它在卡的内部格式与应用程序支持的数据格式间进行转换。</p>
</li>
</ul>
<p>** 注意：** net,ios中rsa加解密使用的是pkcs1，而java使用的是pkcs8</p>
<p>以上参考：<a target="_blank" rel="noopener" href="http://falchion.iteye.com/blog/1472453">PKCS 发布的15 个标准</a></p>
<h3 id="x509证书"><a href="#x509证书" class="headerlink" title="x509证书"></a>x509证书</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>X.509 是密码学里公钥证书的格式标准。 X.509 证书己应用在包括TLS/SSL（WWW万维网安全浏览的基石）在内的众多 Intenet协议里.同时它也用在很多非在线应用场景里，比如电子签名服务。X.509证书里含有公钥、身份信息(比如网络主机名，组织的名称或个体名称等)和签名信息（可以是证书签发机构CA的签名，也可以是自签名）。对于一份经由可信的证书签发机构签名或者可以通过其它方式验证的证书，证书的拥有者就可以用证书及相应的私钥来创建安全的通信，对文档进行数字签名.X.509还附带了证书吊销列表和用于从最终对证书进行签名的证书签发机构直到最终可信点为止的证书合法性验证算法。</p>
<p>当前使用的版本是X.509 V3，它加入了扩展字段支持，这极大地增进了证书的灵活性。X.509 V3证书包括一组按预定义顺序排列的强制字段，还有可选扩展字段，即使在强制字段中，X.509证书也允许很大的灵活性，因为它为大多数字段提供了多种编码方案.</p>
<p>x509证书一般会用到三类文件，key，csr，crt。<br>Key是私用密钥，openssl格式，通常是rsa算法。<br>csr是证书请求文件，用于申请证书。在制作csr文件的时候，必须使用自己的私钥来签署申请，还可以设定一个密钥。<br>crt是CA认证后的证书文件（windows下面的csr，其实是crt），签署人用自己的key给你签署的凭证。</p>
<h4 id="编码格式-也用作扩展"><a href="#编码格式-也用作扩展" class="headerlink" title="编码格式(也用作扩展)"></a>编码格式(也用作扩展)</h4><ul>
<li><p>** .PEM **- PEM扩展名用于不同类型的X.509v3文件,全称Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是ASCII(BASE64)编码.</p>
<p>  查看PEM格式证书的信息: <code>openssl x509 -in certificate.pem -text -noout</code></p>
<p>  Apache和*NIX服务器偏向于使用这种编码格式.</p>
</li>
<li><p>** .DER** - DER扩展用于二进制DER编码证书,全称Distinguished Encoding Rules,打开看是二进制格式,不可读,这些文件也可能带有CER或CRT扩展名.</p>
<p>  查看DER格式证书的信息: <code>openssl x509 -in certificate.der -inform der -text -noout</code></p>
<p>  Java和Windows服务器偏向于使用这种编码格式.</p>
</li>
</ul>
<p>例如：</p>
<p>密钥pem格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<p>证书pem格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<h4 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h4><ul>
<li><p>** .key格式 **：通常用来存放一个公钥或者私钥,默认PKCS＃1,并非X.509证书,可能是PEM,也可能是DER</p>
</li>
<li><p>** .csr/.p10格式 **：证书签名请求（证书请求文件），含有公钥信息，certificate signing request的缩写,PKCS#10标准定义</p>
</li>
<li><p>** .crt格式 **：证书文件，certificate的缩写,CRT扩展名用于证书，只有公钥没有私钥。证书可以编码为二进制DER或ASCII PEM。CER和CRT扩展几乎是同义词</p>
</li>
<li><p>** .cer格式 **：证书文件,常见于Windows系统，certificate缩写，只有公钥没有私钥,可能是PEM编码,也可能是DER编码,大多数应该是DER编码,crt文件和cer文件只有在使用相同编码的时候才可以安全地相互替代。</p>
</li>
<li><p>** .crl格式 **：证书吊销列表，Certificate Revocation List的缩写</p>
</li>
<li><p>** .pem格式 **：用于导出，导入证书时候的证书的格式，用于不同类型的X.509v3文件，有证书开头，结尾的格式</p>
</li>
<li><p>** .p7b/.p7r格式 **： 以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥,PKCS#7标准定义</p>
</li>
<li><p>** .p7c/.p7m/.p7s格式 **：PKCS#7证书格式，仅仅包含证书和CRL列表信息，没有私钥。</p>
</li>
<li><p>** .pfx/p12格式 **：由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作为证书文件后缀名。PFX（也称为PKCS＃12）支持证书，私钥和证书路径中的所有证书的安全存储。PKCS＃12格式是唯一可用于导出证书及其私钥的文件格式。</p>
</li>
</ul>
<h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><h3 id="openssl基本命令"><a href="#openssl基本命令" class="headerlink" title="openssl基本命令"></a>openssl基本命令</h3><p>公钥负责加密，私钥负责解密</p>
<p>私钥负责签名，公钥负责验证</p>
<h4 id="修改openssl-cnf配置文件"><a href="#修改openssl-cnf配置文件" class="headerlink" title="修改openssl.cnf配置文件"></a>修改openssl.cnf配置文件</h4><p>首先需要定位openssl.cnf文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate openssl.cnf</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/pki/tls/openssl.cnf</span><br><span class="line">/usr/share/man/man5/openssl.cnf.5ssl.gz</span><br></pre></td></tr></table></figure>

<p>修改配置文件，修改其中的dir变量,重新设置SSL的工作目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pki/tls/openssl.cnf</span><br></pre></td></tr></table></figure>

<h4 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h4><p>命令：<code>openssl genrsa</code></p>
<p>查看帮助：<code>openssl genrsa -h</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-des           生成的私钥采用DES算法加密</span><br><span class="line">-des3          生成的私钥采用DES3算法加密 (168 bit key)</span><br><span class="line">-seed          encrypt PEM output with cbc seed</span><br><span class="line">-aes128, -aes192, -aes256</span><br><span class="line">-out file       私钥输出位置</span><br><span class="line">-passout arg    输出文件的密码，如果我们指定了对称加密算法，也可以不带此参数，会有命令行提示你输入密码</span><br></pre></td></tr></table></figure>

<p>生成一个私钥：<br>默认长度512,PKCS1格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"><span class="comment">## 或者</span></span><br><span class="line">openssl genrsa -des3 -passout pass:123456 -out RSA.pem</span><br></pre></td></tr></table></figure>

<p>查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat ca.key</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIIEpAIBAAKCAQE..................</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<h4 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h4><p>命令：<code>openssl rsa</code></p>
<p>查看帮助：<code>openssl rsa -h</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-inform arg     输入文件编码格式，只有pem和der两种</span><br><span class="line">-outform arg    输出文件编码格式，只有pem和der两种</span><br><span class="line">-<span class="keyword">in</span> arg         input file  输入文件</span><br><span class="line">-sgckey         Use IIS SGC key format</span><br><span class="line">-passin arg     如果输入文件被对称加密过，需要指定输入文件的密码</span><br><span class="line">-out arg        输出文件位置</span><br><span class="line">-passout arg    如果输出文件也需要被对称加密，需要指定输出文件的密码</span><br><span class="line"></span><br><span class="line">-des            对输出结果采用对称加密 des算法</span><br><span class="line">-des3           对输出结果采用对称加密 des3算法</span><br><span class="line">-seed</span><br><span class="line">-aes128, -aes192, -aes256</span><br><span class="line"></span><br><span class="line">以上几个都是对称加密算法的指定，生成私钥的时候一般会用到，我们不让私钥明文保存</span><br><span class="line"></span><br><span class="line">-text           以明文形式输出各个参数值</span><br><span class="line">-noout          不输出密钥到任何文件</span><br><span class="line">-modulus        输出模数值</span><br><span class="line">-check          检查输入密钥的正确性和一致性</span><br><span class="line">-pubin          指定输入文件是公钥</span><br><span class="line">-pubout         指定输出文件是公钥</span><br><span class="line">-engine e       指定三方加密库或者硬件</span><br></pre></td></tr></table></figure>

<p>使用刚刚生成的私钥，以生成公钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -<span class="keyword">in</span> ca.key -pubout -out ca_pub.key</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 为RSA密钥增加口令保护</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> RSA.pem -des3 -passout pass:123456 -out E_RSA.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">##为RSA密钥去除口令保护</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> E_RSA.pem -passin pass:123456 -out P_RSA.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">## 比较</span></span><br><span class="line">diff RSA.pem P_RSA.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">##修改加密算法为aes128，口令是123456</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -aes128 -passout pass:123456 -out E_RSA.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看密钥对中的各个参数</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> RSA.pem -des -passin pass:123456 -text -noout</span><br><span class="line"></span><br><span class="line"><span class="comment">## 提取密钥中的公钥并打印模数值</span></span><br><span class="line"><span class="comment">## 提取公钥，用pubout参数指定输出为公钥</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -pubout -out pub.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">##打印公钥中模数值</span></span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> pub.pem -pubin -modulus -noout</span><br><span class="line"></span><br><span class="line">Modulus=C2B..........3ED</span><br><span class="line"></span><br><span class="line"><span class="comment">##把pem格式转化成der格式，使用outform指定der格式</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -des -passout pass:123456 -outform der -out rsa.der</span><br><span class="line"></span><br><span class="line"><span class="comment">##把der格式转化成pem格式，使用inform指定der格式</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> rsa.der -inform der -passin pass:123456 -out rsa.pem</span><br></pre></td></tr></table></figure>

<h4 id="加解密-签名验证"><a href="#加解密-签名验证" class="headerlink" title="加解密/签名验证"></a>加解密/签名验证</h4><p>命令：<code>openssl rsautl</code></p>
<p>注意：无论是使用公钥加密还是私钥加密，RSA每次能够加密的数据长度不能超过RSA密钥长度，并且根据具体的补齐方式不同输入的加密数据最大长度也不一样，而输出长度则总是跟RSA密钥长度相等。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180706152021.png" alt="QQ截图20180706152021.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">openssl rsautl -h</span><br><span class="line">Usage: rsautl [options]</span><br><span class="line">-<span class="keyword">in</span> file        input file                                           //输入文件</span><br><span class="line">-out file       output file                                          //输出文件</span><br><span class="line">-inkey file     input key                                            //输入的密钥</span><br><span class="line">-keyform arg    private key format - default PEM                     //指定密钥格式</span><br><span class="line">-pubin          input is an RSA public                               //指定输入的是RSA公钥</span><br><span class="line">-certin         input is a certificate carrying an RSA public key    //指定输入的是证书文件</span><br><span class="line">-ssl            use SSL v2 padding                                   //使用SSLv23的填充方式</span><br><span class="line">-raw            use no padding                                       //不进行填充</span><br><span class="line">-pkcs           use PKCS<span class="comment">#1 v1.5 padding (default)                    //使用V1.5的填充方式</span></span><br><span class="line">-oaep           use PKCS<span class="comment">#1 OAEP                                      //使用OAEP的填充方式</span></span><br><span class="line">-sign           sign with private key                                //使用私钥做签名</span><br><span class="line">-verify         verify with public key                               //使用公钥认证签名</span><br><span class="line">-encrypt        encrypt with public key                              //使用公钥加密</span><br><span class="line">-decrypt        decrypt with private key                             //使用私钥解密</span><br><span class="line">-hexdump        hex dump output                                      //以16进制dump输出</span><br><span class="line">-engine e       use engine e, possibly a hardware device.            //指定三方库或者硬件设备</span><br><span class="line">-passin arg    pass phrase <span class="built_in">source</span>                                    //指定输入的密码</span><br></pre></td></tr></table></figure>

<h5 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##生成RSA密钥</span></span><br><span class="line">openssl genrsa -des3 -passout pass:123456 -out RSA.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">##提取公钥</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> RSA.pem -passin pass:123456 -pubout -out pub.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">##使用RSA作为密钥进行加密，实际上使用其中的公钥进行加密</span></span><br><span class="line">openssl rsautl -encrypt -<span class="keyword">in</span> plain.txt -inkey RSA.pem -passin pass:123456 -out enc.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##使用RSA作为密钥进行解密，实际上使用其中的私钥进行解密</span></span><br><span class="line">openssl rsautl -decrypt -<span class="keyword">in</span> enc.txt -inkey RSA.pem -passin pass:123456 -out replain.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##比较原始文件和解密后文件</span></span><br><span class="line">diff plain.txt replain.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##使用公钥进行加密</span></span><br><span class="line">openssl rsautl -encrypt -<span class="keyword">in</span> plain.txt -inkey pub.pem -pubin -out enc1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##私钥进行解密</span></span><br><span class="line">openssl rsautl -decrypt -<span class="keyword">in</span> enc1.txt -inkey RSA.pem -passin pass:123456 -out replain1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##比较原始文件和解密后文件</span></span><br><span class="line">diff plain.txt replain1.txt</span><br></pre></td></tr></table></figure>

<h5 id="签名与验证"><a href="#签名与验证" class="headerlink" title="签名与验证"></a>签名与验证</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##使用RSA密钥进行签名，实际上使用私钥进行签名</span></span><br><span class="line">openssl rsautl -sign -<span class="keyword">in</span> plain.txt -inkey RSA.pem -passin pass:123456 -out sign.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##使使用RSA密钥进行验证，实际上使用公钥进行验证</span></span><br><span class="line">openssl rsautl -verify -<span class="keyword">in</span> sign.txt -inkey RSA.pem -passin pass:123456 -out replain.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##对比原始文件和签名解密后的文件</span></span><br><span class="line">diff plain.txt replain.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##提取PCKS8格式的私钥</span></span><br><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> RSA.pem -passin pass:123456 -out pri.pem -nocrypt</span><br><span class="line"></span><br><span class="line"><span class="comment">##使用私钥进行签名</span></span><br><span class="line">openssl rsautl -sign -<span class="keyword">in</span> plain.txt -inkey pri.pem  -out sign1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##使用公钥进行验证</span></span><br><span class="line">openssl rsautl -verify -<span class="keyword">in</span> sign1.txt -inkey pub.pem -pubin -out replain1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">##对比原始文件和签名解密后的文件</span></span><br><span class="line">diff plain.txt replain1.txt</span><br></pre></td></tr></table></figure>

<h3 id="CA证书生成"><a href="#CA证书生成" class="headerlink" title="CA证书生成"></a>CA证书生成</h3><p>生成CA私钥（.key）–&gt;生成CA证书请求（.csr）–&gt;自签名得到根证书（.crt）（CA给自已颁发的证书）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate CA private key</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"><span class="comment"># Generate CSR</span></span><br><span class="line">openssl req -new -key ca.key -out ca.csr <span class="comment">## 需要手动输入回车</span></span><br><span class="line"><span class="comment"># Generate Self Signed certificate（CA 根证书）</span></span><br><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment">##或者</span></span><br><span class="line"><span class="comment"># Generate CA private key</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"></span><br><span class="line">openssl req -passin pass:1111 -new -x509 -days 365 -key ca.key -out ca.crt -subj <span class="string">&quot;/C=CN/ST=JS/L=ZJ/O=zx/OU=test/CN=root&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="用户证书"><a href="#用户证书" class="headerlink" title="用户证书"></a>用户证书</h3><p>生成私钥（.key）–&gt;生成证书请求（.csr）–&gt;用CA根证书签名得到证书（.crt）</p>
<h4 id="服务器端证书"><a href="#服务器端证书" class="headerlink" title="服务器端证书"></a>服务器端证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -passout pass:1111 -des3 -out server.key 2048</span><br><span class="line">openssl req -passin pass:1111 -new -key server.key -out server.csr -subj <span class="string">&quot;/C=CN/ST=JS/L=ZJ/O=zx/OU=test/CN=www.shiyx.top:5673&quot;</span></span><br><span class="line">openssl x509 -req -passin pass:1111 -days 365 -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt</span><br><span class="line">openssl rsa -passin pass:1111 -<span class="keyword">in</span> server.key -out server.key <span class="comment">## 移除密码</span></span><br><span class="line"><span class="comment">## 生成pfx格式证书，需要输入密码，或使用 -passin pass:1111</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out server.pfx -inkey server.key -<span class="keyword">in</span> server.crt -certfile ca.crt</span><br></pre></td></tr></table></figure>

<h4 id="客户端证书"><a href="#客户端证书" class="headerlink" title="客户端证书"></a>客户端证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -passout pass:1111 -des3 -out client.key 2048</span><br><span class="line">openssl req -passin pass:1111 -new -key client.key -out client.csr -subj <span class="string">&quot;/C=CN/ST=JS/L=ZJ/O=zx/OU=test/CN=www.shiyx.top:5673&quot;</span></span><br><span class="line">openssl x509 -passin pass:1111 -req -days 365 -<span class="keyword">in</span> client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt</span><br><span class="line">openssl rsa -passin pass:1111 -<span class="keyword">in</span> client.key -out client.key <span class="comment">## 移除密码</span></span><br></pre></td></tr></table></figure>

<h4 id="PKCS＃12-pfx-p12-证书生成"><a href="#PKCS＃12-pfx-p12-证书生成" class="headerlink" title="PKCS＃12(.pfx .p12)证书生成"></a>PKCS＃12(.pfx .p12)证书生成</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##将PEM证书文件和私钥转换为PKCS＃12(.pfx .p12)</span></span><br><span class="line"><span class="comment">## 需要输入密码</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out server.pfx -inkey server.key -<span class="keyword">in</span> server.crt -certfile ca.crt</span><br></pre></td></tr></table></figure>

<h4 id="生成pem格式证书"><a href="#生成pem格式证书" class="headerlink" title="生成pem格式证书"></a>生成pem格式证书</h4><p>有时需要用到pem格式的证书，可以用以下方式合并证书文件（crt）和私钥文件（key）来生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> client.crt client.key&gt; client.pem</span><br><span class="line"><span class="variable">$cat</span> server.crt server.key &gt; server.pem</span><br><span class="line">$ cat server.crt server.key|tee server.pem <span class="comment"># 将私钥和证书合并到一个文件中</span></span><br></pre></td></tr></table></figure>

<p>tee：定向输出到server.pem</p>
<h4 id="证书转换"><a href="#证书转换" class="headerlink" title="证书转换"></a>证书转换</h4><p>可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 <span class="comment">## 必须为证书文件， .key文件非证书文件</span></span><br><span class="line"></span><br><span class="line">openssl rsa  <span class="comment">## 必须为密钥文件。</span></span><br></pre></td></tr></table></figure>

<p>依赖命令中参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-inform pem|der : 输入文件格式</span><br><span class="line">-outform der|pem: 输出文件格式</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## crt转换为pem</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.crt -out server.pem <span class="comment">## -outform der :从pem格式转成der格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## pem转换为crt</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> server.pem -out server1.crt <span class="comment">## -outform der :从der格式转成pem格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 比较</span></span><br><span class="line">diff server.crt server1.crt</span><br><span class="line"></span><br><span class="line"><span class="comment">## der格式转成pem格式</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> ca.crt -outform der -out ca.der</span><br><span class="line">openssl rsa -<span class="keyword">in</span> ca.key -outform der -out ca1.der</span><br><span class="line"></span><br><span class="line"><span class="comment">## pem格式转成crt格式 需要指定 -inform der</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> ca.der -inform der -outform pem -out ca.pem</span><br><span class="line">diff ca.pem ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment">##将PEM证书文件和私钥转换为PKCS＃12(.pfx .p12)</span></span><br><span class="line"><span class="comment">## 需要输入密码</span></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out server.pfx -inkey server.key -<span class="keyword">in</span> server.crt -certfile ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment">##将包含私钥和证书的PKCS＃12文件(.pfx .p12)转换为PEM</span></span><br><span class="line"><span class="comment">## 需要输入密码</span></span><br><span class="line">openssl pkcs12 -<span class="keyword">in</span> server.pfx -out server1.pem -nodes</span><br><span class="line">diff server.pem server.crt</span><br><span class="line"></span><br><span class="line">openssl pkcs12 -<span class="keyword">in</span> server.pfx -out server.cer -nodes</span><br></pre></td></tr></table></figure>

<h4 id="pkcs1与pkcs8格式RSA私钥互相转换"><a href="#pkcs1与pkcs8格式RSA私钥互相转换" class="headerlink" title="pkcs1与pkcs8格式RSA私钥互相转换"></a>pkcs1与pkcs8格式RSA私钥互相转换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -inform PEM -<span class="keyword">in</span> server.key -outform pem -nocrypt -out pkcs8.pem</span><br><span class="line"><span class="comment">## openssl pkcs8 -in pkcs8.pem -nocrypt -out server2.key ## 失效</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> pkcs8.pem -out pkcs1.pem</span><br><span class="line">diff server.key pkcs1.pem</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuchunming033/article/details/48470575">openssl生成SSL证书的流程</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X.509">X.509</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guogangj/p/4118605.html">那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/15b1d935a44b">OpenSSL加解密使用</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/f-ck-need-u/p/7115871.html">openssl ca(签署和自建CA)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/08e41304edab">pkcs1与pkcs8格式RSA私钥互相转换</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/yaozhenfa/p/gRpc_with_ssl.html">http://www.cnblogs.com/yaozhenfa/p/gRpc_with_ssl.html</a></p>
<p><a target="_blank" rel="noopener" href="https://vimsky.com/article/3608.html">https://vimsky.com/article/3608.html</a></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/13732826/convert-pem-to-crt-and-key?answertab=votes">https://stackoverflow.com/questions/13732826/convert-pem-to-crt-and-key?answertab=votes</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/07/04/Docker%E6%90%AD%E5%BB%BARabbitMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BE%A4%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/04/Docker%E6%90%AD%E5%BB%BARabbitMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BE%A4%E9%9B%86/" class="post-title-link" itemprop="url">Docker搭建RabbitMQ高可用群集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-04 13:45:17" itemprop="dateCreated datePublished" datetime="2018-07-04T13:45:17+00:00">2018-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker搭建RabbitMQ高可用群集"><a href="#Docker搭建RabbitMQ高可用群集" class="headerlink" title="Docker搭建RabbitMQ高可用群集"></a>Docker搭建RabbitMQ高可用群集</h1><p>官方镜像：</p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/_/rabbitmq/">https://hub.docker.com/_/rabbitmq/</a><br><a target="_blank" rel="noopener" href="https://github.com/docker-library/rabbitmq/blob/4b2b11c59ee65c2a09616b163d4572559a86bb7b/3.7/debian/management/Dockerfile">Dockerfile</a></p>
<h2 id="Docker搭建RabbitMQ单机容器"><a href="#Docker搭建RabbitMQ单机容器" class="headerlink" title="Docker搭建RabbitMQ单机容器"></a>Docker搭建RabbitMQ单机容器</h2><p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq</span><br><span class="line">|--rabbitmq-a</span><br><span class="line">  |--data</span><br></pre></td></tr></table></figure>

<p>获取镜像：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:<span class="number">3.7</span>.<span class="number">6</span>-management</span><br></pre></td></tr></table></figure>

<p>使用以下命令运行容器：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d --name rabbitmq-a \</span></span><br><span class="line"><span class="bash">    -p 4369:4369 \</span></span><br><span class="line"><span class="bash">    -p 5671:5671 \</span></span><br><span class="line"><span class="bash">    -p 5672:5672 \</span></span><br><span class="line"><span class="bash">    -p 25672:25672 \</span></span><br><span class="line"><span class="bash">    -p 15672:15672 \</span></span><br><span class="line"><span class="bash">    -h rabbitmq-node1 \</span></span><br><span class="line"><span class="bash">    -e RABBITMQ_NODENAME=rabbit \</span></span><br><span class="line"><span class="bash">    -e RABBITMQ_DEFAULT_USER=admin \</span></span><br><span class="line"><span class="bash">    -e RABBITMQ_DEFAULT_PASS=admin \</span></span><br><span class="line"><span class="bash">    -v <span class="variable">$PWD</span>/rabbitmq-a/data:/var/lib/rabbitmq \</span></span><br><span class="line"><span class="bash">    rabbitmq:3.7.6-management</span></span><br></pre></td></tr></table></figure>

<p>进入容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it rabbitmq-a /bin/bash</span><br></pre></td></tr></table></figure>

<p>查看群集：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@rabbitmq-node1:/<span class="comment"># rabbitmqctl cluster_status</span></span><br><span class="line">Cluster status of node rabbit@rabbitmq-node1 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[<span class="string">&#x27;rabbit@rabbitmq-node1&#x27;</span>]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[<span class="string">&#x27;rabbit@rabbitmq-node1&#x27;</span>]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;<span class="string">&quot;rabbit@rabbitmq-node1&quot;</span>&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;<span class="string">&#x27;rabbit@rabbitmq-node1&#x27;</span>,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<p>查找cookie:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;.erlang.cookie&quot;</span></span><br><span class="line">cat /var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@rabbitmq-node1:/<span class="comment"># find / -name &quot;.erlang.cookie&quot;</span></span><br><span class="line">/root/.erlang.cookie</span><br><span class="line">/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">root@rabbitmq-node1:/<span class="comment"># cat /var/lib/rabbitmq/.erlang.cookie</span></span><br><span class="line">BYCWRWRQGDLYZZDXDBSB</span><br></pre></td></tr></table></figure>

<h2 id="RabbitMQ-Server-高可用集群相关概念"><a href="#RabbitMQ-Server-高可用集群相关概念" class="headerlink" title="RabbitMQ Server 高可用集群相关概念"></a>RabbitMQ Server 高可用集群相关概念</h2><h3 id="设计集群的目的"><a href="#设计集群的目的" class="headerlink" title="设计集群的目的"></a>设计集群的目的</h3><ul>
<li>允许消费者和生产者在 RabbitMQ 节点崩溃的情况下继续运行。</li>
<li>通过增加更多的节点来扩展消息通信的吞吐量。</li>
</ul>
<h3 id="集群配置方式"><a href="#集群配置方式" class="headerlink" title="集群配置方式"></a>集群配置方式</h3><ul>
<li>cluster：不支持跨网段，用于同一个网段内的局域网；可以随意的动态增加或者减少；节点之间需要运行相同版本的 RabbitMQ 和 Erlang。</li>
<li>federation：应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器上交换机或队列的消息，可以是单独机器或集群。federation 队列类似于单向点对点连接，消息会在联盟队列之间转发任意次，直到被消费者接受。通常使用 federation 来连接 internet 上的中间服务器，用作订阅分发消息或工作队列。</li>
<li>shovel：连接方式与 federation 的连接方式类似，但它工作在更低层次。可以应用于广域网。</li>
</ul>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>RAM node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。</li>
<li>Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息。</li>
</ul>
<p>** 问题说明：**</p>
<p>RabbitMQ 要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。</p>
<p>** 解决方案：**</p>
<p>设置两个磁盘节点，至少有一个是可用的，可以保存元数据的更改。</p>
<h3 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h3><p>RabbitMQ 的 Cluster 集群模式一般分为两种，普通模式和镜像模式。</p>
<ul>
<li>** 普通模式**：默认的集群模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于 Queue 来说，消息实体只存在于其中一个节点 rabbit01（或者 rabbit02），rabbit01 和 rabbit02 两个节点仅有相同的元数据，即队列的结构。当消息进入 rabbit01 节点的 Queue 后，consumer 从 rabbit02 节点消费时，RabbitMQ 会临时在 rabbit01、rabbit02 间进行消息传输，把 A 中的消息实体取出并经过 B 发送给 consumer。所以 consumer 应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理 Queue。否则无论 consumer 连 rabbit01 或 rabbit02，出口总在 rabbit01，会产生瓶颈。当 rabbit01 节点故障后，rabbit02 节点无法取到 rabbit01 节点中还未消费的消息实体。如果做了消息持久化，那么得等 rabbit01 节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。</li>
<li>** 镜像模式**：将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现 RabbitMQ 的 HA 高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在 consumer 消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。</li>
</ul>
<p>镜像队列实现了 RabbitMQ 的高可用性（HA），具体的实现策略如下所示：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180705085605.png" alt="QQ截图20180705085605.png"></p>
<p>实例列举：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue_args(<span class="string">&quot;x-ha-policy&quot;</span>:<span class="string">&quot;all&quot;</span>) //定义字典来设置额外的队列声明参数</span><br><span class="line">channel.queue_declare(queue=<span class="string">&quot;hello-queue&quot;</span>,argument=queue_args)</span><br></pre></td></tr></table></figure>

<p>如果需要设定特定的节点（以rabbit@localhost为例），再添加一个参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue_args(<span class="string">&quot;x-ha-policy&quot;</span>:<span class="string">&quot;nodes&quot;</span>,</span><br><span class="line">           <span class="string">&quot;x-ha-policy-params&quot;</span>:[<span class="string">&quot;rabbit@localhost&quot;</span>])</span><br><span class="line">channel.queue_declare(queue=<span class="string">&quot;hello-queue&quot;</span>,argument=queue_args)</span><br></pre></td></tr></table></figure>

<p>可以通过命令行查看那个主节点进行了同步</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_queue name slave_pids synchronised_slave_pids</span><br></pre></td></tr></table></figure>

<p>以上内容主要参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/WoogeYu/article/details/51119101">RabbitMQ分布式集群架构</a></p>
<h2 id="Docker-Compose搭建RabbitMQ高可用集群"><a href="#Docker-Compose搭建RabbitMQ高可用集群" class="headerlink" title="Docker-Compose搭建RabbitMQ高可用集群"></a>Docker-Compose搭建RabbitMQ高可用集群</h2><p>架构图：</p>
<p><img src="/img/435188-20180427122219477-216329665.png" alt="435188-20180427122219477-216329665.png"></p>
<p>这个编排主要实现一个磁盘节点、两个内存节点的RabbitMQ集群和一个HAProxy代理。</p>
<p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq</span><br><span class="line">  |--cluster_entrypoint.sh</span><br><span class="line">  |--docker-compose.yml</span><br><span class="line">  |--haproxy.cfg</span><br><span class="line">  |--parameters.env</span><br></pre></td></tr></table></figure>

<h3 id="cluster-entrypoint-sh"><a href="#cluster-entrypoint-sh" class="headerlink" title="cluster_entrypoint.sh"></a>cluster_entrypoint.sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch cluster_entrypoint.sh <span class="comment">##新建</span></span><br><span class="line">chmod +x cluster_entrypoint.sh <span class="comment">##执行权限</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="keyword">if</span> [ -e <span class="string">&quot;/root/is_not_first_time&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    /usr/<span class="built_in">local</span>/bin/docker-entrypoint.sh rabbitmq-server -detached <span class="comment"># 先按官方入口文件启动且是后台运行</span></span><br><span class="line">    rabbitmqctl -n <span class="string">&quot;<span class="variable">$RABBITMQ_NODENAME</span>@<span class="variable">$RABBITMQ_HOSTNAME</span>&quot;</span> stop_app <span class="comment"># 停止应用</span></span><br><span class="line">    rabbitmqctl -n <span class="string">&quot;<span class="variable">$RABBITMQ_NODENAME</span>@<span class="variable">$RABBITMQ_HOSTNAME</span>&quot;</span> join_cluster <span class="variable">$&#123;RMQHA_RAM_NODE:+--ram&#125;</span> <span class="string">&quot;<span class="variable">$RMQHA_MASTER_NODE</span>@<span class="variable">$RMQHA_MASTER_HOST</span>&quot;</span> <span class="comment"># 加入rabbitmq_node0集群</span></span><br><span class="line">    rabbitmqctl -n <span class="string">&quot;<span class="variable">$RABBITMQ_NODENAME</span>@<span class="variable">$RABBITMQ_HOSTNAME</span>&quot;</span> start_app <span class="comment"># 启动应用</span></span><br><span class="line">    rabbitmqctl stop <span class="comment"># 停止所有服务</span></span><br><span class="line">    touch /root/is_not_first_time</span><br><span class="line">    sleep 2s</span><br><span class="line">    <span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>注意：<br>rabbitmqctl join_cluster rabbit@node1<br>//默认是磁盘节点，如果是内存节点的话，需要加–ram参数</p>
<h3 id="parameters-env"><a href="#parameters-env" class="headerlink" title="parameters.env"></a>parameters.env</h3><p>即公共环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch parameters.env</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RMQHA_MASTER_NODE=rabbit</span><br><span class="line">RMQHA_MASTER_HOST=rabbitmq_node0</span><br><span class="line">RABBITMQ_DEFAULT_USER=admin</span><br><span class="line">RABBITMQ_DEFAULT_PASS=admin</span><br><span class="line">RABBITMQ_NODENAME=rabbit</span><br><span class="line">RABBITMQ_ERLANG_COOKIE=FQSCWUREIVFXVRTAOIFI</span><br></pre></td></tr></table></figure>

<h3 id="haproxy-cfg"><a href="#haproxy-cfg" class="headerlink" title="haproxy.cfg"></a>haproxy.cfg</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    <span class="built_in">log</span>     127.0.0.1  local0 info</span><br><span class="line">    <span class="built_in">log</span>     127.0.0.1  local1 notice</span><br><span class="line">    daemon</span><br><span class="line">    maxconn 4096</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    <span class="built_in">log</span>     global</span><br><span class="line">    mode    tcp</span><br><span class="line">    option  tcplog</span><br><span class="line">    option  dontlognull</span><br><span class="line">    retries 3</span><br><span class="line">    option  abortonclose</span><br><span class="line">    maxconn 4096</span><br><span class="line">    timeout connect  5000ms</span><br><span class="line">    timeout client  3000ms</span><br><span class="line">    timeout server  3000ms</span><br><span class="line">    balance roundrobin</span><br><span class="line"></span><br><span class="line">listen private_monitoring</span><br><span class="line">    <span class="built_in">bind</span>    0.0.0.0:8100 <span class="comment"># haproxy容器8100端口显示代理统计页面</span></span><br><span class="line">    mode    http</span><br><span class="line">    option  httplog</span><br><span class="line">    stats   <span class="built_in">enable</span></span><br><span class="line">    stats   refresh  5s</span><br><span class="line">    stats   hide-version</span><br><span class="line">    stats   uri  /stats</span><br><span class="line">    stats   realm   Haproxy</span><br><span class="line">    stats   auth  admin:admin</span><br><span class="line"></span><br><span class="line">listen rabbitmq_admin</span><br><span class="line">    <span class="built_in">bind</span>    0.0.0.0:15672</span><br><span class="line">    server  rabbitmq_node0 rabbitmq_node0:15672</span><br><span class="line">    server  rabbitmq_node1 rabbitmq_node1:15672</span><br><span class="line">    server  rabbitmq_node2 rabbitmq_node2:15672</span><br><span class="line"></span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">    <span class="built_in">bind</span>    0.0.0.0:5672</span><br><span class="line">    mode    tcp</span><br><span class="line">    option  tcplog</span><br><span class="line">    balance roundrobin</span><br><span class="line">    timeout client  3h</span><br><span class="line">    timeout server  3h</span><br><span class="line">    server  rabbitmq_node0 rabbitmq_node0:5672  check inter 5s rise 2 fall 3</span><br><span class="line">    server  rabbitmq_node1 rabbitmq_node1:5672  check inter 5s rise 2 fall 3</span><br><span class="line">    server  rabbitmq_node2 rabbitmq_node2:5672  check inter 5s rise 2 fall 3</span><br><span class="line"><span class="comment"># ssl for rabbitmq</span></span><br><span class="line">frontend ssl_rabbitmq</span><br><span class="line">    <span class="built_in">bind</span> *:5673 ssl crt /usr/<span class="built_in">local</span>/etc/rmqha.pem</span><br><span class="line">    mode tcp</span><br><span class="line">    default_backend rabbitmq_cluster</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>注意三个rabbitmq服务，并没有映射主机端口，而是开放容器端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  diskmq:</span><br><span class="line">    image: rabbitmq:3.7.6-management</span><br><span class="line">    container_name: rabbitmq_node0</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: rabbitmq_node0</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;15672&quot;</span></span><br><span class="line">      - <span class="string">&quot;5672&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./rabbitmq.config:/etc/rabbitmq/conf/rabbitmq.config&quot;</span></span><br><span class="line">      - <span class="string">&quot;/root/CA:/etc/rabbitmq/conf&quot;</span></span><br><span class="line">    env_file:</span><br><span class="line">      - ./parameters.env</span><br><span class="line">    environment:</span><br><span class="line">      - CONTAINER_NAME=rabbitmq_node0</span><br><span class="line">      - RABBITMQ_HOSTNAME=rabbitmq_node0</span><br><span class="line">      - RABBITMQ_NODENAME=rabbit</span><br><span class="line">      - RABBITMQ_CONFIG_FILE=/etc/rabbitmq/rabbitmq.config</span><br><span class="line">  rammq1:</span><br><span class="line">    image: rabbitmq:3.7.6-management</span><br><span class="line">    container_name: rabbitmq_node1</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - diskmq</span><br><span class="line">    hostname: rabbitmq_node1</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;15672&quot;</span></span><br><span class="line">      - <span class="string">&quot;5672&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./cluster_entrypoint.sh:/usr/local/bin/cluster_entrypoint.sh&quot;</span></span><br><span class="line">      - <span class="string">&quot;./rabbitmq.config:/etc/rabbitmq/conf/rabbitmq.config&quot;</span></span><br><span class="line">      - <span class="string">&quot;/root/CA:/etc/rabbitmq/conf&quot;</span></span><br><span class="line">    entrypoint: <span class="string">&quot;/usr/local/bin/cluster_entrypoint.sh&quot;</span></span><br><span class="line">    <span class="built_in">command</span>: <span class="string">&quot;rabbitmq-server&quot;</span></span><br><span class="line">    env_file:</span><br><span class="line">      - ./parameters.env</span><br><span class="line">    environment:</span><br><span class="line">      - CONTAINER_NAME=rabbitmq_node1</span><br><span class="line">      - RABBITMQ_HOSTNAME=rabbitmq_node1</span><br><span class="line">      - RABBITMQ_NODENAME=rabbit</span><br><span class="line">      - RMQHA_RAM_NODE=<span class="literal">true</span></span><br><span class="line">      - RABBITMQ_CONFIG_FILE=/etc/rabbitmq/rabbitmq.config</span><br><span class="line">  rammq2:</span><br><span class="line">    image: rabbitmq:3.7.6-management</span><br><span class="line">    container_name: rabbitmq_node2</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - diskmq</span><br><span class="line">    hostname: rabbitmq_node2</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;15672&quot;</span></span><br><span class="line">      - <span class="string">&quot;5672&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./cluster_entrypoint.sh:/usr/local/bin/cluster_entrypoint.sh&quot;</span></span><br><span class="line">      - <span class="string">&quot;./rabbitmq.config:/etc/rabbitmq/conf/rabbitmq.config&quot;</span></span><br><span class="line">      - <span class="string">&quot;/root/CA:/etc/rabbitmq/conf&quot;</span></span><br><span class="line">    entrypoint: <span class="string">&quot;/usr/local/bin/cluster_entrypoint.sh&quot;</span></span><br><span class="line">    <span class="built_in">command</span>: <span class="string">&quot;rabbitmq-server&quot;</span></span><br><span class="line">    env_file:</span><br><span class="line">      - ./parameters.env</span><br><span class="line">    environment:</span><br><span class="line">      - CONTAINER_NAME=rabbitmq_node2</span><br><span class="line">      - RABBITMQ_HOSTNAME=rabbitmq_node2</span><br><span class="line">      - RABBITMQ_NODENAME=rabbit</span><br><span class="line">      - RMQHA_RAM_NODE=<span class="literal">true</span></span><br><span class="line">      - RABBITMQ_CONFIG_FILE=/etc/rabbitmq/rabbitmq.config</span><br><span class="line">  haproxy:</span><br><span class="line">    image: haproxy:1.8-alpine</span><br><span class="line">    container_name: rabbitmq_proxy</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - diskmq</span><br><span class="line">      - rammq1</span><br><span class="line">      - rammq2</span><br><span class="line">    hostname: rabbitmq_proxy</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;5672:5672&quot;</span></span><br><span class="line">      - <span class="string">&quot;5673:5673&quot;</span></span><br><span class="line">      - <span class="string">&quot;15672:15672&quot;</span></span><br><span class="line">      - <span class="string">&quot;8100:8100&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg&quot;</span></span><br><span class="line">    environment:</span><br><span class="line">      - CONTAINER_NAME=rabbitmq_proxy</span><br></pre></td></tr></table></figure>

<p>** 执行docker-compose**</p>
<p>运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>停止：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure>

<h3 id="rabbitmq-SSL设置"><a href="#rabbitmq-SSL设置" class="headerlink" title="rabbitmq SSL设置"></a>rabbitmq SSL设置</h3><p>证书生成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 生成CA证书</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line">openssl req -passin pass:1111 -new -x509 -days 365 -key ca.key -out ca.crt -subj <span class="string">&quot;/C=CN/ST=JS/L=ZJ/O=zx/OU=test/CN=root&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成服务器端pfx证书</span></span><br><span class="line">openssl genrsa -passout pass:1111 -des3 -out server.key 2048</span><br><span class="line">openssl req -passin pass:1111 -new -key server.key -out server.csr -subj <span class="string">&quot;/C=CN/ST=JS/L=ZJ/O=zx/OU=test/CN=www.shiyx.top&quot;</span></span><br><span class="line">openssl x509 -req -passin pass:1111 -days 365 -<span class="keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt</span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out server.pfx -inkey server.key -<span class="keyword">in</span> server.crt -certfile ca.crt</span><br><span class="line"></span><br><span class="line"><span class="comment">## haproxy使用ssl证书</span></span><br><span class="line">cat server.crt server.key|tee rmqha.pem <span class="comment"># 将私钥和证书合并到一个文件中</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/ssl.html">https://www.rabbitmq.com/ssl.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/configure.html#customise-environment">https://www.rabbitmq.com/configure.html#customise-environment</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example">https://github.com/rabbitmq/rabbitmq-server/blob/master/docs/rabbitmq.conf.example</a></p>
<h3 id="rabbitmq镜像队列"><a href="#rabbitmq镜像队列" class="headerlink" title="rabbitmq镜像队列"></a>rabbitmq镜像队列</h3><p>mirror queue：镜像队列，queue能在多台机器中同步。</p>
<p>通过webui设置</p>
<p><a href="/img/QQ截图20180705161425.png">QQ截图20180705161425.png</a></p>
<p>或者通过命令行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 表示当前如果是test开头的队列都是“镜像队列”。</span></span><br><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;^test&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;^&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="防火墙开放端口"><a href="#防火墙开放端口" class="headerlink" title="防火墙开放端口"></a>防火墙开放端口</h3><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8100/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=5672/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>HAProxy 配置了三个地址：</p>
<p>注：IP地址需要根据实际情况修改</p>
<ul>
<li><code>http://192.168.7.201:8100/stats</code> ：HAProxy 负载均衡信息地址，账号密码：admin/admin。</li>
<li><code>http://192.168.7.201:15672</code>：RabbitMQ Server Web 管理界面（基于负载均衡），账号密码：admin/admin。</li>
<li><code>http://192.168.7.201:5672</code>：RabbitMQ Server 服务地址（基于负载均衡），账号密码：admin/admin。</li>
</ul>
<h2 id="DotNet客户端测试"><a href="#DotNet客户端测试" class="headerlink" title="DotNet客户端测试"></a>DotNet客户端测试</h2><p>安装<a target="_blank" rel="noopener" href="https://www.nuget.org/packages/RabbitMQ.Client">RabbitMQ.Client</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package RabbitMQ.Client -Version 5.1.0</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">        &#123;</span><br><span class="line">            UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">            Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">            AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">            TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步：创建connection </span></span><br><span class="line">        <span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.7.201&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步：创建一个channel</span></span><br><span class="line">        <span class="keyword">var</span> channel = connection.CreateModel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = channel.QueueDeclare(<span class="string">&quot;test1&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            channel.BasicPublish(<span class="built_in">string</span>.Empty, <span class="string">&quot;test1&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125; 推送成功&quot;</span>, i);</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持ssl安全连接：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitMqDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) =&gt; <span class="literal">true</span>;</span><br><span class="line">            ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                UserName = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                Password = <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">                AutomaticRecoveryEnabled = <span class="literal">true</span>,</span><br><span class="line">                Ssl = <span class="keyword">new</span> SslOption()</span><br><span class="line">                &#123;</span><br><span class="line">                    CertPath = <span class="string">@&quot;E:\git\RabbitMqDemo\RabbitMqDemo\server.pfx&quot;</span>,</span><br><span class="line">                    CertPassphrase = <span class="string">&quot;123123&quot;</span>,</span><br><span class="line">                    AcceptablePolicyErrors = SslPolicyErrors.RemoteCertificateNameMismatch |</span><br><span class="line">                                                SslPolicyErrors.RemoteCertificateChainErrors,</span><br><span class="line">                    Enabled = <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//AuthMechanisms = new AuthMechanismFactory[] &#123; new ExternalMechanismFactory() &#125;,</span></span><br><span class="line">                RequestedHeartbeat = <span class="number">60</span>,</span><br><span class="line">                Port = <span class="number">5673</span>,</span><br><span class="line">                TopologyRecoveryEnabled = <span class="literal">true</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//第一步：创建connection </span></span><br><span class="line">            <span class="keyword">var</span> connection = factory.CreateConnection(<span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">1</span>] &#123; <span class="string">&quot;192.168.0.115&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//第二步：创建一个channel</span></span><br><span class="line">            <span class="keyword">var</span> channel = connection.CreateModel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = channel.QueueDeclare(<span class="string">&quot;test1&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>.MaxValue; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                channel.BasicPublish(<span class="built_in">string</span>.Empty, <span class="string">&quot;test1&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; 推送成功&quot;</span>, i);</span><br><span class="line">                <span class="comment">//Thread.Sleep(1000);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xishuai/p/centos-rabbitmq-cluster-and-haproxy.html">搭建 RabbitMQ Server 高可用集群</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/huangxincheng/p/6113891.html">搭建高可用的rabbitmq集群 + Mirror Queue + 使用C#驱动连接</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/97fbf9c82872">RabbitMQ 高可用集群</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WoogeYu/article/details/51119101">RabbitMQ分布式集群架构</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/85543491ab00">docker搭建rabbitmq集群</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.breezelin.site/2017/12/05/practice-rabbitmq-ha-docker-compose/"></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.breezelin.site/2017/12/05/practice-rabbitmq-ha-docker-compose/">用Docker搭建RabbitMQ高可用集群</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fqydhk/article/details/80624547">docker-compose配置rabbitmq集群服务器</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/07/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%91%98%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%91%98%E8%A6%81/" class="post-title-link" itemprop="url">消息队列摘要</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-07-04 10:15:42" itemprop="dateCreated datePublished" datetime="2018-07-04T10:15:42+00:00">2018-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="消息队列摘要"><a href="#消息队列摘要" class="headerlink" title="消息队列摘要"></a>消息队列摘要</h1><h2 id="1-为什么要使用消息队列"><a href="#1-为什么要使用消息队列" class="headerlink" title="1,为什么要使用消息队列"></a>1,为什么要使用消息队列</h2><p>解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步</p>
<p>(1) 解耦</p>
<p>将消息写入消息队列，需要消息的系统自己从消息队列中订阅，原系统不需要做任何修改。</p>
<p>(2) 异步</p>
<p>将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度</p>
<p>(3) 削峰</p>
<p>并发请求到消息队列，业务系统按照实际处理能力从消息队列拉去数据。</p>
<h2 id="2-使用了消息队列会有什么缺点"><a href="#2-使用了消息队列会有什么缺点" class="headerlink" title="2,使用了消息队列会有什么缺点"></a>2,使用了消息队列会有什么缺点</h2><p>** 系统可用性降低**: 消息队列如果宕机，系统直接崩溃，因此，系统可用性降低</p>
<p>** 系统复杂性增加**: 要多考虑的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</p>
<h2 id="3，消息队列如何选型"><a href="#3，消息队列如何选型" class="headerlink" title="3，消息队列如何选型"></a>3，消息队列如何选型</h2><p><img src="/img/1506330751030_7532_1506330753496.png" alt="1506330751030_7532_1506330753496.png"></p>
<p>** 中小型软件公司<strong>：建议选RabbitMQ<br>** 大型软件公司</strong>：根据具体使用在rocketMq和kafka之间二选一</p>
<h2 id="4，如何保证消息队列是高可用的"><a href="#4，如何保证消息队列是高可用的" class="headerlink" title="4，如何保证消息队列是高可用的"></a>4，如何保证消息队列是高可用的</h2><p>参考具体的消息队列高可用方案</p>
<h2 id="5，如何保证消息不被重复消费"><a href="#5，如何保证消息不被重复消费" class="headerlink" title="5，如何保证消息不被重复消费"></a>5，如何保证消息不被重复消费</h2><p>即保证消息队列的幂等性。</p>
<p>正常情况下，消费者在消费消息时候，消费完毕后，会发送一个确认信息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。</p>
<p>解决：</p>
<p>(1) 拿到这个消息做数据库的insert操作,分配这个消息一个唯一主键，如果出现重复消费，则会导致主键冲突。</p>
<p>(2) redis的set的操作，无论set几次结果都是一样的，set操作本来就算幂等操作。</p>
<p>(3) 消费记录，以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p>
<h2 id="6，保证消费的可靠性传输"><a href="#6，保证消费的可靠性传输" class="headerlink" title="6，保证消费的可靠性传输"></a>6，保证消费的可靠性传输</h2><p>（1）生产者丢数据</p>
<p>（2）消息队列丢数据</p>
<p>（3）消费者丢数据</p>
<h2 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h2><p>通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/8994962.html">【原创】分布式之消息队列复习精讲</a></p>
<p><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/kafka-vs-rabbitmq">消息中间件选型分析：从Kafka与RabbitMQ的对比看全局</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/my_life/articles/5128746.html">常用消息队列介绍与对比</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1006035">消息队列及常见消息队列介绍</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/29/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA-No-route-to-host/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/29/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA-No-route-to-host/" class="post-title-link" itemprop="url">Docker容器无法访问宿主机-No route to host</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-29 09:05:05" itemprop="dateCreated datePublished" datetime="2018-06-29T09:05:05+00:00">2018-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker容器无法访问宿主机-No-route-to-host"><a href="#docker容器无法访问宿主机-No-route-to-host" class="headerlink" title="docker容器无法访问宿主机-No route to host"></a>docker容器无法访问宿主机-No route to host</h1><h2 id="方法一：关闭防火墙"><a href="#方法一：关闭防火墙" class="headerlink" title="方法一：关闭防火墙"></a>方法一：关闭防火墙</h2><p>centos关闭防火墙的操作为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<h2 id="方法二：-在防火墙上开发指定端口"><a href="#方法二：-在防火墙上开发指定端口" class="headerlink" title="方法二： 在防火墙上开发指定端口"></a>方法二： 在防火墙上开发指定端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=2181/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/96aebba5d3cc">docker容器无法访问宿主机-No route to host</a></p>
<p><a target="_blank" rel="noopener" href="https://wenfeng-gao.github.io/2016/05/20/docker-bridge-network.html">浅谈Docker Bridge网络模式</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/sparkdev/p/9217310.html">Docker 网络之理解 bridge 驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9198109.html">Docker 网络之进阶篇</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/28/AspNetCore%E5%88%A9%E7%94%A8Skywalking%E7%9B%91%E6%8E%A7%E6%80%A7%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/28/AspNetCore%E5%88%A9%E7%94%A8Skywalking%E7%9B%91%E6%8E%A7%E6%80%A7%E8%83%BD/" class="post-title-link" itemprop="url">AspNetCore利用Skywalking监控性能</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-28 16:40:42" itemprop="dateCreated datePublished" datetime="2018-06-28T16:40:42+00:00">2018-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Skywalking/" itemprop="url" rel="index"><span itemprop="name">Skywalking</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AspNetCore利用Skywalking监控性能"><a href="#AspNetCore利用Skywalking监控性能" class="headerlink" title="AspNetCore利用Skywalking监控性能"></a>AspNetCore利用Skywalking监控性能</h1><p><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-skywalking/blob/master/README_ZH.md">SkyWalking</a>开源项目由吴晟于2015年创建，同年10月在GitHub上作为个人项目开源。</p>
<p>SkyWalking项目的核心目标，是针对微服务、Cloud Native、容器化架构，提供应用性能监控（APM）和分布式调用链追踪能力。</p>
<p>2017年11月，SkyWalking社区正式决定，寻求加入Apache基金会，希望能使项目成为更为开放、全球化和强大的APM开源产品，并加强来自社区的合作和交流。最终实现构建一款功能强大、简单易用的开源APM产品。</p>
<p>2017年12月8日，Apache软件基金会孵化器项目管理委员会 ASF IPMC宣布“SkyWalking全票通过，进入Apache孵化器”。</p>
<p>** 软件环境**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CentOS7</span><br><span class="line">Docker 18.03.1-ce</span><br><span class="line">ElasticSearch5.X</span><br><span class="line">AspDotNetCore2.x</span><br><span class="line">skywalking 5.0.0-beta</span><br></pre></td></tr></table></figure>

<h2 id="Docker安装ElasticSearch5-X"><a href="#Docker安装ElasticSearch5-X" class="headerlink" title="Docker安装ElasticSearch5.X"></a>Docker安装ElasticSearch5.X</h2><p>新建docker-compose.yml文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>编辑，填入以下内容：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  elasticsearch5.<span class="number">6</span>:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:<span class="number">5.6</span>.<span class="number">10</span></span><br><span class="line">    container_name: elasticsearch5.<span class="number">6</span></span><br><span class="line">    environment:</span><br><span class="line">      - cluster.name=CollectorDBCluster</span><br><span class="line">      - xpack.security.enabled=false</span><br><span class="line">      - network.host= <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">      - thread_pool.bulk.queue_size=<span class="number">1000</span></span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -<span class="number">1</span></span><br><span class="line">        hard: -<span class="number">1</span></span><br><span class="line">    volumes:</span><br><span class="line">      - esdata1:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">9200</span>:<span class="number">9200</span></span><br><span class="line">      - <span class="number">9300</span>:<span class="number">9300</span></span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line">volumes:</span><br><span class="line">  esdata1:</span><br><span class="line">    driver: local</span><br><span class="line">networks:</span><br><span class="line">  esnet:</span><br></pre></td></tr></table></figure>

<p>注：需要使用xpack.security.enabled=false，关闭xpack身份验证。</p>
<p>启动：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line">docker ps <span class="comment"># 查看容器</span></span><br></pre></td></tr></table></figure>

<h2 id="部署skywalking"><a href="#部署skywalking" class="headerlink" title="部署skywalking"></a>部署skywalking</h2><p>官网：<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-skywalking/releases">https://github.com/apache/incubator-skywalking/releases</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-skywalking/blob/master/docs/en/Deploy-backend-in-standalone-mode.md">https://github.com/apache/incubator-skywalking/blob/master/docs/en/Deploy-backend-in-standalone-mode.md</a></p>
<p>下载<a target="_blank" rel="noopener" href="https://github.com/apache/incubator-skywalking/archive/v5.0.0-beta.tar.gz">5.0.0-beta</a></p>
<p>解压：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf apache-skywalking-apm-incubating-5.0.0-beta.tar.gz</span><br></pre></td></tr></table></figure>

<p>** 修改配置**</p>
<p>（1） 修改/bin目录下webappService.sh</p>
<p>–collector.ribbon.listOfServers=192.168.0.110:10800</p>
<p>修改localhost为本地IP地址：</p>
<p>localhost=&gt;192.168.0.110</p>
<p>（2） 修改config目录下application.yml</p>
<p>修改localhost为本地IP地址：</p>
<p>localhost=&gt;192.168.0.110</p>
<p>进入解压后的目录，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/startup.sh</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SkyWalking Collector started successfully!</span><br><span class="line">SkyWalking Web Application started successfully!</span><br></pre></td></tr></table></figure>

<p>查看主机监控的端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntlp</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tcp6       0      0 192.168.0.110:12800     :::*                    LISTEN      4147/java</span><br><span class="line">tcp6       0      0 192.168.0.110:10800     :::*                    LISTEN      4147/java</span><br><span class="line">tcp6       0      0 :::8080                 :::*                    LISTEN      4153/java</span><br><span class="line">tcp6       0      0 :::9200                 :::*                    LISTEN      3682/docker-proxy</span><br><span class="line">tcp6       0      0 :::8083                 :::*                    LISTEN      3971/docker-proxy</span><br><span class="line">tcp6       0      0 :::8084                 :::*                    LISTEN      3868/docker-proxy</span><br><span class="line">tcp6       0      0 :::9300                 :::*                    LISTEN      3672/docker-proxy</span><br><span class="line">tcp6       0      0 192.168.0.110:11800     :::*                    LISTEN      4147/java</span><br></pre></td></tr></table></figure>

<p>其中8080，10800，11800，12800为skywalking程序使用的端口，<br>8083，8084为AspDotNetCore使用端口<br>9200，9300为EalsticSearch使用端口</p>
<h2 id="运行dotnetcore应用"><a href="#运行dotnetcore应用" class="headerlink" title="运行dotnetcore应用"></a>运行dotnetcore应用</h2><h3 id="1-获取AspDotNetCore项目"><a href="#1-获取AspDotNetCore项目" class="headerlink" title="1.获取AspDotNetCore项目"></a>1.获取AspDotNetCore项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/syxdevcode/SkyWalking.Sample.git <span class="comment">## 克隆项目</span></span><br><span class="line">git pull origin master <span class="comment">## 更新代码（可选）</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用docker-compose命令启动"><a href="#2-使用docker-compose命令启动" class="headerlink" title="2.使用docker-compose命令启动"></a>2.使用docker-compose命令启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure>

<p>注：运行可能遇到问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to load the service index <span class="keyword">for</span> <span class="built_in">source</span> https://api.nuget.org/v3/index.json</span><br></pre></td></tr></table></figure>

<p>可能因为镜像服务问题：</p>
<p>解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>修改前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://lhao27k5.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启docker服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>之后继续执行docker-compose命令，同时，不要忘记将elasticsearch容器启动。</p>
<p>查看容器IP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> skywalkingsample_skywalkingfrontend_1</span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> skywalkingsample_skywalkingbackend_1</span><br></pre></td></tr></table></figure>

<h3 id="3-firewalld添加端口"><a href="#3-firewalld添加端口" class="headerlink" title="3.firewalld添加端口"></a>3.firewalld添加端口</h3><p>在docker容器内部无法访问宿主机-No route to host问题，需要在宿主机防火墙添加端口，或者关闭防火墙（不推荐）</p>
<p>(1) 关闭/启动防火墙：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<p>(2) 添加端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=11800/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="4-测试AspDotNetCore程序接口"><a href="#4-测试AspDotNetCore程序接口" class="headerlink" title="4.测试AspDotNetCore程序接口"></a>4.测试AspDotNetCore程序接口</h3><p>（1） Backend项目Put接口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl --header <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  --request PUT \</span><br><span class="line">  --data <span class="string">&#x27;&#123;&quot;Id&quot;:&quot;1&quot;,&quot;Name&quot;:&quot;Test1&quot;&#125;&#x27;</span> \</span><br><span class="line">  http://192.168.0.110:8084/api/apps</span><br></pre></td></tr></table></figure>

<p>(2) Backend项目Get接口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8084/api/apps</span><br><span class="line">[&#123;<span class="string">&quot;id&quot;</span>:1,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Test1&quot;</span>&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="5-查看skywalking"><a href="#5-查看skywalking" class="headerlink" title="5.查看skywalking"></a>5.查看skywalking</h3><p>访问：<a target="_blank" rel="noopener" href="http://localhost:8080/#/monitor/dashboard">http://localhost:8080/#/monitor/dashboard</a></p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180629105145.png" alt="QQ截图20180629105145.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-skywalking/blob/master/docs/en/Deploy-backend-in-standalone-mode.md">https://github.com/apache/incubator-skywalking/blob/master/docs/en/Deploy-backend-in-standalone-mode.md</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3ddd986c7581?from=timeline&isappinstalled=0">利用Skywalking-netcore监控你的应用性能</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/liuhaoyang/p/skywalking-dotnet-v02-release.html">Apache SkyWalking 为.NET Core带来开箱即用的分布式追踪和应用性能监控</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/25/Docker%E5%AE%89%E8%A3%85Elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/25/Docker%E5%AE%89%E8%A3%85Elasticsearch/" class="post-title-link" itemprop="url">Docker安装Elasticsearch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-25 09:01:07" itemprop="dateCreated datePublished" datetime="2018-06-25T09:01:07+00:00">2018-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker安装Elasticsearch"><a href="#Docker安装Elasticsearch" class="headerlink" title="Docker安装Elasticsearch"></a>Docker安装Elasticsearch</h1><h2 id="用Dockeredit安装Elasticsearch"><a href="#用Dockeredit安装Elasticsearch" class="headerlink" title="用Dockeredit安装Elasticsearch"></a>用Dockeredit安装Elasticsearch</h2><p>Elasticsearch也可用作Docker镜像。 镜像使用centos:7作为基本图像。</p>
<p>所有发布的Docker镜像和标签列表可以在<a href="www.docker.elastic.co">www.docker.elastic.co</a>找到。 源代码可以在GitHub上找到。</p>
<p>X-Pack是一个Elastic Stack的扩展，可将安全性，警报，监控，报告和图形功能捆绑到一个易于安装的软件包中。 虽然X-Pack组件旨在无缝协同工作，您也可以轻松地启用或禁用要使用的功能。<br>在Elasticsearch 5.0.0之前，您必须安装单独的Shield，Watcher和Marvel插件，以获得X-Pack中捆绑在一起的功能。 使用X-Pack，您不再需要担心每个插件是否具有正确的版本，而只需安装您正在运行的Elasticsearch版本的X-Pack就可以了。</p>
<h2 id="拉去镜像"><a href="#拉去镜像" class="headerlink" title="拉去镜像"></a>拉去镜像</h2><p>镜像仓库：<a target="_blank" rel="noopener" href="https://www.docker.elastic.co">https://www.docker.elastic.co</a></p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:<span class="number">6.3</span>.<span class="number">0</span></span><br><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch-oss:<span class="number">6.3</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="运行Elasticsearch"><a href="#运行Elasticsearch" class="headerlink" title="运行Elasticsearch"></a>运行Elasticsearch</h2><h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p>使用以下命令可以快速启动Elasticsearch以进行开发或测试：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -p 9200:9200 -p 9300:9300 -e <span class="string">&quot;discovery.type=single-node&quot;</span> docker.elastic.co/elasticsearch/elasticsearch:6.3.0</span></span><br></pre></td></tr></table></figure>

<h3 id="生产模式"><a href="#生产模式" class="headerlink" title="生产模式"></a>生产模式</h3><p>Linux</p>
<p>该vm.max_map_count设置应该在/etc/sysctl.conf中永久设置：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/sysctl.conf</span><br><span class="line">vm.max_map_count = <span class="number">262144</span></span><br></pre></td></tr></table></figure>

<p>使命令生效：sysctl -p</p>
<p>要在临时应用该设置： sysctl -w vm.max_map_count=262144</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker-cli-run-prod-mode">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker-cli-run-prod-mode</a></p>
<h4 id="docker-compose启动"><a href="#docker-compose启动" class="headerlink" title="docker-compose启动"></a>docker-compose启动</h4><p>启动命令：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>节点elasticsearch侦听localhost:9200，而elasticsearch2 谈判elasticsearch在桥接网络。</p>
<p>这个例子还使用了 名为卷的Docker，它将被调用esdata1，esdata2如果尚不存在，将会创建它。</p>
<p>docker-compose.yml:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:<span class="number">6.3</span>.<span class="number">0</span></span><br><span class="line">    container_name: elasticsearch</span><br><span class="line">    environment:</span><br><span class="line">      - cluster.name=CollectorDBCluster</span><br><span class="line">      - network.host= <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">      - thread_pool.bulk.queue_size=<span class="number">1000</span></span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -<span class="number">1</span></span><br><span class="line">        hard: -<span class="number">1</span></span><br><span class="line">    volumes:</span><br><span class="line">      - esdata1:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">9200</span>:<span class="number">9200</span></span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line">  elasticsearch2:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:<span class="number">6.3</span>.<span class="number">0</span></span><br><span class="line">    container_name: elasticsearch2</span><br><span class="line">    environment:</span><br><span class="line">      - cluster.name=CollectorDBCluster</span><br><span class="line">      - network.host= <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">      - thread_pool.bulk.queue_size=<span class="number">1000</span></span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">      - <span class="string">&quot;discovery.zen.ping.unicast.hosts=elasticsearch&quot;</span></span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -<span class="number">1</span></span><br><span class="line">        hard: -<span class="number">1</span></span><br><span class="line">    volumes:</span><br><span class="line">      - esdata2:/usr/share/elasticsearch/data</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  esdata1:</span><br><span class="line">    driver: local</span><br><span class="line">  esdata2:</span><br><span class="line">    driver: local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  esnet:</span><br></pre></td></tr></table></figure>

<p>要停止群集，请键入docker-compose down。数据量将持续存在，因此可以使用docker-compose up再次使用相同的数据启动群集。要销毁群集和数据卷，只需键入 docker-compose down -v。</p>
<h4 id="检查群集状态"><a href="#检查群集状态" class="headerlink" title="检查群集状态"></a>检查群集状态</h4><p>查询容器IP：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> elasticsearch</span><br><span class="line"><span class="number">172.24</span>.<span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<p>检查群集状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:9200/_cat/health <span class="comment"># 或者使用Docker IP</span></span><br><span class="line">1529905639 05:47:19 docker-cluster green 2 2 0 0 0 0 0 0 - 100.0%</span><br></pre></td></tr></table></figure>

<p>使用docker logs 查看日志。</p>
<h2 id="用Docker-配置Elasticsearch"><a href="#用Docker-配置Elasticsearch" class="headerlink" title="用Docker 配置Elasticsearch"></a>用Docker 配置Elasticsearch</h2><p>elasticsearch从/usr/share/elasticsearch/config/其下的文件加载它的配置。配置Elasticsearch和设置JVM选项中记录了这些配置文件。</p>
<p>该镜像提供了几种配置Elasticsearch设置的方法，传统方法是提供定制文件，也就是说 elasticsearch.yml。也可以使用环境变量来设置选项：</p>
<h3 id="通过Docker环境变量呈现参数"><a href="#通过Docker环境变量呈现参数" class="headerlink" title="通过Docker环境变量呈现参数"></a>通过Docker环境变量呈现参数</h3><p>要定义群集名称，docker run您可以通过 -e “cluster.name=mynewclustername”。双引号是必需的。</p>
<h3 id="绑定配置"><a href="#绑定配置" class="headerlink" title="绑定配置"></a>绑定配置</h3><p>创建您的自定义配置文件并将其安装在图像的相应文件上。例如结合安装一custom_elasticsearch.yml与docker run可与参数来完成：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v full_path_to / custom_elasticsearch.yml：/usr/share/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure>

<p>容器以用户elasticsearch使用uid：gid的方式运行Elasticsearch1000:1000。绑定安装的主机目录和文件（如custom_elasticsearch.yml上面） 需要由该用户访问。对于数据和日志文件，例如/usr/share/elasticsearch/data写入访问也是必需的。另请参阅下面的注1。</p>
<h3 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> docker.elastic.co/elasticsearch/elasticsearch:<span class="number">6.3</span>.<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=elasticsearch:elasticsearch elasticsearch.yml /usr/share/elasticsearch/config/</span></span><br></pre></td></tr></table></figure>

<p>然后构建镜像</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build --tag=elasticsearch-custom .</span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> -ti -v /usr/share/elasticsearch/data elasticsearch-custom</span></span><br></pre></td></tr></table></figure>

<p>一些插件需要额外的安全权限。您必须通过tty在运行Docker映像时附加一个并在提示中接受yes 来明确接受它们，或者单独检查安全权限，并且如果您对将这些–batch标志添加到plugin install命令时感到满意，那么您必须明确接受它们。查看<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/plugins/6.3/_other_command_line_parameters.html">插件管理文档</a>了解更多详情。</p>
<h2 id="使用Elasticsearch-Docker镜像配置SSL-TLS"><a href="#使用Elasticsearch-Docker镜像配置SSL-TLS" class="headerlink" title="使用Elasticsearch Docker镜像配置SSL/TLS"></a>使用Elasticsearch Docker镜像配置SSL/TLS</h2><p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/configuring-tls-docker.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/configuring-tls-docker.html</a></p>
<h2 id="生产环境注意事项"><a href="#生产环境注意事项" class="headerlink" title="生产环境注意事项"></a>生产环境注意事项</h2><ul>
<li>1.默认情况下，Elasticsearch以elasticsearch使用uid：gid的用户身份在容器内运行1000:1000。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir esdatadir</span><br><span class="line">chmod g+rwx esdatadir</span><br><span class="line">chgrp 1000 esdatadir</span><br></pre></td></tr></table></figure>

<ul>
<li>2.确保nofile 和nproc可用于Elasticsearch容器的ulimits是非常重要的</li>
</ul>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ulimit nofile = <span class="number">65536</span>：<span class="number">65536</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3.交换性能和节点稳定性需要禁用。</li>
</ul>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e“bootstrap.memory_lock = true”--ulimit memlock = -<span class="number">1</span>：-<span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>4.该镜像开放 TCP端口9200和9300.对于群集，建议随机化发布的端口–publish-all，除非您为每个主机固定一个容器。</p>
</li>
<li><p>5.使用ES_JAVA_OPTS环境变量来设置堆大小。例如，使用16GB的使用-e ES_JAVA_OPTS=”-Xms16g -Xmx16g”与docker run。</p>
</li>
<li><p>6.<code>/usr/share/elasticsearch/data</code>如生产示例中所示， 始终使用绑定的卷，原因如下：</p>
</li>
</ul>
<p>(1) 如果容器被杀死，您的elasticsearch节点的数据不会丢失<br>(2) Elasticsearch对I/O敏感，而Docker存储驱动程序对于快速I / O并不理想<br>(3) 它允许使用高级 Docker卷插件</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html</a></p>
<p><a target="_blank" rel="noopener" href="https://wenchao.ren/archives/250">Docker环境中Elasticsearch的安装</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ginb/p/7027910.html">Elasticsearch重要配置</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/wangiqngpei557/p/5967377.html">ElasticSearch大数据分布式弹性搜索引擎使用</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ljhdo/p/4959412.html">ElasticSearch入门 第二篇：集群配置</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/LiZhiW/p/4978396.html">elasticsearch.yml配置文件</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/13428282016/elasticsearch-CN/wiki/es-setup--elasticsearch">https://github.com/13428282016/elasticsearch-CN/wiki/es-setup–elasticsearch</a></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/20/ASP.NET%20Core%E5%9F%BA%E4%BA%8EConsul%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/20/ASP.NET%20Core%E5%9F%BA%E4%BA%8EConsul%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">ASP.NET Core基于Consul服务治理实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-20 14:21:15" itemprop="dateCreated datePublished" datetime="2018-06-20T14:21:15+00:00">2018-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Consul/" itemprop="url" rel="index"><span itemprop="name">Consul</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ASP-NET-Core基于Consul服务治理实现"><a href="#ASP-NET-Core基于Consul服务治理实现" class="headerlink" title="ASP.NET Core基于Consul服务治理实现"></a>ASP.NET Core基于Consul服务治理实现</h1><h2 id="直接运行ASP-NET-Core程序"><a href="#直接运行ASP-NET-Core程序" class="headerlink" title="直接运行ASP.NET Core程序"></a>直接运行ASP.NET Core程序</h2><p>参照：<a target="_blank" rel="noopener" href="https://syxdevcode.github.io/2018/06/13/Docker-Fabio-Consul-%E7%BE%A4%E9%9B%86-ASP.NET%20Core%202.0%E5%AE%9E%E8%B7%B5/">Docker &amp; Fabio &amp; Consul群集 &amp; ASP.NET Core 2.0实践</a></p>
<p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web</span><br><span class="line">|--ConsulTest</span><br><span class="line">|--ConsulTest1</span><br></pre></td></tr></table></figure>

<p>复制一份新目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R ConsulTest ConsulTest1</span><br></pre></td></tr></table></figure>

<p>修改docker-compose.override.yml配置文件：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.4&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  consultest:</span><br><span class="line">    environment:</span><br><span class="line">      - ASPNETCORE_ENVIRONMENT=Development</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:8080&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改bundleconfig.json：</p>
<p>注：service.ip需要使用以下命令查询：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> consultest_consultest_1</span><br></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Service&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;172.22.0.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;ConsulDemo1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Port&quot;</span>: <span class="string">&quot;8080&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;Consul&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;IP&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Port&quot;</span>: <span class="string">&quot;8500&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;Logging&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;IncludeScopes&quot;</span>: false,</span><br><span class="line">    <span class="string">&quot;LogLevel&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Default&quot;</span>: <span class="string">&quot;Warning&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Program.cs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWebHost <span class="title">BuildWebHost</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">    WebHost.CreateDefaultBuilder(args)</span><br><span class="line">        .UseStartup&lt;Startup&gt;()</span><br><span class="line">        .UseUrls(<span class="string">&quot;http://*:8080&quot;</span>) <span class="comment">// 添加端口映射</span></span><br><span class="line">        .Build();</span><br></pre></td></tr></table></figure>

<p>运行以下命令，启动服务：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure>

<h2 id="使用配置文件重新启动consul客户端"><a href="#使用配置文件重新启动consul客户端" class="headerlink" title="使用配置文件重新启动consul客户端"></a>使用配置文件重新启动consul客户端</h2><p>准备配置文件，取名services_config.json(命名规则，需要使用.json后缀)</p>
<p>注：配置中的web service服务需要提前启动，以获取IP，port信息。</p>
<p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document</span><br><span class="line">|--consul</span><br><span class="line">   |--client1.josn</span><br><span class="line">   |--config</span><br><span class="line">      |--services_config.json</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;services&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;EDC_DNC_MSAD_CLIENT_SERVICE_01&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Client-Service&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;urlprefix-/ClientService80&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;172.21.0.2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="attr">&quot;checks&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;clientservice80_check&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;http://172.21.0.2:80/api/health&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;timeout&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;EDC_DNC_MSAD_CLIENT_SERVICE_02&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Client-Service&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;urlprefix-/ClientService8080&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;172.22.0.2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;port&quot;</span>: <span class="number">8080</span>,</span><br><span class="line">            <span class="attr">&quot;checks&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;clientservice8080_check&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;http://172.22.0.2:8080/api/health&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;timeout&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在document文件夹下运行以下命令：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name=client1 -it -d -p 8500:8500 -v <span class="variable">$PWD</span>/consul:/consul consul agent -config-dir=/consul/config -config-file=/consul/client1.json</span></span><br></pre></td></tr></table></figure>

<p>-config-dir - 要加载的配置文件的目录。 Consul将加载后缀为“.json”的所有文件。加载顺序是按字母顺序排列的，并且与上面的配置文件选项一样使用相同的合并例程。可以多次指定此选项以加载多个目录。不加载config目录的子目录。</p>
<p>结果：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180620162327.png" alt="QQ截图20180620162327.png"></p>
<h3 id="通过API进行服务发现"><a href="#通过API进行服务发现" class="headerlink" title="通过API进行服务发现"></a>通过API进行服务发现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8500/v1/catalog/service/Client-Service | python -m json.tool</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost document]<span class="comment"># curl http://localhost:8500/v1/catalog/service/Client-Service | python -m json.tool</span></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     100   945  100   945    0     0  51053      0 --:--:-- --:--:-- --:--:-- 52500</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Address&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CreateIndex&quot;</span>: 24219,</span><br><span class="line">        <span class="string">&quot;Datacenter&quot;</span>: <span class="string">&quot;consul-test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ID&quot;</span>: <span class="string">&quot;8bc069e0-821b-b714-751d-c6fe07dfa7ea&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ModifyIndex&quot;</span>: 24442,</span><br><span class="line">        <span class="string">&quot;Node&quot;</span>: <span class="string">&quot;client1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NodeMeta&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;consul-network-segment&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ServiceAddress&quot;</span>: <span class="string">&quot;172.21.0.2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceEnableTagOverride&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ServiceID&quot;</span>: <span class="string">&quot;EDC_DNC_MSAD_CLIENT_SERVICE_01&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceMeta&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;ServiceName&quot;</span>: <span class="string">&quot;Client-Service&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServicePort&quot;</span>: 80,</span><br><span class="line">        <span class="string">&quot;ServiceTags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;urlprefix-/ClientService80&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;TaggedAddresses&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;lan&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;wan&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Address&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CreateIndex&quot;</span>: 24220,</span><br><span class="line">        <span class="string">&quot;Datacenter&quot;</span>: <span class="string">&quot;consul-test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ID&quot;</span>: <span class="string">&quot;8bc069e0-821b-b714-751d-c6fe07dfa7ea&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ModifyIndex&quot;</span>: 24443,</span><br><span class="line">        <span class="string">&quot;Node&quot;</span>: <span class="string">&quot;client1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NodeMeta&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;consul-network-segment&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ServiceAddress&quot;</span>: <span class="string">&quot;172.22.0.2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceEnableTagOverride&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ServiceID&quot;</span>: <span class="string">&quot;EDC_DNC_MSAD_CLIENT_SERVICE_02&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServiceMeta&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;ServiceName&quot;</span>: <span class="string">&quot;Client-Service&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ServicePort&quot;</span>: 8080,</span><br><span class="line">        <span class="string">&quot;ServiceTags&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;urlprefix-/ClientService8080&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;TaggedAddresses&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;lan&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span>,</span><br><span class="line">            <span class="string">&quot;wan&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到返回了两个服务实例的信息，当然，这里建议服务名还是不要有空格为好。此外，在服务发现的过程中，会加以一定的负载均衡策略，从这两个服务实例中选择一个返回给服务消费端，比如：随机、轮询、加权轮询、基于性能的最小连接数等等。</p>
<h2 id="Consul集群之Key-Value存储"><a href="#Consul集群之Key-Value存储" class="headerlink" title="Consul集群之Key/Value存储"></a>Consul集群之Key/Value存储</h2><p>Consul除了可以实现服务注册和服务发现之外，还提供了强大的KV（Key/Value）存储。我们可以使用Consul的分层KV存储干任何事情，比如：动态配置，特征标记，协调，leader选举等。KV存储的API是基于http的。</p>
<h3 id="查看所有KV"><a href="#查看所有KV" class="headerlink" title="查看所有KV"></a>查看所有KV</h3><p>通过<code>curl http://localhost:8500/v1/kv/?recurse</code>命令</p>
<p>或者通过Web UI 查看。</p>
<h3 id="新增KV"><a href="#新增KV" class="headerlink" title="新增KV"></a>新增KV</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -d <span class="string">&#x27;consulvalue&#x27;</span> http://172.17.0.5:8500/v1/kv/web/value1</span><br></pre></td></tr></table></figure>

<p>key：value1, value：consulvalue</p>
<p>查看key/value:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ConsulTest]<span class="comment"># curl http://172.17.0.5:8500/v1/kv/web/value1</span></span><br><span class="line">[&#123;<span class="string">&quot;LockIndex&quot;</span>:0,<span class="string">&quot;Key&quot;</span>:<span class="string">&quot;web/value1&quot;</span>,<span class="string">&quot;Flags&quot;</span>:0,<span class="string">&quot;Value&quot;</span>:<span class="string">&quot;Y29uc3VsdmFsdWU=&quot;</span>,<span class="string">&quot;CreateIndex&quot;</span>:24586,<span class="string">&quot;ModifyIndex&quot;</span>:24592&#125;]</span><br></pre></td></tr></table></figure>

<p>由于Consul的Value是经过Base64编码的（主要是为了允许非UTF-8的字符），所以这里看到的是编码后的结果。我们可以通过解码得到最终的Value值。</p>
<h3 id="验证KV是否同步"><a href="#验证KV是否同步" class="headerlink" title="验证KV是否同步"></a>验证KV是否同步</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost document]<span class="comment"># docker exec -it server1 sh</span></span><br><span class="line">/ <span class="comment"># consul kv get web/value1</span></span><br><span class="line">consulvalue</span><br><span class="line">/ <span class="comment"># exit</span></span><br><span class="line">[root@localhost document]<span class="comment"># docker exec -it server2 sh</span></span><br><span class="line">/ <span class="comment"># consul kv get web/value1</span></span><br><span class="line">consulvalue</span><br><span class="line">/ <span class="comment"># exit</span></span><br><span class="line">[root@localhost document]<span class="comment"># docker exec -it server3 sh</span></span><br><span class="line">/ <span class="comment"># consul kv get web/value1</span></span><br><span class="line">consulvalue</span><br></pre></td></tr></table></figure>

<h3 id="编辑KV和删除KV"><a href="#编辑KV和删除KV" class="headerlink" title="编辑KV和删除KV"></a>编辑KV和删除KV</h3><p>编辑：(同添加KV)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -d <span class="string">&#x27;consulvalue&#x27;</span> http://172.17.0.5:8500/v1/kv/web/value1</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE http://172.17.0.5:8500/v1/kv/web/value1</span><br></pre></td></tr></table></figure>

<h2 id="Consul服务告警之Watch机制"><a href="#Consul服务告警之Watch机制" class="headerlink" title="Consul服务告警之Watch机制"></a>Consul服务告警之Watch机制</h2><h3 id="添加NoticeService服务"><a href="#添加NoticeService服务" class="headerlink" title="添加NoticeService服务"></a>添加NoticeService服务</h3><p>源码参考：<a target="_blank" rel="noopener" href="https://github.com/syxdevcode/ConsulTest.git">https://github.com/syxdevcode/ConsulTest.git</a></p>
<p>首先在ConsulTest目录运行以下命令更新源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout .  ##撤销更改</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>在NoticeService目录运行以下命令，启动服务：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure>

<p>查看生成的容器的IP:</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> noticeservice_noticeservice_1</span><br><span class="line"><span class="number">172.23</span>.<span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><h4 id="添加watch-json配置文件"><a href="#添加watch-json配置文件" class="headerlink" title="添加watch.json配置文件"></a>添加watch.json配置文件</h4><p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document</span><br><span class="line">|--consul</span><br><span class="line">   |--client1.josn</span><br><span class="line">   |--config</span><br><span class="line">      |--services_config.json</span><br><span class="line">      |--watch.json</span><br></pre></td></tr></table></figure>

<p>在config文件夹下，添加watch.json文件，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;watches&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;checks&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;handler_type&quot;</span>: <span class="string">&quot;http&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;critical&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;http_handler_config&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;http://172.23.0.2:8081/notice&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;timeout&quot;</span>: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;header&quot;</span>: &#123; <span class="attr">&quot;Authorization&quot;</span>: [ <span class="string">&quot;token&quot;</span> ] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节请参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/docs/agent/watches.html">https://www.consul.io/docs/agent/watches.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/api/health.html">https://www.consul.io/api/health.html</a></p>
<p>state支持： any, passing, warning, or critical。</p>
<h4 id="修改services-config-json文件"><a href="#修改services-config-json文件" class="headerlink" title="修改services_config.json文件"></a>修改services_config.json文件</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;services&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;EDC_DNC_MSAD_CLIENT_SERVICE_01&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Client-Service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;urlprefix-/ClientService80&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;172.21.0.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">80</span>,</span><br><span class="line">      <span class="attr">&quot;checks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;clientservice80_check&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;http://172.21.0.2:80/api/health&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;timeout&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;EDC_DNC_MSAD_CLIENT_SERVICE_02&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Client-Service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;urlprefix-/ClientService8080&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;172.22.0.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">8080</span>,</span><br><span class="line">      <span class="attr">&quot;checks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;clientservice8080_check&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;http://172.22.0.2:8080/api/health&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;timeout&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;EDC_DNC_MSAD_NOTICE_SERVICE&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Client-Service&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;urlprefix-/NoticeService8081&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;172.23.0.2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">8081</span>,</span><br><span class="line">      <span class="attr">&quot;checks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;noticeservice_check&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;http://172.23.0.2:8081/api/health&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;interval&quot;</span>: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;timeout&quot;</span>: <span class="string">&quot;5s&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启client1，并且查看NoticeService是否注册成功：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart client1</span><br></pre></td></tr></table></figure>

<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180621134758.png" alt="QQ截图20180621134758.png"></p>
<h3 id="测试服务预警"><a href="#测试服务预警" class="headerlink" title="测试服务预警"></a>测试服务预警</h3><p>（1） 手动关闭三个dotnet core服务中的其中一个，如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop consultest1_consultest_1</span><br></pre></td></tr></table></figure>

<p>(2) 收到邮件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">健康检查故障:</span><br><span class="line">--------------------------------------</span><br><span class="line">Node:client1</span><br><span class="line">Service ID:EDC_DNC_MSAD_CLIENT_SERVICE_02</span><br><span class="line">Service Name:Client-Service</span><br><span class="line">Check ID:service:EDC_DNC_MSAD_CLIENT_SERVICE_02</span><br><span class="line">Check Name:clientservice8080_check</span><br><span class="line">Check Status:critical</span><br><span class="line">Check Output:Get http://172.22.0.2:8080/api/health: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)</span><br></pre></td></tr></table></figure>

<p>** 注意:确保你的虚拟机可以访问外网，不然是发布出来Email的**</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edisonchou/p/9148034.html">.NET Core微服务之基于Consul实现服务治理（续）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/docs/agent/watches.html">https://www.consul.io/docs/agent/watches.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/api/health.html">https://www.consul.io/api/health.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/PlayFab/consuldotnet">https://github.com/PlayFab/consuldotnet</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/13/Docker-Fabio-Consul-%E7%BE%A4%E9%9B%86-ASP.NET%20Core%202.0%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/13/Docker-Fabio-Consul-%E7%BE%A4%E9%9B%86-ASP.NET%20Core%202.0%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">Docker & Fabio & Consul群集 & ASP.NET Core 2.0实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-13 11:36:36" itemprop="dateCreated datePublished" datetime="2018-06-13T11:36:36+00:00">2018-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Consul/" itemprop="url" rel="index"><span itemprop="name">Consul</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker-amp-Fabio-amp-Consul群集-amp-ASP-NET-Core-2-0实践"><a href="#Docker-amp-Fabio-amp-Consul群集-amp-ASP-NET-Core-2-0实践" class="headerlink" title="Docker &amp; Fabio &amp; Consul群集 &amp; ASP.NET Core 2.0实践"></a>Docker &amp; Fabio &amp; Consul群集 &amp; ASP.NET Core 2.0实践</h1><h2 id="1，Docker运行consul环境"><a href="#1，Docker运行consul环境" class="headerlink" title="1，Docker运行consul环境"></a>1，Docker运行consul环境</h2><h3 id="1、Consul基础介绍"><a href="#1、Consul基础介绍" class="headerlink" title="1、Consul基础介绍"></a>1、Consul基础介绍</h3><p><a target="_blank" rel="noopener" href="https://www.consul.io/">https://www.consul.io/</a></p>
<p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，比如 Airbnb 的 SmartStack 等相比，Consul 的方案更“一站式”，一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制，内置了服务注册与发现框架、分布一致性协议实现、健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对、Key/Value 存储、多数据中心方案，不再需要依赖其他工具（比如 ZooKeeper 等）。使用起来也较为简单。<br>Consul 用 Golang 实现，因此具有天然可移植性(支持 Linux、windows 和 Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。</p>
<p>要想利用Consul提供的服务实现服务的注册与发现，我们需要建立Consul Cluster。在Consul方案中，每个提供服务的节点上都要部署和运行Consul的agent，所有运行Consul Agent节点的集合构成Consul Cluster。Consul Agent有两种运行模式：Server和Client。这里的Server和Client只是Consul集群层面的区分，与搭建在Cluster之上的应用服务无关。以Server模式运行的Consul Agent节点用于维护Consul集群的状态，官方建议每个Consul Cluster至少有3个或以上的运行在Server Mode的Agent，Client节点不限。</p>
<p>　　Consul支持多数据中心，每个数据中心的Consul Cluster都会在运行于Server模式下的Agent节点中选出一个Leader节点，这个选举过程通过Consul实现的raft协议保证，多个Server节点上的Consul数据信息是强一致的。处于Client Mode的Consul Agent节点比较简单，无状态，仅仅负责将请求转发给Server Agent节点。</p>
<p>** Consul 功能：**</p>
<ul>
<li><p>服务发现（Service Discovery）：客户端通过 Consul 提供服务，其他客户端可以通过 Consul 利用 dns 或者 http 发现依赖服务</p>
</li>
<li><p>健康检查（Health Checking）: Consul 提供任务的健康检查，可以用来操作或者监控集群的健康，也可以在服务发现时去除失效的服务</p>
</li>
<li><p>键值对存储（Key/Value Store）: 存储层级键值对</p>
</li>
<li><p>多数据中心（Multi Datacenter）: Consul 支持开箱即用的多数据中心</p>
</li>
</ul>
<p>** Consul的优势**</p>
<ul>
<li><p>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft.</p>
</li>
<li><p>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等. zookeeper 和 etcd 均不提供多数据中心功能的支持.</p>
</li>
<li><p>支持健康检查. etcd 不提供此功能.</p>
</li>
<li><p>支持 http 和 dns 协议接口. zookeeper 的集成较为复杂, etcd 只支持 http 协议,官方提供web管理界面, etcd 无此功能.</p>
</li>
</ul>
<p>** Consul 的使用场景**</p>
<ul>
<li><p>docker 实例的注册与配置共享</p>
</li>
<li><p>coreos 实例的注册与配置共享</p>
</li>
<li><p>vitess 集群</p>
</li>
<li><p>SaaS 应用的配置共享</p>
</li>
<li><p>与 confd 服务集成，动态生成 nginx 和 haproxy 配置文件</p>
</li>
</ul>
<p>** Consul 的模式**</p>
<ul>
<li><p>client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。一个 Client 是一个转发所有 RPC 到 Server 的代理。这个 Client 是相对无状态的；Client 唯一执行的后台活动是加入 LAN gossip 池，这有一个最低的资源开销并且仅消耗少量的网络带宽。</p>
</li>
<li><p>server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其他数据中心通讯. 每个数据中心的 server 数量推荐为 3 个或是 5 个。参与 Raft 选举，维护集群状态，响应 RPC 查询，与其他数据中心交互 WAN gossip 和转发查询给 leader 或者远程数据中心。</p>
</li>
</ul>
<p>群集架构图如下：</p>
<p><img src="/img/n4mdw.jpg" alt="n4mdw.jpg"></p>
<p><img src="/img/435188-20161228110501664-588566717.png" alt="435188-20161228110501664-588566717.png"></p>
<p>Consul和其他类似软件的对比：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180613135320.png" alt="QQ截图20180613135320.png"></p>
<h3 id="2、Consul群集搭建"><a href="#2、Consul群集搭建" class="headerlink" title="2、Consul群集搭建"></a>2、Consul群集搭建</h3><p>Consul 集群搭建时一般提供两种模式:</p>
<p>** 手动模式<strong>: 启动第一个节点后，此时此节点处于 bootstrap 模式，其节点手动执行加入，使用： -join命令<br>** 自动模式</strong>: 启动第一个节点后，在其他节点配置好尝试加入的目标节点，然后等待其自动加入(不需要人为命令加入)，配置：retry_join</p>
<p>以自动模式为例：</p>
<p>目录结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document</span><br><span class="line">|--consul</span><br><span class="line">   |--server1.json</span><br><span class="line">   |--server2.json</span><br><span class="line">   |--server3.json</span><br><span class="line">   |--client1.json</span><br><span class="line">   |--data</span><br></pre></td></tr></table></figure>

<p>server1.json配置文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data_dir&quot;</span>: <span class="string">&quot;/data&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;datacenter&quot;</span>: <span class="string">&quot;consul-test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;log_level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;node_name&quot;</span>: <span class="string">&quot;server1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;server&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;bind_addr&quot;</span>: <span class="string">&quot;172.17.0.2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bootstrap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;retry_join&quot;</span>: [<span class="string">&quot;172.17.0.2&quot;</span>, <span class="string">&quot;172.17.0.3&quot;</span>, <span class="string">&quot;172.17.0.4&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server2.json配置文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data_dir&quot;</span>: <span class="string">&quot;/data&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;datacenter&quot;</span>: <span class="string">&quot;consul-test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;log_level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;node_name&quot;</span>: <span class="string">&quot;server2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;server&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;bind_addr&quot;</span>: <span class="string">&quot;172.17.0.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;retry_join&quot;</span>: [<span class="string">&quot;172.17.0.2&quot;</span>, <span class="string">&quot;172.17.0.3&quot;</span>, <span class="string">&quot;172.17.0.4&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>server3.json配置文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data_dir&quot;</span>: <span class="string">&quot;/data&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;datacenter&quot;</span>: <span class="string">&quot;consul-test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;log_level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;node_name&quot;</span>: <span class="string">&quot;server3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;server&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;bind_addr&quot;</span>: <span class="string">&quot;172.17.0.4&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;retry_join&quot;</span>: [<span class="string">&quot;172.17.0.2&quot;</span>, <span class="string">&quot;172.17.0.3&quot;</span>, <span class="string">&quot;172.17.0.4&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client1.json配置文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data_dir&quot;</span>: <span class="string">&quot;/data&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;datacenter&quot;</span>: <span class="string">&quot;consul-test&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;log_level&quot;</span>: <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;node_name&quot;</span>: <span class="string">&quot;client1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;ui&quot;</span>: <span class="literal">true</span>,                         <span class="comment">// 是否开启 UI 访问</span></span><br><span class="line">    <span class="attr">&quot;http_config&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;response_headers&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;addresses&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;http&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;start_join&quot;</span>: [<span class="string">&quot;172.17.0.2&quot;</span>, <span class="string">&quot;172.17.0.3&quot;</span>, <span class="string">&quot;172.17.0.4&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行docker容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=server1 -it -d -v <span class="variable">$PWD</span>/consul:/consul consul agent -config-file=/consul/server1.json</span><br><span class="line"></span><br><span class="line">docker run --name=server2 -it -d -v <span class="variable">$PWD</span>/consul:/consul consul agent -config-file=/consul/server2.json</span><br><span class="line"></span><br><span class="line">docker run --name=server3 -it -d -v <span class="variable">$PWD</span>/consul:/consul consul agent -config-file=/consul/server3.json</span><br><span class="line"></span><br><span class="line">docker run --name=client1 -it -d -v <span class="variable">$PWD</span>/consul:/consul consul agent -config-file=/consul/client1.json</span><br></pre></td></tr></table></figure>

<p>查看容器运行日志(选择其中一个即可)，可以看出选举server1作为Leader：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs server1</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018/06/14 08:12:06 [INFO] consul: New leader elected: server1</span><br></pre></td></tr></table></figure>

<p>可以查看容器的ip:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27;</span> server1</span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> server1</span><br></pre></td></tr></table></figure>

<p>查看下集群的状态</p>
<p>注：server1为Leader;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -t server1 consul members</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost document]<span class="comment"># docker exec -t server1 consul members</span></span><br><span class="line">Node     Address          Status  Type    Build  Protocol  DC           Segment</span><br><span class="line">server1  172.17.0.2:8301  alive   server  1.1.0  2         consul-test  &lt;all&gt;</span><br><span class="line">server2  172.17.0.3:8301  alive   server  1.1.0  2         consul-test  &lt;all&gt;</span><br><span class="line">server3  172.17.0.4:8301  alive   server  1.1.0  2         consul-test  &lt;all&gt;</span><br><span class="line">client1  172.17.0.5:8301  alive   client  1.1.0  2         consul-test  &lt;default&gt;</span><br></pre></td></tr></table></figure>

<p>访问：<a target="_blank" rel="noopener" href="http://172.17.0.5:8500">http://172.17.0.5:8500</a>,打开 Consul UI 界面，就可以看到我们配置的 Consul Client:</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180615092803.png" alt="QQ截图20180615092803.png"></p>
<p>可以使用以下命令查询其它信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L http://172.17.0.5:8500/v1/catalog/datacenters</span><br><span class="line">curl -L http://172.17.0.5:8500/v1/agent/members | python -m json.tool</span><br><span class="line">curl http://172.17.0.5:8500/v1/agent/self | python -m json.tool</span><br></pre></td></tr></table></figure>

<h3 id="3、节点异常处理"><a href="#3、节点异常处理" class="headerlink" title="3、节点异常处理"></a>3、节点异常处理</h3><h4 id="LEADER-挂了"><a href="#LEADER-挂了" class="headerlink" title="LEADER 挂了"></a>LEADER 挂了</h4><p>leader挂了，consul会重新选取出新的leader，只要超过一半的SERVER还活着，集群是可以正常工作的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop server1</span><br></pre></td></tr></table></figure>

<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180615095815.png" alt="QQ截图20180615095815.png"></p>
<p>运行以下命令查看现在的Leader：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://172.17.0.5:8500/v1/status/leader</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost document]<span class="comment"># curl http://172.17.0.5:8500/v1/status/leader</span></span><br><span class="line"><span class="string">&quot;172.17.0.3:8300&quot;</span></span><br></pre></td></tr></table></figure>

<p>注：172.17.0.3为server2 IP。</p>
<h2 id="2，Docker-运行-Fabio-环境"><a href="#2，Docker-运行-Fabio-环境" class="headerlink" title="2，Docker 运行 Fabio 环境"></a>2，Docker 运行 Fabio 环境</h2><h3 id="Fabio简介"><a href="#Fabio简介" class="headerlink" title="Fabio简介"></a>Fabio简介</h3><p><a target="_blank" rel="noopener" href="https://github.com/fabiolb/fabio">Fabio</a> 是 ebay 团队用 golang 开发的一个快速、现代、zero-conf 负载均衡 HTTP(S) 路由器，用于部署 Consul 管理的微服务。</p>
<p>因为 consul 支持服务注册与健康检查所以 fabio 能够零配置提供负载。</p>
<p>根据项目的介绍fabio 能提供每秒15000次请求。</p>
<p>** 服务发现的特点**</p>
<p>服务与服务之间的调用需要在配置文件中填写好主机和端口,不易于维护且分布式环境中不易于部署与扩容。</p>
<p>那么此时就需要考虑服务启动的时候自己把主机和端口以及一些其他信息注册到注册中心，这样其他服务可以从中找到它。</p>
<p>甚至更为简单的注册完毕后通过 DNS 的方式来『寻址』。比如 Zookeepr 可以很好的完成这个工作，但是其中还有一个弊端就是服务的健康检查服务注册到注册中心之后如何保证这个服务一定可用？此时就需要自己来写逻辑当服务不可用的时候自动从注册中心下线掉。 然后Consul 可以很轻易的解决这个问题。</p>
<p>** 工作原理**</p>
<p>Consul 提供了一套健康检测机制简单的说针对 http 类型的服务(consul 也支持 其他类型例如tcp)在注册的时候可以顺便注册下健康检测的信息，提供一个健康检测的地址(url)以及一个频率超时时间这样的话 consul 会定期的来请求当状态码是200的时候设置次服务是健康的状态否则是故障状态。</p>
<p>既然注册到consul的服务能够自己维护健康状态此时 fabio 的工作就很简单了！ 就是直接从consul 注册表里面取出健康的服务根据服务注册时候的 tags 配置自动创建自己的路由表，然后当一个 http 请求过来的时候自动去做负载均衡</p>
<p>简单流程图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">======    服务注册     =========       =========</span><br><span class="line">A服务   &lt;------&gt;      consul集群  ----&gt;  健康的 A/不健康的 A 集群</span><br><span class="line">======    健康检查     =========       =========</span><br><span class="line">                                     ^</span><br><span class="line">                                     | 加入/移出路由表</span><br><span class="line">                                     |</span><br><span class="line">                                  ========</span><br><span class="line">                                   fabio 集群</span><br><span class="line">                                  ========</span><br><span class="line">                                     ^</span><br><span class="line">                                     |</span><br><span class="line">                                     | A服务   如果找到则成功路由否则返回错误</span><br><span class="line">                                     V</span><br><span class="line">                                    http 请求</span><br></pre></td></tr></table></figure>

<h3 id="Docker-运行-Fabio"><a href="#Docker-运行-Fabio" class="headerlink" title="Docker 运行 Fabio"></a>Docker 运行 Fabio</h3><p>Fabio Docker 镜像地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/magiconair/fabio/">https://hub.docker.com/r/magiconair/fabio/</a></p>
<p>** 目录结构**</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fabio</span><br><span class="line">|--fabio.properties</span><br></pre></td></tr></table></figure>

<p>首先，在/fabio/目录下创建一个fabio.properties文件（<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/eBay/fabio/master/fabio.properties">示例配置</a>），然后vim fabio.properties增加下面配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">registry.consul.register.addr = 172.17.0.6:9998</span><br><span class="line">registry.consul.addr = 172.17.0.5:8500</span><br></pre></td></tr></table></figure>

<p>在fabio文件夹下运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9999:9999 -p 9998:9998 --name=fabio -v <span class="variable">$PWD</span>/fabio.properties:/etc/fabio/fabio.properties magiconair/fabio</span><br></pre></td></tr></table></figure>

<p>注：默认是bridge网络模式，也就是我们常用的桥接模式，Docker 会分配给容器一个独立的 IP 地址（端口也是独立的），并且容器和主机之间可以相互访问。或者添加参数：–net=host：host网络模式，容器的网络接口和主机一样，也就是共享一个 IP 地址。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180615172806.png" alt="QQ截图20180615172806.png"></p>
<h2 id="3，Docker-运行-ASP-NET-Core-2-0-服务"><a href="#3，Docker-运行-ASP-NET-Core-2-0-服务" class="headerlink" title="3，Docker 运行 ASP.NET Core 2.0 服务"></a>3，Docker 运行 ASP.NET Core 2.0 服务</h2><h3 id="3-1-准备asp-net-Core应用程序"><a href="#3-1-准备asp-net-Core应用程序" class="headerlink" title="3.1 准备asp.net Core应用程序"></a>3.1 准备asp.net Core应用程序</h3><p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180620090937.png" alt="QQ截图20180620090937.png"></p>
<h3 id="3-2-添加HealthController用于Consul健康检查"><a href="#3-2-添加HealthController用于Consul健康检查" class="headerlink" title="3.2 添加HealthController用于Consul健康检查"></a>3.2 添加HealthController用于Consul健康检查</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Produces(<span class="meta-string">&quot;application/json&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">&quot;api/Health&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HealthController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Get</span>(<span class="params"></span>)</span> =&gt; Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-调用Consul-API注册服务"><a href="#3-3-调用Consul-API注册服务" class="headerlink" title="3.3 调用Consul API注册服务"></a>3.3 调用Consul API注册服务</h3><p>组件地址：<a target="_blank" rel="noopener" href="https://github.com/PlayFab/consuldotnet">https://github.com/PlayFab/consuldotnet</a></p>
<p>（1） 首先安装 Consul包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install-package Conusl</span><br></pre></td></tr></table></figure>

<p>（2） 添加扩展方法，用于调用Consul API</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AppBuilderExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">RegisterWithConsul</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app, IApplicationLifetime lifetime, ServiceEntity serviceEntity</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> consulClient = <span class="keyword">new</span> ConsulClient(x =&gt; x.Address = <span class="keyword">new</span> Uri(<span class="string">$&quot;http://<span class="subst">&#123;serviceEntity.ConsulIP&#125;</span>:<span class="subst">&#123;serviceEntity.ConsulPort&#125;</span>&quot;</span>));<span class="comment">//请求注册的 Consul 地址</span></span><br><span class="line">            <span class="keyword">var</span> httpCheck = <span class="keyword">new</span> AgentServiceCheck()</span><br><span class="line">            &#123;</span><br><span class="line">                DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(<span class="number">5</span>),<span class="comment">//服务启动多久后注册</span></span><br><span class="line">                Interval = TimeSpan.FromSeconds(<span class="number">10</span>),<span class="comment">//健康检查时间间隔，或者称为心跳间隔</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 即本程序运行后的IP地址。需要使用命令：</span></span><br><span class="line">                <span class="comment">// docker inspect -f &#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; consultest_consultest_1</span></span><br><span class="line">                HTTP = <span class="string">$&quot;http://<span class="subst">&#123;serviceEntity.IP&#125;</span>:<span class="subst">&#123;serviceEntity.Port&#125;</span>/api/health&quot;</span>,<span class="comment">//健康检查地址</span></span><br><span class="line">                Timeout = TimeSpan.FromSeconds(<span class="number">5</span>)</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register service with consul</span></span><br><span class="line">            <span class="keyword">var</span> registration = <span class="keyword">new</span> AgentServiceRegistration()</span><br><span class="line">            &#123;</span><br><span class="line">                Checks = <span class="keyword">new</span>[] &#123; httpCheck &#125;,</span><br><span class="line">                ID = Guid.NewGuid().ToString(),</span><br><span class="line">                Name = serviceEntity.ServiceName,</span><br><span class="line">                Address = serviceEntity.IP,</span><br><span class="line">                Port = serviceEntity.Port,</span><br><span class="line">                Tags = <span class="keyword">new</span>[] &#123; <span class="string">$&quot;urlprefix-/<span class="subst">&#123;serviceEntity.ServiceName&#125;</span>&quot;</span> &#125;<span class="comment">//添加 urlprefix-/servicename 格式的 tag 标签，以便 Fabio 识别</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            consulClient.Agent.ServiceRegister(registration).Wait();<span class="comment">//服务启动时注册，内部实现其实就是使用 Consul API 进行注册（HttpClient发起）</span></span><br><span class="line">            lifetime.ApplicationStopping.Register(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                consulClient.Agent.ServiceDeregister(registration.ID).Wait();<span class="comment">//服务停止时取消注册</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（3）Starup类的Configure方法中，调用此扩展方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime lifetime</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">           &#123;</span><br><span class="line">               app.UseBrowserLink();</span><br><span class="line">               app.UseDeveloperExceptionPage();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               app.UseExceptionHandler(<span class="string">&quot;/Home/Error&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">           app.UseMvc(routes =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               routes.MapRoute(</span><br><span class="line">                   name: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">                   template: <span class="string">&quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// register this service</span></span><br><span class="line">           ServiceEntity serviceEntity = <span class="keyword">new</span> ServiceEntity</span><br><span class="line">           &#123;</span><br><span class="line">               IP = Configuration[<span class="string">&quot;Service:IP&quot;</span>],<span class="comment">// NetworkHelper.LocalIPAddress,</span></span><br><span class="line">               Port = Convert.ToInt32(Configuration[<span class="string">&quot;Service:Port&quot;</span>]),</span><br><span class="line">               ServiceName = Configuration[<span class="string">&quot;Service:Name&quot;</span>],</span><br><span class="line">               ConsulIP = Configuration[<span class="string">&quot;Consul:IP&quot;</span>],</span><br><span class="line">               ConsulPort = Convert.ToInt32(Configuration[<span class="string">&quot;Consul:Port&quot;</span>])</span><br><span class="line">           &#125;;</span><br><span class="line">           app.RegisterWithConsul(lifetime, serviceEntity);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>ServiceEntity类定义:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ServiceEntity</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> IP &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Port &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> ServiceName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> ConsulIP &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ConsulPort &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>appSettings.json配置文件:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Service&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;IP&quot;</span>: <span class="string">&quot;172.21.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;ConsulDemo&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Port&quot;</span>: <span class="string">&quot;80&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Consul&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;IP&quot;</span>: <span class="string">&quot;172.17.0.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Port&quot;</span>: <span class="string">&quot;8500&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;Logging&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;IncludeScopes&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;LogLevel&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Default&quot;</span>: <span class="string">&quot;Warning&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-运行ASP-NET-Core程序"><a href="#3-4-运行ASP-NET-Core程序" class="headerlink" title="3.4 运行ASP.NET Core程序"></a>3.4 运行ASP.NET Core程序</h3><p>在Linux服务器下，建立程序文件夹，使用git clone命令下载代码，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir web</span><br><span class="line"><span class="built_in">cd</span> web</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/syxdevcode/ConsulTest.git</span><br><span class="line">git pull origin master <span class="comment">### 更新代码</span></span><br></pre></td></tr></table></figure>

<p>使用docker-compose 运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ConsulTest <span class="comment">## 进入目录</span></span><br><span class="line">docker-compose up -d --build</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Successfully built dfaf37c4246f</span><br><span class="line">Successfully tagged consultest:latest</span><br><span class="line">Recreating consultest_consultest_1 ... <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>查看docker 容器：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180620092619.png" alt="QQ截图20180620092619.png"></p>
<p>其它命令：</p>
<p>查看容器IP：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> consultest_consultest_1</span><br></pre></td></tr></table></figure>

<h3 id="3-5-验证"><a href="#3-5-验证" class="headerlink" title="3.5 验证"></a>3.5 验证</h3><p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180620093002.png" alt="QQ截图20180620093002.png"></p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20180620093047.png" alt="QQ截图20180620093047.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PlayFab/consuldotnet">https://github.com/PlayFab/consuldotnet</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/docs/agent/options.html">https://www.consul.io/docs/agent/options.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/edisonchou/p/9124985.html">.NET Core微服务之基于Consul实现服务治理</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xishuai/p/macos-ubuntu-install-consul.html">Mac OS、Ubuntu 安装及使用 Consul</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xishuai/p/ubuntu-docker-consul-fabio-aspnet-core.html">Docker &amp; Consul &amp; Fabio &amp; ASP.NET Core 2.0 微服务跨平台实践</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xishuai/p/docker-compose.html">Docker 三剑客之 Docker Compose</a></p>
<p><a target="_blank" rel="noopener" href="http://xiaoquqi.github.io/blog/2015/12/07/consul-installation/">Consul的安装方法</a></p>
<p><a target="_blank" rel="noopener" href="http://soft.dog/2016/03/18/consul-basic/">Consul 基础</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.coding.net/blog/intro-consul">Consul 原理和使用简介</a></p>
<p><a target="_blank" rel="noopener" href="https://mritd.me/2017/09/21/set-up-ha-consul-cluster/">Consul 集群搭建</a></p>
<p><a target="_blank" rel="noopener" href="http://www.10tiao.com/html/357/201705/2247485185/1.html">Consul集群部署</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f8746b81d65d">服务发现 - consul 的介绍、部署和使用</a></p>
<p><a target="_blank" rel="noopener" href="http://dockone.io/article/1567">Consul + fabio 实现自动服务发现、负载均衡</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/13/Consul%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81dotnet%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/13/Consul%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81dotnet%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Consul的分布式锁DotNet实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-13 10:23:53" itemprop="dateCreated datePublished" datetime="2018-06-13T10:23:53+00:00">2018-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Consul/" itemprop="url" rel="index"><span itemprop="name">Consul</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Consul的分布式锁dotnet实现"><a href="#Consul的分布式锁dotnet实现" class="headerlink" title="Consul的分布式锁dotnet实现"></a>Consul的分布式锁dotnet实现</h1><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>基于Consul的分布式锁主要利用Key/Value存储API中的acquire和release操作来实现。acquire和release操作是类似Check-And-Set的操作：</p>
<p>acquire操作只有当锁不存在持有者时才会返回true，并且set设置的Value值，同时执行操作的session会持有对该Key的锁，否则就返回false</p>
<p>release操作则是使用指定的session来释放某个Key的锁，如果指定的session无效，那么会返回false，否则就会set设置Value值，并返回true</p>
<p>具体实现中主要使用了这几个Key/Value的API：</p>
<p>create session：<a target="_blank" rel="noopener" href="https://www.consul.io/api/session.html#session_create">https://www.consul.io/api/session.html#session_create</a></p>
<p>delete session：<a target="_blank" rel="noopener" href="https://www.consul.io/api/session.html#delete-session">https://www.consul.io/api/session.html#delete-session</a></p>
<p>KV acquire/release：<a target="_blank" rel="noopener" href="https://www.consul.io/api/kv.html#create-update-key">https://www.consul.io/api/kv.html#create-update-key</a></p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p><img src="/img/consul-lock.png" alt="consul-lock.png"></p>
<p>以上内容引用自：<a target="_blank" rel="noopener" href="http://blog.didispace.com/spring-cloud-consul-lock-and-semphore/">http://blog.didispace.com/spring-cloud-consul-lock-and-semphore/</a></p>
<p>代码参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PlayFab/consuldotnet">https://github.com/PlayFab/consuldotnet</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/PlayFab/consuldotnet">https://github.com/PlayFab/consuldotnet</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/docs/guides/leader-election.html">https://www.consul.io/docs/guides/leader-election.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/api/kv.html">https://www.consul.io/api/kv.html</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.didispace.com/spring-cloud-consul-lock-and-semphore/">基于Consul的分布式锁实现</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/13/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-consistent-hashing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/13/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-consistent-hashing/" class="post-title-link" itemprop="url">一致性哈希算法 consistent hashing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-13 10:19:39" itemprop="dateCreated datePublished" datetime="2018-06-13T10:19:39+00:00">2018-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一致性哈希算法-consistent-hashing"><a href="#一致性哈希算法-consistent-hashing" class="headerlink" title="一致性哈希算法 consistent hashing"></a>一致性哈希算法 consistent hashing</h1><p>参考：<a target="_blank" rel="noopener" href="http://www.zsythink.net/archives/1182">白话解析：一致性哈希算法 consistent hashing</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/12/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E5%A4%B1%E6%95%88%E4%BB%A5%E5%8F%8A%E7%83%AD%E7%82%B9key/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/12/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E5%A4%B1%E6%95%88%E4%BB%A5%E5%8F%8A%E7%83%AD%E7%82%B9key/" class="post-title-link" itemprop="url">缓存击穿，失效以及热点key</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-12 14:41:31" itemprop="dateCreated datePublished" datetime="2018-06-12T14:41:31+00:00">2018-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存一般是Key，value方式存在，当某一个Key不存在时会查询数据库，假如这个Key，一直不存在，则会频繁的请求数据库，对数据库造成访问压力。</p>
<h3 id="1、使用互斥锁"><a href="#1、使用互斥锁" class="headerlink" title="1、使用互斥锁"></a>1、使用互斥锁</h3><p>在根据key获得的value值为空时，先锁上，再从数据库加载，加载完毕，释放锁。若其他线程发现获取锁失败，则睡眠50ms后重试。</p>
<p>当通过某一个key去查询数据的时候，如果对应在数据库中的数据都不存在（不管是数据不存在，还是系统故障），我们将此key对应的value设置为一个默认的值，比如“NULL”，并设置一个缓存的失效时间，它的过期时间会很短，最长不超过五分钟。这时在缓存失效之前，所有通过此key的访问都被缓存挡住了。后面如果此key对应的数据在DB中存在时，缓存失效之后，通过此key再去访问数据，就能拿到新的value了。</p>
<p>至于锁的类型，单机环境用并发包的Lock类型就行，集群环境则使用分布式锁( redis的setnx)</p>
<p>** 优点**</p>
<p>思路简单<br>保证一致性</p>
<p>** 缺点**</p>
<p>代码复杂度增大<br>存在死锁的风险</p>
<p>** SETNX语法**</p>
<p>SETNX key value</p>
<p>将 key 的值设为 value ，当且仅当 key 不存在。</p>
<p>若给定的 key 已经存在，则 SETNX 不做任何动作。</p>
<p>SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>可用版本：&gt;= 1.0.0</p>
<p>时间复杂度： O(1)</p>
<p>返回值： 设置成功，返回 1。设置失败，返回 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; EXISTS job</span><br><span class="line">(integer) 0</span><br><span class="line">172.19.0.2:6380&gt; setnx job &quot;programmer&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; setnx job &quot;code-farmer&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">172.19.0.2:6380&gt; get job</span><br><span class="line">&quot;programmer&quot;</span><br></pre></td></tr></table></figure>

<p>.net 代码</p>
<p>参考：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/yaoshangjin/p/7456378.html">http://www.cnblogs.com/yaoshangjin/p/7456378.html</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 分布式锁</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;resource&quot;&gt;</span>The thing we are locking on<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;expirationTime&quot;&gt;</span>The time after which the lock will automatically be expired by Redis<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span>Action to be performed with locking<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>True if lock was acquired and action was performed; otherwise false<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">PerformActionWithLock</span>(<span class="params"><span class="built_in">string</span> resource, TimeSpan expirationTime, Action action</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RedisValue lockToken = Guid.NewGuid().ToString(); <span class="comment">//Environment.MachineName;</span></span><br><span class="line">    RedisKey locKey = resource;</span><br><span class="line">    <span class="keyword">var</span> db = GetDatabase();</span><br><span class="line">    <span class="keyword">if</span> (db.LockTake(locKey, lockToken, expirationTime))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            action();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            db.LockRelease(locKey, lockToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestLock</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RedisKey _lockKey = <span class="string">&quot;lock_key&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> _lockDuration = TimeSpan.FromSeconds(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">var</span> mainTask = <span class="keyword">new</span> Task(() =&gt; _redisMSConnectionWrapper.PerformActionWithLock(_lockKey, _lockDuration, () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;1.执行锁内任务-开始&quot;</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">10000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;1.执行锁内任务-结束&quot;</span>);</span><br><span class="line">    &#125;));</span><br><span class="line">    mainTask.Start();</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">var</span> subOk = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (subOk)</span><br><span class="line">    &#123;</span><br><span class="line">        _redisMSConnectionWrapper.PerformActionWithLock(_lockKey, _lockDuration, () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;2.执行锁内任务-开始&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;2.执行锁内任务-结束&quot;</span>);</span><br><span class="line">            subOk = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、异步构建缓存"><a href="#2、异步构建缓存" class="headerlink" title="2、异步构建缓存"></a>2、异步构建缓存</h3><p>或者叫”提前”使用互斥锁</p>
<p>在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。</p>
<p>** 优点**</p>
<p>性价最佳，用户无需等待</p>
<p>** 缺点**</p>
<p>无法保证缓存一致性</p>
<h3 id="3、布隆过滤器"><a href="#3、布隆过滤器" class="headerlink" title="3、布隆过滤器"></a>3、布隆过滤器</h3><p>布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。因此他有如下三个使用场景:</p>
<p>1.网页爬虫对URL的去重，避免爬取相同的URL地址<br>2.反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）<br>3.缓存击穿，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</p>
<p>** 布隆过滤器的原理**</p>
<p>其内部维护一个全为0的bit数组，需要说明的是，布隆过滤器有一个误判率的概念，误判率越低，则数组越长，所占空间越大。误判率越高则数组越小，所占的空间越小。</p>
<p>** 优点**</p>
<p>思路简单<br>保证一致性<br>性能强</p>
<p>** 缺点**</p>
<p>代码复杂度增大<br>需要另外维护一个集合来存放缓存的Key<br>布隆过滤器不支持删值操作</p>
<h2 id="缓存雪崩（缓存失效）"><a href="#缓存雪崩（缓存失效）" class="headerlink" title="缓存雪崩（缓存失效）"></a>缓存雪崩（缓存失效）</h2><p>在高并发的环境下，缓存集中在一段时间内大量失效（例如设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效），此时有多个进程就会去同时去查询DB，然后再去同时设置缓存。DB访问量会瞬间增大，造成了缓存雪崩。</p>
<p>解决方法：</p>
<p>1, 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待，参考上文：1、使用互斥锁。<br>2, 可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存。<br>3, 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀,例如在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>4, 做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。</p>
<h2 id="热点key问题"><a href="#热点key问题" class="headerlink" title="热点key问题"></a>热点key问题</h2><p>(1) 这个key是一个热点key（例如一个重要的新闻，一个热门的八卦新闻等等），所以这种key访问量可能非常大。</p>
<p>(2) 缓存的构建是需要一定时间的。（可能是一个复杂计算，例如复杂的sql、多次IO、多个依赖(各种接口)等等）</p>
<p>于是就会出现一个致命问题：在缓存失效的瞬间，有大量线程来构建缓存，或者由于设计问题，造成缓存击穿，造成后端负载加大，甚至可能会让系统崩溃。</p>
<p>解决方法：</p>
<p>1，使用互斥锁(mutex key):这种解决方案思路比较简单，就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了，参考上文：1、使用互斥锁。</p>
<p>2，”提前”使用互斥锁(mutex key)：在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。参考上文：2、异步构建缓存</p>
<p>3，”永远不过期”：</p>
<p>这里的“永远不过期”包含两层意思：</p>
<p>(1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</p>
<p>(2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/rjzheng/p/8908073.html">分布式之缓存击穿</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wang0112233/article/details/79558612">缓存雪崩、缓存穿透、热点Key解决方案和分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zeb_perfect/article/details/54135506">缓存穿透，缓存击穿，缓存雪崩解决方案分析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d5a3668d4dad">缓存击穿、失效以及热点key问题</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/12/%E7%BC%93%E5%AD%98%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/12/%E7%BC%93%E5%AD%98%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">缓存在分布式系统中的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-12 09:10:31" itemprop="dateCreated datePublished" datetime="2018-06-12T09:10:31+00:00">2018-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="缓存在分布式系统中的应用"><a href="#缓存在分布式系统中的应用" class="headerlink" title="缓存在分布式系统中的应用"></a>缓存在分布式系统中的应用</h1><h2 id="一、缓存概述"><a href="#一、缓存概述" class="headerlink" title="一、缓存概述"></a>一、缓存概述</h2><p>缓存是分布式系统中的重要组件，主要解决高并发，大数据场景下，热点数据访问的性能问题。提供高性能的数据快速访问。</p>
<h3 id="1-1缓存的原理"><a href="#1-1缓存的原理" class="headerlink" title="1.1缓存的原理"></a>1.1缓存的原理</h3><p>（1）将数据写入/读取速度更快的存储（设备）</p>
<p>（2）将数据缓存到离应用最近的位置；</p>
<p>（3）将数据缓存到离用户最近的位置。</p>
<h3 id="1-2缓存分类"><a href="#1-2缓存分类" class="headerlink" title="1.2缓存分类"></a>1.2缓存分类</h3><p>（1）CDN缓存；</p>
<p>（2）反向代理缓存；</p>
<p>（3）分布式Cache；</p>
<p>（4）本地应用缓存；</p>
<h3 id="1-3缓存媒介"><a href="#1-3缓存媒介" class="headerlink" title="1.3缓存媒介"></a>1.3缓存媒介</h3><p>常用中间件：Redis，Memcache，Ngnix，Varnish，Squid，Ehcache等；</p>
<p>缓存的内容：文件，数据，对象；</p>
<p>缓存的介质：CPU，内存（本地，分布式），磁盘（本地，分布式）</p>
<h3 id="1-4缓存设计"><a href="#1-4缓存设计" class="headerlink" title="1.4缓存设计"></a>1.4缓存设计</h3><p>缓存设计需要解决以下几个问题：</p>
<p>（1）缓存什么？</p>
<p>哪些数据需要缓存：1.热点数据；2.静态资源；</p>
<p>（2）缓存的位置？</p>
<p>CDN，反向代理，分布式缓存服务器，本机（内存，硬盘）</p>
<p>（3）如何缓存的问题？</p>
<p>过期策略</p>
<p>1.固定时间：比如指定缓存的时间是30分钟；<br>2.相对时间：比如最近10分钟内没有访问的数据；</p>
<p>同步机制</p>
<p>实时写入；（推）<br>异步刷新；（推拉）</p>
<h2 id="二、CDN缓存"><a href="#二、CDN缓存" class="headerlink" title="二、CDN缓存"></a>二、CDN缓存</h2><p>CDN主要解决将数据缓存到离用户最近的位置，一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署CDN应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p>
<h3 id="2-1-CND原理"><a href="#2-1-CND原理" class="headerlink" title="2.1 CND原理"></a>2.1 CND原理</h3><p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。</p>
<p>（1）未部署CDN应用前</p>
<p>网络请求路径：</p>
<p>请求：本机网络（局域网）——》运营商网络——》应用服务器机房</p>
<p>响应：应用服务器机房——》运营商网络——》本机网络（局域网）</p>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过3个节点，6个步骤完成一次用户访问操作。</p>
<p>（2）部署CDN应用后</p>
<p>网络路径：</p>
<p>请求：本机网络（局域网）——》运营商网络</p>
<p>响应：运营商网络——》本机网络（局域网）</p>
<p>在不考虑复杂网络的情况下，从请求到响应需要经过2个节点，2个步骤完成一次用户访问操作。</p>
<p>与不部署CDN服务相比，减少了1个节点，4个步骤的访问。极大的提高的系统的响应速度。</p>
<h3 id="2-2-CDN优缺点"><a href="#2-2-CDN优缺点" class="headerlink" title="2.2 CDN优缺点"></a>2.2 CDN优缺点</h3><p>（1）优点（摘自百度百科）</p>
<p>1、本地Cache加速：提升访问速度，尤其含有大量图片和静态页面站点；</p>
<p>2、镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；</p>
<p>3、远程加速：远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度；</p>
<p>4、带宽优化：自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。</p>
<p>5、集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量。</p>
<p>（2）缺点</p>
<p>1.动态资源缓存，需要注意实时性；</p>
<p>解决：主要缓存静态资源，动态资源建立多级缓存或准实时同步；</p>
<p>2.如何保证数据的一致性和实时性需要权衡考虑；</p>
<p>解决：</p>
<p>1.设置缓存失效时间（1个小时，最终一致性）；<br>2.数据版本号；</p>
<h2 id="三、反向代理缓存"><a href="#三、反向代理缓存" class="headerlink" title="三、反向代理缓存"></a>三、反向代理缓存</h2><p>反向代理是指在网站服务器机房部署代理服务器，实现负载均衡，数据缓存，安全控制等功能。</p>
<h3 id="3-1缓存原理"><a href="#3-1缓存原理" class="headerlink" title="3.1缓存原理"></a>3.1缓存原理</h3><p>反向代理位于应用服务器机房，处理所有对WEB服务器的请求。如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向WEB服务器的请求数，从而降低了WEB服务器的负载。</p>
<p>反向代理一般缓存静态资源，动态资源转发到应用服务器处理。常用的缓存应用服务器有Varnish，Ngnix，Squid。</p>
<h3 id="3-2-代理缓存比较"><a href="#3-2-代理缓存比较" class="headerlink" title="3.2 代理缓存比较"></a>3.2 代理缓存比较</h3><p>常用的代理缓存有Varnish，Squid，Ngnix，简单比较如下：</p>
<p>（1）varnish和squid是专业的cache服务，nginx需要第三方模块支持；</p>
<p>（2）Varnish采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比Squid高；</p>
<p>（3）Varnish由于是内存cache，所以对小文件如css,js,小图片啥的支持很棒，后端的持久化缓存可以采用的是Squid或ATS；</p>
<p>（4）Squid功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个HAProxy或nginx做负载均衡跑多个实例；</p>
<p>（5）Nginx采用第三方模块ncache做的缓冲，性能基本达到varnish，一般作为反向代理使用，可以实现简单的缓存。</p>
<h2 id="四、分布式缓存"><a href="#四、分布式缓存" class="headerlink" title="四、分布式缓存"></a>四、分布式缓存</h2><p>CDN,反向代理缓存，主要解决静态文件，或用户请求资源的缓存，数据源一般为静态文件或动态生成的文件（有缓存头标识）。</p>
<p>分布式缓存，主要指缓存用户经常访问数据的缓存，数据源为数据库。一般起到热点数据访问和减轻数据库压力的作用。</p>
<p>目前分布式缓存设计，在大型网站架构中是必备的架构要素。常用的中间件有Memcache，Redis。</p>
<h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p>（1）使用物理内存作为缓存区，可独立运行在服务器上。每个进程最大2G，如果想缓存更多的数据，可以开辟更多的memcache进程（不同端口）或者使用分布式memcache进行缓存，将数据缓存到不同的物理机或者虚拟机上。</p>
<p>（2）使用key-value的方式来存储数据，这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为O(1)。</p>
<p>（3）协议简单：基于文本行的协议，直接通过telnet在memcached服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；</p>
<p>（4）基于libevent高性能通信：Libevent是一套利用C开发的程序库，它将BSD系统的kqueue,Linux系统的epoll等事件处理功能封装成一个接口，与传统的select相比，提高了性能。</p>
<p>（5）内置的内存管理方式：所有数据都保存在内存中，存取数据比硬盘快，当内存满后，通过LRU算法自动删除不使用的缓存，但没有考虑数据的容灾问题，重启服务，所有数据会丢失。</p>
<p>（6）分布式：各个memcached服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于memcache客户端。</p>
<p>（7）缓存策略：Memcached的缓存策略是LRU（最近最少使用）到期失效策略。在memcached内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当memcached服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在LRU中，memcached使用的是一种Lazy Expiration策略，自己不会监控存入的key/vlue对是否过期，而是在获取key值时查看记录的时间戳，检查key/value对空间是否过期，这样可减轻服务器的负载。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 是一个开源（BSD许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。 支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。</p>
<p>内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。</p>
<h3 id="Memcache与Redis的比较"><a href="#Memcache与Redis的比较" class="headerlink" title="Memcache与Redis的比较"></a>Memcache与Redis的比较</h3><p>（1）数据结构：Memcache只支持key value存储方式，Redis支持更多的数据类型，比如Key value，hash，list，set，zset；</p>
<p>（2）多线程：Memcache支持多线程，redis支持单线程；CPU利用方面Memcache优于redis；</p>
<p>（3）持久化：Memcache不支持持久化，Redis支持持久化；</p>
<p>（4）内存利用率：memcache高，redis低（采用压缩的情况下比memcache高）；</p>
<p>（5）过期策略：memcache过期后，不删除缓存，会导致下次取数据数据的问题，Redis有专门线程，清除缓存数据；</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是说收到了一个请求，但是该请求缓存里没有，只能去数据库里查询，然后放进缓存。这里面有两个风险，一个是同时有好多请求访问同一个数据，然后业务系统把这些请求全发到了数据库；第二个是有人恶意构造一个逻辑上不存在的数据，然后大量发送这个请求，这样每次请求都会被发送到数据库，可能导致数据挂掉。</p>
<p>怎么应对这种情况呢？对于恶意访问，一个思路是事先做校验，对恶意数据直接过滤掉，不要发到数据库层；第二个思路是缓存空结果，就是对查询不存在的数据仍然记录一条该数据不存在在缓存里，这样能有效的减少查询数据库的次数。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存一般是Key，value方式存在，当某一个Key不存在时会查询数据库，假如这个Key，一直不存在，则会频繁的请求数据库，对数据库造成访问压力。</p>
<p>解决方法：</p>
<p>（1）对结果为空的数据也进行缓存，当此key有数据后，清理缓存；</p>
<p>（2）一定不存在的key，采用布隆过滤器，建立一个大的Bitmap中，查询时通过该bitmap过滤；</p>
<p>一个思路是全局锁，就是所有访问某个数据的请求都共享一个锁，获得锁的那个才有资格去访问数据库，其他线程必须等待。但是现在的业务都是分布式的，本地锁没法控制其他服务器也等待，所以要用到全局锁，比如用redis的setnx实现全局锁。</p>
<p>另一个思路是对即将过期的数据主动刷新，做法可以有很多，比如起一个线程轮询数据，比如把所有数据划分为不同的缓存区间，定期分区间刷新数据等等。</p>
<h2 id="四、缓存雪崩"><a href="#四、缓存雪崩" class="headerlink" title="四、缓存雪崩"></a>四、缓存雪崩</h2><p>雪崩是指当大量缓存失效时，导致大量的请求访问数据库，导致数据库服务器，无法抗住请求或挂掉的情况。</p>
<p>解决方法：</p>
<p>（1）合理规划缓存的失效时间；</p>
<p>（2）合理评估数据库的负载压力；</p>
<p>（3）对数据库进行过载保护或应用层限流；</p>
<p>（4）多级缓存设计，缓存高可用；</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/itfly8/p/5562610.html">大型网站架构系列：缓存在分布式系统中的应用（一）</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/itfly8/p/5562615.html">大型网站架构系列：缓存在分布式系统中的应用（二）</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/itfly8/p/5597639.html">大型网站架构系列：缓存在分布式系统中的应用（三）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bethunebtj/p/9159914.html">高并发请求的缓存设计策略</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/11/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/11/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Redis内存模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-11 14:02:41" itemprop="dateCreated datePublished" datetime="2018-06-11T14:02:41+00:00">2018-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转载<a target="_blank" rel="noopener" href="http://www.cnblogs.com/kismetv/p/8654978.html">深入学习Redis（1）：Redis内存模型</a></p>
<p>这篇文章主要介绍Redis的内存模型（以3.0为例），包括Redis占用内存的情况及如何查询、不同的对象类型在内存中的编码方式、内存分配器(jemalloc)、简单动态字符串(SDS)、RedisObject等；然后在此基础上介绍几个Redis内存模型的应用。</p>
<h2 id="一、Redis内存统计"><a href="#一、Redis内存统计" class="headerlink" title="一、Redis内存统计"></a>一、Redis内存统计</h2><p>在客户端通过redis-cli连接服务器后（后面如无特殊说明，客户端一律使用redis-cli），通过info命令可以查看内存使用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; info memory</span><br><span class="line"># Memory</span><br><span class="line">used_memory:848344</span><br><span class="line">used_memory_human:828.46K</span><br><span class="line">used_memory_rss:7520256</span><br><span class="line">used_memory_rss_human:7.17M</span><br><span class="line">used_memory_peak:848344</span><br><span class="line">used_memory_peak_human:828.46K</span><br><span class="line">used_memory_peak_perc:100.01%</span><br><span class="line">used_memory_overhead:836086</span><br><span class="line">used_memory_startup:786456</span><br><span class="line">used_memory_dataset:12258</span><br><span class="line">used_memory_dataset_perc:19.81%</span><br><span class="line">total_system_memory:1910714368</span><br><span class="line">total_system_memory_human:1.78G</span><br></pre></td></tr></table></figure>

<p>其中，info命令可以显示redis服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；memory是参数，表示只显示内存相关的信息。</p>
<p>返回结果中比较重要的几个说明如下：</p>
<p>（1）** used_memory**：Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。used_memory_human只是显示更友好。</p>
<p>（2）** used_memory_rss**：Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。</p>
<p>因此，used_memory和used_memory_rss，前者是从Redis角度得到的量，后者是从操作系统角度得到的量。二者之所以有所不同，一方面是因为内存碎片和Redis进程运行需要占用内存，使得前者可能比后者小，另一方面虚拟内存的存在，使得前者可能比后者大。</p>
<p>由于在实际应用中，Redis的数据量会比较大，此时进程运行占用的内存与Redis数据量和内存碎片相比，都会小得多；因此used_memory_rss和used_memory的比例，便成了衡量Redis内存碎片率的参数；这个参数就是mem_fragmentation_ratio。</p>
<p>（3）** mem_fragmentation_ratio**：内存碎片比率，该值是used_memory_rss / used_memory的比值。</p>
<p>mem_fragmentation_ratio一般大于1，且该值越大，内存碎片比例越大。mem_fragmentation_ratio&lt;1，说明Redis使用了虚拟内存，由于虚拟内存的媒介是磁盘，比内存速度要慢很多，当这种情况出现时，应该及时排查，如果内存不足应该及时处理，如增加Redis节点、增加Redis服务器的内存、优化应用等。</p>
<p>一般来说，mem_fragmentation_ratio在1.03左右是比较健康的状态（对于jemalloc来说）；</p>
<p>（4）** mem_allocator**：Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。</p>
<h2 id="二、Redis内存划分"><a href="#二、Redis内存划分" class="headerlink" title="二、Redis内存划分"></a>二、Redis内存划分</h2><p>Redis的内存占用主要可以划分为以下几个部分：</p>
<h3 id="1、数据"><a href="#1、数据" class="headerlink" title="1、数据"></a>1、数据</h3><p>作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。</p>
<p>Redis使用键值对存储数据，其中的值（对象）包括5种类型，即字符串、哈希、列表、集合、有序集合。这5种类型是Redis对外提供的，实际上，在Redis内部，每种类型可能有2种或更多的内部编码实现；此外，Redis在存储对象时，并不是直接将数据扔进内存，而是会对对象进行各种包装：如redisObject、SDS等；这篇文章后面将重点介绍Redis中数据存储的细节。</p>
<h3 id="2、进程本身运行需要的内存"><a href="#2、进程本身运行需要的内存" class="headerlink" title="2、进程本身运行需要的内存"></a>2、进程本身运行需要的内存</h3><p>Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。这部分内存不是由jemalloc分配，因此不会统计在used_memory中。</p>
<p>补充说明：除了主进程外，Redis创建的子进程运行也会占用内存，如Redis执行AOF、RDB重写时创建的子进程。当然，这部分内存不属于Redis进程，也不会统计在used_memory和used_memory_rss中。</p>
<h3 id="3、缓冲内存"><a href="#3、缓冲内存" class="headerlink" title="3、缓冲内存"></a>3、缓冲内存</h3><p>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。</p>
<h3 id="4、内存碎片"><a href="#4、内存碎片" class="headerlink" title="4、内存碎片"></a>4、内存碎片</h3><p>内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。</p>
<p>内存碎片的产生与对数据进行的操作、数据的特点等都有关；此外，与使用的内存分配器也有关系：如果内存分配器设计合理，可以尽可能的减少内存碎片的产生。后面将要说到的jemalloc便在控制内存碎片方面做的很好。</p>
<p>如果Redis服务器中的内存碎片已经很大，可以通过安全重启的方式减小内存碎片：因为重启之后，Redis重新从备份文件中读取数据，在内存中进行重排，为每个数据重新选择合适的内存单元，减小内存碎片。</p>
<h2 id="三、Redis数据存储的细节"><a href="#三、Redis数据存储的细节" class="headerlink" title="三、Redis数据存储的细节"></a>三、Redis数据存储的细节</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>关于Redis数据存储的细节，涉及到内存分配器（如jemalloc）、简单动态字符串（SDS）、5种对象类型及内部编码、redisObject。在讲述具体内容之前，先说明一下这几个概念之间的关系。</p>
<p>下图是执行set hello world时，所涉及到的数据模型。</p>
<p><img src="/img/1174710-20180327001055927-1896197804.png" alt="1174710-20180327001055927-1896197804.png"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://searchdatabase.techtarget.com.cn/7-20218/">https://searchdatabase.techtarget.com.cn/7-20218/</a></p>
<p>（1）dictEntry：Redis是Key-Value数据库，因此对每个键值对都会有一个dictEntry，里面存储了指向Key和Value的指针；next指向下一个dictEntry，与本Key-Value无关。</p>
<p>（2）Key：图中右上角可见，Key（”hello”）并不是直接以字符串存储，而是存储在SDS结构中。</p>
<p>（3）redisObject：Value(“world”)既不是直接以字符串存储，也不是像Key一样直接存储在SDS中，而是存储在redisObject中。实际上，不论Value是5种类型的哪一种，都是通过redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。不过可以看出，字符串对象虽然经过了redisObject的包装，但仍然需要通过SDS存储。</p>
<p>实际上，redisObject除了type和ptr字段以外，还有其他字段图中没有给出，如用于指定对象内部编码的字段；后面会详细介绍。</p>
<p>（4）jemalloc：无论是DictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。以DictEntry对象为例，有3个指针组成，在64位机器下占24个字节，jemalloc会为它分配32字节大小的内存单元。</p>
<p>下面来分别介绍jemalloc、redisObject、SDS、对象类型及内部编码。</p>
<h3 id="2、jemalloc"><a href="#2、jemalloc" class="headerlink" title="2、jemalloc"></a>2、jemalloc</h3><p>Redis在编译时便会指定内存分配器；内存分配器可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc。</p>
<p>jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p>
<p>jemalloc划分的内存单元如下图所示：</p>
<p><img src="/img/1174710-20180327001126509-2023165562.png" alt="1174710-20180327001126509-2023165562.png"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="http://blog.csdn.net/zhengpeitao/article/details/76573053">http://blog.csdn.net/zhengpeitao/article/details/76573053</a></p>
<p>例如，如果需要存储大小为130字节的对象，jemalloc会将其放入160字节的内存单元中。</p>
<h3 id="3、redisObject"><a href="#3、redisObject" class="headerlink" title="3、redisObject"></a>3、redisObject</h3><p>前面说到，Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。</p>
<p>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持，下面将通过redisObject的结构来说明它是如何起作用的。</p>
<p>redisObject的定义如下（不同版本的Redis可能稍稍有所不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">　　unsigned type:4;</span><br><span class="line">　　unsigned encoding:4;</span><br><span class="line">　　unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */</span><br><span class="line">　　int refcount;</span><br><span class="line">　　void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>redisObject的每个字段的含义和作用如下：</p>
<h4 id="（1）type"><a href="#（1）type" class="headerlink" title="（1）type"></a>（1）type</h4><p>type字段表示对象的类型，占4个比特；目前包括REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)。</p>
<p>当我们执行type命令时，便是通过读取RedisObject的type字段获得对象的类型；如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set mystring helloredis</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; type mystring</span><br><span class="line">string</span><br><span class="line">172.19.0.2:6380&gt; sadd myset member1 member2 member3</span><br><span class="line">(integer) 3</span><br><span class="line">172.19.0.2:6380&gt; type myset</span><br><span class="line">set</span><br></pre></td></tr></table></figure>

<h4 id="（2）encoding"><a href="#（2）encoding" class="headerlink" title="（2）encoding"></a>（2）encoding</h4><p>encoding表示对象的内部编码，占4个比特。</p>
<p>对于Redis支持的每种类型，都有至少两种内部编码，例如对于字符串，有int、embstr、raw三种编码。通过encoding属性，Redis可以根据不同的使用场景来为对象设置不同的编码，大大提高了Redis的灵活性和效率。以列表对象为例，有压缩列表和双端链表两种编码方式；如果列表中的元素较少，Redis倾向于使用压缩列表进行存储，因为压缩列表占用内存更少，而且比双端链表可以更快载入；当列表对象元素较多时，压缩列表就会转化为更适合存储大量元素的双端链表。</p>
<p>通过object encoding命令，可以查看对象采用的编码方式，如所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set key1 33</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;int&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key2 helloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<h4 id="（3）lru"><a href="#（3）lru" class="headerlink" title="（3）lru"></a>（3）lru</h4><p>lru记录的是对象最后一次被命令程序访问的时间，占据的比特数不同的版本有所不同（如4.0版本占24比特，2.6版本占22比特）。</p>
<p>通过对比lru时间与当前时间，可以计算某个对象的空转时间；object idletime命令可以显示该空转时间（单位是秒）。object idletime命令的一个特殊之处在于它不改变对象的lru值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 540</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 541</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br><span class="line">(integer) 547</span><br><span class="line">172.19.0.2:6380&gt; get mystring</span><br><span class="line">&quot;helloredis&quot;</span><br><span class="line">172.19.0.2:6380&gt; object idletime mystring</span><br></pre></td></tr></table></figure>

<p>lru值除了通过object idletime命令打印之外，还与Redis的内存回收有关系：如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。</p>
<h4 id="（4）refcount"><a href="#（4）refcount" class="headerlink" title="（4）refcount"></a>（4）refcount</h4><p>** refcount与共享对象**</p>
<p>refcount记录的是该对象被引用的次数，类型为整型。refcount的作用，主要在于对象的引用计数和内存回收。当创建新对象时，refcount初始化为1；当有新程序使用该对象时，refcount加1；当对象不再被一个新程序使用时，refcount减1；当refcount变为0时，对象占用的内存会被释放。</p>
<p>Redis中被多次使用的对象(refcount&gt;1)，称为共享对象。Redis为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对象。这个被重复使用的对象，就是共享对象。目前共享对象仅支持整数值的字符串对象。</p>
<p>** 共享对象的具体实现 **</p>
<p>Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。</p>
<p>虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。</p>
<p>就目前的实现来说，Redis服务器在初始化时，会创建10000个字符串对象，值分别是0<del>9999的整数值；当Redis需要使用值为0</del>9999的字符串对象时，可以直接使用这些共享对象。10000这个数字可以通过调整参数REDIS_SHARED_INTEGERS（4.0中是OBJ_SHARED_INTEGERS）的值进行改变。</p>
<h4 id="（5）ptr"><a href="#（5）ptr" class="headerlink" title="（5）ptr"></a>（5）ptr</h4><p>ptr指针指向具体的数据，如前面的例子中，set hello world，ptr指向包含字符串world的SDS。</p>
<h4 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h4><p>综上所述，redisObject的结构与对象类型、编码、内存回收、共享对象都有关系；一个redisObject对象的大小为16字节：</p>
<p>4bit+4bit+24bit+4Byte+8Byte=16Byte。</p>
<h3 id="4、SDS"><a href="#4、SDS" class="headerlink" title="4、SDS"></a>4、SDS</h3><p>Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。</p>
<h4 id="（1）SDS结构"><a href="#（1）SDS结构" class="headerlink" title="（1）SDS结构"></a>（1）SDS结构</h4><p>sds的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，buf表示字节数组，用来存储字符串；len表示buf已使用的长度，free表示buf未使用的长度。下面是两个例子。</p>
<p>通过SDS的结构可以看出，buf数组的长度=free+len+1（其中1表示字符串结尾的空字符）；所以，一个SDS结构占据的空间为：free所占长度+len所占长度+ buf数组的长度=4+4+free+len+1=free+len+9。</p>
<h4 id="2-SDS与C字符串的应用"><a href="#2-SDS与C字符串的应用" class="headerlink" title="(2)SDS与C字符串的应用"></a>(2)SDS与C字符串的应用</h4><p>Redis在存储对象时，一律使用SDS代替C字符串。例如set hello world命令，hello和world都是以SDS的形式存储的。而sadd myset member1 member2 member3命令，不论是键（”myset”），还是集合中的元素（”member1”、 ”member2”和”member3”），都是以SDS的形式存储。除了存储对象，SDS还用于存储各种缓冲区。</p>
<p>只有在字符串不会改变的情况下，如打印日志时，才会使用C字符串。</p>
<h2 id="四、Redis的对象类型与内部编码"><a href="#四、Redis的对象类型与内部编码" class="headerlink" title="四、Redis的对象类型与内部编码"></a>四、Redis的对象类型与内部编码</h2><p>前面已经说过，Redis支持5种对象类型，而每种结构都有至少两种编码；这样做的好处在于：一方面接口与实现分离，当需要增加或改变内部编码时，用户使用不受影响，另一方面可以根据不同的应用场景切换内部编码，提高效率。</p>
<p>关于Redis内部编码的转换，都符合以下规律：编码转换在Redis写入数据时完成，且转换过程不可逆，只能从小内存编码向大内存编码转换。</p>
<h3 id="1、字符串"><a href="#1、字符串" class="headerlink" title="1、字符串"></a>1、字符串</h3><h4 id="（1）概况"><a href="#（1）概况" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>字符串是最基础的类型，因为所有的键都是字符串类型，且字符串之外的其他几种复杂类型的元素也是字符串。</p>
<p>字符串长度不能超过512MB。</p>
<h4 id="（2）内部编码"><a href="#（2）内部编码" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>字符串类型的内部编码有3种，它们的应用场景如下：</p>
<p>** int**：8个字节的长整型。字符串值是整型时，这个值使用long整型表示。</p>
<p>** embstr**：&lt;=39字节的字符串。embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</p>
<p>** raw**：大于39个字节的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;int&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key2 helloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key2</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">172.19.0.2:6380&gt; set key3 helloworldhelloworldhelloworldhelloworldhelloworld</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; strlen key3</span><br><span class="line">(integer) 50</span><br><span class="line">172.19.0.2:6380&gt; object encoding key3</span><br><span class="line">&quot;raw&quot;</span><br><span class="line">172.19.0.2:6380&gt;</span><br></pre></td></tr></table></figure>

<p>embstr和raw进行区分的长度，是39；是因为redisObject的长度是16字节，sds的长度是9+字符串长度；因此当字符串长度是39时，embstr的长度正好是16+9+39=64，jemalloc正好可以分配64字节的内存单元。</p>
<h4 id="（3）编码转换"><a href="#（3）编码转换" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>当int数据不再是整数，或大小超过了long的范围时，自动转化为raw。</p>
<p>而对于embstr，由于其实现是只读的，因此在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了39个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; set key1 hello</span><br><span class="line">OK</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">172.19.0.2:6380&gt; append key1 ,world</span><br><span class="line">(integer) 11</span><br><span class="line">172.19.0.2:6380&gt; get key1</span><br><span class="line">&quot;hello,world&quot;</span><br><span class="line">172.19.0.2:6380&gt; object encoding key1</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2、列表"><a href="#2、列表" class="headerlink" title="2、列表"></a>2、列表</h3><h4 id="（1）列表概况"><a href="#（1）列表概况" class="headerlink" title="（1）列表概况"></a>（1）列表概况</h4><p>列表（list）用来存储多个有序的字符串，每个字符串称为元素；一个列表可以存储2^32-1个元素。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等。</p>
<h4 id="（2）列表内部编码"><a href="#（2）列表内部编码" class="headerlink" title="（2）列表内部编码"></a>（2）列表内部编码</h4><p>列表的内部编码可以是压缩列表（ziplist）或双端链表（linkedlist）。</p>
<p>双端链表：由一个list结构和多个listNode结构组成；典型结构如下图所示：</p>
<p><img src="/img/1174710-20180327001435577-242733744.png" alt="1174710-20180327001435577-242733744.png"></p>
<p>图片来源：《Redis设计与实现》</p>
<p>通过图中可以看出，双端链表同时保存了表头指针和表尾指针，并且每个节点都有指向前和指向后的指针；链表中保存了列表的长度；dup、free和match为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。而链表中每个节点指向的是type为字符串的redisObject。</p>
<p>压缩列表：压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，略。与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算。</p>
<p>压缩列表不仅用于实现列表，也用于实现哈希、有序列表；使用非常广泛。</p>
<h4 id="（3）列表编码转换"><a href="#（3）列表编码转换" class="headerlink" title="（3）列表编码转换"></a>（3）列表编码转换</h4><p>只有同时满足下面两个条件时，才会使用压缩列表：列表中元素数量小于512个；列表中所有字符串对象都不足64字节。如果有一个条件不满足，则使用双端列表；且编码只可能由压缩列表转化为双端链表，反方向则不可能。</p>
<p>其中，单个字符串不能超过64字节，是为了便于统一分配每个节点的长度；这里的64字节是指字符串的长度，不包括SDS结构，因为压缩列表使用连续、定长内存块存储字符串，不需要SDS结构指明长度。后面提到压缩列表，也会强调长度不超过64字节，原理与这里类似。</p>
<h3 id="3、哈希"><a href="#3、哈希" class="headerlink" title="3、哈希"></a>3、哈希</h3><h4 id="（1）概况-1"><a href="#（1）概况-1" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>哈希（作为一种数据结构），不仅是redis对外提供的5种对象类型的一种（与字符串、列表、集合、有序结合并列），也是Redis作为Key-Value数据库所使用的数据结构。为了说明的方便，在本文后面当使用“内层的哈希”时，代表的是redis对外提供的5种对象类型的一种；使用“外层的哈希”代指Redis作为Key-Value数据库所使用的数据结构。</p>
<p>#####（2）内部编码</p>
<p>内层的哈希使用的内部编码可以是压缩列表（ziplist）和哈希表（hashtable）两种；Redis的外层的哈希则只使用了hashtable。</p>
<p>压缩列表前面已介绍。与哈希表相比，压缩列表用于元素个数少、元素长度小的场景；其优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于哈希中元素数量较少，因此操作的时间并没有明显劣势。</p>
<p>hashtable：一个hashtable由1个dict结构、2个dictht结构、1个dictEntry指针数组（称为bucket）和多个dictEntry结构组成。</p>
<p>正常情况下（即hashtable没有进行rehash时）各部分关系如下图所示：</p>
<p><img src="/img/1174710-20180327001627028-325473621.png" alt="1174710-20180327001627028-325473621.png"></p>
<p>图片改编自：《Redis设计与实现》</p>
<p>下面从底层向上依次介绍各个部分：</p>
<p>** dictEntry **</p>
<p>dictEntry结构用于保存键值对，结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">    void *key;</span><br><span class="line">    union&#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>

<p>其中，各个属性的功能如下：</p>
<p>key：键值对中的键；<br>val：键值对中的值，使用union(即共用体)实现，存储的内容既可能是一个指向值的指针，也可能是64位整型，或无符号64位整型；<br>next：指向下一个dictEntry，用于解决哈希冲突问题<br>在64位系统中，一个dictEntry对象占24字节（key/val/next各占8字节）。</p>
<p>** bucket**</p>
<p>bucket是一个数组，数组的每个元素都是指向dictEntry结构的指针。redis中bucket数组的大小计算规则如下：大于dictEntry的、最小的2^n；例如，如果有1000个dictEntry，那么bucket大小为1024；如果有1500个dictEntry，则bucket大小为2048。</p>
<p>** dictht**</p>
<p>dictht结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    unsigned long size;</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure>

<p>其中，各个属性的功能说明如下：</p>
<p>table属性是一个指针，指向bucket；<br>size属性记录了哈希表的大小，即bucket的大小；<br>used记录了已使用的dictEntry的数量；<br>sizemask属性的值总是为size-1，这个属性和哈希值一起决定一个键在table中存储的位置。</p>
<p>** dict**</p>
<p>一般来说，通过使用dictht和dictEntry结构，便可以实现普通哈希表的功能；但是Redis的实现中，在dictht结构的上层，还有一个dict结构。下面说明dict结构的定义及作用。</p>
<p>dict结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pedef struct dict&#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    void *privdata;</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    int trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>其中，type属性和privdata属性是为了适应不同类型的键值对，用于创建多态字典。</p>
<p>ht属性和trehashidx属性则用于rehash，即当哈希表需要扩展或收缩时使用。ht是一个包含两个项的数组，每项都指向一个dictht结构，这也是Redis的哈希会有1个dict、2个dictht结构的原因。通常情况下，所有的数据都是存在放dict的ht[0]中，ht[1]只在rehash的时候使用。dict进行rehash操作的时候，将ht[0]中的所有数据rehash到ht[1]中。然后将ht[1]赋值给ht[0]，并清空ht[1]。</p>
<p>因此，Redis中的哈希之所以在dictht和dictEntry结构之外还有一个dict结构，一方面是为了适应不同类型的键值对，另一方面是为了rehash。</p>
<h3 id="（3）编码转换-1"><a href="#（3）编码转换-1" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h3><p>如前所述，Redis中内层的哈希既可能使用哈希表，也可能使用压缩列表。</p>
<p>只有同时满足下面两个条件时，才会使用压缩列表：哈希中元素数量小于512个；哈希中所有键值对的键和值字符串长度都小于64字节。如果有一个条件不满足，则使用哈希表；且编码只可能由压缩列表转化为哈希表，反方向则不可能。</p>
<p>下图展示了Redis内层的哈希编码转换的特点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">172.19.0.2:6380&gt; hset myhash k1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; hset myhash k2 v2</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line">172.19.0.2:6380&gt; hset myhash k4 vvsdfsddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">172.19.0.2:6380&gt; hdel myhash k4</span><br><span class="line">(integer) 1</span><br><span class="line">172.19.0.2:6380&gt; object encoding myhash</span><br><span class="line">&quot;hashtable&quot;</span><br><span class="line">172.19.0.2:6380&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4、集合"><a href="#4、集合" class="headerlink" title="4、集合"></a>4、集合</h3><h4 id="（1）概况-2"><a href="#（1）概况-2" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>集合（set）与列表类似，都是用来保存多个字符串，但集合与列表有两点不同：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。</p>
<p>一个集合中最多可以存储2^32-1个元素；除了支持常规的增删改查，Redis还支持多个集合取交集、并集、差集。</p>
<h4 id="（2）内部编码-1"><a href="#（2）内部编码-1" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>集合的内部编码可以是整数集合（intset）或哈希表（hashtable）。</p>
<p>哈希表前面已经讲过，这里略过不提；需要注意的是，集合在使用哈希表时，值全部被置为null。</p>
<p>整数集合的结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>其中，encoding代表contents中存储内容的类型，虽然contents（存储集合中的元素）是int8_t类型，但实际上其存储的值是int16_t、int32_t或int64_t，具体的类型便是由encoding决定的；length表示元素个数。</p>
<p>整数集合适用于集合所有元素都是整数且集合元素数量较小的时候，与哈希表相比，整数集合的优势在于集中存储，节省空间；同时，虽然对于元素的操作复杂度也由O(n)变为了O(1)，但由于集合数量较少，因此操作的时间并没有明显劣势。</p>
<h4 id="（3）编码转换-2"><a href="#（3）编码转换-2" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>只有同时满足下面两个条件时，集合才会使用整数集合：集合中元素数量小于512个；集合中所有元素都是整数值。如果有一个条件不满足，则使用哈希表；且编码只可能由整数集合转化为哈希表，反方向则不可能。</p>
<h3 id="5、有序集合"><a href="#5、有序集合" class="headerlink" title="5、有序集合"></a>5、有序集合</h3><h4 id="（1）概况-3"><a href="#（1）概况-3" class="headerlink" title="（1）概况"></a>（1）概况</h4><p>有序集合与集合一样，元素都不能重复；但与集合不同的是，有序集合中的元素是有顺序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p>
<h4 id="（2）内部编码-2"><a href="#（2）内部编码-2" class="headerlink" title="（2）内部编码"></a>（2）内部编码</h4><p>有序集合的内部编码可以是压缩列表（ziplist）或跳跃表（skiplist）。ziplist在列表和哈希中都有使用，前面已经讲过，这里略过不提。</p>
<p>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。除了跳跃表，实现有序数据结构的另一种典型实现是平衡树；大多数情况下，跳跃表的效率可以和平衡树媲美，且跳跃表实现比平衡树简单很多，因此redis中选用跳跃表代替平衡树。跳跃表支持平均O(logN)、最坏O(N)的复杂点进行节点查找，并支持顺序操作。Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成：前者用于保存跳跃表信息（如头结点、尾节点、长度等），后者用于表示跳跃表节点。具体结构相对比较复杂，略。</p>
<h4 id="（3）编码转换-3"><a href="#（3）编码转换-3" class="headerlink" title="（3）编码转换"></a>（3）编码转换</h4><p>只有同时满足下面两个条件时，才会使用压缩列表：有序集合中元素数量小于128个；有序集合中所有成员长度都不足64字节。如果有一个条件不满足，则使用跳跃表；且编码只可能由压缩列表转化为跳跃表，反方向则不可能。</p>
<h2 id="五、应用举例"><a href="#五、应用举例" class="headerlink" title="五、应用举例"></a>五、应用举例</h2><h3 id="1、估算Redis内存使用量"><a href="#1、估算Redis内存使用量" class="headerlink" title="1、估算Redis内存使用量"></a>1、估算Redis内存使用量</h3><p>要估算redis中的数据占据的内存大小，需要对redis的内存模型有比较全面的了解，包括前面介绍的hashtable、sds、redisobject、各种对象类型的编码方式等。</p>
<p>下面以最简单的字符串类型来进行说明。</p>
<p>假设有90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（且key和value都不是整数）；下面来估算这90000个键值对所占用的空间。在估算占据空间之前，首先可以判定字符串类型使用的编码方式：embstr。</p>
<p>90000个键值对占据的内存空间主要可以分为两部分：一部分是90000个dictEntry占据的空间；一部分是键值对所需要的bucket空间。</p>
<p>每个dictEntry占据的空间包括：</p>
<p>1) 一个dictEntry，24字节，jemalloc会分配32字节的内存块</p>
<p>2) 一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节的内存块</p>
<p>3) 一个redisObject，16字节，jemalloc会分配16字节的内存块</p>
<p>4) 一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块</p>
<p>5) 综上，一个dictEntry需要32+16+16+16=80个字节。</p>
<p>bucket空间：bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节）。</p>
<p>因此，可以估算出这90000个键值对占据的内存大小为：90000<em>80 + 131072</em>8 = 8248576。</p>
<h3 id="2、优化内存占用"><a href="#2、优化内存占用" class="headerlink" title="2、优化内存占用"></a>2、优化内存占用</h3><p>了解redis的内存模型，对优化redis内存占用有很大帮助。下面介绍几种优化场景。</p>
<p>（1）利用jemalloc特性进行优化</p>
<p>上一小节所讲述的90000个键值便是一个例子。由于jemalloc分配内存时数值是不连续的，因此key/value字符串变化一个字节，可能会引起占用内存很大的变动；在设计时可以利用这一点。</p>
<p>例如，如果key的长度如果是8个字节，则SDS为17字节，jemalloc分配32字节；此时将key长度缩减为7个字节，则SDS为16字节，jemalloc分配16字节；则每个key所占用的空间都可以缩小一半。</p>
<p>（2）使用整型/长整型</p>
<p>如果是整型/长整型，Redis会使用int类型（8字节）存储来代替字符串，可以节省更多空间。因此在可以使用长整型/整型代替字符串的场景下，尽量使用长整型/整型。</p>
<p>（3）共享对象</p>
<p>利用共享对象，可以减少对象的创建（同时减少了redisObject的创建），节省内存空间。目前redis中的共享对象只包括10000个整数（0-9999）；可以通过调整REDIS_SHARED_INTEGERS参数提高共享对象的个数；例如将REDIS_SHARED_INTEGERS调整到20000，则0-19999之间的对象都可以共享。</p>
<p>考虑这样一种场景：论坛网站在redis中存储了每个帖子的浏览数，而这些浏览数绝大多数分布在0-20000之间，这时候通过适当增大REDIS_SHARED_INTEGERS参数，便可以利用共享对象节省内存空间。</p>
<p>（4）避免过度设计</p>
<p>然而需要注意的是，不论是哪种优化场景，都要考虑内存空间与设计复杂度的权衡；而设计复杂度会影响到代码的复杂度、可维护性。</p>
<p>如果数据量较小，那么为了节省内存而使得代码的开发、维护变得更加困难并不划算；还是以前面讲到的90000个键值对为例，实际上节省的内存空间只有几MB。但是如果数据量有几千万甚至上亿，考虑内存的优化就比较必要了。</p>
<h3 id="3、关注内存碎片率"><a href="#3、关注内存碎片率" class="headerlink" title="3、关注内存碎片率"></a>3、关注内存碎片率</h3><p>内存碎片率是一个重要的参数，对redis 内存的优化有重要意义。</p>
<p>如果内存碎片率过高（jemalloc在1.03左右比较正常），说明内存碎片多，内存浪费严重；这时便可以考虑重启redis服务，在内存中对数据进行重排，减少内存碎片。</p>
<p>如果内存碎片率小于1，说明redis内存不足，部分数据使用了虚拟内存（即swap）；由于虚拟内存的存取速度比物理内存差很多（2-3个数量级），此时redis的访问速度可能会变得很慢。因此必须设法增大物理内存（可以增加服务器节点数量，或提高单机内存），或减少redis中的数据。</p>
<p>要减少redis中的数据，除了选用合适的数据类型、利用共享对象等，还有一点是要设置合理的数据回收策略（maxmemory-policy），当内存达到一定量后，根据不同的优先级对内存进行回收。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">分布式之数据库和缓存双写一致性方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-08 17:14:48" itemprop="dateCreated datePublished" datetime="2018-06-08T17:14:48+00:00">2018-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%93%E5%AD%98/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式之数据库和缓存双写一致性方案"><a href="#分布式之数据库和缓存双写一致性方案" class="headerlink" title="分布式之数据库和缓存双写一致性方案"></a>分布式之数据库和缓存双写一致性方案</h1><p>本文参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a>,做的进一步整理笔记。</p>
<p>三种更新策略：</p>
<p>1.先更新数据库，再更新缓存</p>
<p>2.先删除缓存，再更新数据库</p>
<p>3.先更新数据库，再删除缓存</p>
<h2 id="1-先更新数据库，再更新缓存"><a href="#1-先更新数据库，再更新缓存" class="headerlink" title="(1)先更新数据库，再更新缓存"></a>(1)先更新数据库，再更新缓存</h2><p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。</p>
<p>** 原因一（线程安全角度）**</p>
<p>同时有请求A和请求B进行更新操作，那么会出现</p>
<p>（1）线程A更新了数据库</p>
<p>（2）线程B更新了数据库</p>
<p>（3）线程B更新了缓存</p>
<p>（4）线程A更新了缓存</p>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<p>** 原因二（业务场景角度）**</p>
<p>有如下两点：</p>
<p>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。</p>
<p>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<h2 id="2-先删缓存，再更新数据库"><a href="#2-先删缓存，再更新数据库" class="headerlink" title="(2)先删缓存，再更新数据库"></a>(2)先删缓存，再更新数据库</h2><p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求B查询发现缓存不存在</p>
<p>（3）请求B去数据库查询得到旧值</p>
<p>（4）请求B将旧值写入缓存</p>
<p>（5）请求A将新值写入数据库</p>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，如何解决呢？采用延时双删策略</p>
<p>伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void write(string key,object data)</span><br><span class="line">&#123;</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">    db.updateData(data);</span><br><span class="line">    Thread.sleep(1000);</span><br><span class="line">    redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转化为中文描述就是</p>
<p>（1）先淘汰缓存</p>
<p>（2）再写数据库（这两步和原来一样）</p>
<p>（3）休眠1秒，再次淘汰缓存</p>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。</p>
<p>** 那么，这个1秒怎么确定的，具体该休眠多久呢？**</p>
<p>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>** 如果你用了mysql的读写分离架构怎么办？**</p>
<p>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求A将数据写入数据库了</p>
<p>（3）请求B查询缓存发现，缓存没有值</p>
<p>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值</p>
<p>（5）请求B将旧值写入缓存</p>
<p>（6）数据库完成主从同步，从库变为新值</p>
<p>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。</p>
<p>** 采用这种同步淘汰策略，吞吐量降低怎么办？**</p>
<p>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。</p>
<p>** 第二次删除,如果删除失败怎么办？**</p>
<p>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求B查询发现缓存不存在</p>
<p>（3）请求B去数据库查询得到旧值</p>
<p>（4）请求B将旧值写入缓存</p>
<p>（5）请求A将新值写入数据库</p>
<p>（6）请求A试图去删除请求B写入对缓存值，结果失败了。</p>
<p>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。</p>
<p>如何解决呢？<br>具体解决方案，且看对第(3)种更新策略的解析。</p>
<h2 id="3-先更新数据库，再删缓存"><a href="#3-先更新数据库，再删缓存" class="headerlink" title="(3)先更新数据库，再删缓存"></a>(3)先更新数据库，再删缓存</h2><p>** Cache Aside Pattern **</p>
<p>这是最常用最常用的pattern了。其具体逻辑如下：</p>
<p>** 失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</p>
<p>** 命中**：应用程序从cache中取数据，取到后返回。</p>
<p>** 更新**：先把数据存到数据库中，成功后，再让缓存失效。</p>
<p>注意，我们的更新是先更新数据库，成功后，让缓存失效。</p>
<p>** 这种情况不存在并发问题么？**</p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>
<p>（1）缓存刚好失效</p>
<p>（2）请求A查询数据库，得一个旧值</p>
<p>（3）请求B将新值写入数据库</p>
<p>（4）请求B删除缓存</p>
<p>（5）请求A将查到的旧值写入缓存</p>
<p>ok，如果发生上述情况，确实是会发生脏数据。</p>
<p>** 然而，发生这种情况的概率又有多少呢？**</p>
<p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。</p>
<p>** 如何解决上述并发问题？**</p>
<p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p>
<p>** 还有其他造成不一致的原因么？**</p>
<p>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p>
<p>** 如何解决？**</p>
<p>提供一个保障的重试机制即可，这里给出两套方案。</p>
<p>** 方案一：**</p>
<p>流程如下所示</p>
<p><img src="/img/o_update1.png" alt="o_update1.png"></p>
<p>（1）更新数据库数据；</p>
<p>（2）缓存因为种种问题删除失败</p>
<p>（3）将需要删除的key发送至消息队列</p>
<p>（4）自己消费消息，获得需要删除的key</p>
<p>（5）继续重试删除操作，直到成功</p>
<p>** 方案二：**</p>
<p>流程如下所示：</p>
<p><img src="/img/o_update2.png" alt="o_update2.png"></p>
<p>（1）更新数据库数据</p>
<p>（2）数据库会将操作信息写入binlog日志当中</p>
<p>（3）订阅程序提取出所需要的数据以及key</p>
<p>（4）另起一段非业务代码，获得该信息</p>
<p>（5）尝试删除缓存操作，发现删除失败</p>
<p>（6）将这些信息发送至消息队列</p>
<p>（7）重新从消息队列中获得该数据，重试操作。</p>
<p>备注说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。另外，重试机制，可以采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a></p>
<p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=404308725&idx=1&sn=1a25ce76dd1956014ceb8a011855268e&scene=21#wechat_redirect">主从DB与cache一致性</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2018/06/08/Redis%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/06/08/Redis%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Redis详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-08 16:01:34" itemprop="dateCreated datePublished" datetime="2018-06-08T16:01:34+00:00">2018-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-06 11:30:30" itemprop="dateModified" datetime="2021-06-06T11:30:30+00:00">2021-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Redis详解"><a href="#Redis详解" class="headerlink" title="Redis详解"></a>Redis详解</h1><p>本文参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/rjzheng/p/9096228.html">【原创】分布式之redis复习精讲</a>,做的进一步整理笔记。</p>
<h2 id="1、为什么使用redis"><a href="#1、为什么使用redis" class="headerlink" title="1、为什么使用redis"></a>1、为什么使用redis</h2><p>Redis 的优势：</p>
<p>性能极高 – Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。</p>
<p>丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p>
<p>原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。</p>
<p>丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p>
<h2 id="2、使用redis有什么缺点"><a href="#2、使用redis有什么缺点" class="headerlink" title="2、使用redis有什么缺点"></a>2、使用redis有什么缺点</h2><p>分析:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>
<p>回答:主要是四个问题</p>
<p>(一)缓存和数据库双写一致性问题</p>
<p>(二)缓存雪崩问题</p>
<p>(三)缓存击穿问题</p>
<p>(四)缓存的并发竞争问题</p>
<h2 id="3、单线程的redis为什么这么快"><a href="#3、单线程的redis为什么这么快" class="headerlink" title="3、单线程的redis为什么这么快"></a>3、单线程的redis为什么这么快</h2><p>分析:这个问题其实是对redis内部机制的一个考察。</p>
<p>回答:主要是以下三点</p>
<p>(一)纯内存操作</p>
<p>(二)单线程操作，避免了频繁的上下文切换</p>
<p>(三)采用了非阻塞I/O多路复用机制</p>
<h2 id="4、redis的数据类型，以及每种数据类型的使用场景"><a href="#4、redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="4、redis的数据类型，以及每种数据类型的使用场景"></a>4、redis的数据类型，以及每种数据类型的使用场景</h2><p>** 一共五种 **</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。</p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。</p>
<h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作</p>
<h2 id="5、redis的过期策略以及内存淘汰机制"><a href="#5、redis的过期策略以及内存淘汰机制" class="headerlink" title="5、redis的过期策略以及内存淘汰机制"></a>5、redis的过期策略以及内存淘汰机制</h2><p>分析:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>
<p>回答:<br>redis采用的是定期删除+惰性删除策略。</p>
<h3 id="为什么不用定时删除策略"><a href="#为什么不用定时删除策略" class="headerlink" title="为什么不用定时删除策略"></a>为什么不用定时删除策略</h3><p>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>
<h3 id="定期删除-惰性删除是如何工作的呢"><a href="#定期删除-惰性删除是如何工作的呢" class="headerlink" title="定期删除+惰性删除是如何工作的呢"></a>定期删除+惰性删除是如何工作的呢</h3><p>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<h3 id="采用定期删除-惰性删除就没其他问题了么"><a href="#采用定期删除-惰性删除就没其他问题了么" class="headerlink" title="采用定期删除+惰性删除就没其他问题了么"></a>采用定期删除+惰性删除就没其他问题了么</h3><p>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>在redis.conf中有一行配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<p>该配置就是配内存淘汰策略的</p>
<p>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。** 不推荐**</p>
<p>2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。** 推荐使用。**</p>
<p>3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。** 不推荐。**</p>
<p>4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。** 不推荐 **</p>
<p>5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。** 不推荐**</p>
<p>6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。** 不推荐**</p>
<p>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<h2 id="6、redis和数据库双写一致性问题"><a href="#6、redis和数据库双写一致性问题" class="headerlink" title="6、redis和数据库双写一致性问题"></a>6、redis和数据库双写一致性问题</h2><p>分析:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>
<p>回答: 参考 《<a target="_blank" rel="noopener" href="https://syxdevcode.github.io/2018/06/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88/">分布式之数据库和缓存双写一致性方案解析</a>》首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>
<h2 id="7、如何应对缓存穿透和缓存雪崩问题"><a href="#7、如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="7、如何应对缓存穿透和缓存雪崩问题"></a>7、如何应对缓存穿透和缓存雪崩问题</h2><p>分析:一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>
<p>回答:如下所示</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<p>** 解决方案:**</p>
<p>(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</p>
<p>(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</p>
<p>(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p>解决方案:</p>
<p>(一)给缓存的失效时间，加上一个随机值，避免集体失效。</p>
<p>(二)使用互斥锁，但是该方案吞吐量明显下降了。</p>
<p>(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点</p>
<p>I 从缓存A读数据库，有则直接返回</p>
<p>II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</p>
<p>III 更新线程同时更新缓存A和缓存B。</p>
<h2 id="8、如何解决redis的并发竞争问题"><a href="#8、如何解决redis的并发竞争问题" class="headerlink" title="8、如何解决redis的并发竞争问题"></a>8、如何解决redis的并发竞争问题</h2><p>分析:同时有多个子系统去set一个key。s不推荐使用redis的事务机制。因为生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p>
<p>回答:如下所示</p>
<p>(1)如果对这个key操作，不要求顺序</p>
<p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</p>
<p>(2)如果对这个key操作，要求顺序</p>
<p>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.</p>
<p>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure>

<p>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/rjzheng/p/9096228.html">【原创】分布式之redis复习精讲</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">438</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">178</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
