<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/15/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">一致性hash算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 15:15:26" itemprop="dateCreated datePublished" datetime="2020-01-08T15:15:26+00:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一致性 hash 算法 (consistent hashing)</p>
<p>转载自：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sparkliang/article/details/5279393">一致性hash算法 - consistent hashing</a></p>
<p>consistent hashing 算法早在 1997 年就在论文 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/258533.258660">Consistent hashing and random trees</a> 中被提出，目前在 cache 系统中应用越来越广泛；</p>
<h2 id="基本场景"><a href="#基本场景" class="headerlink" title="基本场景"></a>基本场景</h2><p>比如你有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache ；</p>
<p>hash(object)%N</p>
<p>一切都运行正常，再考虑如下的两种情况；</p>
<p>1 一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1) ；</p>
<p>2 由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1) ；</p>
<p>1 和 2 意味着什么？这意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；</p>
<p>再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。</p>
<p>  有什么方法可以改变这个状况呢，这就是 consistent hashing…</p>
<h2 id="hash-算法和单调性"><a href="#hash-算法和单调性" class="headerlink" title="hash 算法和单调性"></a>hash 算法和单调性</h2><p>　　 Hash 算法的一个衡量指标是单调性（ Monotonicity ），定义如下：</p>
<p>　　单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p>
<p>容易看到，上面的简单 hash 算法 hash(object)%N 难以满足单调性要求。</p>
<h2 id="consistent-hashing-算法的原理"><a href="#consistent-hashing-算法的原理" class="headerlink" title="consistent hashing 算法的原理"></a>consistent hashing 算法的原理</h2><p>consistent hashing 是一种 hash 算法，简单的说，在移除 / 添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。</p>
<p>下面就来按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。</p>
<h3 id="环形hash-空间"><a href="#环形hash-空间" class="headerlink" title="环形hash 空间"></a>环形hash 空间</h3><p>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下面图 1 所示的那样。</p>
<p><img src="/img/circle.jfif" alt="circle.jfif"><br>图1 环形 hash 空间</p>
<h3 id="把对象映射到hash-空间"><a href="#把对象映射到hash-空间" class="headerlink" title="把对象映射到hash 空间"></a>把对象映射到hash 空间</h3><p>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布如图 2 所示。</p>
<p>hash(object1) = key1;</p>
<p>… …</p>
<p>hash(object4) = key4;</p>
<p><img src="/img/object.jfif" alt="object.jfif"><br>图2  4个对象的 key 值分布</p>
<h3 id="把cache-映射到hash-空间"><a href="#把cache-映射到hash-空间" class="headerlink" title="把cache 映射到hash 空间"></a>把cache 映射到hash 空间</h3><p>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。</p>
<p>假设当前有 A,B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。</p>
<p>hash(cache A) = key A;</p>
<p>… …</p>
<p>hash(cache C) = key C; </p>
<p><img src="/img/cache.jfif" alt="cache.jfif"><br>图3 cache 和对象的 key 值分布</p>
<p>说到这里，顺便提一下 cache 的 hash 计算，一般的方法可以使用 cache 机器的 IP 地址或者机器名作为 hash 输入。</p>
<h3 id="把对象映射到cache"><a href="#把对象映射到cache" class="headerlink" title="把对象映射到cache"></a>把对象映射到cache</h3><p>现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，接下来要考虑的就是如何将对象映射到 cache 上面了。</p>
<p><font color=#0099ff size=4 face="黑体">在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache ，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这样不就找到了对象和 cache 的映射方法了吗？！</font></p>
<p>依然继续上面的例子（参见图 3 ），那么根据上面的方法，对象 object1 将被存储到 cache A 上； object2 和 object3 对应到 cache C ； object4 对应到 cache B ；</p>
<h2 id="考察cache-的变动"><a href="#考察cache-的变动" class="headerlink" title="考察cache 的变动"></a>考察cache 的变动</h2><p>前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时， cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。</p>
<h3 id="移除-cache"><a href="#移除-cache" class="headerlink" title="移除 cache"></a>移除 cache</h3><p>考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象，也即是本来映射到 cache B 上的那些对象。</p>
<p>因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可；参见图 4 。</p>
<p><img src="/img/remove.jfif" alt="remove.jfif"><br>图4 Cache B 被移除后的 cache 映射</p>
<h3 id="添加-cache"><a href="#添加-cache" class="headerlink" title="添加 cache"></a>添加 cache</h3><p>再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和 object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache （ cache B ）之间的对象（它们是也本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。</p>
<p>因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上；参见图 5 。</p>
<p><img src="/img/add.jfif" alt="add.jfif"><br>图5 添加 cache D 后的映射关系</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：</p>
<p>平衡性</p>
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p>
<p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中， cache A 仅存储了 object1 ，而 cache C 则存储了 object2 、 object3 和 object4 ；分布是很不均衡的。</p>
<p>为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：</p>
<p>“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p>
<p>仍以仅部署 cache A 和 cache C 的情况为例，在图 4 中我们已经看到， cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见图 6 。</p>
<p><img src="/img/virtual.jfif" alt="virtual.jfif"><br>图 6 引入“虚拟节点”后的映射关系</p>
<p>此时，对象到“虚拟节点”的映射关系为：</p>
<p>objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ；</p>
<p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。</p>
<p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如图 7 所示。</p>
<p><img src="/img/map.jfif" alt="map.jfif"><br>图7 查询对象所在 cache</p>
<p>“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为 202.168.14.241 。</p>
<p>引入“虚拟节点”前，计算 cache A 的 hash 值：</p>
<p>Hash(“202.168.14.241”);</p>
<p>引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：</p>
<p>Hash(“202.168.14.241#1”);  // cache A1</p>
<p>Hash(“202.168.14.241#2”);  // cache A2</p>
<h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C#代码实现"></a>C#代码实现</h2><p><a target="_blank" rel="noopener" href="https://github.com/wsq003/consistent-hash">https://github.com/wsq003/consistent-hash</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/08/NET%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80%EF%BC%88IL%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/NET%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80%EF%BC%88IL%EF%BC%89/" class="post-title-link" itemprop="url">.NET中间语言（IL）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 10:10:34" itemprop="dateCreated datePublished" datetime="2020-01-08T10:10:34+00:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MSIL%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">MSIL指令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-tw/previous-versions/dd229210%28v%3dmsdn.10%29">.NET中间语言（IL）1</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-tw/previous-versions/dd229211%28v%3dmsdn.10%29">.NET中间语言（IL）2</a></p>
<p>.NET CLR 和 Java VM 都是堆栈式虚拟机（Stack-Based VM），也就是说，它们的指令集（Instruction Set）都是采用堆栈运算的方式：执行时的数据都是先放在堆栈中，再进行运算。 Java VM 有约 200 个指令（Instruction），每个指令都是 1 byte 的 opcode（操作码），后面接不等数目的参数；.NET CLR 有超过 220 个指令，但是有些指令使用相同的 opcode，所以 opcode 的 数目比指令数略少。 特别注意，.NET 的 opcode 长度并不固定，大部分的 opcode 长度是 1 byte，少部分是 2 byte。</p>
<p>本文章以一个实际的例子，让你了解堆栈式 VM 的运作原理，并对 .NET IL（Intermediate Language）有最基本的领略。</p>
<p>下面是一个简单的 C# 原始码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> j=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> k=<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> answer = i+j+k;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;i+j+k=&quot;</span>+answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将此原始码编译之后，可以得到一个 EXE 档案。 我们可以透过 ILDASM. EXE 来反组译 EXE 以观察 IL。 我将 Main() 的 IL 反组译条列如下，这里共有十八道 IL 指令，有的指令（例如 ldstr 与 box）后面需要接参数，有的指令（例如 ldc.i4.1 与 add）后面不需要接参数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ldc.i4<span class="number">.1</span></span><br><span class="line">stloc<span class="number">.0</span></span><br><span class="line">ldc.i4<span class="number">.2</span></span><br><span class="line">stloc<span class="number">.1</span></span><br><span class="line">ldc.i4<span class="number">.3</span></span><br><span class="line">stloc<span class="number">.2</span></span><br><span class="line">ldloc<span class="number">.0</span></span><br><span class="line">ldloc<span class="number">.1</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line">ldloc<span class="number">.2</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line">stloc<span class="number">.3</span></span><br><span class="line">ldstr      <span class="string">&quot;i+j+k=&quot;</span></span><br><span class="line">ldloc<span class="number">.3</span></span><br><span class="line">box        [mscorlib]System.Int32</span><br><span class="line">call       <span class="built_in">string</span> [mscorlib]System.String::Concat(<span class="built_in">object</span>, <span class="built_in">object</span>)</span><br><span class="line">call       <span class="keyword">void</span> [mscorlib]System.Console::WriteLine(<span class="built_in">string</span>)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>此程序执行时，关键的内存有三种，分别是：</p>
<ul>
<li><p><strong>Managed Heap：</strong>这是动态配置（Dynamic Allocation）的内存，由 Garbage Collector（GC）在执行时自动管理，整个 Process 共享一个 Managed Heap。</p>
</li>
<li><p><strong>Call Stack：</strong>这是由 .NET CLR 在执行时自动管理的内存，每个 Thread 都有自己专属的 Call Stack。 每呼叫一次 method，就会使得 Call Stack 上多了一个 Record Frame；呼叫完毕之后，此 Record Frame 会被丢弃。 一般来说，Record Frame 内纪录着 method 参数（Parameter）、返回地址（Return Address）、以及局部变量（Local Variable）。 Java VM 和 .NET CLR 都是使用 0, 1, 2… 编号的方式来识别局部变量。</p>
</li>
<li><p><strong>Evaluation Stack：</strong>这是由 .NET CLR 在执行时自动管理的内存，每个 Thread 都有自己专属的 Evaluation Stack。 前面所谓的堆栈式虚拟机，指的就是这个堆栈。</p>
</li>
</ul>
<p>后面有一连串的示意图，用来解说在执行时此三种内存的变化。 首先，在进入 Main() 之后，尚未执行任何指令之前，内存的状况如图 1 所示：</p>
<p><img src="/img/dd229210.il_f1(zh-tw,msdn.10).jpg" alt="dd229210.il_f1(zh-tw,msdn.10).jpg"><br>图 1</p>
<p>接着要执行第一道指令 ldc.i4.1。 此指令的意思是：在 Evaluation Stack 置入一个 4 byte 的常数，其值为 1。 执行完此道指令之后，内存的变化如图 2 所示：</p>
<p><img src="/img/dd229210.il_f2(zh-tw,msdn.10).jpg" alt="dd229210.il_f2(zh-tw,msdn.10).jpg"><br>图 2</p>
<p>接着要执行第二道指令 stloc.0。 此指令的意思是：从 Evaluation Stack 取出一个值，放到第 0 号变量（V0）中。 这里的第 0 号变量其实就是原始码中的 i。 执行完此道指令之后，内存的变化如图 3 所示：</p>
<p><img src="/img/dd229210.il_f3(zh-tw,msdn.10).jpg" alt="dd229210.il_f3(zh-tw,msdn.10).jpg"><br>图 3</p>
<p>后面的第三道指令和第五道指令雷同于第一道指令，且第四道指令和第六道指令雷同于第二道指令。 为了节省篇幅，我不在此一一赘述。 提醒大家第 1 号变量（V1）其实就是原始码中的 j，且第 2 号变量（V2）其实就是源码中的 k。 图 4<del>7 分别是执行完第三</del>六道指令之后，内存的变化图：</p>
<p><img src="/img/dd229210.il_f4(zh-tw,msdn.10).jpg" alt="dd229210.il_f4(zh-tw,msdn.10).jpg"><br>图 4</p>
<p><img src="/img/dd229210.il_f5(zh-tw,msdn.10).jpg" alt="dd229210.il_f5(zh-tw,msdn.10).jpg"><br>图 5</p>
<p><img src="/img/dd229210.il_f6(zh-tw,msdn.10).jpg" alt="dd229210.il_f6(zh-tw,msdn.10).jpg"><br>图 6</p>
<p><img src="/img/dd229210.il_f7(zh-tw,msdn.10).jpg" alt="dd229210.il_f7(zh-tw,msdn.10).jpg"><br>图 7</p>
<p>接着要执行第七道指令 ldloc.0 以及第八道指令 ldloc.1：分别将 V0（也就是 i）和 V1（也就是 j）的值放到 Evaluation Stack，这是相加前的准备动作。 图 8 与图 9 分别是执行完第七、第八道指令之后，内存的变化图：</p>
<p><img src="/img/dd229210.il_f8(zh-tw,msdn.10).jpg" alt="dd229210.il_f8(zh-tw,msdn.10).jpg"><br>图 8</p>
<p><img src="/img/dd229210.il_f9(zh-tw,msdn.10).jpg" alt="dd229210.il_f9(zh-tw,msdn.10).jpg"><br>图 9</p>
<p>接着要执行第九道指令 add。 此指令的意思是：从 Evaluation Stack 取出两个值（也就是 i 和 j），相加之后将结果放回 Evaluation Stack 中。 执行完此道指令之后，内存的变化如图 10 所示：</p>
<p><img src="/img/dd229210.il_f10(zh-tw,msdn.10).jpg" alt="dd229210.il_f10(zh-tw,msdn.10).jpg"><br>图 10</p>
<p>接着要执行第十道指令 ldloc.2。 此指令的意思是：分别将 V2（也就是 k）的值放到 Evaluation Stack，这是相加前的准备动作。 执行完此道指令之后，内存的变化如图 11 所示：</p>
<p><img src="/img/dd229211.il_f11(zh-tw,msdn.10).jpg" alt="dd229211.il_f11(zh-tw,msdn.10).jpg"><br>图 11</p>
<p>接着要执行第十一道指令 add。 从 Evaluation Stack 取出两个值，相加之后将结果放回 Evaluation Stack 中，此为 i+j+k 的值。 执行完此道指令之后，内存的变化如图 12 所示：</p>
<p><img src="/img/dd229211.il_f12(zh-tw,msdn.10).jpg" alt="dd229211.il_f12(zh-tw,msdn.10).jpg"><br>图 12</p>
<p>接着要执行第十二道指令 stloc.3。 从 Evaluation Stack 取出一个值，放到第 3 号变量（V3）中。 这里的第3号变量其实就是原始码中的 answer。 执行完此道指令之后，内存的变化如图 13 所示：</p>
<p><img src="/img/dd229211.il_f13(zh-tw,msdn.10).jpg" alt="dd229211.il_f13(zh-tw,msdn.10).jpg"><br>图 13</p>
<p>接着要执行第十三道指令 ldstr “i+j+k=”。 此指令的意思是：将 “i+j+k=” 的 Reference 放进 Evaluation Stack。 执行完此道指令之后，内存的变化如图 14 所示：</p>
<p><img src="/img/dd229211.il_f14(zh-tw,msdn.10).jpg" alt="dd229211.il_f14(zh-tw,msdn.10).jpg"><br>图 14</p>
<p>接着要执行第十四道指令 ldloc.3。 将 V3 的值放进 Evaluation Stack。 执行完此道指令之后，内存的变化如图 15 所示：</p>
<p><img src="/img/dd229211.il_f15(zh-tw,msdn.10).jpg" alt="dd229211.il_f15(zh-tw,msdn.10).jpg"><br>图 15</p>
<p>接着要执行第十五道指令 box [mscorlib]System.Int32。 此指令的意思是：从 Evaluation Stack 中取出一个值，将此 Value Type 包装（box）成为 Reference Type。 执行完此道指令之后，内存的变化如图 16 所示：</p>
<p><img src="/img/dd229211.il_f16(zh-tw,msdn.10).jpg" alt="dd229211.il_f16(zh-tw,msdn.10).jpg"><br>图 16</p>
<p>接着要执行第十六道指令 call string [mscorlib] System.String::Concat(object, object)。 此指令的意思是：从 Evaluation Stack 中取出两个值，此二值皆为 Reference Type，下面的值当作第一个参数，上面的值当作第二个参数，呼叫 mscorlib.dll 所提供的 System.String.Concat() method 来将此二参数进行字符串接合（String Concatenation），将接合出来的新字符串放在 Managed Heap，将其 Reference 放进 Evaluation Stack。 值得注意的是：由于 System.String.Concat() 是 static method，所以此处使用的指令是 call，而非 callvirt（呼叫虚拟）。 执行完此道指令之后，内存的变化如图 17 所示：</p>
<p><img src="/img/dd229211.il_f17(zh-tw,msdn.10).jpg" alt="dd229211.il_f17(zh-tw,msdn.10).jpg"><br>图 17</p>
<p>请注意：此时 Managed Heap 中的 Int32(6) 以及 String(“i+j+k=”) 已经不再被参考到，所以变成垃圾，等待 GC 的回收。</p>
<p>接着要执行第十七道指令 call void [mscorlib] System.Console::WriteLine(string)。 此指令的意思是：从 Evaluation Stack 中取出一个值，此值为 Reference Type，将此值当作参数，呼叫 mscorlib.dll 所提供的 System.Console.WriteLine() method 来将此字符串显示在 Console 窗口上。 System.Console.WriteLine() 也是 static method。 执行完此道指令之后，内存的变化如图 18 所示：</p>
<p><img src="/img/dd229211.il_f18(zh-tw,msdn.10).jpg" alt="dd229211.il_f18(zh-tw,msdn.10).jpg"><br>图 18</p>
<p>接着要执行第十八道指令 ret。 此指令的意思是：结束此次呼叫（也就是 Main 的呼叫）。 此时会检查 Evaluation Stack 内剩下的数据，由于 Main() 宣告不需要传出值（void），所以 Evaluation Stack 内必须是空的，本范例符合这样的情况，所以此时可以顺利结束此次呼叫。 而 Main 的呼叫一结束，程序也随之结束。 执行完此道指令之后（且在程序结束前），内存的变化如图 19 所示：</p>
<p><img src="/img/dd229211.il_f19(zh-tw,msdn.10).jpg" alt="dd229211.il_f19(zh-tw,msdn.10).jpg"><br>图 19</p>
<p>透过此范例，读者应该可以对于 IL 有最基本的认识。 对 IL 感兴趣的读者应该自行阅读 Serge Lidin 所著的《Inside Microsoft .NET IL Assembler》（Microsoft Press 出版）。 我认为：熟知 IL 每道指令的作用，是 .NET 程序员必备的知识。.NET 程序员可以不会用 IL Assembly 写程序，但是至少要看得懂 ILDASM 反组译出来的 IL 组合码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/12/31/vs%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/vs%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">vs插件整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-31 09:35:22" itemprop="dateCreated datePublished" datetime="2019-12-31T09:35:22+00:00">2019-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8F%92%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">插件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="codeMaid"><a href="#codeMaid" class="headerlink" title="codeMaid"></a>codeMaid</h2><p>CodeMaid快速整理代码文件，规范你的代码，提高代码阅读体验。</p>
<h2 id="Markdown-Editor"><a href="#Markdown-Editor" class="headerlink" title="Markdown Editor"></a>Markdown Editor</h2><p>Markdown Editor一个在visual studio 中的markdown工具<br>功能齐全的Markdown编辑器，具有实时预览和语法突出显示功能。支持GitHub风格的Markdown。</p>
<h2 id="JSON-Viewer"><a href="#JSON-Viewer" class="headerlink" title="JSON Viewer"></a>JSON Viewer</h2><p>JSON Viewer用于显示和处理JSON数据。</p>
<h2 id="Output-enhancer"><a href="#Output-enhancer" class="headerlink" title="Output enhancer"></a>Output enhancer</h2><p>Output enhancer将output窗口的输出的文字添加样式值得赶紧试试的插件，给输出内容着色。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SUtgV3U35yNFUjzl0Z-ypA">收藏！推荐12个超实用的Visual Studio插件</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/12/25/%E8%AE%A4%E8%AF%8632%E4%BD%8D64%E4%BD%8DWindows%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/25/%E8%AE%A4%E8%AF%8632%E4%BD%8D64%E4%BD%8DWindows%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">认识32位64位Windows系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-25 18:15:04" itemprop="dateCreated datePublished" datetime="2019-12-25T18:15:04+00:00">2019-12-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">Windows系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Wow64"><a href="#Wow64" class="headerlink" title="Wow64"></a>Wow64</h2><p>Wow64，全称是32bit Windows On 64bit Windows（64位Windows上的32位Windows）。</p>
<p>Windows系统的主要系统文件都是放在一个叫做System32的文件夹中的。为了能同时放下两套系统文件，Windows会在64位的系统上，增加了一个文件夹，叫SysWow64。</p>
<p>总结：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SysWow64文件夹，是<span class="number">64</span>位Windows，用来存放<span class="number">32</span>位Windows系统文件的地方，而System32文件夹，是用来存放<span class="number">64</span>位程序文件的地方。</span><br><span class="line">当<span class="number">32</span>位程序加载System32文件夹中的dll时，操作系统会自动映射到SysWow64文件夹中的对应的文件。</span><br><span class="line">只要<span class="number">32</span>位程序访问System32文件夹，无论是加载dll，还是读取文本信息，都会被映射到SysWow64文件夹</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blogs.msdn.microsoft.com/tianlin/2011/10/26/syswow64/">什么是SysWow64</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hbccdf/p/dllchecktoolandsyswow64.html">dll文件32位64位检测工具以及Windows文件夹SysWow64的坑</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/asxinyu/p/dotnet_api_alibaba_ons_service_MQ.html">【结果很简单,过程很艰辛】记阿里云Ons消息队列服务.NET接口填坑过程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hbccdf/p/3486565.html">玩转Windows服务系列——Debug、Release版本的注册和卸载，及其原理</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/sysinternals/">Windows Sysinternals</a></p>
<p><a target="_blank" rel="noopener" href="https://live.sysinternals.com/">live.sysinternals.com</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">分布式事务整理笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-20 13:41:22" itemprop="dateCreated datePublished" datetime="2019-12-20T13:41:22+00:00">2019-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">分布式事务</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h2><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种 “要么什么都不做，要么做全套（All or Nothing）” 机制。</p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：</p>
<p>1，为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>2，当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</p>
<p>数据库事务拥有以下四个特性，ACID 特性。</p>
<ul>
<li><p>A 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p>C 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p>
</li>
<li><p>I 隔离性（Isolation）或独立性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p>
</li>
<li><p>D 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p>
</li>
</ul>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的 分布式系统 的不同节点之上。</p>
<p>在应用程序只部署在一台计算机，数据库只部署在一台计算机的情况下，事务的ACID四个特性很容易全部满足。</p>
<p>但是单机的处理能力很容易达到上限，此时必须使用分布式系统。在分布式环境下，应用程序可能部署在多台计算机，并且可能有多个不同的应用程序参与到同一个事务中；数据库也可能部署在多台计算机，并且多个不同的数据库可能会参与到同一个事务中。一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p>
<h2 id="分布式事务的基础"><a href="#分布式事务的基础" class="headerlink" title="分布式事务的基础"></a>分布式事务的基础</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP定理，又被叫作布鲁尔定理。</p>
<ul>
<li><p>C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</p>
</li>
<li><p>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。</p>
</li>
<li><p>P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。</p>
</li>
</ul>
<p>分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。</p>
<p>对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。</p>
<p>对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。</p>
<p>CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。</p>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对CAP中AP的一个扩展。</p>
<ul>
<li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</li>
<li>软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。</li>
<li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。</li>
</ul>
<p>BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p>
<h2 id="分布式事务方案"><a href="#分布式事务方案" class="headerlink" title="分布式事务方案"></a>分布式事务方案</h2><h3 id="基于XA协议的2PC-2阶段提交"><a href="#基于XA协议的2PC-2阶段提交" class="headerlink" title="基于XA协议的2PC(2阶段提交)"></a>基于XA协议的2PC(2阶段提交)</h3><p>XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。XA实现分布式事务的原理如下：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191221173353.png" alt="QQ截图20191221173353.png"></p>
<p>两阶段提交，是实现分布式事务的成熟方案。</p>
<ul>
<li>第一阶段是表决阶段，事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li>
<li>第二阶段是执行阶段，事务协调器要求每个数据库提交数据，或者回滚数据。</li>
</ul>
<p>优点： 尽量保证了数据的强一致，实现成本较低，XA目前在商业数据库支持的比较理想，在MySQL（MySQL5.5开始支持）数据库中支持的不太理想，mysql的XA实现，没有记录prepare阶段日志，主备切换回导致主库与备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得非常狭隘。</p>
<p>缺点:</p>
<ul>
<li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li>
<li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li>
<li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li>
</ul>
<p>总的来说，XA协议比较简单，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。XA协议已在业界成熟运行数十年，但目前它在互联网海量流量的应用场景中，吞吐量这个瓶颈变得十分致命，因此很少被用到。</p>
<p>两阶段提交可以满足ACID，但代价是吞吐量。例如，数据库需要频繁地对资源上锁等等。而且更致命的是，资源被锁住的时间相对较长—-在第一阶段即需要上锁，第二阶段才能解锁，依赖于所有分支的最慢者—-这期间没有任何人可以对该资源进行修改。</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>TCC（Try、Confirm、Cancel）是两阶段提交的一个变种。TCC提供了一个框架，需要应用程序按照该框架编程，将业务逻辑的每个分支都分为Try、Confirm、Cancel三个操作集。TCC让应用程序自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。</p>
<p>TCC事务机制相比于上面介绍的XA，解决了其几个缺点:</p>
<ul>
<li>1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</li>
<li>2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</li>
<li>3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性</li>
</ul>
<p>流程图：</p>
<p><img src="/img/1010726-20191031060901955-1099206419.png" alt="1010726-20191031060901955-1099206419.png"></p>
<ul>
<li><p>Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</p>
</li>
<li><p>Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</p>
</li>
<li><p>Cancel阶段：取消执行，释放Try阶段预留的业务资源</p>
</li>
</ul>
<p>Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</p>
<p>以一个典型的淘宝订单为例，按照TCC框架，应用需要在Try阶段将商品的库存减去，将买家支付宝账户中的相应金额扣掉，在临时表中记录下商品的数量，订单的金额等信息；另外再编写Confirm的逻辑，即在临时表中删除相关记录，生成订单，告知CRM、物流等系统，等等；以及Cancel逻辑，即恢复库存和买家账户金额，删除临时表相关记录。</p>
<p>很明显，最终一致性部分牺牲了ACID中的C和I，但它带来了可观的收益：资源不再需要长时间上锁，极大地提高了吞吐量。</p>
<p>最终一致性在互联网应用场景中被广泛用做吞吐量和ACID的妥协点。</p>
<p>在前面TCC的例子。在这个流程中，商品库存和买家余额都没有被锁住，因此可以得到很高的吞吐量。但在交易进行中，商品库存和买家余额的变化就已经被外界感知到，而物流系统却可能还没有相应的记录，此时数据是不一致的，但最终（无论是Confirm阶段结束后，还是Cancel阶段结束后）它们会一致。</p>
<h3 id="TXC"><a href="#TXC" class="headerlink" title="TXC"></a>TXC</h3><p>TXC(Taobao Transaction Constructor)是阿里巴巴的一个分布式事务中间件，它可以通过极少的代码侵入，实现分布式事务。</p>
<p>在大部分情况下，应用只需要引入TXC Client的jar包，进行几项简单配置，以及以行计的代码改造，即可轻松保证分布式数据一致性。</p>
<p>TXC同时提供了丰富的编程和配置策略，以适应各种长尾的应用需求。</p>
<p>实现原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快走信息和创建锁。当需要回滚的时候就采用这些记录数据回滚数据库，目前锁实现依赖redis分布式锁控制。</p>
<p>TXC的目标应用场景是：解决在分布式应用中，多条数据库记录被修改而可能带来的一致性问题；该分布式应用可以接受最终一致性；该应用的事务改造对工作量有较严格的限制。</p>
<h3 id="LCN"><a href="#LCN" class="headerlink" title="LCN"></a>LCN</h3><p>原理：LCN模式是通过代理Connection的方式实现对本地事务的操作，然后在由TxManager统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由LCN连接池管理。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.txlcn.org/zh-cn/index.html">TX-LCN</a></p>
<h3 id="本地消息表-异步确保"><a href="#本地消息表-异步确保" class="headerlink" title="本地消息表 (异步确保)"></a>本地消息表 (异步确保)</h3><p>本地消息表是国外的 ebay 搞出来的一套方案，如图所示：</p>
<p><img src="/img/1010726-20191031061916148-594757786.png" alt="1010726-20191031061916148-594757786.png"></p>
<p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p>
<p>我们首先需要在本地数据新建一张本地消息表，然后我们必须还要一个MQ（不一定是mq，但必须是类似的中间件）。</p>
<p>这个表应该包括这些字段： id, biz_id, biz_type, msg, msg_result, msg_desc,atime,try_count。分别表示uuid，业务id，业务类型，消息内容，消息结果（成功或失败），消息描述，创建时间，重试次数， 其中biz_id，msg_desc字段是可选的。</p>
<p>实现思路为：</p>
<ul>
<li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li>
<li>接着 A 系统将这个消息发送到 MQ 中去；</li>
<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；</li>
<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li>
<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li>
<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。<br>　　<br>这个方案严重依赖于数据库的消息表来管理事务，这样在高并发的情况下难以扩展，同时要在数据库中额外添加一个与实际业务无关的消息表来实现分布式事务，繁琐。</li>
</ul>
<p>本地消息表核心是把大事务转变为小事务。</p>
<p>例如，用100元去买一瓶水的例子。</p>
<ul>
<li>1.当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。</li>
<li>2.这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。</li>
<li>3.商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。</li>
<li>4.针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。</li>
</ul>
<p>本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。</p>
<h3 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h3><p>直接基于 MQ 来实现事务，不再用本地的消息表。所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部。</p>
<p><img src="/img/20170320083222287.png" alt="20170320083222287.png"></p>
<p>基本流程如下:</p>
<ul>
<li>1、A系统向消息中间件发送一条预备消息</li>
<li>2、消息中间件保存预备消息并返回成功</li>
<li>3、A执行本地事务</li>
<li>4、A发送提交消息给消息中间件</li>
</ul>
<p>通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：</p>
<ul>
<li>步骤一出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤二出错，则整个事务失败，不会执行A的本地操作</li>
<li>步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息</li>
<li>步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务</li>
</ul>
<p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。</p>
<p><img src="/img/20170320083228100.png" alt="20170320083228100.png"></p>
<p>上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失。</p>
<p><img src="/img/164d77389afdfd6b.png" alt="164d77389afdfd6b.png"></p>
<h3 id="Saga事务"><a href="#Saga事务" class="headerlink" title="Saga事务"></a>Saga事务</h3><p>SAGA可以看做一个异步的、利用队列实现的补偿事务。</p>
<p>其适用于无需马上返回业务发起方最终状态的场景，例如：你的请求已提交，请稍后查询或留意通知 之类。</p>
<p>Saga是30年前一篇数据库伦理提到的一个概念。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<p>saga的提出，最早是为了解决可能会长时间运行的分布式事务（long-running process）的问题。所谓long-running的分布式事务，是指那些企业业务流程，需要跨应用、跨企业来完成某个事务，甚至在事务流程中还需要有手工操作的参与，这类事务的完成时间可能以分计，以小时计，甚至可能以天计。这类事务如果按照事务的ACID的要求去设计，势必造成系统的可用性大大的降低。试想一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务，B的事务需要人工参与，所以处理时间可能很长。如果按照ACID的原则，要保持事务的隔离性、一致性，服务器A中发起的事务中使用到的事务资源将会被锁定，不允许其他应用访问到事务过程中的中间结果，直到整个事务被提交或者回滚。这就造成事务A中的资源被长时间锁定，系统的可用性将不可接受。</p>
<p>而saga，则是一种基于补偿的消息驱动的用于解决long-running process的一种解决方案。目标是为了在确保系统高可用的前提下尽量确保数据的一致性。还是上面的例子，如果用saga来实现，那就是这样的流程：服务器A的事务先执行，如果执行顺利，那么事务A就先行提交；如果提交成功，那么就开始执行事务B，如果事务B也执行顺利，则事务B也提交，整个事务就算完成。但是如果事务B执行失败，那事务B本身需要回滚，这时因为事务A已经提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态。这样的基于消息驱动的实现思路，就是saga。我们可以看出，saga是牺牲了数据的强一致性，仅仅实现了最终一致性，但是提高了系统整体的可用性。</p>
<p>Saga的组成：</p>
<p>每个Saga由一系列sub-transaction Ti 组成<br>每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。<br>可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。</p>
<p>Saga的执行顺序有两种：</p>
<ul>
<li>T1, T2, T3, …, Tn</li>
<li>T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n</li>
</ul>
<p>Saga定义了两种恢复策略：</p>
<ul>
<li>向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。</li>
<li>向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。</li>
</ul>
<p>这里要注意的是，在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。</p>
<p>拿100元买一瓶水的例子来说，这里定义:</p>
<p>T1=扣100元 T2=给用户加一瓶水 T3=减库存一瓶水<br>C1=加100元 C2=给用户减一瓶水 C3=给库存加一瓶水</p>
<p>我们一次进行T1,T2，T3如果发生问题，就执行发生问题的C操作的反向。</p>
<p>上面说到的隔离性的问题会出现在，如果执行到T3这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。这就是事务之间没有隔离性的问题</p>
<p>可以看见saga模式没有隔离性的影响还是较大，可以参照华为的解决方案:从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源。也可以在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。</p>
<p>具体实例:可以参考华为的 servicecomb 。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/balavatasky/p/6101345.html">saga中的saga（A Saga on Sagas）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyesx/p/9697817.html">如何选择分布式事务形态（TCC，SAGA，2PC，补偿，基于消息最终一致性等等）</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b5a0bf9f265da0f6523913b">再有人问你分布式事务，把这篇扔给他</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sky-chen/p/10342207.html">TX-LCN分布式事务Demo实战</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38110132/article/details/77043580">TXC分布式事务简介</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38110132/article/details/76994165">分布式事务的解决方案</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/72011">GTS让分布式事务简单高效</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangyu666/p/8522547.html">微服务架构下分布式事务解决方案——阿里GTS</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/netfocus/p/3149156.html">ENode 1.0 - Saga的思想与实现</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/25/CSharp-ValueTask%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/25/CSharp-ValueTask%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">CSharp-ValueTask解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-25 14:28:13" itemprop="dateCreated datePublished" datetime="2019-11-25T14:28:13+00:00">2019-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:37" itemprop="dateModified" datetime="2021-06-04T01:00:37+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/net%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C/" itemprop="url" rel="index"><span itemprop="name">.net异步与并行</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="结构vs类，栈vs堆"><a href="#结构vs类，栈vs堆" class="headerlink" title="结构vs类，栈vs堆"></a>结构vs类，栈vs堆</h2><p>&emsp;&emsp;在托管.NET世界中，您应该关注两个内存区域：栈和堆。堆是在其中分配所有对象的托管内存（无论何时调用 <code>new YourClass</code>）。重要的方面是它与任何线程都不相关或没有连接。一个线程可以分配一个对象并将其传递给另一线程。只要垃圾收集器没有收集该对象，该对象就会在堆上。</p>
<p>&emsp;&emsp;栈以不同的方式工作。它被分配给特定的线程（每个线程的堆栈大小有限）。栈具有框架，可用于分配一些内存，例如用于在调用过程中创建并分配给变量的结构值，例如，通过调用<code>Guid.NewGuid()</code>。</p>
<p>&emsp;&emsp;堆分配的内存可用于在线程之间传输某些数据。由于栈是分配给特定线程的，因此不能用于传输某些数据。另一方面，如果您要分配少量内存，则堆栈将更快一些，因为它是线程本地的，并且不会陷入启动垃圾收集器等缓慢的路径中。</p>
<h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p><code>Task</code> 在 .NET Framework 4 中 <code>System.Threading.Tasks</code> 命名空间被引入，在 C#5 以及 .NET Framwrok 4.5 中的异步编程模式引入了 <code>async/await</code>。</p>
<p><code>Task</code> 的核心就是 <code>promise</code>，它表示最终完成的一些操作。当初始化一个操作时，返回一个 <code>Task</code>，当操作完成时，<code>Task</code> 会完成。</p>
<p>特点：</p>
<p><code>Task</code> 很灵活，并且有很多好处。例如你可以通过多个消费者并行等待多次。你可以存储一个到字典中，以便后面的任意数量的消费者等待，它允许为异步结果像缓存一样使用。如果场景需要，你可以阻塞一个等待完成。并且你可以在这些任务上编写和使用各种操作（就像组合器），例如 WhenAny 操作，它可以异步等待第一个操作完成。</p>
<p>然而，这种灵活性对于大多数情况下是不需要的：仅仅只是调用异步操作并且等待结果：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TResult result = <span class="keyword">await</span> SomeOperationAsync();</span><br><span class="line">UseResult(result);</span><br></pre></td></tr></table></figure>

<p>副作用:</p>
<p>Task 是一个类。作为一个类，就是说任意操作创建一个 Task 都会分配一个对象，越来越多的对象都会被分配，所以 GC 操作也会越来越频繁，也就会消耗越来越多的资源，本来它应该是去做其他事的。</p>
<h2 id="ValueTask"><a href="#ValueTask" class="headerlink" title="ValueTask"></a>ValueTask</h2><p>.NET CORE 2.0 引入了一个新类型 <code>ValueTask&lt;TResult&gt;</code>，在 <code>System.Threading.Tasks.Extensions</code> 命名空间中。<code>ValueTask&lt;TResult&gt;</code> 作为结构体引入的，它是 <code>TResult</code> 或 <code>Task&lt;TResult&gt;</code> 包装器。</p>
<p>实例可以等待或 <code>Task&lt;TResult&gt;</code> 使用 <code>AsTask</code> 转换为。 <code>ValueTask&lt;TResult&gt;</code> 实例仅可等待一次, 并且在实例完成之前, 使用者可能不会调用 <code>GetAwaiter()</code>。</p>
<p>永远不应对 <code>ValueTask&lt;TResult&gt;</code>实例执行以下操作:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">等待实例多次。</span><br><span class="line">多次AsTask调用。</span><br><span class="line">使用/操作未完成/使用多次 .Result.GetAwaiter().GetResult()</span><br><span class="line">使用多种方法来使用此实例。</span><br></pre></td></tr></table></figure>

<p>如果执行上述任一操作, 则结果是不确定的。</p>
<h3 id="同步完成-synchronous-completion"><a href="#同步完成-synchronous-completion" class="headerlink" title="同步完成 (synchronous completion)"></a>同步完成 (synchronous completion)</h3><p>它能从异步方法返回并且如果这个方法同步成功完成，不需要分配任何内存：只简单的初始化这个 <code>ValueTask&lt;TResult&gt;</code> 结构体，它返回 <code>TResult</code>。</p>
<p>只有当该方法异步完成时，<code>Task&lt;TResult&gt;</code> 才需要进行分配， 创建包装该 <code>ValueTask &lt;TResult&gt;</code> 的实例（以最小化 <code>ValueTask &lt;TResult&gt;</code>的大小，并用于优化成功路径，异步方法未处理的异常故障也将分配一个 <code>Task&lt;TResult&gt;</code>，所以 <code>ValueTask&lt;TResult&gt;</code> 可以简单地包裹该 <code>Task&lt;TResult&gt;</code>, 而并不是 随身携带附加字段以存储异常）。</p>
<h3 id="异步完成-asynchronous-completion"><a href="#异步完成-asynchronous-completion" class="headerlink" title="异步完成 (asynchronous completion)"></a>异步完成 (asynchronous completion)</h3><p>在.NET Core 2.1，引入 <code>IValueTaskSource&lt;TResult&gt;</code> 支持池化和重用。</p>
<p>.NET Core 2.1为 <code>ValueTask</code> 添加了另一个构造函数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> ValueTask&lt;TResult&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValueTask</span>(<span class="params">IValueTaskSource&lt;TResult&gt; source, <span class="built_in">short</span> token</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>token：令牌参数，该值确保将 <code>IValueTaskSource</code> 返回到池后不会使用 <code>ValueTask</code>。有效地，此令牌值将传递到 <code>IValueTaskSource</code> 实现的每个方法，该方法能够检查调用者是否滥用 <code>ValueTask</code>。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IValueTaskSource</span>&lt;<span class="keyword">out</span> <span class="title">TResult</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ValueTaskSourceStatus <span class="title">GetStatus</span>(<span class="params"><span class="built_in">short</span> token</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params">Action&lt;<span class="built_in">object</span>&gt; continuation, <span class="built_in">object</span> state, <span class="built_in">short</span> token, ValueTaskSourceOnCompletedFlags flags</span>)</span>;</span><br><span class="line">    <span class="function">TResult <span class="title">GetResult</span>(<span class="params"><span class="built_in">short</span> token</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参与：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.valuetask-1?view=netcore-3.0">ValueTask<TResult> 结构</a></p>
<p><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/">Understanding the Whys, Whats, and Whens of ValueTask</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.scooletz.com/2018/05/14/task-async-await-valuetask-ivaluetasksource-and-how-to-keep-your-sanity-in-modern-net-world/">Task, Async Await, ValueTask, IValueTaskSource and how to keep your sanity in modern .NET world</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/22/Actor%E6%A8%A1%E5%9E%8B%E5%92%8CCSP%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/Actor%E6%A8%A1%E5%9E%8B%E5%92%8CCSP%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Actor模型和CSP模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-22 14:23:02" itemprop="dateCreated datePublished" datetime="2019-11-22T14:23:02+00:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:37" itemprop="dateModified" datetime="2021-06-04T01:00:37+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">并发模型</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="传统三层无状态架构的缺陷"><a href="#传统三层无状态架构的缺陷" class="headerlink" title="传统三层无状态架构的缺陷"></a>传统三层无状态架构的缺陷</h2><p>三层架构包括表示层、业务逻辑层(中间层)、数据访问层（存储层）</p>
<p>　　传统的三层体系结构具有无状态前端、无状态的中间层和存储层，由于存储层的延迟和吞吐量限制，其可扩展性有限（存储层常常会成为系统的瓶颈），因此必须针对每个请求进行咨询。这就意味着整套系统也会因为存储层的限制而变得低效。通常的做法是在中间层与存储层中间加一层缓存逻辑出来，以提升系统性能，但是很快就会遇到存储层与缓存层的数据一致性问题，为了防止缓存项的并发更新导致不一致，应用程序或缓存管理器必须实现并发控制协议。这无疑为开发人员和运维人员增加了额外的工作量。</p>
<p>Actor模型和CSP模型的出现，解决了传统三层架构的缺陷。</p>
<h2 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h2><h3 id="Actor模型简介"><a href="#Actor模型简介" class="headerlink" title="Actor模型简介"></a>Actor模型简介</h3><p>　　actor模型最早被1973年的“A Universal Modular ACTOR Formalism for Artificial Intelligence”引入，作为人工智能研究中的一种计算方法。它的最初目标是用一种能安全地跨工作站并发分布的通信方式来建模并行计算。这篇文章几乎没有假设实现细节，而是定义了一种高级消息传递通信模型。actor模型的四个主要变体：经典actor模型、基于进程的actor模型、通信事件循环模型、以及活动对象模型。</p>
<p>　　有些健壮的工业级actor系统正被用于赋能大规模可伸缩分布式系统，主要案例：例如Akka被用于服务PayPal的十亿级的事务，Erlang被用于为WhatsApp的上亿用户发送消息，而Orleans被用于服务Halo4的数百万玩家。</p>
<p>　　Actor模型作为一种用于处理并发计算的数学概念模型，它定义了系统组件该如何表现，以及如何与其他组件交互的一些通用规则。它将Actor对象用作并发计算的基本单元，它也是一种重要的软件设计思想，它在架构、设计、实现以及组件之间的消息传递方面有着非常好的应用，也更好的发挥了多核计算机的潜力。该思想与我们经常用到的面向对象语言的思想很类似：一个对象接受消息（方法调用）然后依据消息数据进行计算。主要的不同点在于，actor之间完全独立，没有共享内存。值得注意的是，一个actor维持的私有状态从来不会被其他actor改变，而只会通过接受消息，自己改变自己。通过创建新的Actor对象，可以在计算操作的生命周期中以抽象方式提高系统的分布性。</p>
<p>　　Actor模型允许建立一个有状态的中间层，其内存级的读写性能和特定于相关领域的业务实体行为，确保了系统的高性能以及数据的一致性。Actor模型天然的拥有着面向对象的程序设计功能，在实践中我们应该把主要精力放到组件之间的消息传递，而不是对象的属性和内部行为。</p>
<p>一个actor并不能成为actor模型。actor是系统的组件，actor模型认为系统所有的组件都是actor，都有地址，actor通过这些地址进行异步通信。</p>
<p><img src="/img/260879-325a351b6a349d3c.png" alt="260879-325a351b6a349d3c.png"></p>
<h3 id="经典actor模型"><a href="#经典actor模型" class="headerlink" title="经典actor模型"></a>经典actor模型</h3><p>经典actor模型，保持了在隔离的计算单元和状态单元之间通过消息来做异步通信的思想，主要特点如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">异步通信：使消息就像从一个Actor对象传输到了另一个Actor对象</span><br><span class="line">状态机：Actor模型支持有限状态机</span><br><span class="line">独立性：多个Actor对象之间不会共享状态</span><br><span class="line">无锁的并发处理：由于Actor不会共享状态，且在同一时刻只处理一条消息，因而无需使用锁策略，这极大的提高了Actor系统的性能</span><br><span class="line">并行性：当顶级Actor将任务分拆后发送给多个下级Actor后，可以使用Actor模型的并行处理方式</span><br><span class="line">位置透明：可以使用抽象引用表示Actor对象的地址</span><br><span class="line">Future/Promise对象：这是对异步操作的发送与接收方式，以表示异步操作的完成结果</span><br></pre></td></tr></table></figure>

<p>当一个actor接收消息时，通常做以下三件事情：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create：用一种行为的描述和一组参数（包括其它actor）来创建一个actor。</span><br><span class="line">send：向其它actor发送消息。</span><br><span class="line">become：将一个actor的当前行为替换为另一种行为。（设置对下一条消息做出的回应方式）</span><br></pre></td></tr></table></figure>

<p>　　在经典actor模型中，状态变化均由become操作来聚合完成。每当actor处理一条消息时，它会计算出一个行为，来响应它期望处理的下一种消息类型。become操作的参数是一个有名字的continuation b，表示actor应该被更新为的行为，以及它应该传递给 b 的状态。(continuation：延续)</p>
<p>可以简单理解成，在一个actor维持私有状态之前，第三条基本上意味着定义了接收下条信息之前actor的状态。或者说，actor是如何改变自身状态的。</p>
<p>假设一个actor是一个计算器，初始状态为0。当这个actor接收到“+1”的消息后，它将指定接收下一个消息时，actor的状态为1，而不是改变原始的状态。</p>
<h3 id="Orleans对Actor的应用"><a href="#Orleans对Actor的应用" class="headerlink" title="Orleans对Actor的应用"></a>Orleans对Actor的应用</h3><p>　　Actor平台（例如Erlang和Akka）在简化分布式系统编程方面向前迈了一步。但是，由于提供的抽象和系统服务的水平相对较低，它们仍然使开发人员承担着许多分布式系统的复杂性。主要包括开发用于管理Actor的生命周期，处理分布式簇，处理Actor的失败和恢复，放置Actor以及由此产生的管理分布式资源的应用程序代码。要为应用程序中的这些问题构建正确的解决方案，这就开发人员的要求就非常高了，必须是分布式系统专家级别的。</p>
<p>　　为了减少这些问题的发生，Orleans框架引入了虚拟Actor的新型抽象，它解决了许多复杂的分布式系统问题，例如可靠性和分布式资源管理，从而使开发人员摆脱了那些麻烦。同时，Orleans运行时使应用程序能够获得高性能，可靠性和可伸缩性。</p>
<p>Orleans对Actor的实现特点：</p>
<ul>
<li>1，Orleans Actor无处不在：无法明确创建或销毁它。它的生命周期超越了其任何内存对象的生命周期，因此也超越了任何特定服务器的生命周期。</li>
<li>2，Orleans Actor会自动实例化：如果没有Actor的内存实例，则发送给Actor的消息会促使在可用服务器上创建一个新实例。作为运行时资源管理的一部分，将自动回收未使用的Actor实例。</li>
<li>3，Actor永远不会失败：如果服务器崩溃了，下一条发送给运行在故障服务器上的Actor的消息将会促使Orleans自动在另一台服务器上重新实例化该Actor ，从而无需应用程序来监督和显式重新创建已经挂掉的Actor。</li>
<li>4，Actor实例的位置对于应用程序代码是透明的，从而大大简化了编程。</li>
<li>5，Orleans可以自动创建同一个无状态Actor的多个实例，从而无缝扩展热门Actor。</li>
</ul>
<p>　　虚拟Actor的引入，相当于为开发者提供了一个虚拟的内存空间，使开发人员可以调用系统中的任何角色，无论它是否存在于内存中。虚拟化依赖于从虚拟角色映射到当前运行的物理实例的间接寻址。运行时通过一个分布式目录支持间接寻址，该目录将Actor标识映射到其当前物理位置。Orleans通过使用该映射的本地缓存来最小化间接寻址的运行时开销。这个策略被证明是非常有效的。在微软的生产服务中，缓存命中率通常远远超过90%。</p>
<p><img src="/img/533598-20190922155518083-577463983.jpg" alt="533598-20190922155518083-577463983.jpg"></p>
<h2 id="CSP模型"><a href="#CSP模型" class="headerlink" title="CSP模型"></a>CSP模型</h2><p>　　CSP是 Communicating Sequential Processes(通信顺序进程) 的简称。在CSP中，多了一个角色Channel，过程（比如goroutine，Worker1）与过程（Worker2）之间不直接通信，而是通过Channle进行通信。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Worker1 --&gt; Channel --&gt; Worker2</span><br></pre></td></tr></table></figure>

<p>CSP模型特点：</p>
<ul>
<li>Channel是过程的中间媒介，Worker1想要跟Worker2发信息时，直接把信息放到Channel里（在程序中其实就是一块内存），然后Worker2在方便的时候到Channel里获取。</li>
<li>Worker1和Worker2之间可以存在很多个Channel；在Golang中每个Channel定义不同的数据类型，即发送不同类型的消息的时候会用到多个不同的Channel。</li>
</ul>
<p>Go语言的CSP模型是由协程Goroutine与通道Channel实现：</p>
<ul>
<li>Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。</li>
<li>通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。</li>
</ul>
<p><img src="/img/channel.png" alt="channel.png"></p>
<h2 id="Actor模型和CSP模型比较"><a href="#Actor模型和CSP模型比较" class="headerlink" title="Actor模型和CSP模型比较"></a>Actor模型和CSP模型比较</h2><p>Actor之间直接通讯，而CSP是通过Channel通讯，在耦合度上两者是有区别的，后者更加松耦合。</p>
<p>　　同时，它们都是描述独立的流程通过消息传递进行通信。主要的区别在于：在CSP消息交换是同步的(即两个流程的执行”接触点”的，在此他们交换消息)，而Actor模型是完全解耦的，可以在任意的时间将消息发送给任何未经证实的接受者。由于Actor享有更大的相互独立,因为他可以根据自己的状态选择处理哪个传入消息。自主性更大些。</p>
<p>　　在Go语言中为了不堵塞流程，程序员必须检查不同的传入消息，以便预见确保正确的顺序。CSP好处是Channel不需要缓冲消息，而Actor理论上需要一个无限大小的邮箱作为消息缓冲。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://fuzhe1989.github.io/2018/05/17/message-passing-and-the-actor-model/#orleans">[翻译]消息传递与actor模型</a></p>
<p><a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/">Orleans – Virtual Actors</a></p>
<p><a target="_blank" rel="noopener" href="https://jingwei.link/2018/07/08/actor-and-csp-model.html">并发模型：Actors与CSP</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edison0621/p/11567800.html">.NET分布式大规模计算利器-Orleans(一)</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/wanborj/blog/852410">十分钟了解Actor模型</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jdon.com/concurrent/actor-csp.html">Actor模型和CSP模型的区别</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/16/C-Sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AD%97%E8%8A%82%E4%BA%92%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/16/C-Sharp%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%AD%97%E8%8A%82%E4%BA%92%E8%BD%AC/" class="post-title-link" itemprop="url">C-Sharp字符串与字节互转</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 16:37:24" itemprop="dateCreated datePublished" datetime="2019-11-16T16:37:24+00:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:37" itemprop="dateModified" datetime="2021-06-04T01:00:37+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">CSharp基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><p>十六进制的表示:<br>C语言、Shell、Python语言及其他相近的语言使用字首“0x”，例如“0x5A3”。开头的“0”令解析器更易辨认数，而“x”则代表十六进制。在“0x”中的“x”可以大写或小写。</p>
<p>16进制就有16个数，0<del>15，用二进制表示15的方法就是1111，从而可以推断出，16进制用2进制可以表现成0000</del>1111，顾名思义，也就是每四个为一位。最高位不够可用零代替。</p>
<p>一个字节包含8个二进制位，一个十六进制可表示4个二进制位，所以，一个字节可以由2个十六进制表示。即，一个byte 对应两位十六进制位。</p>
<h2 id="十六进制转换"><a href="#十六进制转换" class="headerlink" title="十六进制转换"></a>十六进制转换</h2><h3 id="字符串转为16进制字符"><a href="#字符串转为16进制字符" class="headerlink" title="字符串转为16进制字符"></a>字符串转为16进制字符</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">StringToHexString</span>(<span class="params"><span class="built_in">string</span> s, Encoding encode</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] b = encode.GetBytes(s);<span class="comment">//按照指定编码将string编程字节数组</span></span><br><span class="line">    <span class="built_in">string</span> result = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; b.Length; i++)<span class="comment">//逐字节变为16进制字符</span></span><br><span class="line">    &#123;</span><br><span class="line">        result += Convert.ToString(b[i], <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">System.Console.WriteLine(StringToHexString(<span class="string">&quot;严&quot;</span>, System.Text.Encoding.UTF8));</span><br><span class="line">System.Console.WriteLine(BitConverter.ToString(Encoding.UTF8.GetBytes(<span class="string">&quot;严&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191116174552.png" alt="QQ截图20191116174552.png"></p>
<h3 id="16进制字符串转为字符串"><a href="#16进制字符串转为字符串" class="headerlink" title="16进制字符串转为字符串"></a>16进制字符串转为字符串</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">HexStringToString</span>(<span class="params"><span class="built_in">string</span> hs, Encoding encode</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> strTemp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] b = <span class="keyword">new</span> <span class="built_in">byte</span>[hs.Length / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hs.Length / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        strTemp = hs.Substring(i * <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        b[i] = Convert.ToByte(strTemp, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照指定编码将字节数组变为字符串</span></span><br><span class="line">    <span class="keyword">return</span> encode.GetString(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">string</span> hexstring = StringToHexString(<span class="string">&quot;严&quot;</span>, System.Text.Encoding.UTF8);</span><br><span class="line"><span class="built_in">string</span> content = HexStringToString(hexstring, System.Text.Encoding.UTF8);</span><br></pre></td></tr></table></figure>

<h3 id="byte-转为16进制字符串"><a href="#byte-转为16进制字符串" class="headerlink" title="byte[]转为16进制字符串"></a>byte[]转为16进制字符串</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ByteToHexStr</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> returnStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (bytes != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            returnStr += bytes[i].ToString(<span class="string">&quot;X2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> byteStr = StringToHexString(<span class="string">&quot;严&quot;</span>, Encoding.UTF8);</span><br><span class="line">Console.WriteLine(byteStr);<span class="comment">// 输出 e4b8a5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bytes = Encoding.UTF8.GetBytes(<span class="string">&quot;严&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> str = Encoding.UTF8.GetString(bytes);<span class="comment">// 输出 严</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = ByteToHexStr(bytes); <span class="comment">//  输出 E4B8A5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bytes1 = StrToToHexByte(str1);</span><br><span class="line"><span class="keyword">var</span> bytes2 = StrToToHexByte(byteStr);</span><br></pre></td></tr></table></figure>

<h3 id="16进制的字符串转为byte"><a href="#16进制的字符串转为byte" class="headerlink" title="16进制的字符串转为byte[]"></a>16进制的字符串转为byte[]</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">StrToToHexByte</span>(<span class="params"><span class="built_in">string</span> hexString</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hexString = hexString.Replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((hexString.Length % <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        hexString += <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] returnBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[hexString.Length / <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; returnBytes.Length; i++)</span><br><span class="line">        returnBytes[i] = Convert.ToByte(hexString.Substring(i * <span class="number">2</span>, <span class="number">2</span>), <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> returnBytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/WuLex/article/details/75452472">C#数字、16进制字符串和字节之间互转</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/16/%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/16/%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">工具集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 16:16:05" itemprop="dateCreated datePublished" datetime="2019-11-16T16:16:05+00:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="UltraEdit"><a href="#UltraEdit" class="headerlink" title="UltraEdit"></a>UltraEdit</h2><p>文本编辑器，可以查看16进制字节；</p>
<h2 id="ef-core-power-tool"><a href="#ef-core-power-tool" class="headerlink" title="ef core power tool"></a>ef core power tool</h2><p>生成DbContext；反向生成 POCO 类等；</p>
<h2 id="emeditor"><a href="#emeditor" class="headerlink" title="emeditor"></a>emeditor</h2><p>大文本文件编辑器，方便查找；</p>
<h2 id="ListDLLs"><a href="#ListDLLs" class="headerlink" title="ListDLLs"></a>ListDLLs</h2><p>检测当前运行的进程已经加载的dll文件</p>
<h2 id="WinHex"><a href="#WinHex" class="headerlink" title="WinHex"></a>WinHex</h2><p>是在Windows下执行的十六进制编辑软件，此软件功能很强大，有完好的分区管理功能和文件管理功能。能自己主动分析分区链和文件簇链。能对硬盘进行不同方式不同程度的备份。甚至克隆整个硬盘；它可以编辑不论什么一种文件类型的二进制内容（用十六进制显示）其磁盘编辑器可以编辑物理磁盘或逻辑磁盘的随意扇区。是手工恢复数据的首选工具软件。</p>
<h2 id="PEid"><a href="#PEid" class="headerlink" title="PEid"></a>PEid</h2><p>PEiD(PE Identifier)是一款著名的查壳工具，其功能强大，几乎可以侦测出所有的壳，其数量已超过470 种PE 文档 的加壳类型和签名。</p>
<h2 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h2><p>命令行增强工具</p>
<h2 id="VLC-mediaplayer"><a href="#VLC-mediaplayer" class="headerlink" title="VLC mediaplayer"></a>VLC mediaplayer</h2><p>视频流播放软件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/16/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/16/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">字符编码笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 13:26:06" itemprop="dateCreated datePublished" datetime="2019-11-16T13:26:06+00:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><p>每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。<br>ASCII，美国信息交换标准代码，是基于拉丁字母的一套电脑编码系统。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191116140828.png" alt="QQ截图20191116140828.png"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://tool.oschina.net/commons?type=4">ASCII对照表</a></p>
<h2 id="Unicode-与-UCS"><a href="#Unicode-与-UCS" class="headerlink" title="Unicode 与 UCS"></a>Unicode 与 UCS</h2><p>Unicode也是一种字符编码方法，不过它是由国际组织设计，可以容纳全世界所有语言文字的编码方案。Unicode的学名是”Universal Multiple-Octet Coded Character Set”，简称为UCS。UCS可以看作是”Unicode Character Set”的缩写。</p>
<p>在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。</p>
<p>Unicode 当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。</p>
<p><a target="_blank" rel="noopener" href="https://home.unicode.org/">Unicode符号对应表</a></p>
<h2 id="UTF编码"><a href="#UTF编码" class="headerlink" title="UTF编码"></a>UTF编码</h2><p>UTF-8就是以8位为单元对UCS进行编码。从UCS-2到UTF-8的编码方式如下：</p>
<table>
<thead>
<tr>
<th>UCS-2编码(16进制)</th>
<th>UTF-8 字节流(二进制)</th>
</tr>
</thead>
<tbody><tr>
<td>0000 - 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0080 - 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0800 - FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM —— <code>Byte Order Mark</code>，中文名译作“字节顺序标记”。在这里找到一段关于 BOM 的说明：</p>
<p>在UCS 编码中有一个叫做 “Zero Width No-Break Space” ，中文译名作“零宽无间断间隔”的字符，它的编码是 FEFF。而 FFFE 在 UCS 中是不存在的字符，所以不应该出现在实际传输中。</p>
<p>UCS 规范建议我们在传输字节流前，先传输字符 “Zero Width No-Break Space”。这样如果接收者收到 FEFF，就表明这个字节流是 Big-Endian 的；如果收到FFFE，就表明这个字节流是 Little- Endian 的。因此字符 “Zero Width No-Break Space” （“零宽无间断间隔”）又被称作 BOM。</p>
<p>UTF-8 不需要 BOM 来表明字节顺序，但可以用 BOM 来表明编码方式。字符 “Zero Width No-Break Space” 的 UTF-8 编码是 <code>EF BB BF</code>。所以如果接收者收到以 <code>EF BB BF</code> 开头的字节流，就知道这是 UTF-8 编码了。Windows 就是使用 BOM 来标记文本文件的编码方式的。</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8的一个特别的好处是它与ISO-8859-1完全兼容。UTF是 <code>UCS Transformation Format</code> 的缩写。</p>
<p>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。UTF-8 是 Unicode 的实现方式之一。</p>
<p>UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>
<p>UTF-8 的编码规则很简单，只有二条：</p>
<p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</p>
<p>2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<p>下表总结了编码规则，字母x表示可用编码的位。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191116141405.png" alt="QQ截图20191116141405.png"></p>
<p>下面，还是以汉字严为例，演示如何实现 UTF-8 编码。</p>
<p>严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。</p>
<h2 id="UCS-2、UCS-4、BMP"><a href="#UCS-2、UCS-4、BMP" class="headerlink" title="UCS-2、UCS-4、BMP"></a>UCS-2、UCS-4、BMP</h2><p>CS有两种格式：UCS-2和UCS-4。顾名思义，UCS-2就是用两个字节编码，UCS-4就是用4个字节（实际上只用了31位，最高位必须为0）编码。下面让我们做一些简单的数学游戏：</p>
<p>UCS-2有2^16=65536个码位，UCS-4有2^31=2147483648个码位。</p>
<p>UCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行 (rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。</p>
<p>group 0的plane 0被称作 <code>Basic Multilingual Plane</code>, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。</p>
<p>将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。</p>
<h2 id="Unicode-与-UTF-8-之间的转换"><a href="#Unicode-与-UTF-8-之间的转换" class="headerlink" title="Unicode 与 UTF-8 之间的转换"></a>Unicode 与 UTF-8 之间的转换</h2><p>Windows平台，有一个最简单的转化方法，就是使用内置的记事本小程序notepad.exe。打开文件后，点击文件菜单中的另存为命令，会跳出一个对话框，在最底部有一个编码的下拉条。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191116155852.png" alt="QQ截图20191116155852.png"></p>
<p>里面有四个选项：ANSI，Unicode，Unicode big endian和UTF-8。</p>
<p>1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对 Windows 简体中文版，如果是繁体中文版会采用 Big5 码）。</p>
<p>2）Unicode编码这里指的是notepad.exe使用的 UCS-2 编码方式，即直接用两个字节存入字符的 Unicode 码，这个选项用的 little endian 格式。</p>
<p>3）Unicode big endian编码与上一个选项相对应。</p>
<p>4）UTF-8编码，也就是上一节谈到的编码方法。</p>
<p>选择完”编码方式”后，点击”保存”按钮，文件的编码方式就立刻转换好了。</p>
<h2 id="Little-endian-LE-和-Big-endian-BE"><a href="#Little-endian-LE-和-Big-endian-BE" class="headerlink" title="Little endian (LE) 和 Big endian (BE)"></a>Little endian (LE) 和 Big endian (BE)</h2><p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。</p>
<p>如果一个文本文件的头两个字节是<code>FE FF</code>，就表示该文件采用大头方式；如果头两个字节是<code>FF FE</code>，就表示该文件采用小头方式。</p>
<p>对照表：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191229134206.png" alt="QQ截图20191229134206.png"></p>
<p>示例：</p>
<p>用文本编辑软件UltraEdit 中的”十六进制功能”，观察该文件的内部编码方式。</p>
<p>1）ANSI：文件的编码就是两个字节<code>D1 CF</code>，这正是严的 <code>GB2312</code> 编码，这也暗示 <code>GB2312</code> 是采用大头方式存储的。</p>
<p>2）Unicode：编码是四个字节<code>FF FE 25 4E</code>，其中<code>FF FE</code>表明是小头方式存储，真正的编码是<code>4E 25</code>。</p>
<p>3）Unicode big endian：编码是四个字节<code>FE FF 4E 25</code>，其中<code>FE FF</code>表明是大头方式存储。</p>
<p>4）UTF-8：编码是六个字节<code>EF BB BF E4 B8 A5</code>，前三个字节<code>EF BB BF</code>表示这是UTF-8编码，后三个<code>E4 B8 A5</code>就是严的具体编码，它的存储顺序与编码顺序是一致的。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bdc0d52620a">彻底弄懂 Unicode 编码</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/malecrab/p/5300503.html">细说：Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4</a></p>
<p><a target="_blank" rel="noopener" href="http://www.fmddlmyy.cn/text6.html">谈谈Unicode编码，简要解释UCS、UTF、BMP、BOM等名词</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/16/bit(%E6%AF%94%E7%89%B9)%20%E5%92%8C%20Byte(%E5%AD%97%E8%8A%82)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/16/bit(%E6%AF%94%E7%89%B9)%20%E5%92%8C%20Byte(%E5%AD%97%E8%8A%82)/" class="post-title-link" itemprop="url">bit(比特) 和 Byte(字节)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-16 10:57:11" itemprop="dateCreated datePublished" datetime="2019-11-16T10:57:11+00:00">2019-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="bit（比特）"><a href="#bit（比特）" class="headerlink" title="bit（比特）"></a>bit（比特）</h2><p>bit 是信息量的单位，是表示信息的最小单位，只有两种状态：0和1。二进制的一位，就叫做 1 bit。<br>它的简写为小写字母 “b”。</p>
<h2 id="Byte-字节"><a href="#Byte-字节" class="headerlink" title="Byte (字节)"></a>Byte (字节)</h2><p>表示一个 8 位无符号整数。</p>
<p>即，8 bit（比特位）= 1 Byte（字节）；</p>
<h2 id="bit（比特）与-Byte-字节-的关系"><a href="#bit（比特）与-Byte-字节-的关系" class="headerlink" title="bit（比特）与 Byte (字节) 的关系"></a>bit（比特）与 Byte (字节) 的关系</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>MB = <span class="number">1024</span>KB = <span class="number">1024</span> * <span class="number">1024B</span> = <span class="number">1048576B</span>；</span><br><span class="line"><span class="number">1024B</span>yte = <span class="number">1</span>KB；</span><br><span class="line"><span class="number">1024</span>KB = <span class="number">1</span>MB;</span><br><span class="line"><span class="number">1024</span>MB = <span class="number">1</span>GB;</span><br><span class="line"><span class="number">1024</span>GB = <span class="number">1</span>TB;</span><br></pre></td></tr></table></figure>

<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191116112021.png" alt="QQ截图20191116112021.png"></p>
<p>例如：</p>
<p>根据 一字节 等于 8 比特的 换算方法，就可以得出以下结论。</p>
<p>下载速度从理论上来说，应该是 带宽的 八分之一。</p>
<p>2M 宽带理论下载速度是 256 KB</p>
<p>10M 宽带理论下载速度是 1280 KB</p>
<p>总结：</p>
<p>存储单位和网速的单位，不管是 B 还是 b，代表的都是 字节 Byte。<br>带宽的单位，不管是 B 还是 b，代表的都是 比特 bit 。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/46040087">bit ( 比特 )和 Byte（字节）的关系？</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.byte?view=netframework-4.8">Byte 结构</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/15/CSharp%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/15/CSharp%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8E%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">CSharp位运算与移位运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-15 15:54:17" itemprop="dateCreated datePublished" datetime="2019-11-15T15:54:17+00:00">2019-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:37" itemprop="dateModified" datetime="2021-06-04T01:00:37+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">CSharp基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>移位运算符仅针对 int、uint、long 和 ulong 类型定义，因此运算的结果始终包含至少 32 位。 如果左侧操作数是其他整数类型（sbyte、byte、short、ushort 或 char），则其值将转换为 int 类型。</p>
<h2 id="左移位运算符-lt-lt"><a href="#左移位运算符-lt-lt" class="headerlink" title="左移位运算符 &lt;&lt;"></a>左移位运算符 &lt;&lt;</h2><p><code>&lt;&lt;</code> 运算符将其左侧操作数向左移动右侧操作数定义的位数。<br>左移运算会放弃超出结果类型范围的高阶位，并将低阶空位位置设置为零</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uint</span> x = <span class="number">0b</span>_1100_1001_0000_0000_0000_0000_0001_0001;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Before: <span class="subst">&#123;Convert.ToString(x, toBase: <span class="number">2</span>)&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">uint</span> y = x &lt;&lt; <span class="number">4</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;After:  <span class="subst">&#123;Convert.ToString(y, toBase: <span class="number">2</span>)&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Before: 11001001000000000000000000010001</span></span><br><span class="line"><span class="comment">// After:  10010000000000000000000100010000</span></span><br></pre></td></tr></table></figure>

<p>总结：左移相当于 X * 2的N次方 (乘以 2 的N次方)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x&lt;&lt;<span class="number">1</span>= x*<span class="number">2</span></span><br><span class="line">x&lt;&lt;<span class="number">2</span>= x*<span class="number">4</span></span><br><span class="line">x&lt;&lt;<span class="number">3</span>= x*<span class="number">8</span></span><br><span class="line">x&lt;&lt;<span class="number">4</span>= x*<span class="number">16</span></span><br></pre></td></tr></table></figure>

<h2 id="右移位运算符-gt-gt"><a href="#右移位运算符-gt-gt" class="headerlink" title="右移位运算符 &gt;&gt;"></a>右移位运算符 &gt;&gt;</h2><p><code>&gt;&gt;</code> 运算符将其左侧操作数向右移动右侧操作数定义的位数。<br>右移位运算会放弃低阶位。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uint</span> x = <span class="number">0b</span>_1001;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Before: <span class="subst">&#123;Convert.ToString(x, toBase: <span class="number">2</span>), <span class="number">4</span>&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">uint</span> y = x &gt;&gt; <span class="number">2</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;After:  <span class="subst">&#123;Convert.ToString(y, toBase: <span class="number">2</span>), <span class="number">4</span>&#125;</span>&quot;</span>);</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// Before: 1001</span></span><br><span class="line"><span class="comment">// After:    10</span></span><br></pre></td></tr></table></figure>

<p>总结：左移相当于 X / 2的N次方 (除以 2 的N次方)</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x&gt;&gt;<span class="number">1</span>= x/<span class="number">2</span></span><br><span class="line">x&gt;&gt;<span class="number">2</span>= x/<span class="number">4</span></span><br><span class="line">x&gt;&gt;<span class="number">3</span>= x/<span class="number">8</span></span><br><span class="line">x&gt;&gt;<span class="number">4</span>=x/<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-">位运算符和移位运算符（C# 参考）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kakimsun/archive/2010/04/27/1722403.html">C#移位运算(左移和右移)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/11/13/dot%20net%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/13/dot%20net%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96/" class="post-title-link" itemprop="url">dot net数字格式化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-13 16:06:35" itemprop="dateCreated datePublished" datetime="2019-11-13T16:06:35+00:00">2019-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:38" itemprop="dateModified" datetime="2021-06-04T01:00:38+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSharp%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">CSharp基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>标准数字格式字符串用于格式化通用数值类型。 标准数字格式字符串采用 Axx 的形式。</p>
<p>A 是称为“格式说明符” 的单个字母字符。</p>
<p>xx 是称为“精度说明符” 的可选整数。 精度说明符的范围从 0 到 99，并且影响结果中的位数。</p>
<h2 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h2><h3 id="十进制（“D”）格式说明符"><a href="#十进制（“D”）格式说明符" class="headerlink" title="十进制（“D”）格式说明符"></a>十进制（“D”）格式说明符</h3><p>“D”或“d” ：表示10进制；</p>
<p>示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">value</span> = <span class="number">12345</span>;</span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;D&quot;</span>));</span><br><span class="line"><span class="comment">// Displays 12345</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;D8&quot;</span>));</span><br><span class="line"><span class="comment">// Displays 00012345</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">value</span> = <span class="number">-12345</span>;</span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;D&quot;</span>));</span><br><span class="line"><span class="comment">// Displays -12345</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;D8&quot;</span>));</span><br><span class="line"><span class="comment">// Displays -00012345</span></span><br></pre></td></tr></table></figure>

<h3 id="定点（“F”）格式说明符"><a href="#定点（“F”）格式说明符" class="headerlink" title="定点（“F”）格式说明符"></a>定点（“F”）格式说明符</h3><p>定点（“F”）格式说明符将数字转换为“-ddd.ddd…”形式的字符串，其中每个“d”表示一个数字 (0-9)。 如果该数字为负，则该字符串以减号开头。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> integerNumber;</span><br><span class="line">integerNumber = <span class="number">17843</span>;</span><br><span class="line">Console.WriteLine(integerNumber.ToString(<span class="string">&quot;F&quot;</span>, </span><br><span class="line">                  CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays 17843.00</span></span><br><span class="line"></span><br><span class="line">integerNumber = <span class="number">-29541</span>;</span><br><span class="line">Console.WriteLine(integerNumber.ToString(<span class="string">&quot;F3&quot;</span>, </span><br><span class="line">                  CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays -29541.000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> doubleNumber;</span><br><span class="line">doubleNumber = <span class="number">18934.1879</span>;</span><br><span class="line">Console.WriteLine(doubleNumber.ToString(<span class="string">&quot;F&quot;</span>, CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays 18934.19</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(doubleNumber.ToString(<span class="string">&quot;F0&quot;</span>, CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays 18934</span></span><br><span class="line"></span><br><span class="line">doubleNumber = <span class="number">-1898300.1987</span>;</span><br><span class="line">Console.WriteLine(doubleNumber.ToString(<span class="string">&quot;F1&quot;</span>, CultureInfo.InvariantCulture));  </span><br><span class="line"><span class="comment">// Displays -1898300.2</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(doubleNumber.ToString(<span class="string">&quot;F3&quot;</span>, </span><br><span class="line">                  CultureInfo.CreateSpecificCulture(<span class="string">&quot;es-ES&quot;</span>)));</span><br><span class="line"><span class="comment">// Displays -1898300,199</span></span><br></pre></td></tr></table></figure>

<h3 id="百分比（“P”）格式说明符"><a href="#百分比（“P”）格式说明符" class="headerlink" title="百分比（“P”）格式说明符"></a>百分比（“P”）格式说明符</h3><p>百分比（“P”）格式说明符将数字乘以 100 并将其转换为表示百分比的字符串。</p>
<p>“P”或“p”</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> number = <span class="number">.2468013</span>;</span><br><span class="line">Console.WriteLine(number.ToString(<span class="string">&quot;P&quot;</span>, CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays 24.68 %</span></span><br><span class="line">Console.WriteLine(number.ToString(<span class="string">&quot;P&quot;</span>, </span><br><span class="line">                  CultureInfo.CreateSpecificCulture(<span class="string">&quot;hr-HR&quot;</span>)));</span><br><span class="line"><span class="comment">// Displays 24,68%</span></span><br><span class="line">Console.WriteLine(number.ToString(<span class="string">&quot;P1&quot;</span>, CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays 24.7 %</span></span><br></pre></td></tr></table></figure>

<h3 id="数字（“N”）格式说明符"><a href="#数字（“N”）格式说明符" class="headerlink" title="数字（“N”）格式说明符"></a>数字（“N”）格式说明符</h3><p>数字（”N”）格式说明符将数字转换为”-d,ddd,ddd.ddd…”形式的字符串</p>
<p>“N”或“n”</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> dblValue = <span class="number">-12445.6789</span>;</span><br><span class="line">Console.WriteLine(dblValue.ToString(<span class="string">&quot;N&quot;</span>, CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays -12,445.68</span></span><br><span class="line">Console.WriteLine(dblValue.ToString(<span class="string">&quot;N1&quot;</span>, </span><br><span class="line">                  CultureInfo.CreateSpecificCulture(<span class="string">&quot;sv-SE&quot;</span>)));</span><br><span class="line"><span class="comment">// Displays -12 445,7</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> intValue = <span class="number">123456789</span>;</span><br><span class="line">Console.WriteLine(intValue.ToString(<span class="string">&quot;N1&quot;</span>, CultureInfo.InvariantCulture));</span><br><span class="line"><span class="comment">// Displays 123,456,789.0 </span></span><br></pre></td></tr></table></figure>

<h3 id="十六进制（“X”）格式说明符"><a href="#十六进制（“X”）格式说明符" class="headerlink" title="十六进制（“X”）格式说明符"></a>十六进制（“X”）格式说明符</h3><p>十六进制（“X”）格式说明符将数字转换为十六进制数的字符串。</p>
<p>“X”或“x”</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="keyword">value</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">value</span> = <span class="number">0x2045e</span>;</span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;x&quot;</span>));</span><br><span class="line"><span class="comment">// Displays 2045e</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;X&quot;</span>));</span><br><span class="line"><span class="comment">// Displays 2045E</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;X8&quot;</span>));</span><br><span class="line"><span class="comment">// Displays 0002045E</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">value</span> = <span class="number">123456789</span>;</span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;X&quot;</span>));</span><br><span class="line"><span class="comment">// Displays 75BCD15</span></span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>.ToString(<span class="string">&quot;X2&quot;</span>));</span><br><span class="line"><span class="comment">// Displays 75BCD15</span></span><br></pre></td></tr></table></figure>

<p>十六进制的表示:<br>C语言、Shell、Python语言及其他相近的语言使用字首“0x”，例如“0x5A3”。开头的“0”令解析器更易辨认数，而“x”则代表十六进制。在“0x”中的“x”可以大写或小写。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/formatting-types?view=netframework-4.8">.NET 中的格式类型</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/standard-numeric-format-strings?view=netframework-4.8#using-standard-numeric-format-strings">标准数字格式字符串</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/composite-formatting">复合格式设置</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/custom-numeric-format-strings?view=netframework-4.8">自定义数字格式字符串</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/10/17/ABP%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%8826%EF%BC%89-%20Authorization%20%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/17/ABP%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%8826%EF%BC%89-%20Authorization%20%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">ABP框架学习记录（26）- Authorization 解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-17 15:22:11" itemprop="dateCreated datePublished" datetime="2019-10-17T15:22:11+00:00">2019-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:37" itemprop="dateModified" datetime="2021-06-04T01:00:37+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ABP/" itemprop="url" rel="index"><span itemprop="name">ABP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ABP框架学习记录（26）-Authorization-解析"><a href="#ABP框架学习记录（26）-Authorization-解析" class="headerlink" title="ABP框架学习记录（26）- Authorization 解析"></a>ABP框架学习记录（26）- Authorization 解析</h1><p>本文 以 <code>Volo.Abp</code> 解决方案展开研究；</p>
<p>在 <code>Volo.Abp</code> 解决方案中，提供了单独的项目 实现 <code>Authorization</code> 功能，如下图:</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191017152520.png" alt="QQ截图20191017152520.png"></p>
<p><code>Authorization</code>：中文解释，授权。ABP 中检查是否对 <code>用户或者角色</code> 授予权限。整个功能可以分为两个方面理解：<br>1，许可定义；<br>2，检查许可；</p>
<h2 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h2><p><code>Permission</code> 的中文解释为：许可，允许。</p>
<p>首先介绍 <code>Permission</code> 相关的类定义：</p>
<p><code>PermissionDefinition</code>：许可定义，包括父级权限和子级列表。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021114332.png" alt="QQ截图20191021114332.png"></p>
<p><code>PermissionGroupDefinition</code>：定义许可组；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021131218.png" alt="QQ截图20191021131218.png"></p>
<p><code>PermissionGrantResult</code>：授权结果；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021131648.png" alt="QQ截图20191021131648.png"></p>
<p><code>IPermissionChecker</code>：检查授权，提供 <code>IsGrantedAsync</code> 方法检查是否有权限。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021104232.png" alt="QQ截图20191021104232.png"></p>
<p><code>PermissionChecker</code>：实现 <code>IPermissionChecker</code> 接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021131755.png" alt="QQ截图20191021131755.png"></p>
<p><code>IPermissionDefinitionContext</code>：许可定义上下文，封装了 <code>PermissionGroupDefinition</code> 对象，并且提供了添加，移除的方法；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021132317.png" alt="QQ截图20191021132317.png"></p>
<p><code>PermissionDefinitionContext</code>：实现 <code>IPermissionDefinitionContext</code> 接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021132414.png" alt="QQ截图20191021132414.png"></p>
<p><code>IPermissionDefinitionManager</code>：管理 <code>PermissionDefinition</code>;</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021135949.png" alt="QQ截图20191021135949.png"></p>
<p><code>PermissionDefinitionManager</code>：默认实现 <code>IPermissionDefinitionManager</code> 接口。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021140150.png" alt="QQ截图20191021140150.png"></p>
<p><code>IPermissionDefinitionProvider</code>：定义 <code>PermissionDefinition</code> 提供者接口；对 <code>Define</code> 方法传入的 <code>IPermissionDefinitionContext</code> 对象进行操作；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021140648.png" alt="QQ截图20191021140648.png"></p>
<p><code>PermissionDefinitionProvider</code>：实现 <code>IPermissionDefinitionProvider</code> 接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021140742.png" alt="QQ截图20191021140742.png"></p>
<p><code>IPermissionStore</code>：定义许可 存储接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021141034.png" alt="QQ截图20191021141034.png"></p>
<p><code>NullPermissionStore</code> ：<code>IPermissionStore</code> 接口的空实现。</p>
<p><code>IPermissionValueProvider</code>：定义获取 <code>PermissionValue</code> 的接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021151209.png" alt="QQ截图20191021151209.png"></p>
<p><code>PermissionValueProvider</code>：实现 <code>IPermissionValueProvider</code> 接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021171013.png" alt="QQ截图20191021171013.png"></p>
<p><code>RolePermissionValueProvider</code>：提供角色相关许可；</p>
<p><code>UserPermissionValueProvider</code>：提供用户相关许可；</p>
<p><code>ClientPermissionValueProvider</code>：提供客户端相关许可；</p>
<p><code>IPermissionValueProviderManager</code>：定义管理 <code>IPermissionValueProvider</code> 的接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021171140.png" alt="QQ截图20191021171140.png"></p>
<p><code>PermissionValueProviderManager</code>：实现 <code>IPermissionValueProviderManager</code> 接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021171437.png" alt="QQ截图20191021171437.png"></p>
<p><code>PermissionOptions</code>：许可选项；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021141758.png" alt="QQ截图20191021141758.png"></p>
<p><code>PermissionValueCheckContext</code>：检查 <code>PermissionValue</code> 的上下文；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021171820.png" alt="QQ截图20191021171820.png"></p>
<h2 id="AbpAuthorizationModule"><a href="#AbpAuthorizationModule" class="headerlink" title="AbpAuthorizationModule"></a>AbpAuthorizationModule</h2><p>这一部分主要分析 <code>AbpAuthorizationModule</code> 的实现。</p>
<p>在 <code>Volo.Abp</code> 解决方案中，其 <code>Module</code> 系统集成 Core 自带的 <code>IServiceCollection</code> ，通过自定义的 <code>ServiceConfigurationContext</code> 类，封装了 <code>IServiceCollection</code> 对象：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021175125.png" alt="QQ截图20191021175125.png"></p>
<p><code>AbpAuthorizationModule</code>：定义<code>Module</code>，<code>OnRegistred</code> 扩展方法 添加 拦截器注册者；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021174716.png" alt="QQ截图20191021174716.png"></p>
<h3 id="PreConfigureServices"><a href="#PreConfigureServices" class="headerlink" title="PreConfigureServices"></a>PreConfigureServices</h3><p><code>AuthorizationInterceptorRegistrar</code>：拦截器注册类；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021175737.png" alt="QQ截图20191021175737.png"></p>
<p><code>AuthorizationInterceptor</code>：定义拦截器；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021175839.png" alt="QQ截图20191021175839.png"></p>
<p><code>MethodInvocationAuthorizationContext</code>：定义方法调用 许可上下文，校验方法是否被允许；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021180118.png" alt="QQ截图20191021180118.png"></p>
<p><code>IMethodInvocationAuthorizationService</code>：定义校验方法许可的接口；</p>
<p><code>MethodInvocationAuthorizationService</code>：实现 <code>IMethodInvocationAuthorizationService</code> 接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021180541.png" alt="QQ截图20191021180541.png"></p>
<h3 id="ConfigureServices"><a href="#ConfigureServices" class="headerlink" title="ConfigureServices"></a>ConfigureServices</h3><p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021180851.png" alt="QQ截图20191021180851.png"></p>
<p><code>PermissionRequirement</code>：许可参数；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021181401.png" alt="QQ截图20191021181401.png"></p>
<p><code>PermissionRequirementHandler</code>：定义 回调 <code>Handler</code>；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021181600.png" alt="QQ截图20191021181600.png"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><code>IAbpAuthorizationService</code>：定义 <code>Abp</code> 授权服务接口；继承 Dot Net Core自带 <code>IAuthorizationService</code> 接口；</p>
<p><code>AbpAuthorizationService</code>：实现  <code>IAuthorizationService</code> 接口;</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021182258.png" alt="QQ截图20191021182258.png"></p>
<p><code>IAbpAuthorizationPolicyProvider</code>：定义 授权 策略 提供者接口；继承 Dot Net Core 自带 <code>IAuthorizationPolicyProvider</code> 接口；</p>
<p><code>AbpAuthorizationPolicyProvider</code>：实现 <code>IAbpAuthorizationPolicyProvider</code> 接口；</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191021182527.png" alt="QQ截图20191021182527.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2019/10/17/Identity%E7%AC%94%E8%AE%B0%E4%B9%8B%20-%20Claim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/17/Identity%E7%AC%94%E8%AE%B0%E4%B9%8B%20-%20Claim/" class="post-title-link" itemprop="url">Identity笔记之 - Claim</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-17 14:45:07" itemprop="dateCreated datePublished" datetime="2019-10-17T14:45:07+00:00">2019-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 01:00:37" itemprop="dateModified" datetime="2021-06-04T01:00:37+00:00">2021-06-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/" itemprop="url" rel="index"><span itemprop="name">认证与授权</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Identity笔记之-Claim"><a href="#Identity笔记之-Claim" class="headerlink" title="Identity笔记之 - Claim"></a>Identity笔记之 - Claim</h1><p>本文介绍 <code>Claim</code> 相关概念，具体类在 <code>System.Security.Claims</code> 命名空间下。</p>
<h2 id="Claim"><a href="#Claim" class="headerlink" title="Claim"></a>Claim</h2><p><code>Claim</code>：要求；主张；声称; 宣称; 自称; 认领</p>
<p>在 <code>Identity</code> 可以理解成 <code>证件单元</code>，以键值对表示：</p>
<p>例如：<code>姓名：特斯拉</code></p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191017150008.png" alt="QQ截图20191017150008.png"></p>
<h2 id="ClaimsIdentity"><a href="#ClaimsIdentity" class="headerlink" title="ClaimsIdentity"></a>ClaimsIdentity</h2><p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191017150602.png" alt="QQ截图20191017150602.png"></p>
<p>在 <code>Identity</code> 可以理解成 <code>身份证件</code>，即包括一系列 <code>Claim</code> 的集合；</p>
<h2 id="ClaimsPrincipal"><a href="#ClaimsPrincipal" class="headerlink" title="ClaimsPrincipal"></a>ClaimsPrincipal</h2><p><code>Principal</code>：主体，委托人</p>
<p><code>ClaimsPrincipal</code> 可以理解成 <code>证件当事人</code>;</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20191017151234.png" alt="QQ截图20191017151234.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/savorboard/p/aspnetcore-identity.html">ASP.NET Core 之 Identity 入门（一）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">430</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">122</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">178</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
