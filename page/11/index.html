<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/page/11/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/05/11/Centos7%20%E6%8C%82%E8%BD%BDiso%E9%95%9C%E5%83%8F(yum%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/Centos7%20%E6%8C%82%E8%BD%BDiso%E9%95%9C%E5%83%8F(yum%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85)/" class="post-title-link" itemprop="url">Centos7 挂载iso镜像(yum离线安装)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-11 16:57:45" itemprop="dateCreated datePublished" datetime="2020-05-11T16:57:45+00:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CentOS7/" itemprop="url" rel="index"><span itemprop="name">CentOS7</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="挂载iso文件到挂载点"><a href="#挂载iso文件到挂载点" class="headerlink" title="挂载iso文件到挂载点"></a>挂载iso文件到挂载点</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建文件夹</span></span><br><span class="line">mkdir -p /media/cdrom</span><br><span class="line"></span><br><span class="line"><span class="comment">## 挂载iso文件到挂载点</span></span><br><span class="line">mount -o loop /media/CentOS-7-x86_64-DVD-1804.iso /media/cdrom</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看挂载状态</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line"><span class="comment">## 重新挂载系统分区</span></span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure>
<h2 id="修改yum的配置文件，使用本地ISO做yum源"><a href="#修改yum的配置文件，使用本地ISO做yum源" class="headerlink" title="修改yum的配置文件，使用本地ISO做yum源"></a>修改yum的配置文件，使用本地ISO做yum源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># (可选) 一个一个文件备份</span></span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br><span class="line">cp CentOS-Media.repo CentOS-Media.repo.bak</span><br><span class="line"></span><br><span class="line">mkdir bak</span><br><span class="line"><span class="comment"># 拷贝目录下所有.repo和.bak文件到 bak文件夹下</span></span><br><span class="line">mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak</span><br><span class="line">mv /etc/yum.repos.d/*.bak /etc/yum.repos.d/bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 local.repo</span></span><br><span class="line">touch local.repo</span><br><span class="line">vi local.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># local.repo 内容</span></span><br><span class="line">[<span class="built_in">local</span>]</span><br><span class="line">name=local_yum</span><br><span class="line">baseurl=file:///media/cdrom</span><br><span class="line"><span class="built_in">enable</span>=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>

<p>介绍：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">local</span>]　　　　　　　　　　　　　　 <span class="comment">#库名称</span></span><br><span class="line">name=<span class="built_in">local</span>　　               <span class="comment">#名称描述</span></span><br><span class="line">baseurl=file:///media/cdrom   <span class="comment">#yum源目录，源地址为rpm的目录</span></span><br><span class="line">gpgcheck=1　　　　　　　　　　   <span class="comment">#检查GPG-KEY，0为不检查，1为检查</span></span><br><span class="line">enabled=1　　　　　　　　　　　  <span class="comment">#是否用该yum源，0为禁用，1为使用</span></span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6　　<span class="comment">#gpgcheck=0时无需配置</span></span><br></pre></td></tr></table></figure>

<h2 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum list</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libicu</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hl-piglet/p/8445988.html">centos–软件源–本地软件源—离线安装</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/oftenlin/p/4325023.html">CentOS 本地ISO 挂载并配置本地软件源</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/05/11/linux%E4%B8%ADyum%E4%B8%8Erpm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/linux%E4%B8%ADyum%E4%B8%8Erpm/" class="post-title-link" itemprop="url">linux中yum与rpm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-11 10:03:34" itemprop="dateCreated datePublished" datetime="2020-05-11T10:03:34+00:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="源代码形式"><a href="#源代码形式" class="headerlink" title="源代码形式"></a>源代码形式</h2><p>1.绝大多数开源软件都是直接以原码形式发布的</p>
<p>2.源代码一般会被打成.tar.gz的归档压缩文件</p>
<p>3.源代码需要编译成为二进制形式之后才能够运行使用</p>
<p>4.源代码基本编译流程：</p>
<p>1）.configure 检查编译环境；</p>
<p>2）make对源代码进行编译；</p>
<p>3）make insall 将生成的可执行文件安装到当前计算机中</p>
<h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>1.源代码形式的特点：操作复杂、编译时间长、极易出现问题、依赖关系复杂</p>
<p>2.为了方便，RPM（redhat package manager）</p>
<p>3.RPM通过将代码基于特定平台系统编译为可执行文件，并保存依赖关系，来简化开源软件的安装管理。针对不同的系统设定不同的包</p>
<p>4.常用命令规范：linuxcast-1.2.0-30.el6.1686.rpm 包名-版本号-适用平台-32/64-rpm</p>
<p>5.使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装</span></span><br><span class="line">rpm –i software.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">## 卸载</span></span><br><span class="line">rpm -e software.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">## 升级形式安装</span></span><br><span class="line">rpm –U software.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">## 例子</span></span><br><span class="line">rpm –ivh http://www.linuxcast.net/software.rpm <span class="comment">## 支持通过http\ftp协议形式安装</span></span><br><span class="line"></span><br><span class="line">-v 显示详细信息；-h显示进度条</span><br><span class="line">查询功能：rpm –qa </span><br><span class="line">列出全部已经安装的.rpm软件  rpm –qa |grep ***</span><br></pre></td></tr></table></figure>

<h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>1.rpm软件包形式的管理虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件安装一个软件需要安装1个或者多个其他软件，手动解决时，很复杂，yum解决这些问题。Yum是rpm的前端程序，主要目的是设计用来自动解决rpm的依赖关系，其特点：</p>
<p>1）自动解决依赖关系；<br>2）可以对rpm进行分组，基于组进行安装操作；<br>3）引入仓库概念，支持多个仓库；<br>4）配置简单</p>
<p>2.yum仓库用来存放所有的现有的.rpm包，当使用yum安装一个rpm包时，需要依赖关系，会自动在仓库中查找依赖软件并安装。仓库可以是本地的，也可以是HTTP、FTP、nfs形式使用的集中地、统一的网络仓库。</p>
<p>3.仓库的配置文件/etc/yum.repos.d目录下</p>
<p>4.使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1 安装</span></span><br><span class="line">yum install 全部安装</span><br><span class="line">yum install package1 安装指定的安装包package1</span><br><span class="line">yum groupinsall group1 安装程序组group1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2 更新和升级</span></span><br><span class="line">yum update 全部更新</span><br><span class="line">yum update package1 更新指定程序包package1</span><br><span class="line">yum check-update 检查可更新的程序</span><br><span class="line">yum upgrade package1 升级指定程序包package1</span><br><span class="line">yum groupupdate group1 升级程序组group1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3 查找和显示</span></span><br><span class="line">yum info package1 显示安装包信息package1</span><br><span class="line">yum list 显示所有已经安装和可以安装的程序包</span><br><span class="line">yum list package1 显示指定程序包安装情况package1</span><br><span class="line">yum groupinfo group1 显示程序组group1信息yum search string 根据关键字string查找安装包</span><br><span class="line"></span><br><span class="line"><span class="comment">## 4 删除程序</span></span><br><span class="line">yum remove &amp;<span class="comment">#124; erase package1 删除程序包package1</span></span><br><span class="line">yum groupremove group1 删除程序组group1</span><br><span class="line">yum deplist package1 查看程序package1依赖情况</span><br><span class="line"></span><br><span class="line"><span class="comment">## 5 清除缓存</span></span><br><span class="line">yum clean packages 清除缓存目录下的软件包</span><br><span class="line">yum clean headers 清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders 清除缓存目录下旧的 headers</span><br><span class="line">yum clean, yum clean all (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的headers</span><br></pre></td></tr></table></figure>

<p>5.查询软件：</p>
<p>可以使用 <code>yumsearch **</code></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ziyun_xiaoyan/article/details/54341823">linux中yum与rpm区别</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html">linux yum命令详解</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/05/10/Centos7make%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Centos7make%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">Centos7make编译安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 13:07:36" itemprop="dateCreated datePublished" datetime="2020-05-10T13:07:36+00:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CentOS7/" itemprop="url" rel="index"><span itemprop="name">CentOS7</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://ftp.gnu.org/gnu/make/make-4.3.tar.gz</span><br><span class="line">tar -zxvf make-4.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> make-4.3</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">ln -s -f /usr/<span class="built_in">local</span>/bin/make  /usr/bin/make</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7ccfe99cab05">Centos7make编译安装</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/05/10/CentOS7%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/CentOS7%E6%9B%B4%E6%8D%A2%E9%95%9C%E5%83%8F%E6%BA%90/" class="post-title-link" itemprop="url">CentOS7更换镜像源</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 11:20:31" itemprop="dateCreated datePublished" datetime="2020-05-10T11:20:31+00:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CentOS7/" itemprop="url" rel="index"><span itemprop="name">CentOS7</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CentOS，是基于 Red Hat Linux 提供的可自由使用源代码的企业级 Linux 发行版本；是一个稳定，可预测，可管理和可复制的免费企业级计算平台。</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><ol>
<li>备份</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CentOS 6</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-6.repo</span><br><span class="line"></span><br><span class="line">CentOS 7</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">CentOS 8</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">或者</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>运行 <code>yum makecache</code> 生成缓存</p>
</li>
<li><p>其他<br>非阿里云ECS用户会出现 Couldn’t resolve host ‘mirrors.cloud.aliyuncs.com’ 信息，不影响使用。用户也可自行修改相关配置: eg:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;/mirrors.cloud.aliyuncs.com/d&#x27;</span> -e <span class="string">&#x27;/mirrors.aliyuncs.com/d&#x27;</span> /etc/yum.repos.d/CentOS-Base.repo</span><br></pre></td></tr></table></figure>

<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/mirror/centos">CentOS 镜像</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/05/10/%E6%9F%A5%E7%9C%8Bcentos%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/%E6%9F%A5%E7%9C%8Bcentos%E5%B7%B2%E7%BB%8F%E5%AE%89%E8%A3%85%E7%9A%84%E5%8C%85/" class="post-title-link" itemprop="url">查看centos已经安装的包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 10:01:47" itemprop="dateCreated datePublished" datetime="2020-05-10T10:01:47+00:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CentOS7/" itemprop="url" rel="index"><span itemprop="name">CentOS7</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>rpm包安装的，可以用rpm -qa看到，如果要查找某软件包是否安装，用 rpm -qa | grep “软件或者包的名字”。</p>
</li>
<li><p>deb包安装的，可以用dpkg -l能看到。如果是查找指定软件包，用dpkg -l | grep “软件或者包的名字”； </p>
</li>
<li><p>yum方法安装的，可以用yum list installed查找，如果是查找指定包，命令后加 | grep “软件名或者包名”； </p>
</li>
<li><p>如果是以源码包自己编译安装的，例如.tar.gz或者tar.bz2形式的，这个只能看可执行文件是否存在了，<br>上面两种方法都看不到这种源码形式安装的包。如果是以root用户安装的，可执行程序通常都在/sbin:/usr/bin目录下</p>
</li>
<li><p>pip安装的所有包：</p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br><span class="line"></span><br><span class="line">rpm -qa | grep libcurl</span><br><span class="line">rpm -qa | grep openssl-libs</span><br><span class="line">rpm -qa | grep krb5-libs</span><br><span class="line">rpm -qa | grep zlib</span><br><span class="line"></span><br><span class="line">rpm -qa | grep lttng-ust</span><br><span class="line">rpm -qa | grep libicu</span><br><span class="line"></span><br><span class="line">yum list installed | grep lttng-ust</span><br><span class="line"></span><br><span class="line">yum list installed | libicu</span><br><span class="line"></span><br><span class="line">rpm -qa | grep bzip2</span><br></pre></td></tr></table></figure>


<p>lttng-ust<br><a target="_blank" rel="noopener" href="https://lttng.org/docs/v2.11/#doc-fedora">https://lttng.org/docs/v2.11/#doc-fedora</a></p>
<p>bzip2 –安装<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/thrillerz/p/3935789.html">https://www.cnblogs.com/thrillerz/p/3935789.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/02/29/github%E6%B7%BB%E5%8A%A0ssh(tortoisegit)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/github%E6%B7%BB%E5%8A%A0ssh(tortoisegit)/" class="post-title-link" itemprop="url">github添加ssh(tortoisegit)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-29 14:20:23" itemprop="dateCreated datePublished" datetime="2020-02-29T14:20:23+00:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PuTTYgen生成密钥"><a href="#PuTTYgen生成密钥" class="headerlink" title="PuTTYgen生成密钥"></a>PuTTYgen生成密钥</h2><p>生成，并保存私钥(.ppk)格式。</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200302165208.png" alt="QQ截图20200302165208.png"></p>
<h2 id="配置ssh密钥"><a href="#配置ssh密钥" class="headerlink" title="配置ssh密钥"></a>配置ssh密钥</h2><p>在github设置页面配置：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200302113117.png" alt="QQ截图20200302113117.png"></p>
<h2 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库"></a>配置仓库</h2><p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200302165822.png" alt="QQ截图20200302165822.png"></p>
<h2 id="Pageant-添加-ppk密钥"><a href="#Pageant-添加-ppk密钥" class="headerlink" title="Pageant 添加.ppk密钥"></a>Pageant 添加.ppk密钥</h2><p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200302170027.png" alt="QQ截图20200302170027.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/21/win10%E5%AE%89%E8%A3%85linux%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/21/win10%E5%AE%89%E8%A3%85linux%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">win10安装linux子系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-21 16:25:13" itemprop="dateCreated datePublished" datetime="2020-01-21T16:25:13+00:00">2020-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/WSL/" itemprop="url" rel="index"><span itemprop="name">WSL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200121163159.png" alt="QQ截图20200121163159.png"></p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200121163433.png" alt="QQ截图20200121163433.png"></p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200121163508.png" alt="QQ截图20200121163508.png"></p>
<p>Microsoft Store应用商店获取子系统</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200121163729.png" alt="QQ截图20200121163729.png"></p>
<h2 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h2><p>cmder下载： <a target="_blank" rel="noopener" href="http://cmder.net/">http://cmder.net/</a></p>
<h2 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"><span class="comment"># 使用vim命令删除:直接连着按下d键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按下i键，拷贝下面的命令修改为阿里云的源</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ zesty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ zesty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ zesty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ zesty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ zesty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ zesty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ zesty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ zesty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ zesty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ zesty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按下 : vim 命令 wq 保存退出</span></span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h2 id="ubuntu命令"><a href="#ubuntu命令" class="headerlink" title="ubuntu命令"></a>ubuntu命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 系统</span><br><span class="line"><span class="comment"># uname -a               # 查看内核/操作系统/CPU信息</span></span><br><span class="line"><span class="comment"># head -n 1 /etc/issue   # 查看操作系统版本</span></span><br><span class="line"><span class="comment"># cat /proc/cpuinfo      # 查看CPU信息</span></span><br><span class="line"><span class="comment"># hostname               # 查看计算机名</span></span><br><span class="line"><span class="comment"># lspci -tv              # 列出所有PCI设备</span></span><br><span class="line"><span class="comment"># lsusb -tv              # 列出所有USB设备</span></span><br><span class="line"><span class="comment"># lsmod                  # 列出加载的内核模块</span></span><br><span class="line"><span class="comment"># env                    # 查看环境变量</span></span><br><span class="line"></span><br><span class="line">// 资源</span><br><span class="line"><span class="comment"># free -m                # 查看内存使用量和交换区使用量</span></span><br><span class="line"><span class="comment"># df -h                  # 查看各分区使用情况</span></span><br><span class="line"><span class="comment"># du -sh &lt;目录名&gt;         # 查看指定目录的大小</span></span><br><span class="line"><span class="comment"># grep MemTotal /proc/meminfo   # 查看内存总量</span></span><br><span class="line"><span class="comment"># grep MemFree /proc/meminfo    # 查看空闲内存量</span></span><br><span class="line"><span class="comment"># uptime                 # 查看系统运行时间、用户数、负载</span></span><br><span class="line"><span class="comment"># cat /proc/loadavg      # 查看系统负载</span></span><br><span class="line"></span><br><span class="line">// 磁盘和分区</span><br><span class="line"><span class="comment"># mount | column -t      # 查看挂接的分区状态</span></span><br><span class="line"><span class="comment"># fdisk -l               # 查看所有分区</span></span><br><span class="line"><span class="comment"># swapon -s              # 查看所有交换分区</span></span><br><span class="line"><span class="comment"># hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)</span></span><br><span class="line"><span class="comment"># dmesg | grep IDE       # 查看启动时IDE设备检测状况</span></span><br><span class="line"></span><br><span class="line">// 网络</span><br><span class="line"><span class="comment"># ifconfig               # 查看所有网络接口的属性</span></span><br><span class="line"><span class="comment"># iptables -L            # 查看防火墙设置</span></span><br><span class="line"><span class="comment"># route -n               # 查看路由表</span></span><br><span class="line"><span class="comment"># netstat -lntp          # 查看所有监听端口</span></span><br><span class="line"><span class="comment"># netstat -antp          # 查看所有已经建立的连接</span></span><br><span class="line"><span class="comment"># netstat -s             # 查看网络统计信息</span></span><br><span class="line"></span><br><span class="line">// 进程</span><br><span class="line"><span class="comment"># ps -ef                 # 查看所有进程</span></span><br><span class="line"><span class="comment"># top                    # 实时显示进程状态</span></span><br><span class="line"></span><br><span class="line">// 用户</span><br><span class="line"><span class="comment"># w                      # 查看活动用户</span></span><br><span class="line"><span class="comment"># id &lt;用户名&gt;             # 查看指定用户信息</span></span><br><span class="line"><span class="comment"># last                    # 查看用户登录日志</span></span><br><span class="line"><span class="comment"># cut -d: -f1 /etc/passwd   # 查看系统所有用户</span></span><br><span class="line"><span class="comment"># cut -d: -f1 /etc/group    # 查看系统所有组</span></span><br><span class="line"><span class="comment"># crontab -l             # 查看当前用户的计划任务</span></span><br><span class="line"></span><br><span class="line">// 服务</span><br><span class="line"><span class="comment"># chkconfig --list       # 列出所有系统服务</span></span><br><span class="line"><span class="comment"># chkconfig --list | grep on    # 列出所有启动的系统服务</span></span><br></pre></td></tr></table></figure>














<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/helaisun/article/details/80712287">win10上linux子系统的开启、升级及使用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/TechSnail/p/7754969.html">Ubuntu修改apt-get源</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/15/IHostedService%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E6%91%98%E8%A6%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/15/IHostedService%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E6%91%98%E8%A6%81/" class="post-title-link" itemprop="url">IHostedService后台任务摘要</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-15 11:14:02" itemprop="dateCreated datePublished" datetime="2020-01-15T11:14:02+00:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HostService/" itemprop="url" rel="index"><span itemprop="name">HostService</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h2><p>摘自：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&tabs=visual-studio">Background tasks with hosted services in ASP.NET Core</a></p>
<p>BackgroundService is a base class for implementing a long running IHostedService.</p>
<p>ExecuteAsync(CancellationToken) is called to run the background service. The implementation returns a Task that represents the entire lifetime of the background service. No further services are started until ExecuteAsync becomes asynchronous, such as by calling . Avoid performing long, blocking initialization work in . The host blocks in StopAsync(CancellationToken) waiting for to complete.awaitExecuteAsyncExecuteAsync</p>
<p>The cancellation token is triggered when IHostedService.StopAsync is called. Your implementation of should finish promptly when the cancellation token is fired in order to gracefully shut down the service. Otherwise, the service ungracefully shuts down at the shutdown timeout. For more information, see the IHostedService interface section.ExecuteAsync</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当继承 <code>IHostedService</code> 接口实现 <code>BackgroundService</code> 或者 <code>BackgroundTasks</code> ，其实现类在注入时，不受注入的先后顺序影响。</p>
<p>下面的例子，<code>ConsumerManager</code> 依赖 <code>IKafkaEventBusContainer</code> 的实现：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serviceCollection.AddHostedService&lt;ConsumerManager&gt;();</span><br><span class="line">serviceCollection.AddSingleton&lt;IKafkaEventBusContainer, EventBusContainer&gt;();</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&tabs=visual-studio">Background tasks with hosted services in ASP.NET Core</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/13/CSharp%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/CSharp%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">C#线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-13 14:49:00" itemprop="dateCreated datePublished" datetime="2020-01-13T14:49:00+00:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="index"><span itemprop="name">线程池</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>“线程池”就是用来存放“线程”的对象池。</p>
<p>作用：因为创建一个线程的代价较高，因此我们使用线程池设法复用线程。</p>
<h2 id="CLR线程池"><a href="#CLR线程池" class="headerlink" title="CLR线程池"></a>CLR线程池</h2><p>在.NET中，CLR线程和操作系统线程对应，您可以简单地认为.NET中的Thread对象便封装了一个操作系统线程，并附带一些托管环境下所需要的数据（如GC Handle）。而CLR线程池便是存放这些CLR线程的对象池。Thread对象只有当真正Start了之后，CLR才会创建一个操作系统线程与它绑定。</p>
<p>ThreadPool类的两个静态方法：QueueUserWorkItem和UnsafeUserQueueWorkItem向CLR线程池中添加任务（一个WorkCallback委托对象），这两个方法的区别，在于前者会收集调用方的ExecutionContext，也就是保留了的当前线程的执行信息（如认证或语言文化等），使任务最终会在“创建”时刻的环境中执行——后者就不会。因此，如果比较两个方法的绝对性能，Unsafe方法会略胜一筹。但是平时还是建议使用QueueUserWorkItem方法，因为保留执行上下文会避免很多麻烦事情，且这点性能损耗其实算不上什么。</p>
<p>注：</p>
<p>ASP.NET在得到一个请求后，也会将这个请求处理的任务交由CLR线程池去执行——请注意，它们最多只是添加任务而已，并不表示任务会立即执行。所有添加到CLR线程池的任务都会在合适的时候得以执行——可能马上，也可能要稍等片刻，甚至更久。简单的概括说来，便是线程池内有空闲的线程，或线程池所管理的线程数量还没有达到上限的时候。如果有空闲的线程，线程池就会立即让它领取一个任务执行。如果是第二种情况，线程池便会创建新的Thread对象。由于让操作系统管理太多线程反而会造成性能下降，因此CLR线程池会有一个上限。</p>
<p>对于ASP.NET应用程序来说，CLR线程池容量代表了应用程序最多可以同时执行的请求数量。对于托管在IIS上的ASP.NET执行环境来说，这个值由全局配置决定。这个配置在machine.config文件中system.web/processModel节点中，为maxWorkerThreads属性，它决定了为单个处理器分配的线程数。如果这个值为40，且机器上拥有4个处理器（2 * 2CPU），那么这台机器目前的配置表示在同一时刻，ASP.NET可以同时处理160个请求。</p>
<p>既然有最大值，也就相应有了最小值，它代表了CLR线程池“总是会保留”的最少线程数量。由于线程会占用资源，如在默认情况下，每个线程将获得1MB大小的栈空间3。所以如果在系统中保留太多空闲线程对资源也是一种浪费。因此，CLR线程池在使用大量线程处理完大量任务之后，也会逐步地释放线程，直至到达最小值。CLR线程池的最小线程数量确保了在任务数量较少的情况下，新来的任务可以立即执行，从而省去了创建新线程的时间。在普通应用程序中这个值为“处理器数 * 1”，而在ASP.NET应用程序中这个值配置在machine.config文件中system.web/processModel节点的minWorkerThreads属性中4。</p>
<p>对于processModel节点的数据，ASP.NET只会读取machine.config中的全局配置信息，这意味着我们不能使用web.config为不同应用程序配置不同的参数。如果我们要实现应用程序级别的配置，那么必须使用ThreadPool类中提供的API进行设置。</p>
<p>CLR线程池限制了线程的创建速度不超过每秒2个。这样，即使在某个瞬时获得了大量的任务，CLR线程池也可以使用相对较少的线程来完成所有工作。</p>
<p>但是，还有一种情况也值得考虑。例如，对于一个比较繁忙的Web应用程序来说，一打开便会涌入大量的连接。由于线程的创建速度有限，因此可以执行的请求数量也只能慢慢增加。对于这种您预料到会产生大量线程，而且忙碌状况会持续一段时间的情况，限制线程的创建速度反而会带来损伤效率。这时，您就可以手动设置CLR线程池的最小线程数量。如果此时CLR线程池中拥有的线程数量较少，那么系统就会立即创建一定数量的线程来达到这个最小值。设置和获取CLR线程池最小线程数量的接口为：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetMinThreads</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> workerThreads, <span class="keyword">out</span> <span class="built_in">int</span> completionPortThreads</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">SetMinThreads</span>(<span class="params"><span class="built_in">int</span> workerThreads, <span class="built_in">int</span> completionPortThreads</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetAvailableThreads</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> workerThreads, <span class="keyword">out</span> <span class="built_in">int</span> completionPortThreads</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool?view=netcore-3.1">ThreadPool 类</a></p>
<p>注意：</p>
<p>无论是设置还是获取到的这些数值，都与处理器数量没有任何关系了。也就是说，在一台2 * 2CPU的机器上运行一个普通的.NET应用程序时：</p>
<ul>
<li>调用GetMaxThreads方法将获得1000，表示CLR线程池最大容量为1000（250 * 4），而不是250。</li>
<li>调用SetMinThreads并传入100，表示CLR线程池所拥有的最小线程数量为100，而不是400（100 * 4）。</li>
</ul>
<h2 id="独立线程池"><a href="#独立线程池" class="headerlink" title="独立线程池"></a>独立线程池</h2><p>在一个.NET应用程序中会有一个CLR线程池，可以使用ThreadPool类中的静态方法来使用这个线程池。整个进程内部几乎所有的任务都会依赖这个线程池。由于开发人员对于统一的线程池无法做到精确控制，因此在一些特别的需要就无法满足了。举个最常见例子：控制运算能力。</p>
<p>我们可以简单的认为，在同样的环境下，一个任务使用的线程数量越多，它所获得的运算能力就比另一个线程数量较少的任务要来得多。运算能力自然就涉及到任务执行的快慢。</p>
<p>可以设想一下，有一个生产任务，和一个消费任务，它们使用一个队列做临时存储。在理想情况下，生产和消费的速度应该保持相同，这样可以带来最好的吞吐量。如果生产任务执行较快，则队列中便会产生堆积，反之消费任务就会不断等待，吞吐量也会下降。因此，在实现的时候，我们往往会为生产任务和消费任务分别指派独立的线程池，并且通过增加或减少线程池内线程数量来条件运算能力，使生产和消费的步调达到平衡。</p>
<p>如果需要在同一进程内创建多个线程池，可以借助 <a target="_blank" rel="noopener" href="https://github.com/amibar/SmartThreadPool">SmartThreadPool</a></p>
<h2 id="IO线程池"><a href="#IO线程池" class="headerlink" title="IO线程池"></a>IO线程池</h2><p>IO线程池便是为异步IO服务的线程池。</p>
<p>BeginGetResponse将发起一个利用IOCP的异步IO操作，并在结束时调用HandleAsyncCallback回调函数。那么，这个回调函数是由哪里的线程执行的呢？没错，就是传说中“IO线程池”的线程。.NET在一个进程中准备了两个线程池，除了上篇文章中所提到的CLR线程池之外，它还为异步IO操作的回调准备了一个IO线程池。IO线程池的特性与CLR线程池类似，也会动态地创建和销毁线程，并且也拥有最大值和最小值。</p>
<p>只可惜，IO线程池也仅仅是那“一整个”线程池，CLR线程池的缺点IO线程池也一应俱全。例如，在使用异步IO方式读取了一段文本之后，下一步操作往往是对其进行分析，这就进入了计算密集型操作了。但对于计算密集型操作来说，如果使用整个IO线程池来执行，我们无法有效的控制某项任务的运算能力。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JeffreyZhao/archive/2009/07/22/thread-pool-1-the-goal-and-the-clr-thread-pool.html">浅谈线程池（上）：线程池的作用及CLR线程池</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JeffreyZhao/archive/2009/07/24/thread-pool-2-dedicate-pool-and-io-pool.html">浅谈线程池（中）：独立线程池的作用及IO线程池</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JeffreyZhao/archive/2009/10/20/thread-pool-3-lab.html">浅谈线程池（下）：相关试验及注意事项</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/10/%E7%90%86%E8%A7%A3.Net%20Standard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/%E7%90%86%E8%A7%A3.Net%20Standard/" class="post-title-link" itemprop="url">理解.Net Standard</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-10 17:11:22" itemprop="dateCreated datePublished" datetime="2020-01-10T17:11:22+00:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Net-Standard/" itemprop="url" rel="index"><span itemprop="name">.Net Standard</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>.NET Standard 是一项 API 规范，每一个特定的版本，都定义了必须实现的基类库（NETStandard.Library）。</p>
<p>如图：</p>
<p><img src="/img/dotnet-tomorrow.png" alt="dotnet-tomorrow.png"></p>
<p>托管框架的每一种实现都有一套自己的基类库。基类库（BCL）包含诸如异常处理、字符串、XML、I/O、网络和集合这样的类。</p>
<p>.NET Standard 是一项实现BCL 的规范。由于.NET 实现需要遵循这项规范，所以应用程序开发人员就不用担心每一种托管框架实现的BCL 不同。</p>
<p>框架类库（FCL），如 WPF、WCF、ASP.NET，不包含在 BCL 中，因此，也就不包含在.NET Standard 中。</p>
<p>.NET Standard 与.NET 实现之间的关系就和 HTML 规范与浏览器之间的关系一样。后者是前者的实现。</p>
<p>因此，.NET Framework、Xamarin 和.NET Core，每一种托管框架都实现了.NET Standard 中的 BCL。随着计算机工业不断推出新的硬件和操作系统，将来还会出现新的.NET 托管框架。该标准让应用程序开发人员知道，他们可以依赖于一套始终如一的 API。</p>
<p>每个.NET 版本都对应一个.NET Standard 版本。</p>
<p>版本对应图：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200110132446.png" alt="QQ截图20200110132446.png"></p>
<p>API 一致，将应用程序移植到不同的托管实现以及提供工具都会更简单。</p>
<p>.NET Standard 被定义为一个单独的 NuGet 包，因为所有的.NET 实现都必须支持它。工具变得简单了，因为对于特定的版本，它们有一套相同的 API。你还可以针对多个.NET 实现构建一个库项目。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/dotnet/introducing-net-standard/">Introducing .NET Standard</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2017/10/dotnet-core-standard-difference/">.NET Core 和.NET Standard 有什么不同</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/dotnet/standard/blob/master/docs/versions.md">.NET Standard Versions</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/10/TPL%20DataFlow%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/TPL%20DataFlow%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">TPL DataFlow笔记（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-10 16:50:01" itemprop="dateCreated datePublished" datetime="2020-01-10T16:50:01+00:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TPL-DataFlow/" itemprop="url" rel="index"><span itemprop="name">TPL DataFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/haoxinyue/archive/2013/03/01/2938953.html">TPL DataFlow初探（二）</a></p>
<p><a target="_blank" rel="noopener" href="https://syxdevcode.github.io/2020/01/10/TPL%20DataFlow%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">TPL DataFlow初探（二）</a>简单的介绍了TDF提供的一些Block，通过对这些Block配置和组合，可以满足很多的数据处理的场景。这一篇将继续介绍与这些Block配置的相关类，和挖掘一些高级功能。</p>
<p>在一些Block的构造函数中，我们常常可以看见需要你输入 <code>DataflowBlockOptions</code> 类型或者它的两个派生类型<code>ExecutionDataflowBlockOptions</code> 和 <code>GroupingDataflowBlockOptions</code>。</p>
<h2 id="DataflowBlockOptions"><a href="#DataflowBlockOptions" class="headerlink" title="DataflowBlockOptions"></a>DataflowBlockOptions</h2><p><code>DataflowBlockOptions</code> 有五个属性：<code>BoundedCapacity</code>，<code>CancellationToken</code>，<code>MaxMessagesPerTask</code>，<code>NameFormat</code> 和 <code>TaskScheduler</code>。</p>
<h3 id="用BoundedCapacity来限定容量"><a href="#用BoundedCapacity来限定容量" class="headerlink" title="用BoundedCapacity来限定容量"></a>用BoundedCapacity来限定容量</h3><p>这个属性用来限制一个Block中最多可以缓存数据项的数量，大多数Block都支持这个属性，这个值默认是<code>DataflowBlockOptions.Unbounded = -1</code>，也就是说没有限制。开发人员可以制定这个属性设置数量的上限。那后面的新数据将会延迟。比如说用一个 <code>BufferBlock</code> 连接一个 <code>ActionBlock</code>，如果在 <code>ActionBlock</code> 上面设置了上限，<code>ActionBlock</code> 处理的操作速度比较慢，留在 <code>ActionBlock</code> 中的数据到达了上限，那么余下的数据将留在<code>BufferBlock</code>中，直到 <code>ActionBlock</code> 中的数据量低于上限。这种情况常常会发生在生产者生产的速度大于消费者速度的时候，导致的问题是内存越来越大，数据操作越来越延迟。我们可以通过一个 <code>BufferBlock</code> 连接多个<code>ActionBlock</code> 来解决这样的问题，也就是负载均衡。一个 <code>ActionBlock</code> 满了，就会放到另外一个 <code>ActionBlock</code> 中去了。</p>
<h3 id="用CancellationToken来取消操作"><a href="#用CancellationToken来取消操作" class="headerlink" title="用CancellationToken来取消操作"></a>用CancellationToken来取消操作</h3><p>TPL中常用的类型。在Block的构造函数中放入 <code>CancellationToken</code>，Block将在它的整个生命周期中全程监控这个对象，只要在这个Block结束运行（调用Complete方法）前，用 <code>CancellationToken</code> 发送取消请求，该Block将会停止运行，如果Block中还有没有处理的数据，那么将不会再被处理。</p>
<h3 id="用MaxMessagesPerTask控制公平性"><a href="#用MaxMessagesPerTask控制公平性" class="headerlink" title="用MaxMessagesPerTask控制公平性"></a>用MaxMessagesPerTask控制公平性</h3><p>每一个Block内部都是异步处理，都是使用TPL的 <code>Task</code>。TDF的设计是在保证性能的情况下，尽量使用最少的任务对象来完成数据的操作，这样效率会高一些，一个任务执行完成一个数据以后，任务对象并不会销毁，而是会保留着去处理下一个数据，直到没有数据处理的时候，Block才会回收掉这个任务对象。但是如果数据来自于多个Source，公平性就很难保证。从其他Source来的数据必须要等到早前的那些Source的数据都处理完了才能被处理。这时我们就可以通过<code>MaxMessagesPerTask</code> 来控制。这个属性的默认值还是 <code>DataflowBlockOptions.Unbounded=-1</code>，表示没有上限。假如这个数值被设置为1的话，那么单个任务只会处理一个数据。这样就会带来极致的公平性，但是将带来更多的任务对象消耗。</p>
<h3 id="用NameFormat来定义Block名称"><a href="#用NameFormat来定义Block名称" class="headerlink" title="用NameFormat来定义Block名称"></a>用NameFormat来定义Block名称</h3><p>MSDN上说属性 <code>NameFormat</code> 用来获取或设置查询块的名称时要使用的格式字符串。</p>
<p>Block的名字 <code>Name=string.format(NameFormat, block.GetType ().Name, block.Completion.Id)</code>。所以当我们输入”{0}”的时候，名字就是 <code>block.GetType ().Name</code>，如果我们数据的是”{1}”，那么名字就是<code>block.Completion.Id</code>。如果是“{2}”，那么就会抛出异常。</p>
<h3 id="用TaskScheduler来调度Block行为"><a href="#用TaskScheduler来调度Block行为" class="headerlink" title="用TaskScheduler来调度Block行为"></a>用TaskScheduler来调度Block行为</h3><p><code>TaskScheduler</code> 是非常重要的属性。同样这个类型来源于TPL。每个Block里面都使用 <code>TaskScheduler</code> 来调度行为，无论是源Block和目标Block之间的数据传递，还是用户自定义的执行数据方法委托，都是使用的 <code>TaskScheduler</code>。如果没有特别设置的话，将使用 <code>TaskScheduler.Default（System.Threading.Tasks.ThreadPoolTaskScheduler）</code>来调度。我们可以使用其他的一些继承于 <code>TaskScheduler</code> 的类型来设置这个调度器，一旦设置了以后，Block中的所有行为都会使用这个调度器来执行。<code>.Net Framework 4</code> 中内建了两个 <code>Scheduler</code> ，一个是默认的 <code>ThreadPoolTaskScheduler</code> ，另一个是用于UI线程切换的 <code>SynchronizationContextTaskScheduler</code> 。如果你使用的Block设计到UI的话，那可以使用后者，这样在UI线程切换上面将更加方便。</p>
<p>.Net Framework 4.5 中，还有一个类型被加入到 <code>System.Threading.Tasks</code> 名称空间下：<code>ConcurrentExclusiveSchedulerPair</code> 。这个类是两个 <code>TaskScheduler</code> 的组合。它提供两个 <code>TaskScheduler</code>： <code>ConcurrentScheduler</code> 和 <code>ExclusiveScheduler</code>；我们可以把这两个 <code>TaskScheduler</code> 构造进要使用的Block中。他们保证了在没有排他任务的时候（使用 <code>ExclusiveScheduler</code> 的任务），其他任务（使用<code>ConcurrentScheduler</code>）可以同步进行，当有排他任务在运行的时候，其他任务都不能运行。其实它里面就是一个读写锁。这在多个Block操作共享资源的问题上是一个很方便的解决方案。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ActionBlock&lt;<span class="built_in">int</span>&gt; readerAB1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ActionBlock&lt;<span class="built_in">int</span>&gt; readerAB2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ActionBlock&lt;<span class="built_in">int</span>&gt; readerAB3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ActionBlock&lt;<span class="built_in">int</span>&gt; writerAB1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BroadcastBlock</span>&lt;<span class="title">int</span>&gt; bb</span> = <span class="keyword">new</span> BroadcastBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; &#123; <span class="keyword">return</span> i; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcurrentExclusiveSchedulerPair pair = <span class="keyword">new</span> ConcurrentExclusiveSchedulerPair();</span><br><span class="line"></span><br><span class="line">    readerAB1 = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ReaderAB1 begin handling.&quot;</span> + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    , <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; TaskScheduler = pair.ConcurrentScheduler &#125;);</span><br><span class="line"></span><br><span class="line">    readerAB2 = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ReaderAB2 begin handling.&quot;</span> + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    , <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; TaskScheduler = pair.ConcurrentScheduler &#125;);</span><br><span class="line"></span><br><span class="line">    readerAB3 = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ReaderAB3 begin handling.&quot;</span> + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">        Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    , <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; TaskScheduler = pair.ConcurrentScheduler &#125;);</span><br><span class="line"></span><br><span class="line">    writerAB1 = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.ForegroundColor = ConsoleColor.Red;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;WriterAB1 begin handling.&quot;</span> + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">        Console.ResetColor();</span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    , <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; TaskScheduler = pair.ExclusiveScheduler &#125;);</span><br><span class="line"></span><br><span class="line">    bb.LinkTo(readerAB1);</span><br><span class="line">    bb.LinkTo(readerAB2);</span><br><span class="line">    bb.LinkTo(readerAB3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bb.Post(<span class="number">1</span>);</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">6000</span>);</span><br><span class="line">            writerAB1.Post(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161456-7b8227892cb14d20b5347fa310224619.jpg" alt="01161456-7b8227892cb14d20b5347fa310224619.jpg"></p>
<h3 id="用MaxDegreeOfParallelism来并行处理"><a href="#用MaxDegreeOfParallelism来并行处理" class="headerlink" title="用MaxDegreeOfParallelism来并行处理"></a>用MaxDegreeOfParallelism来并行处理</h3><p>通常，Block中处理数据都是单线程的，一次只能处理一个数据，比如说 <code>ActionBlock</code> 中自定义的代理。使用 <code>MaxDegreeOfParallelism</code> 可以让你并行处理这些数据。属性的定义是最大的并行处理个数。如果定义成-1的话，那就是没有限制。用户需要在实际情况中选择这个值的大小，并不是越大越好。如果是平行处理的话，还应该考虑是否有共享资源。</p>
<h2 id="TDF中的负载均衡"><a href="#TDF中的负载均衡" class="headerlink" title="TDF中的负载均衡"></a>TDF中的负载均衡</h2><p>我们可以使用Block很方便的构成一个生产者消费者的模式来处理数据。当生产者产生数据的速度快于消费者的时候，消费者Block的Buffer中的数据会越来越多，消耗大量的内存，数据处理也会延时。这时，我们可以用一个生产者Block连接多个消费者Block来解决这个问题。由于多个消费者Block一定是并行处理，所以对共享资源的处理一定要做同步处理。</p>
<h3 id="使用BoundedCapacity属性来实现"><a href="#使用BoundedCapacity属性来实现" class="headerlink" title="使用BoundedCapacity属性来实现"></a>使用BoundedCapacity属性来实现</h3><p>当连接多个 <code>ActionBlock</code> 的时候，可以通过设置 <code>ActionBlock</code> 的 <code>BoundedCapacity</code> 属性。当第一个满了，就会放到第二个，第二个满了就会放到第三个。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferBlock</span>&lt;<span class="title">int</span>&gt; bb</span> = <span class="keyword">new</span> BufferBlock&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActionBlock</span>&lt;<span class="title">int</span>&gt; ab1</span> = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ab1 handle data&quot;</span> + i + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">    &#125;</span><br><span class="line">    , <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; BoundedCapacity = <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActionBlock</span>&lt;<span class="title">int</span>&gt; ab2</span> = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ab2 handle data&quot;</span> + i + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">    &#125;</span><br><span class="line">    , <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; BoundedCapacity = <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActionBlock</span>&lt;<span class="title">int</span>&gt; ab3</span> = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ab3 handle data:&quot;</span> + i + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">    &#125;</span><br><span class="line">    , <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; BoundedCapacity = <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bb.LinkTo(ab1);</span><br><span class="line">    bb.LinkTo(ab2);</span><br><span class="line">    bb.LinkTo(ab3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bb.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161504-e9c265982cb54d0eb844ee1a1be1e92d.jpg" alt="01161504-e9c265982cb54d0eb844ee1a1be1e92d.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/10/TPL%20DataFlow%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/10/TPL%20DataFlow%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">TPL DataFlow笔记（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-10 10:27:52" itemprop="dateCreated datePublished" datetime="2020-01-10T10:27:52+00:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TPL-DataFlow/" itemprop="url" rel="index"><span itemprop="name">TPL DataFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/haoxinyue/archive/2013/03/01/2938959.html">TPL DataFlow初探（一）</a></p>
<p>属性 <code>TPL Dataflow</code> 是微软面向高并发应用而推出的一个类库。借助于异步消息传递与管道，它可以提供比线程池更好的控制，也比手工线程方式具备更好的性能。我们常常可以消息传递，生产-消费模式或Actor-Agent模式中使用。在TDF是构建于 <code>Task Parallel Library</code> (TPL)之上的，它是我们开发高性能，高并发的应用程序的又一利器。</p>
<p>TDF的主要作用就是 <code>Buffering Data</code> 和 <code>Processing Data</code> ，在TDF中，有两个非常重要的接口，<code>ISourceBlock&lt;T&gt;</code> 和 <code>ITargetBlock&lt;T&gt;</code> 接口。继承于 <code>ISourceBlock&lt;T&gt;</code> 的对象时作为提供数据的数据源对象-生产者，而继承于 <code>ITargetBlock&lt;T&gt;</code> 接口类主要是扮演目标对象-消费者。在这个类库中，<code>System.Threading.Tasks.Dataflow</code> 名称空间下，提供了很多以Block名字结尾的类，<code>ActionBlock</code>，<code>BufferBlock</code>，<code>TransformBlock</code>，<code>BroadcastBlock</code> 等9个Block，我们在开发中通常使用单个或多个Block组合的方式来实现一些功能。</p>
<p>支持的版本：</p>
<p><img src="/img/QQ%E6%88%AA%E5%9B%BE20200110135719.png" alt="QQ截图20200110135719.png"></p>
<p>备注：<br>TPL 数据流库（<code>System.Threading.Tasks.Dataflow</code> 命名空间）不随 .NET 一起分发。 若要在 Visual Studio 中安装 <code>System.Threading.Tasks.Dataflow</code> 命名空间，请打开项目，选择“项目” 菜单中的“管理 NuGet 包” ，再在线搜索 <code>System.Threading.Tasks.Dataflow</code> 包。 或者，若要使用 .NET Core CLI 进行安装，请运行 <code>dotnet add package System.Threading.Tasks.Dataflow</code>。</p>
<h2 id="BufferBlock"><a href="#BufferBlock" class="headerlink" title="BufferBlock"></a>BufferBlock</h2><p><code>BufferBlock</code> 是TDF中最基础的 <code>Block</code>。<code>BufferBlock</code> 提供了一个有界限或没有界限的 <code>Buffer</code>，该 <code>Buffer</code> 中存储T。该 <code>Block</code> 很像 <code>BlockingCollection&lt;T&gt;</code> 。可以用过 <code>Post</code> 往里面添加数据，也可以通过<code>Receive</code> 方法阻塞或异步的的获取数据，数据处理的顺序是 <code>FIFO</code> 的。它也可以通过Link向其他 <code>Block</code> 输出数据。</p>
<p><img src="/img/01161517-0f5c7949243a4f9b995672da83950fb9.png" alt="01161517-0f5c7949243a4f9b995672da83950fb9.png"></p>
<p>简单的同步的生产者消费者代码示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">BufferBlock</span>&lt;<span class="title">int</span>&gt; m_buffer</span> = <span class="keyword">new</span> BufferBlock&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Producer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> item = Produce();</span><br><span class="line">        m_buffer.Post(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Consumer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> item = m_buffer.Receive();</span><br><span class="line">        Process(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = Task.Factory.StartNew(Producer);</span><br><span class="line">    <span class="keyword">var</span> c = Task.Factory.StartNew(Consumer);</span><br><span class="line">    Task.WaitAll(p,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.bufferblock-1?view=netcore-3.1">BufferBlock<T> 类</a></p>
<h2 id="ActionBlock"><a href="#ActionBlock" class="headerlink" title="ActionBlock"></a>ActionBlock</h2><p><code>ActionBlock</code> 实现 <code>ITargetBlock</code>，说明它是消费数据的，也就是对输入的一些数据进行处理。它在构造函数中，允许输入一个委托，来对每一个进来的数据进行一些操作。如果使用<code>Action(T)</code> 委托，那说明每一个数据的处理完成需要等待这个委托方法结束，如果使用了 <code>Func&lt;TInput, Task&gt;)</code> 来构造的话，那么数据的结束将不是委托的返回，而是Task的结束。默认情况下，<code>ActionBlock</code> 会 <code>FIFO</code> 的处理每一个数据，而且一次只能处理一个数据，一个处理完了再处理第二个，但也可以通过配置来并行的执行多个数据。</p>
<p><img src="/img/01161519-5f62f15310e548b9a06f3fa9b603a149.png" alt="01161519-5f62f15310e548b9a06f3fa9b603a149.png"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActionBlock</span>&lt;<span class="title">int</span>&gt; abSync</span> = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(i + <span class="string">&quot; ThreadId:&quot;</span> + Thread.CurrentThread.ManagedThreadId + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        abSync.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161524-b5276dfab96c4200aa72b906a3b4009b.jpg" alt="01161524-b5276dfab96c4200aa72b906a3b4009b.jpg"></p>
<p>可见，<code>ActionBlock</code> 是顺序处理数据的，这也是 <code>ActionBlock</code> 一大特性之一。主线程在往 <code>ActionBlock</code> 中 <code>Post</code> 数据以后马上返回，具体数据的处理是另外一个线程来做的。数据是异步处理的，但处理本身是同步的，这样在一定程度上保证数据处理的准确性。下面的例子是使用async和await。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActionBlock</span>&lt;<span class="title">int</span>&gt; abSync2</span> = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;(<span class="keyword">async</span> (i) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">1000</span>);</span><br><span class="line">    Console.WriteLine(i + <span class="string">&quot; ThreadId:&quot;</span> + Thread.CurrentThread.ManagedThreadId + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161525-ab3d15e3e91641be9a15988a88effddf.jpg" alt="01161525-ab3d15e3e91641be9a15988a88effddf.jpg"></p>
<p>虽然还是1秒钟处理一个数据，但是处理数据的线程会有不同。</p>
<p>如果你想异步处理多个消息的话，<code>ActionBlock</code> 也提供了一些接口，让你轻松实现。在 <code>ActionBlock</code> 的构造函数中，可以提供一个 <code>ExecutionDataflowBlockOptions</code> 的类型，让你定义 <code>ActionBlock</code> 的执行选项，在下面了例子中，我们定义了 <code>MaxDegreeOfParallelism</code> 选项，设置为3。目的的让 <code>ActionBlock</code> 中的Item最多可以3个并行处理。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActionBlock</span>&lt;<span class="title">int</span>&gt; abAsync</span> = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    Console.WriteLine(i + <span class="string">&quot; ThreadId:&quot;</span> + Thread.CurrentThread.ManagedThreadId + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">&#125;, <span class="keyword">new</span> ExecutionDataflowBlockOptions() &#123; MaxDegreeOfParallelism = <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        abAsync.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161530-c51b7a2e84254edebe2d85a63e3bf576.jpg" alt="01161530-c51b7a2e84254edebe2d85a63e3bf576.jpg"></p>
<p>运行程序，我们看见，每3个数据几乎同时处理，并且他们的线程ID也是不一样的。</p>
<p><code>ActionBlock</code> 也有自己的生命周期，所有继承 <code>IDataflowBlock</code> 的类型都有 <code>Completion</code> 属性和 <code>Complete</code> 方法。调用 <code>Complete</code> 方法是让 <code>ActionBlock</code> 停止接收数据，而 <code>Completion</code> 属性则是一个Task，是在 <code>ActionBlock</code> 处理完所有数据时候会执行的任务，我们可以使用 <code>Completion.Wait()</code> 方法来等待 <code>ActionBlock</code> 完成所有的任务，<code>Completion</code> 属性只有在设置了 <code>Complete</code> 方法后才会有效。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        abAsync.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line">    abAsync.Complete();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line">    abAsync.Completion.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Process finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161531-151aebc85b31469894f4cae064eac264.jpg" alt="01161531-151aebc85b31469894f4cae064eac264.jpg"></p>
<h2 id="TransformBlock"><a href="#TransformBlock" class="headerlink" title="TransformBlock"></a>TransformBlock</h2><p><code>TransformBlock</code> 是TDF提供的另一种 <code>Block</code> ，顾名思义它常常在数据流中充当数据转换处理的功能。在<code>TransformBlock</code> 内部维护了2个 <code>Queue</code>，一个 <code>InputQueue</code>，一个 <code>OutputQueue</code>。<code>InputQueue</code> 存储输入的数据，而通过 <code>Transform</code> 处理以后的数据则放在 <code>OutputQueue</code>，<code>OutputQueue</code> 就好像是一个 <code>BufferBlock</code>。最终我们可以通过 <code>Receive</code> 方法来阻塞的一个一个获取 <code>OutputQueue</code> 中的数据。 <code>TransformBlock</code> 的 <code>Completion.Wait()</code> 方法只有在 <code>OutputQueue</code> 中的数据为0的时候才会返回。</p>
<p><img src="/img/01161534-bdb94184e8814888b2fcc44c75c89a76.png" alt="01161534-bdb94184e8814888b2fcc44c75c89a76.png"></p>
<p>举个例子，我们有一组网址的URL，我们需要对每个URL下载它的HTML数据并存储。那我们通过如下的代码来完成：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransformBlock</span>&lt;<span class="title">string</span>, <span class="title">string</span>&gt; tbUrl</span> = <span class="keyword">new</span> TransformBlock&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;((url) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    WebClient webClient = <span class="keyword">new</span> WebClient();</span><br><span class="line">    <span class="keyword">return</span> webClient.DownloadString(<span class="keyword">new</span> Uri(url));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestDownloadHTML</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tbUrl.Post(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">    tbUrl.Post(<span class="string">&quot;www.sina.com.cn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> baiduHTML = tbUrl.Receive();</span><br><span class="line">    <span class="built_in">string</span> sinaHTML = tbUrl.Receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，<code>Post</code> 操作和 <code>Receive</code> 操作可以在不同的线程中进行，<code>Receive</code> 操作同样也是阻塞操作，在 <code>OutputQueue</code> 中有可用的数据时，才会返回。</p>
<h2 id="TransformManyBlock"><a href="#TransformManyBlock" class="headerlink" title="TransformManyBlock"></a>TransformManyBlock</h2><p><code>TransformManyBlock</code> 和 <code>TransformBlock</code> 非常类似，关键的不同点是，<code>TransformBlock</code> 对应于一个输入数据只有一个输出数据，而 <code>TransformManyBlock</code> 可以有多个，及可以从 <code>InputQueue</code> 中取一个数据出来，然后放多个数据放入到 <code>OutputQueue</code> 中。</p>
<p><img src="/img/01161536-f582de1c67994e409b4f7835251b3c53.png" alt="01161536-f582de1c67994e409b4f7835251b3c53.png"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TransformManyBlock&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; tmb = <span class="keyword">new</span> TransformManyBlock&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;((i) =&gt; &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; i, i + <span class="number">1</span> &#125;; &#125;);</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>&gt; ab = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; Console.WriteLine(i));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmb.LinkTo(ab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmb.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Finished post&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161542-6d6c0dd2327a43f5982ad5405487b717.jpg" alt="01161542-6d6c0dd2327a43f5982ad5405487b717.jpg"></p>
<h2 id="BroadcastBlock"><a href="#BroadcastBlock" class="headerlink" title="BroadcastBlock"></a>BroadcastBlock</h2><p><code>BroadcastBlock</code> 的作用不像 <code>BufferBlock</code> ，它是使命是让所有和它相联的目标 <code>Block</code> 都收到数据的副本，这点从它的命名上面就可以看出来了。还有一点不同的是，<code>BroadcastBlock</code> 并不保存数据，在每一个数据被发送到所有接收者以后，这条数据就会被后面最新的一条数据所覆盖。如没有目标 <code>Block</code> 和 <code>BroadcastBlock</code> 相连的话，数据将被丢弃。但 <code>BroadcastBlock</code> 总会保存最后一个数据，不管这个数据是不是被发出去过，如果有一个新的目标 <code>Block</code> 连上来，那么这个 <code>Block</code> 将收到这个最后一个数据。</p>
<p><img src="/img/01161543-bbfd0d43c8ad434f9af8dab2827c148c.png" alt="01161543-bbfd0d43c8ad434f9af8dab2827c148c.png"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BroadcastBlock&lt;<span class="built_in">int</span>&gt; bb = <span class="keyword">new</span> BroadcastBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; &#123; <span class="keyword">return</span> i; &#125;);</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>&gt; displayBlock = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; Console.WriteLine(<span class="string">&quot;Displayed &quot;</span> + i));</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>&gt; saveBlock = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; Console.WriteLine(<span class="string">&quot;Saved &quot;</span> + i));</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>&gt; sendBlock = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; Console.WriteLine(<span class="string">&quot;Sent &quot;</span> + i));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bb.LinkTo(displayBlock);</span><br><span class="line">    bb.LinkTo(saveBlock);</span><br><span class="line">    bb.LinkTo(sendBlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bb.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161545-e9724f3e074644f5b5d756efe3ea4c02.jpg" alt="01161545-e9724f3e074644f5b5d756efe3ea4c02.jpg"></p>
<p>如果我们在Post以后再添加连接Block的话，那些Block就只会收到最后一个数据了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bb.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    bb.LinkTo(displayBlock);</span><br><span class="line">    bb.LinkTo(saveBlock);</span><br><span class="line">    bb.LinkTo(sendBlock);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteOnceBlock"><a href="#WriteOnceBlock" class="headerlink" title="WriteOnceBlock"></a>WriteOnceBlock</h2><p>如果说 <code>BufferBlock</code> 是最基本的 <code>Block</code> ，那么 <code>WriteOnceBock</code> 则是最最简单的 <code>Block</code> 。它最多只能存储一个数据，一旦这个数据被发送出去以后，这个数据还是会留在Block中，但不会被删除或被新来的数据替换，同样所有的接收者都会收到这个数据的备份。</p>
<p><img src="/img/01161551-f163f3bb35014568ac90dd5d3175d7ee.png" alt="01161551-f163f3bb35014568ac90dd5d3175d7ee.png"></p>
<p>和BroadcastBlock同样的代码，但是结果不一样：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">WriteOnceBlock&lt;<span class="built_in">int</span>&gt; bb = <span class="keyword">new</span> WriteOnceBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; &#123; <span class="keyword">return</span> i; &#125;);</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>&gt; displayBlock = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; Console.WriteLine(<span class="string">&quot;Displayed &quot;</span> + i));</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>&gt; saveBlock = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; Console.WriteLine(<span class="string">&quot;Saved &quot;</span> + i));</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>&gt; sendBlock = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>&gt;((i) =&gt; Console.WriteLine(<span class="string">&quot;Sent &quot;</span> + i));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bb.LinkTo(displayBlock);</span><br><span class="line">    bb.LinkTo(saveBlock);</span><br><span class="line">    bb.LinkTo(sendBlock);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bb.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161558-66b3a94704ba426385f65e0f0d78433e.jpg" alt="01161558-66b3a94704ba426385f65e0f0d78433e.jpg"></p>
<p>WriteOnceBock只会接收一次数据。而且始终保留那个数据。</p>
<p>同样使用Receive方法来获取数据也是一样的结果，获取到的都是第一个数据：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestReceive</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bb.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;1st Receive:&quot;</span> + bb.Receive());</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;2nd Receive:&quot;</span> + bb.Receive());</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;3rd Receive:&quot;</span> + bb.Receive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161605-e4ff0fa705c941059b3d0d6d0087eb25.jpg" alt="01161605-e4ff0fa705c941059b3d0d6d0087eb25.jpg"></p>
<h2 id="BatchBlock"><a href="#BatchBlock" class="headerlink" title="BatchBlock"></a>BatchBlock</h2><p><img src="/img/01161612-424f44c875a64999aa48d0a15a6d2f8a.png" alt="01161612-424f44c875a64999aa48d0a15a6d2f8a.png"></p>
<p><code>BatchBlock</code> 提供了能够把多个单个的数据组合起来处理的功能，如上图。应对有些需求需要固定多个数据才能处理的问题。在构造函数中需要制定多少个为一个 <code>Batch</code>，一旦它收到了那个数量的数据后，会打包放在它的 <code>OutputQueue</code> 中。当 <code>BatchBlock</code> 被调用 <code>Complete</code> 告知 <code>Post</code> 数据结束的时候，会把 <code>InputQueue</code> 中余下的数据打包放入 <code>OutputQueue</code> 中等待处理，而不管 <code>InputQueue</code> 中的数据量是不是满足构造函数的数量。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">BatchBlock&lt;<span class="built_in">int</span>&gt; bb = <span class="keyword">new</span> BatchBlock&lt;<span class="built_in">int</span>&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;<span class="built_in">int</span>[]&gt; ab = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">int</span>[]&gt;((i) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="built_in">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> m <span class="keyword">in</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        s += m + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(s);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bb.LinkTo(ab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bb.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line">    bb.Complete();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Finished post&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161613-22d4c06138354a2db448bc5bfa3c9d6b.jpg" alt="01161613-22d4c06138354a2db448bc5bfa3c9d6b.jpg"></p>
<p><code>BatchBlock</code> 执行数据有两种模式：贪婪模式和非贪婪模式。贪婪模式是默认的。贪婪模式是指任何Post到<code>BatchBlock</code>，<code>BatchBlock</code> 都接收，并等待个数满了以后处理。非贪婪模式是指 <code>BatchBlock</code> 需要等到构造函数中设置的 <code>BatchSize</code> 个数的 <code>Source</code> 都向 <code>BatchBlock</code> 发数据，<code>Post</code> 数据的时候才会处理。不然都会留在Source的Queue中。也就是说 <code>BatchBlock</code> 可以使用在每次从N个 <code>Source</code> 那个收一个数据打包处理或从1个 <code>Source</code> 那里收N个数据打包处理。这里的Source是指其他的继承 <code>ISourceBlock</code> 的，用 <code>LinkTo</code> 连接到这个<code>BatchBlock</code> 的 <code>Block</code> 。</p>
<p>在另一个构造参数中 <code>GroupingDataflowBlockOptions</code>，可以通过设置 <code>Greedy</code> 属性来选择是否贪婪模式和 <code>MaxNumberOfGroups</code> 来设置最大产生Batch的数量，如果到达了这个数量，<code>BatchBlock</code> 将不会再接收数据。</p>
<h2 id="JoinBlock"><a href="#JoinBlock" class="headerlink" title="JoinBlock"></a>JoinBlock</h2><p><img src="/img/01161619-5805d12c170c4dd291897abe0fff07f6.png" alt="01161619-5805d12c170c4dd291897abe0fff07f6.png"></p>
<p><code>JoinBlock</code> 一看名字就知道是需要和两个或两个以上的 <code>Source Block</code> 相连接的。它的作用就是等待一个数据组合，这个组合需要的数据都到达了，它才会处理数据，并把这个组合作为一个 <code>Tuple</code> 传递给目标 <code>Block</code>。举个例子，如果定义了 <code>JoinBlock&lt;int, string&gt;</code> 类型，那么 <code>JoinBlock</code> 内部会有两个 <code>ITargetBlock</code>，一个接收int类型的数据，一个接收string类型的数据。那只有当两个 <code>ITargetBlock</code> 都收到各自的数据后，才会放到<code>JoinBlock的OutputQueue</code> 中，输出。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JoinBlock&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; jb = <span class="keyword">new</span> JoinBlock&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line">ActionBlock&lt;Tuple&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;&gt; ab = <span class="keyword">new</span> ActionBlock&lt;Tuple&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;&gt;((i) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i.Item1 + <span class="string">&quot; &quot;</span> + i.Item2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jb.LinkTo(ab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        jb.Target1.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        jb.Target2.Post(i.ToString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Finished post&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161623-de3f5cbecec145d88c3bc4ac70276026.jpg" alt="01161623-de3f5cbecec145d88c3bc4ac70276026.jpg"></p>
<h2 id="BatchedJoinBlock"><a href="#BatchedJoinBlock" class="headerlink" title="BatchedJoinBlock"></a>BatchedJoinBlock</h2><p><img src="/img/01161627-35dfb0f1f22448f6a68d78ea78e6012a.png" alt="01161627-35dfb0f1f22448f6a68d78ea78e6012a.png"></p>
<p><code>BatchedJoinBlock</code> 一看就是 <code>BacthBlock</code> 和 <code>JoinBlick</code> 的组合。<code>JoinBlick</code> 是组合目标队列的一个数据，而 <code>BatchedJoinBlock</code> 是组合目标队列的N个数据，当然这个N可以在构造函数中配置。如果我们定义的是<code>BatchedJoinBlock&lt;int, string&gt;</code>， 那么在最后的 <code>OutputQueue</code> 中存储的是 <code>Tuple&lt;IList&lt;int&gt;, IList&lt;string&gt;&gt;</code>，也就是说最后得到的数据是 <code>Tuple&lt;IList&lt;int&gt;, IList&lt;string&gt;&gt;</code>。它的行为是这样的，还是假设上文的定义，<code>BatchedJoinBlock&lt;int, string&gt;</code>， 构造 <code>BatchSize</code> 输入为3。那么在这个<code>BatchedJoinBlock</code> 种会有两个 <code>ITargetBlock</code>，会接收Post的数据。那什么时候会生成一个 <code>Tuple&lt;IList&lt;int&gt;，IList&lt;string&gt;&gt;</code> 到 <code>OutputQueue</code> 中呢，测试下来并不是我们想的需要有3个int数据和3个string数据，而是只要2个 <code>ITargetBlock</code> 中的数据个数加起来等于3就可以了。3和0,2和1，1和2或0和3的组合都会生成 <code>Tuple&lt;IList&lt;int&gt;，IList&lt;string&gt;&gt;</code>到 <code>OutputQueue</code> 中。可以参看下面的例子：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BatchedJoinBlock&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; bjb = <span class="keyword">new</span> BatchedJoinBlock&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">ActionBlock&lt;Tuple&lt;IList&lt;<span class="built_in">int</span>&gt;, IList&lt;<span class="built_in">string</span>&gt;&gt;&gt; ab = <span class="keyword">new</span> ActionBlock&lt;Tuple&lt;IList&lt;<span class="built_in">int</span>&gt;, IList&lt;<span class="built_in">string</span>&gt;&gt;&gt;((i) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;-----------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> m <span class="keyword">in</span> i.Item1)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(m);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> i.Item2)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bjb.LinkTo(ab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bjb.Target1.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        bjb.Target2.Post(i.ToString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Finished post&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161631-152815cac25746c9a5a04d09bc7cf172.jpg" alt="01161631-152815cac25746c9a5a04d09bc7cf172.jpg"></p>
<p>最后剩下的一个数据1，由于没有满3个，所以一直被保留在Target2中。</p>
<p>TDF中最有用的功能之一就是多个 <code>Block</code> 之间可以组合应用。<code>ISourceBlock</code> 可以连接 <code>ITargetBlock</code> ，一对一，一对多，或多对多。下面的例子就是一个 <code>TransformBlock</code> 和一个 <code>ActionBlock</code> 的组合。<code>TransformBlock</code> 用来把数据*2，并转换成字符串，然后把数据扔到 <code>ActionBlock</code> 中，而 <code>ActionBlock</code> 则用来最后的处理数据打印结果。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActionBlock</span>&lt;<span class="title">string</span>&gt; abSync</span> = <span class="keyword">new</span> ActionBlock&lt;<span class="built_in">string</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(i + <span class="string">&quot; ThreadId:&quot;</span> + Thread.CurrentThread.ManagedThreadId + <span class="string">&quot; Execute Time:&quot;</span> + DateTime.Now);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransformBlock</span>&lt;<span class="title">int</span>, <span class="title">string</span>&gt; tbSync</span> = <span class="keyword">new</span> TransformBlock&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;((i) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> i.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestSync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tbSync.LinkTo(abSync);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tbSync.Post(i);</span><br><span class="line">    &#125;</span><br><span class="line">    tbSync.Complete();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Post finished&quot;</span>);</span><br><span class="line"></span><br><span class="line">    tbSync.Completion.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;TransformBlock process finished&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/01161632-f4dc0afbc9fa49b3a36336842ac52009.jpg" alt="01161632-f4dc0afbc9fa49b3a36336842ac52009.jpg"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow?view=netcore-3.1">System.Threading.Tasks.Dataflow 命名空间</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/dataflow-task-parallel-library?view=netcore-3.1">数据流（任务并行库）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/08/hash%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/hash%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">hash算法笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 15:53:28" itemprop="dateCreated datePublished" datetime="2020-01-08T15:53:28+00:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是Hash"><a href="#什么是Hash" class="headerlink" title="什么是Hash"></a>什么是Hash</h2><p>Hash也称散列、哈希，对应的英文都是Hash。Hash算法,也叫散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。</p>
<p>基本原理就是把任意长度的输入，通过Hash算法变成固定长度的输出。这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。活动开发中经常使用的MD5和SHA都是历史悠久的Hash算法。</p>
<p>echo md5(“这是一个测试文案”);</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果：2124968af757ed51e71e6abeac04f98d</span></span><br></pre></td></tr></table></figure>

<p>在这个例子里，这是一个测试文案是原始值，2124968af757ed51e71e6abeac04f98d 就是经过hash算法得到的Hash值。整个Hash算法的过程就是把原始任意长度的值空间，映射成固定长度的值空间的过程。</p>
<h2 id="Hash的特点"><a href="#Hash的特点" class="headerlink" title="Hash的特点"></a>Hash的特点</h2><p>一个优秀的 hash 算法，将能实现：</p>
<ul>
<li>正向快速：给定明文和 hash 算法，在有限时间和有限资源内能计算出 hash 值。</li>
<li>逆向困难：给定（若干） hash 值，在有限时间内很难（基本不可能）逆推出明文。</li>
<li>输入敏感：原始输入信息修改一点信息，产生的 hash 值看起来应该都有很大不同。</li>
<li>冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。即对于任意两个不同的数据块，其hash值相同的可能性极小；对于一个给定的数据块，找到和它hash值相同的数据块极为困难。</li>
</ul>
<p>但在不同的使用场景中，如数据结构和安全领域里，其中对某一些特点会有所侧重。</p>
<h2 id="Hash流行的算法"><a href="#Hash流行的算法" class="headerlink" title="Hash流行的算法"></a>Hash流行的算法</h2><p>目前流行的 Hash 算法包括 MD5、SHA-1 和 SHA-2。</p>
<ul>
<li><p>MD4（RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。其输出为 128 位。MD4 已证明不够安全。</p>
</li>
<li><p>MD5（RFC 1321）是 Rivest 于1991年对 MD4 的改进版本。它对输入仍以 512 位分组，其输出是 128 位。MD5 比 MD4 复杂，并且计算速度要慢一点，更安全一些。MD5 已被证明不具备”强抗碰撞性”。</p>
</li>
<li><p>SHA （Secure Hash Algorithm）是一个 Hash 函数族，由 NIST（National Institute of Standards and Technology）于 1993 年发布第一个算法。目前知名的 SHA-1 在 1995 年面世，它的输出为长度 160 位的 hash 值，因此抗穷举性更好。SHA-1 设计时基于和 MD4 相同原理，并且模仿了该算法。SHA-1 已被证明不具”强抗碰撞性”。</p>
</li>
<li><p>为了提高安全性，NIST 还设计出了 SHA-224、SHA-256、SHA-384，和 SHA-512 算法（统称为 SHA-2），跟 SHA-1 算法原理类似。SHA-3 相关算法也已被提出。</p>
</li>
</ul>
<p>注意：MD5在数年前就已经不被推荐作为应用中的散列算法方案，取代它的是SHA家族算法，也就是安全散列算法（Secure Hash Algorithm，缩写为SHA）。</p>
<p>git等版本控制工具使用SHA1等散列函数检查文件。</p>
<h2 id="SHA家族算法以及SHA1碰撞"><a href="#SHA家族算法以及SHA1碰撞" class="headerlink" title="SHA家族算法以及SHA1碰撞"></a>SHA家族算法以及SHA1碰撞</h2><p>安全散列算法与MD5算法本质上的算法是类似的，但安全性要领先很多——这种领先型更多的表现在碰撞攻击的时间开销更大，当然相对应的计算时间也会慢一点。</p>
<p>SHA家族算法的种类很多，有SHA0、SHA1、SHA256、SHA384等等，它们的计算方式和计算速度都有差别。其中SHA1是现在用途最广泛的一种算法。包括GitHub在内的众多版本控制工具以及各种云同步服务都是用SHA1来区别文件，很多安全证书或是签名也使用SHA1来保证唯一性。长期以来，人们都认为SHA1是十分安全的，至少大家还没有找到一次碰撞案例。</p>
<p>但这一事实在2017年2月破灭了。CWI和Google的研究人员们成功找到了一例SHA1碰撞，而且很厉害的是，发生碰撞的是两个真实的、可阅读的PDF文件。这两个PDF文件内容不相同，但SHA1值完全一样。(对于这件事的影响范围及讨论，可参考知乎上的讨论:<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/56234281/answer/148349930">如何评价 2 月 23 日谷歌宣布实现了 SHA-1 碰撞？</a>)</p>
<p>所以，对于一些大的商业机构来说， MD5 和 SHA1 已经不够安全，推荐至少使用 SHA2-256 算法。</p>
<h2 id="murmurhash算法"><a href="#murmurhash算法" class="headerlink" title="murmurhash算法"></a>murmurhash算法</h2><p>murmur：低语，嘟囔</p>
<p>MurmurHash是一种非加密型哈希函数，适用于一般的哈希检索操作。由Austin Appleby在2008年发明，并且有多个变种，都已经发布到了公有领域(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。</p>
<p>特点：对于规律性较强的key，MurmurHash的随机分布特性表现更良好。与加密散列函数不同，它不是专门设计为难以被对手逆转，因此不适用于加密目的。</p>
<pre><code>Redis在实现字典时用到了两种不同的哈希算法，MurmurHash便是其中一种（另一种是djb），在Redis中应用十分广泛，包括数据库、集群、哈希键、阻塞操作等功能都用到了这个算法。发明算法的作者被邀到google工作，该算法最新版本是MurmurHash3，基于MurmurHash2改进了一些小瑕疵，使得速度更快，实现了32位（低延时）、128位HashKey，尤其对大块的数据，具有较高的平衡性与低碰撞率。</code></pre><p>版本：</p>
<p>Murmurhash3<br>2018年的版本是Murmurhash3，它产生一个32位或128位散列值。 使用128位时，x86和x64版本不会生成相同的值，因为算法针对各自的平台进行了优化。</p>
<p>Murmurhash2<br>旧的Murmurhash2 产生一个32位或64位的值。 较慢版本的Murmurhash2可用于大端和对齐的机器。 Murmurhash2A变体添加了Merkle-Damgård构造，因此可以逐渐调用它。 有两种变体生成64位值; 针对64位处理器的Murmurhash64A和针对32位处理器的Murmurhash64B。 Murmurhash2-160生成160位散列，而Murmurhash1已过时。</p>
<h2 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h2><p><a target="_blank" rel="noopener" href="https://syxdevcode.github.io/2020/01/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">一致性hash算法</a></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26762707">什么是 hash？</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/asdzheng/article/details/70226007">Hash算法总结</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">一致性hash算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 15:15:26" itemprop="dateCreated datePublished" datetime="2020-01-08T15:15:26+00:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一致性 hash 算法 (consistent hashing)</p>
<p>转载自：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sparkliang/article/details/5279393">一致性hash算法 - consistent hashing</a></p>
<p>consistent hashing 算法早在 1997 年就在论文 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/258533.258660">Consistent hashing and random trees</a> 中被提出，目前在 cache 系统中应用越来越广泛；</p>
<h2 id="基本场景"><a href="#基本场景" class="headerlink" title="基本场景"></a>基本场景</h2><p>比如你有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache ；</p>
<p>hash(object)%N</p>
<p>一切都运行正常，再考虑如下的两种情况；</p>
<p>1 一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1) ；</p>
<p>2 由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1) ；</p>
<p>1 和 2 意味着什么？这意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；</p>
<p>再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。</p>
<p>  有什么方法可以改变这个状况呢，这就是 consistent hashing…</p>
<h2 id="hash-算法和单调性"><a href="#hash-算法和单调性" class="headerlink" title="hash 算法和单调性"></a>hash 算法和单调性</h2><p>　　 Hash 算法的一个衡量指标是单调性（ Monotonicity ），定义如下：</p>
<p>　　单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p>
<p>容易看到，上面的简单 hash 算法 hash(object)%N 难以满足单调性要求。</p>
<h2 id="consistent-hashing-算法的原理"><a href="#consistent-hashing-算法的原理" class="headerlink" title="consistent hashing 算法的原理"></a>consistent hashing 算法的原理</h2><p>consistent hashing 是一种 hash 算法，简单的说，在移除 / 添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。</p>
<p>下面就来按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。</p>
<h3 id="环形hash-空间"><a href="#环形hash-空间" class="headerlink" title="环形hash 空间"></a>环形hash 空间</h3><p>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下面图 1 所示的那样。</p>
<p><img src="/img/circle.jfif" alt="circle.jfif"><br>图1 环形 hash 空间</p>
<h3 id="把对象映射到hash-空间"><a href="#把对象映射到hash-空间" class="headerlink" title="把对象映射到hash 空间"></a>把对象映射到hash 空间</h3><p>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布如图 2 所示。</p>
<p>hash(object1) = key1;</p>
<p>… …</p>
<p>hash(object4) = key4;</p>
<p><img src="/img/object.jfif" alt="object.jfif"><br>图2  4个对象的 key 值分布</p>
<h3 id="把cache-映射到hash-空间"><a href="#把cache-映射到hash-空间" class="headerlink" title="把cache 映射到hash 空间"></a>把cache 映射到hash 空间</h3><p>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。</p>
<p>假设当前有 A,B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。</p>
<p>hash(cache A) = key A;</p>
<p>… …</p>
<p>hash(cache C) = key C; </p>
<p><img src="/img/cache.jfif" alt="cache.jfif"><br>图3 cache 和对象的 key 值分布</p>
<p>说到这里，顺便提一下 cache 的 hash 计算，一般的方法可以使用 cache 机器的 IP 地址或者机器名作为 hash 输入。</p>
<h3 id="把对象映射到cache"><a href="#把对象映射到cache" class="headerlink" title="把对象映射到cache"></a>把对象映射到cache</h3><p>现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，接下来要考虑的就是如何将对象映射到 cache 上面了。</p>
<p><font color=#0099ff size=4 face="黑体">在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache ，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这样不就找到了对象和 cache 的映射方法了吗？！</font></p>
<p>依然继续上面的例子（参见图 3 ），那么根据上面的方法，对象 object1 将被存储到 cache A 上； object2 和 object3 对应到 cache C ； object4 对应到 cache B ；</p>
<h2 id="考察cache-的变动"><a href="#考察cache-的变动" class="headerlink" title="考察cache 的变动"></a>考察cache 的变动</h2><p>前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时， cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。</p>
<h3 id="移除-cache"><a href="#移除-cache" class="headerlink" title="移除 cache"></a>移除 cache</h3><p>考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象，也即是本来映射到 cache B 上的那些对象。</p>
<p>因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可；参见图 4 。</p>
<p><img src="/img/remove.jfif" alt="remove.jfif"><br>图4 Cache B 被移除后的 cache 映射</p>
<h3 id="添加-cache"><a href="#添加-cache" class="headerlink" title="添加 cache"></a>添加 cache</h3><p>再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和 object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache （ cache B ）之间的对象（它们是也本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。</p>
<p>因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上；参见图 5 。</p>
<p><img src="/img/add.jfif" alt="add.jfif"><br>图5 添加 cache D 后的映射关系</p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：</p>
<p>平衡性</p>
<p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p>
<p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中， cache A 仅存储了 object1 ，而 cache C 则存储了 object2 、 object3 和 object4 ；分布是很不均衡的。</p>
<p>为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：</p>
<p>“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p>
<p>仍以仅部署 cache A 和 cache C 的情况为例，在图 4 中我们已经看到， cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见图 6 。</p>
<p><img src="/img/virtual.jfif" alt="virtual.jfif"><br>图 6 引入“虚拟节点”后的映射关系</p>
<p>此时，对象到“虚拟节点”的映射关系为：</p>
<p>objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ；</p>
<p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。</p>
<p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如图 7 所示。</p>
<p><img src="/img/map.jfif" alt="map.jfif"><br>图7 查询对象所在 cache</p>
<p>“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为 202.168.14.241 。</p>
<p>引入“虚拟节点”前，计算 cache A 的 hash 值：</p>
<p>Hash(“202.168.14.241”);</p>
<p>引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：</p>
<p>Hash(“202.168.14.241#1”);  // cache A1</p>
<p>Hash(“202.168.14.241#2”);  // cache A2</p>
<h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C#代码实现"></a>C#代码实现</h2><p><a target="_blank" rel="noopener" href="https://github.com/wsq003/consistent-hash">https://github.com/wsq003/consistent-hash</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2020/01/08/NET%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80%EF%BC%88IL%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/NET%E4%B8%AD%E9%97%B4%E8%AF%AD%E8%A8%80%EF%BC%88IL%EF%BC%89/" class="post-title-link" itemprop="url">.NET中间语言（IL）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-08 10:10:34" itemprop="dateCreated datePublished" datetime="2020-01-08T10:10:34+00:00">2020-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-07 08:52:36" itemprop="dateModified" datetime="2021-04-07T08:52:36+00:00">2021-04-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MSIL%E6%8C%87%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">MSIL指令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-tw/previous-versions/dd229210%28v%3dmsdn.10%29">.NET中间语言（IL）1</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-tw/previous-versions/dd229211%28v%3dmsdn.10%29">.NET中间语言（IL）2</a></p>
<p>.NET CLR 和 Java VM 都是堆栈式虚拟机（Stack-Based VM），也就是说，它们的指令集（Instruction Set）都是采用堆栈运算的方式：执行时的数据都是先放在堆栈中，再进行运算。 Java VM 有约 200 个指令（Instruction），每个指令都是 1 byte 的 opcode（操作码），后面接不等数目的参数；.NET CLR 有超过 220 个指令，但是有些指令使用相同的 opcode，所以 opcode 的 数目比指令数略少。 特别注意，.NET 的 opcode 长度并不固定，大部分的 opcode 长度是 1 byte，少部分是 2 byte。</p>
<p>本文章以一个实际的例子，让你了解堆栈式 VM 的运作原理，并对 .NET IL（Intermediate Language）有最基本的领略。</p>
<p>下面是一个简单的 C# 原始码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> j=<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> k=<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">int</span> answer = i+j+k;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;i+j+k=&quot;</span>+answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将此原始码编译之后，可以得到一个 EXE 档案。 我们可以透过 ILDASM. EXE 来反组译 EXE 以观察 IL。 我将 Main() 的 IL 反组译条列如下，这里共有十八道 IL 指令，有的指令（例如 ldstr 与 box）后面需要接参数，有的指令（例如 ldc.i4.1 与 add）后面不需要接参数。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ldc.i4<span class="number">.1</span></span><br><span class="line">stloc<span class="number">.0</span></span><br><span class="line">ldc.i4<span class="number">.2</span></span><br><span class="line">stloc<span class="number">.1</span></span><br><span class="line">ldc.i4<span class="number">.3</span></span><br><span class="line">stloc<span class="number">.2</span></span><br><span class="line">ldloc<span class="number">.0</span></span><br><span class="line">ldloc<span class="number">.1</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line">ldloc<span class="number">.2</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line">stloc<span class="number">.3</span></span><br><span class="line">ldstr      <span class="string">&quot;i+j+k=&quot;</span></span><br><span class="line">ldloc<span class="number">.3</span></span><br><span class="line">box        [mscorlib]System.Int32</span><br><span class="line">call       string [mscorlib]System.String::Concat(object, object)</span><br><span class="line">call       void [mscorlib]System.Console::WriteLine(string)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>此程序执行时，关键的内存有三种，分别是：</p>
<ul>
<li><p><strong>Managed Heap：</strong>这是动态配置（Dynamic Allocation）的内存，由 Garbage Collector（GC）在执行时自动管理，整个 Process 共享一个 Managed Heap。</p>
</li>
<li><p><strong>Call Stack：</strong>这是由 .NET CLR 在执行时自动管理的内存，每个 Thread 都有自己专属的 Call Stack。 每呼叫一次 method，就会使得 Call Stack 上多了一个 Record Frame；呼叫完毕之后，此 Record Frame 会被丢弃。 一般来说，Record Frame 内纪录着 method 参数（Parameter）、返回地址（Return Address）、以及局部变量（Local Variable）。 Java VM 和 .NET CLR 都是使用 0, 1, 2… 编号的方式来识别局部变量。</p>
</li>
<li><p><strong>Evaluation Stack：</strong>这是由 .NET CLR 在执行时自动管理的内存，每个 Thread 都有自己专属的 Evaluation Stack。 前面所谓的堆栈式虚拟机，指的就是这个堆栈。</p>
</li>
</ul>
<p>后面有一连串的示意图，用来解说在执行时此三种内存的变化。 首先，在进入 Main() 之后，尚未执行任何指令之前，内存的状况如图 1 所示：</p>
<p><img src="/img/dd229210.il_f1(zh-tw,msdn.10).jpg" alt="dd229210.il_f1(zh-tw,msdn.10).jpg"><br>图 1</p>
<p>接着要执行第一道指令 ldc.i4.1。 此指令的意思是：在 Evaluation Stack 置入一个 4 byte 的常数，其值为 1。 执行完此道指令之后，内存的变化如图 2 所示：</p>
<p><img src="/img/dd229210.il_f2(zh-tw,msdn.10).jpg" alt="dd229210.il_f2(zh-tw,msdn.10).jpg"><br>图 2</p>
<p>接着要执行第二道指令 stloc.0。 此指令的意思是：从 Evaluation Stack 取出一个值，放到第 0 号变量（V0）中。 这里的第 0 号变量其实就是原始码中的 i。 执行完此道指令之后，内存的变化如图 3 所示：</p>
<p><img src="/img/dd229210.il_f3(zh-tw,msdn.10).jpg" alt="dd229210.il_f3(zh-tw,msdn.10).jpg"><br>图 3</p>
<p>后面的第三道指令和第五道指令雷同于第一道指令，且第四道指令和第六道指令雷同于第二道指令。 为了节省篇幅，我不在此一一赘述。 提醒大家第 1 号变量（V1）其实就是原始码中的 j，且第 2 号变量（V2）其实就是源码中的 k。 图 4<del>7 分别是执行完第三</del>六道指令之后，内存的变化图：</p>
<p><img src="/img/dd229210.il_f4(zh-tw,msdn.10).jpg" alt="dd229210.il_f4(zh-tw,msdn.10).jpg"><br>图 4</p>
<p><img src="/img/dd229210.il_f5(zh-tw,msdn.10).jpg" alt="dd229210.il_f5(zh-tw,msdn.10).jpg"><br>图 5</p>
<p><img src="/img/dd229210.il_f6(zh-tw,msdn.10).jpg" alt="dd229210.il_f6(zh-tw,msdn.10).jpg"><br>图 6</p>
<p><img src="/img/dd229210.il_f7(zh-tw,msdn.10).jpg" alt="dd229210.il_f7(zh-tw,msdn.10).jpg"><br>图 7</p>
<p>接着要执行第七道指令 ldloc.0 以及第八道指令 ldloc.1：分别将 V0（也就是 i）和 V1（也就是 j）的值放到 Evaluation Stack，这是相加前的准备动作。 图 8 与图 9 分别是执行完第七、第八道指令之后，内存的变化图：</p>
<p><img src="/img/dd229210.il_f8(zh-tw,msdn.10).jpg" alt="dd229210.il_f8(zh-tw,msdn.10).jpg"><br>图 8</p>
<p><img src="/img/dd229210.il_f9(zh-tw,msdn.10).jpg" alt="dd229210.il_f9(zh-tw,msdn.10).jpg"><br>图 9</p>
<p>接着要执行第九道指令 add。 此指令的意思是：从 Evaluation Stack 取出两个值（也就是 i 和 j），相加之后将结果放回 Evaluation Stack 中。 执行完此道指令之后，内存的变化如图 10 所示：</p>
<p><img src="/img/dd229210.il_f10(zh-tw,msdn.10).jpg" alt="dd229210.il_f10(zh-tw,msdn.10).jpg"><br>图 10</p>
<p>接着要执行第十道指令 ldloc.2。 此指令的意思是：分别将 V2（也就是 k）的值放到 Evaluation Stack，这是相加前的准备动作。 执行完此道指令之后，内存的变化如图 11 所示：</p>
<p><img src="/img/dd229211.il_f11(zh-tw,msdn.10).jpg" alt="dd229211.il_f11(zh-tw,msdn.10).jpg"><br>图 11</p>
<p>接着要执行第十一道指令 add。 从 Evaluation Stack 取出两个值，相加之后将结果放回 Evaluation Stack 中，此为 i+j+k 的值。 执行完此道指令之后，内存的变化如图 12 所示：</p>
<p><img src="/img/dd229211.il_f12(zh-tw,msdn.10).jpg" alt="dd229211.il_f12(zh-tw,msdn.10).jpg"><br>图 12</p>
<p>接着要执行第十二道指令 stloc.3。 从 Evaluation Stack 取出一个值，放到第 3 号变量（V3）中。 这里的第3号变量其实就是原始码中的 answer。 执行完此道指令之后，内存的变化如图 13 所示：</p>
<p><img src="/img/dd229211.il_f13(zh-tw,msdn.10).jpg" alt="dd229211.il_f13(zh-tw,msdn.10).jpg"><br>图 13</p>
<p>接着要执行第十三道指令 ldstr “i+j+k=”。 此指令的意思是：将 “i+j+k=” 的 Reference 放进 Evaluation Stack。 执行完此道指令之后，内存的变化如图 14 所示：</p>
<p><img src="/img/dd229211.il_f14(zh-tw,msdn.10).jpg" alt="dd229211.il_f14(zh-tw,msdn.10).jpg"><br>图 14</p>
<p>接着要执行第十四道指令 ldloc.3。 将 V3 的值放进 Evaluation Stack。 执行完此道指令之后，内存的变化如图 15 所示：</p>
<p><img src="/img/dd229211.il_f15(zh-tw,msdn.10).jpg" alt="dd229211.il_f15(zh-tw,msdn.10).jpg"><br>图 15</p>
<p>接着要执行第十五道指令 box [mscorlib]System.Int32。 此指令的意思是：从 Evaluation Stack 中取出一个值，将此 Value Type 包装（box）成为 Reference Type。 执行完此道指令之后，内存的变化如图 16 所示：</p>
<p><img src="/img/dd229211.il_f16(zh-tw,msdn.10).jpg" alt="dd229211.il_f16(zh-tw,msdn.10).jpg"><br>图 16</p>
<p>接着要执行第十六道指令 call string [mscorlib] System.String::Concat(object, object)。 此指令的意思是：从 Evaluation Stack 中取出两个值，此二值皆为 Reference Type，下面的值当作第一个参数，上面的值当作第二个参数，呼叫 mscorlib.dll 所提供的 System.String.Concat() method 来将此二参数进行字符串接合（String Concatenation），将接合出来的新字符串放在 Managed Heap，将其 Reference 放进 Evaluation Stack。 值得注意的是：由于 System.String.Concat() 是 static method，所以此处使用的指令是 call，而非 callvirt（呼叫虚拟）。 执行完此道指令之后，内存的变化如图 17 所示：</p>
<p><img src="/img/dd229211.il_f17(zh-tw,msdn.10).jpg" alt="dd229211.il_f17(zh-tw,msdn.10).jpg"><br>图 17</p>
<p>请注意：此时 Managed Heap 中的 Int32(6) 以及 String(“i+j+k=”) 已经不再被参考到，所以变成垃圾，等待 GC 的回收。</p>
<p>接着要执行第十七道指令 call void [mscorlib] System.Console::WriteLine(string)。 此指令的意思是：从 Evaluation Stack 中取出一个值，此值为 Reference Type，将此值当作参数，呼叫 mscorlib.dll 所提供的 System.Console.WriteLine() method 来将此字符串显示在 Console 窗口上。 System.Console.WriteLine() 也是 static method。 执行完此道指令之后，内存的变化如图 18 所示：</p>
<p><img src="/img/dd229211.il_f18(zh-tw,msdn.10).jpg" alt="dd229211.il_f18(zh-tw,msdn.10).jpg"><br>图 18</p>
<p>接着要执行第十八道指令 ret。 此指令的意思是：结束此次呼叫（也就是 Main 的呼叫）。 此时会检查 Evaluation Stack 内剩下的数据，由于 Main() 宣告不需要传出值（void），所以 Evaluation Stack 内必须是空的，本范例符合这样的情况，所以此时可以顺利结束此次呼叫。 而 Main 的呼叫一结束，程序也随之结束。 执行完此道指令之后（且在程序结束前），内存的变化如图 19 所示：</p>
<p><img src="/img/dd229211.il_f19(zh-tw,msdn.10).jpg" alt="dd229211.il_f19(zh-tw,msdn.10).jpg"><br>图 19</p>
<p>透过此范例，读者应该可以对于 IL 有最基本的认识。 对 IL 感兴趣的读者应该自行阅读 Serge Lidin 所著的《Inside Microsoft .NET IL Assembler》（Microsoft Press 出版）。 我认为：熟知 IL 每道指令的作用，是 .NET 程序员必备的知识。.NET 程序员可以不会用 IL Assembly 写程序，但是至少要看得懂 ILDASM 反组译出来的 IL 组合码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">383</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">173</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
