<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/04/01/Linux-load-average%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/Linux-load-average%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Linux load average解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 14:33:15" itemprop="dateCreated datePublished" datetime="2021-04-01T14:33:15+00:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">Linux优化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>load average</code> 分别代表最近1分钟、5分钟、15分钟内系统的平均负荷。</p>
<p>可以使用 <code>uptime</code> ，<code>w</code> 和 <code>top</code> 命令查看。<code>load average</code> 的值越低，比如等于0.2或0.3，就说明电脑的工作量越小，系统负荷比较轻。</p>
<h2 id="系统负荷的经验法则"><a href="#系统负荷的经验法则" class="headerlink" title="系统负荷的经验法则"></a>系统负荷的经验法则</h2><ul>
<li>当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。</li>
<li>当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。</li>
<li>当系统负荷达到5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。</li>
</ul>
<h2 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h2><p><code>系统负荷=电脑CPU个数</code>。如 <code>n</code> 个CPU的电脑，可接受的系统负荷最大为 <code>n.0</code>。</p>
<p>查看物理CPU的个数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;physical id&quot;</span> | sort | uniq | wc -l</span><br></pre></td></tr></table></figure>

<h2 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h2><p>一个CPU内部，包含多个CPU核心，这被称为多核CPU。</p>
<p>在系统负荷方面，多核CPU与多CPU效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个CPU、每个CPU有几个核心。然后，把 <code>系统负荷 除以 总的核心数</code>，只要每个核心的负荷不超过1.0，就表明电脑正常运行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接返回CPU的总核心数</span></span><br><span class="line">grep -c <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;processor&quot;</span> | wc -l</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html">理解Linux系统负荷</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/04/01/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E6%8C%87%E6%A0%87%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0%E6%8C%87%E6%A0%87%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Linux 服务器的性能参数指标总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 14:16:59" itemprop="dateCreated datePublished" datetime="2021-04-01T14:16:59+00:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">Linux优化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sVJA4z-aB3XgWvREJ4_NAg">Linux 服务器的性能参数指标总结</a></p>
<p>&emsp;&emsp;记录简单的工具查看系统的相关参数，当然很多工具也是通过分析加工 /proc、/sys 下的数据来工作的，而那些更加细致、专业的性能监测和调优，可能还需要更加专业的工具(perf、systemtap 等)和技术才能完成。毕竟来说，系统性能监控本身就是个大学问。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210401144746.jpg" alt="微信图片_20210401144746.jpg"></p>
<h2 id="一、CPU和内存类"><a href="#一、CPU和内存类" class="headerlink" title="一、CPU和内存类"></a>一、CPU和内存类</h2><h3 id="1-1-top"><a href="#1-1-top" class="headerlink" title="1.1 top"></a>1.1 top</h3><p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210401144946.jpg" alt="微信图片_20210401144946.jpg"></p>
<p>&emsp;&emsp;第一行后面的三个值是系统在之前 1、5、15 的平均负载，也可以看出系统负载是上升、平稳、下降的趋势，当这个值超过 CPU 可执行单元的数目，则表示 CPU 的性能已经饱和成为瓶颈了。</p>
<p>&emsp;&emsp;第二行统计了系统的任务状态信息。running 很自然不必多说，包括正在 CPU 上运行的和将要被调度运行的；sleeping 通常是等待事件(比如 IO 操作)完成的任务，细分可以包括 interruptible 和 uninterruptible 的类型；stopped 是一些被暂停的任务，通常发送 SIGSTOP 或者对一个前台任务操作 Ctrl-Z 可以将其暂停；zombie 僵尸任务，虽然进程终止资源会被自动回收，但是含有退出任务的 task descriptor 需要父进程访问后才能释放，这种进程显示为 defunct 状态，无论是因为父进程提前退出还是未 wait 调用，出现这种进程都应该格外注意程序是否设计有误。</p>
<p>第三行 CPU 占用率根据类型有以下几种情况：</p>
<p>√ (us) user：CPU 在低 nice 值(高优先级)用户态所占用的时间(nice&lt;=0)。正常情况下只要服务器不是很闲，那么大部分的 CPU 时间应该都在此执行这类程序<br>√ (sy) system：CPU 处于内核态所占用的时间，操作系统通过系统调用(system call)从用户态陷入内核态，以执行特定的服务；通常情况下该值会比较小，但是当服务器执行的 IO 比较密集的时候，该值会比较大<br>√ (ni) nice：CPU 在高 nice 值(低优先级)用户态以低优先级运行占用的时间(nice&gt;0)。默认新启动的进程 nice=0，是不会计入这里的，除非手动通过 renice 或者 setpriority() 的方式修改程序的nice值<br>√ (id) idle：CPU 在空闲状态(执行 kernel idle handler )所占用的时间<br>√ (wa) iowait：等待 IO 完成做占用的时间<br>√ (hi) irq：系统处理硬件中断所消耗的时间<br>√ (si) softirq：系统处理软中断所消耗的时间，记住软中断分为 softirqs、tasklets (其实是前者的特例)、work queues，不知道这里是统计的是哪些的时间，毕竟 work queues 的执行已经不是中断上下文了<br>√ (st) steal：在虚拟机情况下才有意义，因为虚拟机下 CPU 也是共享物理 CPU 的，所以这段时间表明虚拟机等待 hypervisor 调度 CPU 的时间，也意味着这段时间 hypervisor 将 CPU 调度给别的 CPU 执行，这个时段的 CPU 资源被“stolen”了。这个值在我 KVM 的 VPS 机器上是不为 0 的，但也只有 0.1 这个数量级，是不是可以用来判断 VPS 超售的情况？<br>CPU 占用率高很多情况下意味着一些东西，这也给服务器 CPU 使用率过高情况下指明了相应地排查思路：<br>√ 当 user 占用率过高的时候，通常是某些个别的进程占用了大量的 CPU，这时候很容易通过 top 找到该程序；此时如果怀疑程序异常，可以通过 perf 等思路找出热点调用函数来进一步排查；<br>√ 当 system 占用率过高的时候，如果 IO 操作(包括终端 IO)比较多，可能会造成这部分的 CPU 占用率高，比如在 file server、database server 等类型的服务器上，否则(比如&gt;20%)很可能有些部分的内核、驱动模块有问题；<br>√ 当 nice 占用率过高的时候，通常是有意行为，当进程的发起者知道某些进程占用较高的 CPU，会设置其 nice 值确保不会淹没其他进程对 CPU 的使用请求；<br>√ 当 iowait 占用率过高的时候，通常意味着某些程序的 IO 操作效率很低，或者 IO 对应设备的性能很低以至于读写操作需要很长的时间来完成；<br>√ 当 irq/softirq 占用率过高的时候，很可能某些外设出现问题，导致产生大量的irq请求，这时候通过检查 /proc/interrupts 文件来深究问题所在；<br>√ 当 steal 占用率过高的时候，黑心厂商虚拟机超售了吧！</p>
<p>第四行和第五行是物理内存和虚拟内存(交换分区)的信息：</p>
<p>&emsp;&emsp;total = free + used + buff/cache，现在buffers和cached Mem信息总和到一起了，但是buffers和cached Mem 的关系很多地方都没说清楚。其实通过对比数据，这两个值就是 /proc/meminfo 中的 Buffers 和 Cached 字段：Buffers 是针对 raw disk 的块缓存，主要是以 raw block 的方式缓存文件系统的元数据(比如超级块信息等)，这个值一般比较小(20M左右)；而 Cached 是针对于某些具体的文件进行读缓存，以增加文件的访问效率而使用的，可以说是用于文件系统中文件缓存使用。</p>
<p>&emsp;&emsp;而 avail Mem 是一个新的参数值，用于指示在不进行交换的情况下，可以给新开启的程序多少内存空间，大致和 free + buff/cached 相当，而这也印证了上面的说法，free + buffers + cached Mem才是真正可用的物理内存。并且，使用交换分区不见得是坏事情，所以交换分区使用率不是什么严重的参数，但是频繁的 swap in/out 就不是好事情了，这种情况需要注意，通常表示物理内存紧缺的情况。</p>
<p>&emsp;&emsp;最后是每个程序的资源占用列表，其中 CPU 的使用率是所有 CPU core 占用率的总和。通常执行 top 的时候，本身该程序会大量的读取 /proc 操作，所以基本该 top 程序本身也会是名列前茅的。</p>
<p>&emsp;&emsp;top 虽然非常强大，但是通常用于控制台实时监测系统信息，不适合长时间(几天、几个月)监测系统的负载信息，同时对于短命的进程也会遗漏无法给出统计信息。</p>
<h3 id="1-2-vmstat"><a href="#1-2-vmstat" class="headerlink" title="1.2 vmstat"></a>1.2 vmstat</h3><p>vmstat 是除 top 之外另一个常用的系统检测工具，下面截图是我用-j4编译boost的系统负载。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210401150007.jpg" alt="微信图片_20210401150007.jpg"></p>
<p>&emsp;&emsp;r 表示可运行进程数目，数据大致相符；而b表示的是 uninterruptible 睡眠的进程数目；swpd 表示使用到的虚拟内存数量，跟 top-Swap-used 的数值是一个含义，而如手册所说，通常情况下 buffers 数目要比 cached Mem 小的多，buffers 一般20M这么个数量级；io 域的 bi、bo 表明每秒钟向磁盘接收和发送的块数目(blocks/s)；system 域的 in 表明每秒钟的系统中断数(包括时钟中断)，cs表明因为进程切换导致上下文切换的数目。</p>
<p>&emsp;&emsp;说到这里，想到以前很多人纠结编译 linux kernel 的时候 -j 参数究竟是 CPU Core 还是 CPU Core+1？通过上面修改 -j 参数值编译 boost 和 linux kernel 的同时开启 vmstat 监控，发现两种情况下 context switch 基本没有变化，且也只有显著增加 -j 值后 context switch 才会有显著的增加，看来不必过于纠结这个参数了，虽然具体编译时间长度我还没有测试。资料说如果不是在系统启动或者 benchmark 的状态，参数 context switch&gt;100000 程序肯定有问题。</p>
<h3 id="1-3-pidstat"><a href="#1-3-pidstat" class="headerlink" title="1.3 pidstat"></a>1.3 pidstat</h3><p>&emsp;&emsp;如果想对某个进程进行全面具体的追踪，没有什么比 pidstat 更合适的了——栈空间、缺页情况、主被动切换等信息尽收眼底。这个命令最有用的参数是-t，可以将进程中各个线程的详细信息罗列出来。</p>
<p>-r：显示缺页错误和内存使用状况，缺页错误是程序需要访问映射在虚拟内存空间中但是还尚未被加载到物理内存中的一个分页，缺页错误两个主要类型是<br>√ minflt/s 指的 minor faults，当需要访问的物理页面因为某些原因(比如共享页面、缓存机制等)已经存在于物理内存中了，只是在当前进程的页表中没有引用，MMU 只需要设置对应的 entry 就可以了，这个代价是相当小的<br>√ majflt/s 指的 major faults，MMU 需要在当前可用物理内存中申请一块空闲的物理页面(如果没有可用的空闲页面，则需要将别的物理页面切换到交换空间去以释放得到空闲物理页面)，然后从外部加载数据到该物理页面中，并设置好对应的 entry，这个代价是相当高的，和前者有几个数据级的差异<br>-s：栈使用状况，包括 StkSize 为线程保留的栈空间，以及 StkRef 实际使用的栈空间。使用ulimit -s发现CentOS 6.x上面默认栈空间是10240K，而 CentOS 7.x、Ubuntu系列默认栈空间大小为8196K</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210401150052.jpg" alt="微信图片_20210401150052.jpg"></p>
<p>-u：CPU使用率情况，参数同前面类似<br>-w：线程上下文切换的数目，还细分为cswch/s因为等待资源等因素导致的主动切换，以及nvcswch/s线程CPU时间导致的被动切换的统计</p>
<p>&emsp;&emsp;如果每次都先ps得到程序的pid后再操作pidstat会显得很麻烦，所以这个杀手锏的-C可以指定某个字符串，然后Command中如果包含这个字符串，那么该程序的信息就会被打印统计出来，-l可以显示完整的程序名和参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w -t -C <span class="string">&quot;ailaw&quot;</span> -l</span><br></pre></td></tr></table></figure>

<p>这么看来，如果查看单个尤其是多线程的任务时候，pidstat比常用的ps更好使！</p>
<h3 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h3><p>&emsp;&emsp;当需要单独监测单个 CPU 情况的时候，除了 htop 还可以使用 mpstat，查看在 SMP 处理器上各个 Core 的工作量是否负载均衡，是否有某些热点线程占用 Core。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 1</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果想直接监测某个进程占用的资源，既可以使用 <code>top -u taozj</code> 的方式过滤掉其他用户无关进程，也可以采用下面的方式进行选择，ps命令可以自定义需要打印的条目信息：</p>
<p><code>while :; do ps -eo user,pid,ni,pri,pcpu,psr,comm | grep &#39;ailawd&#39;; sleep 1; done</code></p>
<p>如想理清继承关系，下面一个常用的参数可以用于显示进程树结构，显示效果比pstree详细美观的多</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axjf</span><br></pre></td></tr></table></figure>

<h2 id="磁盘IO类"><a href="#磁盘IO类" class="headerlink" title="磁盘IO类"></a>磁盘IO类</h2><p>&emsp;&emsp;iotop 可以直观的显示各个进程、线程的磁盘读取实时速率；lsof 不仅可以显示普通文件的打开信息(使用者)，还可以操作 /dev/sda1 这类设备文件的打开信息，那么比如当分区无法 umount 的时候，就可以通过 lsof 找出磁盘该分区的使用状态了，而且添加 +fg 参数还可以额外显示文件打开 flag 标记。</p>
<h3 id="2-1-iostat"><a href="#2-1-iostat" class="headerlink" title="2.1 iostat"></a>2.1 iostat</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -xz 1</span><br></pre></td></tr></table></figure>

<p>其实无论使用 <code>iostat -xz 1</code> 还是使用 <code>sar -d 1</code>，对于磁盘重要的参数是：</p>
<p>√ avgqu-s：发送给设备 I/O 请求的等待队列平均长度，对于单个磁盘如果值&gt;1表明设备饱和，对于多个磁盘阵列的逻辑磁盘情况除外<br>√ await(r_await、w_await)：平均每次设备 I/O 请求操作的等待时间(ms)，包含请求排列在队列中和被服务的时间之和；<br>√ svctm：发送给设备 I/O 请求的平均服务时间(ms)，如果 svctm 与 await 很接近，表示几乎没有 I/O 等待，磁盘性能很好，否则磁盘队列等待时间较长，磁盘响应较差；<br>√ %util：设备的使用率，表明每秒中用于 I/O 工作时间的占比，单个磁盘当 %util&gt;60% 的时候性能就会下降(体现在 await 也会增加)，当接近100%时候就设备饱和了，但对于有多个磁盘阵列的逻辑磁盘情况除外；</p>
<p>&emsp;&emsp;还有，虽然监测到的磁盘性能比较差，但是不一定会对应用程序的响应造成影响，内核通常使用 I/O asynchronously 技术，使用读写缓存技术来改善性能，不过这又跟上面的物理内存的限制相制约了。</p>
<p>上面的这些参数，对网络文件系统也是受用的。</p>
<h2 id="三、网络类"><a href="#三、网络类" class="headerlink" title="三、网络类"></a>三、网络类</h2><p>&emsp;&emsp;网络性能对于服务器的重要性不言而喻，工具 iptraf 可以直观的现实网卡的收发速度信息，比较的简洁方便通过 sar -n DEV 1 也可以得到类似的吞吐量信息，而网卡都标配了最大速率信息，比如百兆网卡千兆网卡，很容易查看设备的利用率。</p>
<p>&emsp;&emsp;通常，网卡的传输速率并不是网络开发中最为关切的，而是针对特定的 UDP、TCP 连接的丢包率、重传率，以及网络延时等信息。</p>
<h3 id="3-1-netstat"><a href="#3-1-netstat" class="headerlink" title="3.1 netstat"></a>3.1 netstat</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure>

<p>显示自从系统启动以来，各个协议的总体数据信息。虽然参数信息比较丰富有用，但是累计值，除非两次运行做差才能得出当前系统的网络状态信息，亦或者使用 watch 眼睛直观</p>
<p>其数值变化趋势。所以netstat通常用来检测端口和连接信息的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat –all(a) –numeric(n) –tcp(t) –udp(u) –timers(o) –listening(l) –program(p)</span><br></pre></td></tr></table></figure>

<p>–timers可以取消域名反向查询，加快显示速度；比较常用的有</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出所有TCP的连接</span></span><br><span class="line">netstat -antp</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出本地所有TCP侦听套接字，不要加-a参数</span></span><br><span class="line">netstat -nltp</span><br></pre></td></tr></table></figure>

<h3 id="3-2-sar"><a href="#3-2-sar" class="headerlink" title="3.2 sar"></a>3.2 sar</h3><p>&emsp;&emsp;sar 这个工具太强大了，什么 CPU、磁盘、页面交换啥都管，这里使用 -n 主要用来分析网络活动，虽然网络中它还给细分了 NFS、IP、ICMP、SOCK 等各种层次各种协议的数据信息，我们只关心 TCP 和 UDP。下面的命令除了显示常规情况下段、数据报的收发情况，还包括 </p>
<p><strong>TCP</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sar -n TCP,ETCP 1</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210401150545.jpg" alt="微信图片_20210401150545.jpg"></p>
<p>√ active/s：本地发起的 TCP 连接，比如通过 connect()，TCP 的状态从CLOSED -&gt; SYN-SENT<br>√ passive/s：由远程发起的 TCP 连接，比如通过 accept()，TCP 的状态从LISTEN -&gt; SYN-RCVD<br>√ retrans/s(tcpRetransSegs)：每秒钟 TCP 重传数目，通常在网络质量差，或者服务器过载后丢包的情况下，根据 TCP 的确认重传机制会发生重传操作<br>√ isegerr/s(tcpInErrs)：每秒钟接收到出错的数据包(比如 checksum 失败)</p>
<p><strong>UDP</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sar -n UDP 1</span><br></pre></td></tr></table></figure>

<p>√ noport/s(udpNoPorts)：每秒钟接收到的但是却没有应用程序在指定目的端口的数据报个数<br>√ idgmerr/s(udpInErrors)：除了上面原因之外的本机接收到但却无法派发的数据报个数</p>
<p>当然，这些数据一定程度上可以说明网络可靠性，但也只有同具体的业务需求场景结合起来才具有意义。</p>
<h3 id="3-3-tcpdump"><a href="#3-3-tcpdump" class="headerlink" title="3.3 tcpdump"></a>3.3 tcpdump</h3><p>&emsp;&emsp;tcpdump 不得不说是个好东西。大家都知道本地调试的时候喜欢使用 wireshark，但是线上服务端出现问题怎么弄呢？</p>
<p>&emsp;&emsp;附录的参考文献给出了思路：复原环境，使用 tcpdump 进行抓包，当问题复现(比如日志显示或者某个状态显现)的时候，就可以结束抓包了，而且 tcpdump 本身带有 -C/-W 参数，可以限制抓取包存储文件的大小，当达到这个这个限制的时候保存的包数据自动 rotate，所以抓包数量总体还是可控的。此后将数据包拿下线来，用 wireshark 想怎么看就怎么看，岂不乐哉！tcpdump 虽然没有 GUI 界面，但是抓包的功能丝毫不弱，可以指定网卡、主机、端口、协议等各项过滤参数，抓下来的包完整又带有时间戳，所以线上程序的数据包分析也可以这么简单。</p>
<p>&emsp;&emsp;下面就是一个小的测试，可见 Chrome 启动时候自动向 Webserver 发起建立了三条连接，由于这里限制了 dst port 参数，所以服务端的应答包被过滤掉了，拿下来用 wireshark 打开，SYNC、ACK 建立连接的过程还是很明显的！在使用 tcpdump 的时候，需要尽可能的配置抓取的过滤条件，一方面便于接下来的分析，二则 tcpdump 开启后对网卡和系统的性能会有影响，进而会影响到在线业务的性能。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210401150615.jpg" alt="微信图片_20210401150615.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/04/01/MQTT%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/MQTT%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">MQTT协议解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-01 13:35:51" itemprop="dateCreated datePublished" datetime="2021-04-01T13:35:51+00:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQTT/" itemprop="url" rel="index"><span itemprop="name">MQTT</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议），是一种基于发布/订阅（publish/subscribe）模式的 “轻量级”通讯协议，由IBM在1999年发布,它工作在TCP/IP协议族上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议。</p>
<p>&emsp;&emsp;MQTT最大优点在于，可以以极少的代码和有限的带宽，为连接远程设备提供实时可靠的消息服务。作为一种低开销、低带宽占用的即时通讯协议，使其在物联网、小型设备、移动应用等方面有较广泛的应用。 </p>
<p>&emsp;&emsp;目前应用比较广泛的是MQTT3.1.1，这个版本包括各种数据传输所需的功能和特征，而且对应生态非常成熟，因此以MQTT 3.1.1为例介绍一下MQTT的协议格式。</p>
<p><img src="/img/mqtt-fidge-2.svg" alt="mqtt-fidge-2.svg"></p>
<h2 id="MQTT协议原理"><a href="#MQTT协议原理" class="headerlink" title="MQTT协议原理"></a>MQTT协议原理</h2><h3 id="MQTT协议实现方式"><a href="#MQTT协议实现方式" class="headerlink" title="MQTT协议实现方式"></a>MQTT协议实现方式</h3><p>&emsp;&emsp;实现MQTT协议需要客户端和服务器端通讯完成，在通讯过程中，MQTT协议中有三种身份：发布者（Publish）、代理（Broker）（服务器）、订阅者（Subscribe）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，消息发布者可以同时是订阅者。</p>
<p>MQTT传输的消息分为：主题（Topic）和负载（payload）两部分：</p>
<ul>
<li>（1）Topic，可以理解为消息的类型，订阅者订阅（Subscribe）后，就会收到该主题的消息内容（payload）；</li>
<li>（2）payload，可以理解为消息的内容，是指订阅者具体要使用的内容。</li>
</ul>
<h3 id="网络传输与应用消息"><a href="#网络传输与应用消息" class="headerlink" title="网络传输与应用消息"></a>网络传输与应用消息</h3><p>MQTT会构建底层网络传输：它将建立客户端到服务器的连接，提供两者之间的一个有序的、无损的、基于字节流的双向传输。</p>
<p>当应用数据通过MQTT网络发送时，MQTT会把与之相关的服务质量（QoS）和主题名（Topic）相关连。</p>
<h3 id="MQTT客户端"><a href="#MQTT客户端" class="headerlink" title="MQTT客户端"></a>MQTT客户端</h3><p>一个使用MQTT协议的应用程序或者设备，它总是建立到服务器的网络连接。客户端可以：</p>
<ul>
<li>（1）发布其他客户端可能会订阅的信息；</li>
<li>（2）订阅其它客户端发布的消息；</li>
<li>（3）退订或删除应用程序的消息；</li>
<li>（4）断开与服务器连接。</li>
</ul>
<h3 id="MQTT服务器"><a href="#MQTT服务器" class="headerlink" title="MQTT服务器"></a>MQTT服务器</h3><p>MQTT服务器以称为”消息代理”（Broker），可以是一个应用程序或一台设备。它是位于消息发布者和订阅者之间，它可以：</p>
<p>（1）接受来自客户的网络连接；<br>（2）接受客户发布的应用信息；<br>（3）处理来自客户端的订阅和退订请求；<br>（4）向订阅的客户转发应用程序消息。</p>
<h3 id="MQTT协议中的订阅、主题、会话"><a href="#MQTT协议中的订阅、主题、会话" class="headerlink" title="MQTT协议中的订阅、主题、会话"></a>MQTT协议中的订阅、主题、会话</h3><h4 id="一、订阅（Subscription）"><a href="#一、订阅（Subscription）" class="headerlink" title="一、订阅（Subscription）"></a>一、订阅（Subscription）</h4><p>订阅包含主题筛选器（Topic Filter）和最大服务质量（QoS）。订阅会与一个会话（Session）关联。一个会话可以包含多个订阅。每一个会话中的每个订阅都有一个不同的主题筛选器。</p>
<h4 id="二、会话（Session）"><a href="#二、会话（Session）" class="headerlink" title="二、会话（Session）"></a>二、会话（Session）</h4><p>每个客户端与服务器建立连接后就是一个会话，客户端和服务器之间有状态交互。会话存在于一个网络之间，也可能在客户端和服务器之间跨越多个连续的网络连接。</p>
<h4 id="三、主题名（Topic-Name）"><a href="#三、主题名（Topic-Name）" class="headerlink" title="三、主题名（Topic Name）"></a>三、主题名（Topic Name）</h4><p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p>
<h4 id="四、主题筛选器（Topic-Filter）"><a href="#四、主题筛选器（Topic-Filter）" class="headerlink" title="四、主题筛选器（Topic Filter）"></a>四、主题筛选器（Topic Filter）</h4><p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p>
<h4 id="五、负载（Payload）"><a href="#五、负载（Payload）" class="headerlink" title="五、负载（Payload）"></a>五、负载（Payload）</h4><p>消息订阅者所具体接收的内容。</p>
<h3 id="MQTT协议中的方法"><a href="#MQTT协议中的方法" class="headerlink" title="MQTT协议中的方法"></a>MQTT协议中的方法</h3><p>MQTT协议中定义了一些方法（也被称为动作），来于表示对确定资源所进行操作。这个资源可以代表预先存在的数据或动态生成数据，这取决于服务器的实现。</p>
<p>通常来说，资源指服务器上的文件或输出。主要方法有：</p>
<ul>
<li>（1）Connect。等待与服务器建立连接。</li>
<li>（2）Disconnect。等待MQTT客户端完成所做的工作，并与服务器断开TCP/IP会话。</li>
<li>（3）Subscribe。等待完成订阅。</li>
<li>（4）UnSubscribe。等待服务器取消客户端的一个或多个topics订阅。</li>
<li>（5）Publish。MQTT客户端发送消息请求，发送完成后返回应用程序线程。</li>
</ul>
<h2 id="MQTT协议数据包结构"><a href="#MQTT协议数据包结构" class="headerlink" title="MQTT协议数据包结构"></a>MQTT协议数据包结构</h2><p>在MQTT协议中，一个MQTT数据包由：固定头（Fixed header）、可变头（Variable header）、消息体（payload）三部分构成。</p>
<p>MQTT数据包结构如下：</p>
<ul>
<li>（1）固定头（Fixed header）。存在于所有MQTT数据包中，表示数据包类型及数据包的分组类标识。</li>
<li>（2）可变头（Variable header）。存在于部分MQTT数据包中，数据包类型决定了可变头是否存在及其具体内容。</li>
<li>（3）消息体（Payload）。存在于部分MQTT数据包中，表示客户端收到的具体内容。</li>
</ul>
<h3 id="MQTT固定头"><a href="#MQTT固定头" class="headerlink" title="MQTT固定头"></a>MQTT固定头</h3><p>所有的MQTT报文都包含固定报头：可变报头与有效载荷是部分MQTT报文包含。 </p>
<p>固定报头占据两字节的空间：</p>
<p><img src="/img/20210320224829539.png" alt="20210320224829539.png"></p>
<h4 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h4><p>固定报头的第一个字节分为控制报文的类型（4bit），以及控制报文类型的标志位，控制类型共有14种，其中0与15被系统保留出来：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="center">值</th>
<th align="center">报文流动方向</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Reserved</td>
<td align="center">0</td>
<td align="center">禁止</td>
<td align="left">系统保留</td>
</tr>
<tr>
<td align="left">CONNECT</td>
<td align="center">1</td>
<td align="center">客户端到服务端</td>
<td align="left">客户端请求连接服务端</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="center">2</td>
<td align="center">服务端到客户端</td>
<td align="left">连接报文确认</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="center">3</td>
<td align="center">两个方向都允许</td>
<td align="left">发布消息</td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="center">4</td>
<td align="center">两个方向都允许</td>
<td align="left">消息发布收到确认（QoS 1）</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="center">5</td>
<td align="center">两个方向都允许</td>
<td align="left">发布收到（QoS2 第一阶段）</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="center">6</td>
<td align="center">两个方向都允许</td>
<td align="left">发布释放（QoS2第二阶段)）</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="center">7</td>
<td align="center">两个方向都允许</td>
<td align="left">消息发布完成（QoS2第三阶段）</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="center">8</td>
<td align="center">客户端到服务端</td>
<td align="left">客户端订阅请求</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="center">9</td>
<td align="center">服务端到客户端</td>
<td align="left">订阅请求报文确认</td>
</tr>
<tr>
<td align="left">UNSUBSCRIBE</td>
<td align="center">10</td>
<td align="center">客户端到服务端</td>
<td align="left">客户端取消订阅请求</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="center">11</td>
<td align="center">服务端到客户端</td>
<td align="left">取消订阅报文确认</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="center">12</td>
<td align="center">客户端到服务端</td>
<td align="left">心跳请求</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="center">13</td>
<td align="center">服务端到客户端</td>
<td align="left">心跳响应</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="center">14</td>
<td align="center">客户端到服务端</td>
<td align="left">客户端断开连接</td>
</tr>
<tr>
<td align="left">Reserved</td>
<td align="center">15</td>
<td align="center">禁止</td>
<td align="left">系统保留</td>
</tr>
</tbody></table>
<h4 id="报文类型的标志位"><a href="#报文类型的标志位" class="headerlink" title="报文类型的标志位"></a>报文类型的标志位</h4><p>固定报头( <code>Byte 1</code> )的 <code>bit0-bit3</code> 为标志位，依照报文类型有不同的含义。</p>
<p>在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：</p>
<p>（1）DUP：发布消息的副本。用来在保证消息的可靠传输，如果设置为1，则在下面的变长中增加 <code>MessageId</code>，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。</p>
<p>（2）QoS：发布消息的服务质量(可靠性控制QoS)，即：保证消息传递的次数</p>
<p>00：&lt;=1，至多一次，只发一次，不确保到达。<br>01：&gt;=1，至少一次，确保消息到达但可能有重复<br>10：=1，只有一次，确保消息到达且无重复<br>11：预留，客户端或服务器认为这是一条非法的消息，会关闭当前连接。</p>
<p>（3）RETAIN： 发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。</p>
<p>&emsp;&emsp;目前Bit[3-0]只在 <code>PUBLISH</code> 协议中使用有效，并且表中指明了是 <code>MQTT 3.1.1</code> 版本，其他报文的标志位均为系统保留。对于其它 MQTT 协议版本，内容可能不同。</p>
<p>&emsp;&emsp;所有固定头标记为”保留”的协议类型，<code>Bit[3-0]</code> 必须保持与表中保持一致，如 <code>SUBSCRIBE</code> 协议，其 <code>Bit 1</code> 必须为 1。如果接收方接收到非法的消息，会强行关闭当前连接。</p>
<p>&emsp;&emsp;<code>PUBLISH</code> 报文的第一字节 <code>bit3</code> 是控制报文的重复分发标志（DUP），<code>bit1-bit2</code>是服务质量等级，<code>bit0</code> 是 <code>PUBLISH</code> 报文的保留标志，用于标识 <code>PUBLISH</code> 是否保留。</p>
<p>&emsp;&emsp;当客户端发送一个<code>PUBLISH</code> 消息到服务器，如果保留标识位置1，那么服务器应该保留这条消息，当一个新的订阅者订阅这个主题的时候，最后保留的主题消息应被发送到新订阅的用户。如果 DUP 字段( <code>bit 3</code> )设置为1，表明这是一条重复消息，否则是第一次发布消息。为了保证消息的可靠性传递，当 <code>QoS</code> 设置为1时，客户端或服务器发布消息时，需要得到对方的确认(<code>PUBACK</code>)，如果一段时间后没收到<code>PUBACK</code>，那么会再次发送当前消息，并将DUP字段标记为1。</p>
<table>
<thead>
<tr>
<th align="left">报文类型</th>
<th align="center">固定头标记</th>
<th align="center">Bit3</th>
<th align="left">Bit2</th>
<th align="left">Bit1</th>
<th align="left">Bit0</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONNECT</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">CONNACK</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBLISH</td>
<td align="center">Used in MQTT 3.1.1</td>
<td align="center">DUP</td>
<td align="left">QoS</td>
<td align="left">QoS</td>
<td align="left">RETAIN</td>
</tr>
<tr>
<td align="left">PUBACK</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBREC</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBREL</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PUBCOMP</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SUBSCRIBE</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">SUBACK</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">UNSUBACRIBE</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">UNSUBACK</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PINGREQ</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">PINGRESP</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">DISCONNECT</td>
<td align="center">保留</td>
<td align="center">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<h3 id="剩余长度（Remaining-Length）"><a href="#剩余长度（Remaining-Length）" class="headerlink" title="剩余长度（Remaining Length）"></a>剩余长度（Remaining Length）</h3><p><code>剩余长度（Remaining Length）</code>= <code>Variable Header</code> + <code>Payload的长度(如果存在)</code>。</p>
<p>剩余长度不包括用于编码剩余长度字段本身的字节数。</p>
<p>剩余长度从 <code>Byte 2</code> 开始，最长可达 <code>4Byte</code>。所以剩余长度范围是 <code>Byte[2-5]</code>。</p>
<p>&emsp;&emsp;确定其长度到底是<code>1Byte</code> 还是 <code>4Byte</code> ，这取决于字节的最高位 <code>Bit 7</code>(默认都是高字节在前)，如果这个值是1，那么就继续计算字节长度，如果是0，那么就不再计算字节长度。</p>
<p>&emsp;&emsp;剩余长度字段使用一个变长度编码方案，对小于 <code>128（2^7）</code> 的值它使用单字节编码，而对于更大的数值则按下面的方式处理：每个字节的低7位用于编码数据长度，最高位（bit7）用于标识剩余长度字段是否有更多的字节，且按照大端模式进行编码，因此每个字节可以编码128个数值和一个延续位，剩余长度字段最大可拥有4个字节，最大可以表示 <code>128*128*128*128Byte/1024/1024=256MB</code>。</p>
<p>注：</p>
<ul>
<li>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放。</li>
<li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</li>
</ul>
<p>字节对应取值：</p>
<ul>
<li>当剩余长度使用1个字节存储时，其取值范围为 <code>0(0x00)~127(0x7f)</code>。</li>
<li>2个字节，其取值范围为 <code>128(0x80,0x01)~16383(0Xff,0x7f)</code>。</li>
<li>3个字节，其取值范围为 <code>16384(0x80,0x80,0x01)~2097151(0xFF,0xFF,0x7F)</code>。</li>
<li>4个字节，取值范围为 <code>2097152(0x80,0x80,0x80,0x01)~268435455(0xFF,0xFF,0xFF,0x7F)</code>。</li>
</ul>
<p>总结：<code>MQTT</code> 报文理论上可以发送最大 <code>256M</code> 的报文，但这种情况非常少。 </p>
<p><strong>例子</strong></p>
<p>1，消息假设长度是 <code>[0X60]</code>，其二进制是 <code>01100000</code> ，字节最高位 <code>Bit7</code> (从左边起第0位)是0，所以不需要继续往后计算。那么消息长度就是0X60，十进制数是96。</p>
<p>2，如果消息长度是[0XC1, 0XC2, 0X33]，那么他们的二进制分别如下，</p>
<figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xC1</span>=<span class="number">1100</span> <span class="number">0001</span></span><br><span class="line"><span class="number">0xC2</span>=<span class="number">1100</span> <span class="number">0010</span></span><br><span class="line"><span class="number">0x33</span>=<span class="number">0011</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure>

<p>第一字节最高位是1，那么需要继续向后计算，去掉标记位(0xC1%128)，得到100 0001=41<br>第二字节最高位是1，那么需要继续向后计算，去掉标记位(0xC2%128)，得到100 0010=42<br>第三字节最高位是0，不需要向后计算，其结果就是0x33=51</p>
<p>因为低位在前，高位在后，那么长度计算为 <code>Length=41 + 42*128 + 51*128*128 = 841001B = 821KB</code></p>
<p>&emsp;&emsp;需要注意的是，消息长度=可变头部长度+消息内容长度。不包括首字节和消息长度本身，如果消息长度为5(占用1字节长度)，那么说明这条消息后边还有5字节，整条消息长度为7(首字节+1位长度字节+5)。</p>
<p>&emsp;&emsp;另外如果消息长度为4字节，最后一位不能超过 <code>0X7F=127</code>，因为如果超出这个值，其最高位 <code>Bit7</code> 是1，还需要往后计算，这与消息最大长度为4字节矛盾。所以如果出现 <code>[0XFF, 0XFF, 0XFF, 0XFF]</code> 这样的消息长度，那么接收方认为这是一条非法的消息。</p>
<h3 id="MQTT可变头（Variable-header）"><a href="#MQTT可变头（Variable-header）" class="headerlink" title="MQTT可变头（Variable header）"></a>MQTT可变头（Variable header）</h3><p>&emsp;&emsp;MQTT数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是作为包的标识。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210401134259.png" alt="微信截图_20210401134259.png"></p>
<p>&emsp;&emsp;只有某些报文才拥有可变报头，它在固定报头和有效负载之间，可变报头的内容会根据报文类型的不同而有所不同，但可变报头的报文标识符（Packet Identifier）字段存在于在多个类型的报文里，而有一些报文又没有报文标识符字段，具体见表格，报文标识符结构具体见图：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210401134438.png" alt="微信截图_20210401134438.png"></p>
<h3 id="Payload消息体"><a href="#Payload消息体" class="headerlink" title="Payload消息体"></a>Payload消息体</h3><p>Payload消息体位MQTT数据包的第三部分，包含 <code>CONNECT</code>、<code>SUBSCRIBE</code>、<code>SUBACK</code>、<code>UNSUBSCRIBE</code>、<code>PUBLISH</code>（类型可选）五种类型的消息，除了上面列出的报文类型，其它的报文类型都没有 <code>Payload</code>。</p>
<ul>
<li>（1）CONNECT，消息体内容主要是：客户端的 ClientID、订阅的Topic、Message以及用户名和密码。</li>
<li>（2）SUBSCRIBE，消息体内容是一系列的要订阅的主题以及QoS。</li>
<li>（3）SUBACK，消息体内容是服务器对于SUBSCRIBE所申请的主题及QoS进行确认和回复。</li>
<li>（4）UNSUBSCRIBE，消息体内容是要订阅的主题。</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_28877125/article/details/78325003">MQTT–入门</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/beauty0beast/article/details/106304197">MQTT数据包格式</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.mcxiaoke.com/mqtt/protocol/MQTT-3.1.1-CN.html">MQTT 协议 3.1.1 中文版</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/31/Linux-find%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/Linux-find%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux find命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-31 09:12:40" itemprop="dateCreated datePublished" datetime="2021-03-31T09:12:40+00:00">2021-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find   搜索路径 [选项] 搜索内容</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">find   path -option  [-<span class="built_in">print</span>] [-<span class="built_in">exec</span> -ok <span class="built_in">command</span> ] &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul>
<li>-amin&lt;分钟&gt;：查找在指定时间曾被存取过的文件或目录，单位以分钟计算；</li>
<li>-anewer&lt;参考文件或目录&gt;：查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录；</li>
<li>-atime&lt;24小时数&gt;：查找在指定时间曾被存取过的文件或目录，单位以24小时计算；</li>
<li>-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；</li>
<li>-cnewer&lt;参考文件或目录&gt;查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</li>
<li>-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；</li>
<li>-daystart：从本日开始计算时间；</li>
<li>-depth：从指定目录下最深层的子目录开始查找；</li>
<li>-empty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；</li>
<li>-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；</li>
<li>-false：将find指令的回传值皆设为False；</li>
<li>-fls&lt;列表文件&gt;：此参数的效果和指定 “-ls” 参数类似，但会把结果保存为指定的列表文件；</li>
<li>-follow：排除符号连接；</li>
<li>-fprint&lt;列表文件&gt;：此参数的效果和指定 “-print” 参数类似，但会把结果保存成指定的列表文件；</li>
<li>-fprint0&lt;列表文件&gt;：此参数的效果和指定 “-print0” 参数类似，但会把结果保存成指定的列表文件；</li>
<li>-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定 “-printf” 参数类似，但会把结果保存成指定的列表文件；</li>
<li>-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；</li>
<li>-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；</li>
<li>-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；</li>
<li>-help或——help：在线帮助；</li>
<li>-ilname&lt;范本样式&gt;：此参数的效果和指定 “-lname” 参数类似，但忽略字符大小写的差别；</li>
<li>-iname&lt;范本样式&gt;：按照文件名搜索，不区分文件名大小；</li>
<li>-inum&lt;inode编号&gt;：查找符合指定的 inode编号 的文件或目录；</li>
<li>-ipath&lt;范本样式&gt;：此参数的效果和指定 “-path” 参数类似，但忽略字符大小写的差别；</li>
<li>-iregex&lt;范本样式&gt;：此参数的效果和指定 “-regexe” 参数类似，但忽略字符大小写的差别；</li>
<li>-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；</li>
<li>-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；</li>
<li>-maxdepth&lt;目录层级&gt;：设置最大目录层级；</li>
<li>-mindepth&lt;目录层级&gt;：设置最小目录层级；</li>
<li>-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；</li>
<li>-mount：此参数的效果和指定 “-xdev” 相同；</li>
<li>-mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；</li>
<li>-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</li>
<li>-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；</li>
<li>-nogroup：找出不属于本地主机群组识别码的文件或目录；</li>
<li>-noleaf：不去考虑目录至少需拥有两个硬连接存在；</li>
<li>-nouser：找出不属于本地主机用户识别码的文件或目录；</li>
<li>-ok&lt;执行指令&gt;：此参数的效果和指定 “-exec” 类似，但在执行指令之前会先询问用户，若回答 “y” 或 “Y” ，则放弃执行命令；</li>
<li>-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；</li>
<li>-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；</li>
<li>-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有 “./“ 字符串；</li>
<li>-print0：指定输出的文件列表以 null分隔。格式为全部的名称皆在同一行；</li>
<li>-printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；</li>
<li>-prune：不寻找字符串作为寻找文件或目录的范本样式;</li>
<li>-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；</li>
<li>-size&lt;+-文件大小&gt;：查找符合指定的文件大小的文件；</li>
<li>-true：将find指令的回传值皆设为True；</li>
<li>-type&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；</li>
<li>-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；</li>
<li>-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；</li>
<li>-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；</li>
<li>-version或——version：显示版本信息；</li>
<li>-xdev：将范围局限在先行的文件系统中；</li>
<li>-xtype&lt;文件类型&gt;：此参数的效果和指定 “-type” 参数类似，差别在于它针对符号连接检查。</li>
<li>-o: 或</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="根据文件或者正则表达式进行匹配"><a href="#根据文件或者正则表达式进行匹配" class="headerlink" title="根据文件或者正则表达式进行匹配"></a>根据文件或者正则表达式进行匹配</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录及子目录下所有文件和文件夹</span></span><br><span class="line">find .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/home目录下查找以.txt结尾的文件名</span></span><br><span class="line">find /home -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"><span class="comment"># 忽略大小写</span></span><br><span class="line">find /home -iname <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前目录及子目录下查找所有以.txt和.pdf结尾的文件</span></span><br><span class="line">find . \( -name <span class="string">&quot;*.txt&quot;</span> -o -name <span class="string">&quot;*.pdf&quot;</span> \)</span><br><span class="line">或</span><br><span class="line">find . -name <span class="string">&quot;*.txt&quot;</span> -o -name <span class="string">&quot;*.pdf&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配文件路径或者文件</span></span><br><span class="line">find /usr/ -path <span class="string">&quot;*local*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于正则表达式匹配文件路径</span></span><br><span class="line">find . -regex <span class="string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span></span><br><span class="line"><span class="comment"># 忽略大小写</span></span><br><span class="line">find . -iregex <span class="string">&quot;.*\(\.txt\|\.pdf\)$&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数"></a>否定参数</h3><p>找出/home下不是以.txt结尾的文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home ! -name <span class="string">&quot;*.txt&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="根据文件类型进行搜索"><a href="#根据文件类型进行搜索" class="headerlink" title="根据文件类型进行搜索"></a>根据文件类型进行搜索</h3><p><code>find . -type 类型参数</code></p>
<p>类型参数列表：</p>
<ul>
<li>f 普通文件</li>
<li>l 符号连接</li>
<li>d 目录</li>
<li>c 字符设备</li>
<li>b 块设备</li>
<li>s 套接字</li>
<li>p Fifo</li>
</ul>
<h3 id="基于目录深度搜索"><a href="#基于目录深度搜索" class="headerlink" title="基于目录深度搜索"></a>基于目录深度搜索</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向下最大深度限制为3</span></span><br><span class="line">find . -maxdepth 3 -<span class="built_in">type</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索出深度距离当前目录至少2个子目录的所有文件</span></span><br><span class="line">find . -mindepth 2 -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<h3 id="根据文件时间戳进行搜索"><a href="#根据文件时间戳进行搜索" class="headerlink" title="根据文件时间戳进行搜索"></a>根据文件时间戳进行搜索</h3><p><code>find . -type f 时间戳</code></p>
<p>UNIX/Linux文件系统每个文件都有三种时间戳：</p>
<ul>
<li>访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。</li>
<li>修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li>
<li>变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索最近七天内被访问过的所有文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -atime -7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索恰好在七天前被访问过的所有文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -atime 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索超过七天内被访问过的所有文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -atime +7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索访问时间超过10分钟的所有文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -amin +10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出比file.log修改时间更长的所有文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -newer file.log</span><br></pre></td></tr></table></figure>

<h3 id="根据文件大小进行匹配"><a href="#根据文件大小进行匹配" class="headerlink" title="根据文件大小进行匹配"></a>根据文件大小进行匹配</h3><p><code>find . -type f -size 文件大小单元</code></p>
<p>文件大小单元：</p>
<ul>
<li>b —— 块（512字节）</li>
<li>c —— 字节</li>
<li>w —— 字（2字节）</li>
<li>k —— 千字节</li>
<li>M —— 兆字节</li>
<li>G —— 吉字节</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索大于10KB的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -size +10k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索小于10KB的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -size -10k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索等于10KB的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -size 10k</span><br></pre></td></tr></table></figure>

<h3 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除当前目录下所有.txt文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -delete</span><br></pre></td></tr></table></figure>

<h3 id="根据文件权限-所有权进行匹配"><a href="#根据文件权限-所有权进行匹配" class="headerlink" title="根据文件权限/所有权进行匹配"></a>根据文件权限/所有权进行匹配</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下搜索出权限为777的文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -perm 777</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出当前目录下权限不是644的php文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.php&quot;</span> ! -perm 644</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出当前目录用户tom拥有的所有文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -user tom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出当前目录用户组sunk拥有的所有文件</span></span><br><span class="line">find . -<span class="built_in">type</span> f -group sunk</span><br></pre></td></tr></table></figure>

<h3 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助-exec选项与其他命令结合使用</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找出当前目录下所有root的文件，并把所有权更改为用户tom</span></span><br><span class="line"><span class="comment"># &#123;&#125; 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</span></span><br><span class="line">find .-<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown tom &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出自己家目录下所有的.txt文件并删除</span></span><br><span class="line"><span class="comment"># -ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。</span></span><br><span class="line">find <span class="variable">$HOME</span>/. -name <span class="string">&quot;*.txt&quot;</span> -ok rm &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> cat &#123;&#125; \;&gt; all.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将30天前的.log文件移动到old目录中</span></span><br><span class="line">find . -<span class="built_in">type</span> f -mtime +30 -name <span class="string">&quot;*.log&quot;</span> -<span class="built_in">exec</span> cp &#123;&#125; old \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">printf</span> <span class="string">&quot;File: %s\n&quot;</span> &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</span></span><br><span class="line">-<span class="built_in">exec</span> ./text.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<h3 id="搜索但跳出指定的目录"><a href="#搜索但跳出指定的目录" class="headerlink" title="搜索但跳出指定的目录"></a>搜索但跳出指定的目录</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</span></span><br><span class="line">find . -path <span class="string">&quot;./sk&quot;</span> -prune -o -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<h3 id="find其他技巧收集"><a href="#find其他技巧收集" class="headerlink" title="find其他技巧收集"></a>find其他技巧收集</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要列出所有长度为零的文件</span></span><br><span class="line">find . -empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用du -m -d 1 /|sort -nr  先看看根路径下，哪个文件夹比较大，并且有嫌疑是导致磁盘满的罪魁祸首。</span></span><br><span class="line"><span class="comment"># 然后再基于那个目录进行find。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务器磁盘满，一般由大的日志文件导致，需找到大文件并删除。</span></span><br><span class="line"><span class="comment"># find指令为找出500M以上的文件，print0和xargs -0配合使用，用来解决文件名中有空格或特殊字符问题。</span></span><br><span class="line"><span class="comment"># du -m是查看这些文件的大小，并以m为单位显示。最后sort -nr是按照数字反向排序（大的文件在前）</span></span><br><span class="line">find / -size +500M -print0|xargs -0 du -m|sort -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模糊查找下这个文件</span></span><br><span class="line">find / -name *xxx*.c</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-find.html">Linux find 命令</a></p>
<p><a target="_blank" rel="noopener" href="https://man.linuxde.net/find">find命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/30/Linux-xargs%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/30/Linux-xargs%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux xargs命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-30 16:11:22" itemprop="dateCreated datePublished" datetime="2021-03-30T16:11:22+00:00">2021-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。它能够捕获一个命令的输出，然后传递给另外一个命令。</p>
<p>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。xargs 一般是和管道一起使用。</p>
<p>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</p>
<p><strong>命令格式:</strong></p>
<p><code>somecommand |xargs -item  command</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>-a file 从文件中读入作为 stdin</li>
<li>-e flag ，注意有的时候可能会是-E，flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li>
<li>-p 当每次执行一个argument的时候询问一次用户。</li>
<li>-n num 后面加次数，xargs生成的命令行参数，每次传递几个参数给其后面的命令执行，默认是用所有的。</li>
<li>-t 表示先打印命令，然后再执行。</li>
<li>-i 或者是-I，将xargs的每项名称，一般是一行一行赋值给 {}，可以用 {} 代替。</li>
<li>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs，不用再去执行了。</li>
<li>-s num 命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li>
<li>-L num 从标准输入一次读取 num 行送给 command 命令。</li>
<li>-l 同 -L。</li>
<li>-d delim 分隔符，默认的xargs分隔符是回车，argument的分隔符是空格，这里修改的是xargs的分隔符。</li>
<li>-x exit的意思，主要是配合-s使用。。</li>
<li>-P 修改最大的进程数，默认是1，为0时候为as many as it can ，这个例子我没有想到，应该平时都用不到的吧。</li>
<li>-0：参数表示用null当作分隔符。</li>
</ul>
<p><strong>实例</strong></p>
<p>xargs 用作替换工具，读取输入数据重新格式化后输出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt | xargs</span></span><br><span class="line">1123 ls: 无法访问dd: 没有那个文件或目录 ls: 无法访问dd: 没有那个文件或目录</span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt | xargs -n2</span></span><br><span class="line">1123 ls:</span><br><span class="line">无法访问dd: 没有那个文件或目录</span><br><span class="line">ls: 无法访问dd:</span><br><span class="line">没有那个文件或目录</span><br></pre></td></tr></table></figure>

<p><code>-d</code> 选项可以自定义一个定界符</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameXnameXnameXname&quot;</span> | xargs -dX</span><br><span class="line">name name name name</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameXnameXnameXname&quot;</span> | xargs -dX -n2</span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure>

<p>读取 stdin，将格式化后的参数传递给命令</p>
<p>假设一个命令为 sk.sh 和一个保存参数的文件 arg.txt：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#sk.sh命令内容，打印出所有参数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $*</span><br></pre></td></tr></table></figure>

<p>arg.txt文件内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat arg.txt</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<p>xargs 的一个选项 -I，使用 -I 指定一个替换字符串 {}，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat arg.txt | xargs -I &#123;&#125; ./sk.sh -p &#123;&#125; -l</span></span><br><span class="line"></span><br><span class="line">-p aaa -l</span><br><span class="line">-p bbb -l</span><br><span class="line">-p ccc -l</span><br></pre></td></tr></table></figure>

<p>复制所有图片文件到 <code>/data/images</code> 目录下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls *.jpg | xargs -n1 -I &#123;&#125; cp &#123;&#125; /data/images</span><br></pre></td></tr></table></figure>

<p><strong>xargs 结合 find 使用</strong></p>
<p>由于 <code>xargs</code> 默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。</p>
<p><code>find</code>命令有一个特别的参数 <code>-print0</code>，指定输出的文件列表以 <code>null</code>分隔。然后，<code>xargs</code> 命令的 <code>-0</code> 参数表示用 <code>null</code>当作分隔符。</p>
<p>用 rm 删除太多的文件时候，可能得到一个错误信息：<code>/bin/rm Argument list too long</code>. 用 xargs 去避免这个问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span> -print0 | xargs -0 rm -f</span><br><span class="line">xargs -0</span><br></pre></td></tr></table></figure>

<p>统计一个源代码目录中所有 php 文件的行数：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.php&quot;</span> -print0 | xargs -0 wc -l</span><br></pre></td></tr></table></figure>

<p>查找所有的 jpg 文件，并且压缩它们：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.jpg&quot;</span> -<span class="built_in">print</span> | xargs tar -czvf images.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>xargs 其他应用</strong></p>
<p>假如你有一个文件包含了很多你希望下载的 URL，你能够使用 xargs下载所有链接：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat url-list.txt | xargs wget -c</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-xargs.html">Linux xargs 命令</a></p>
<p><a target="_blank" rel="noopener" href="https://ruanyifeng.com/blog/2019/08/xargs-tutorial.html">xargs 命令教程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/30/Linux%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/30/Linux%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6%E5%8F%B7/" class="post-title-link" itemprop="url">Linux重定向符号-<,<<,>,>></a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-30 15:22:17" itemprop="dateCreated datePublished" datetime="2021-03-30T15:22:17+00:00">2021-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>箭头的指向就是数据的流向。</p>
<p>数字说明</p>
<ul>
<li>1、标准输入（英文：stdin）： 代码为 <code>0</code>，使用 <code>&lt;</code> 或 <code>&lt;&lt;</code> 。数据流从右向左。</li>
<li>2、标准正常输出（英文：stdout）：代码为 <code>1</code>，使用 <code>&gt;</code> 或 <code>&gt;&gt;</code> 。数据流从左向右。</li>
<li>3、标准错误输出（英文：stderr）：代码为 <code>2</code> ，使用 <code>2&gt;</code> 或 <code>2&gt;&gt;</code> 。数据流从左向右。</li>
<li>&amp;  ：表示等同于的意思，如 <code>&amp;1</code>。 </li>
<li>&amp;&gt;file：将标准输入和标准错误输出到重定向到文件。</li>
</ul>
<p>例如：<code>2&gt;&amp;1</code> 表示2的输出重定向等同于1，也就是标准错误输出重定向到标准输出。</p>
<h2 id="命令-lt-文件"><a href="#命令-lt-文件" class="headerlink" title="命令 &lt; 文件"></a>命令 &lt; 文件</h2><p>将文件作为命令的标准输入</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">123</span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># echo &#x27;123&#x27; &gt; source.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># xargs -n 2 &lt; source.txt</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h2 id="命令-lt-lt-分界符"><a href="#命令-lt-lt-分界符" class="headerlink" title="命令 &lt;&lt; 分界符"></a>命令 &lt;&lt; 分界符</h2><p>从标准输入中读入，直到遇到分界符停止。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat &gt;&gt; source.txt &lt;&lt;EOF</span></span><br><span class="line">&gt; 23456</span><br><span class="line">&gt; EOF</span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">123</span><br><span class="line">23456</span><br></pre></td></tr></table></figure>

<h2 id="命令-lt-文件1-gt-文件2"><a href="#命令-lt-文件1-gt-文件2" class="headerlink" title="命令 &lt; 文件1 &gt; 文件2"></a>命令 &lt; 文件1 &gt; 文件2</h2><p>将文件1作为命令的标准输入并将标准输出到文件2</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># touch source1.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># xargs -n 2 &lt;source.txt &gt; source1.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source1.txt</span></span><br><span class="line">123 23456</span><br></pre></td></tr></table></figure>

<h2 id="命令-gt-文件"><a href="#命令-gt-文件" class="headerlink" title="命令 &gt; 文件"></a>命令 &gt; 文件</h2><p>将标准输出重定向到文件中（清除原有文件中的数据）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">123</span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># echo &#x27;456&#x27; &gt; source.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">456</span><br></pre></td></tr></table></figure>

<h2 id="命令-2-gt-文件"><a href="#命令-2-gt-文件" class="headerlink" title="命令 2&gt; 文件"></a>命令 2&gt; 文件</h2><p>将错误输出重定向到文件中（清除原有文件中的数据）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里使用错误命令 -2</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># xargs -n -2 &lt;source.txt 2&gt; source1.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source1.txt</span></span><br><span class="line">xargs: 选项 -n 的值必须 &gt;= 1</span><br><span class="line">Usage: xargs [OPTION]... COMMAND INITIAL-ARGS...</span><br><span class="line">Run COMMAND with arguments INITIAL-ARGS and more arguments <span class="built_in">read</span> from input.</span><br></pre></td></tr></table></figure>

<h2 id="命令-gt-gt-文件"><a href="#命令-gt-gt-文件" class="headerlink" title="命令 &gt;&gt; 文件"></a>命令 &gt;&gt; 文件</h2><p>将标准输出重定向到文件中（在原有的内容后追加）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">123</span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># echo &#x27;456&#x27; &gt;&gt; source.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure>

<h2 id="命令-2-gt-gt-文件"><a href="#命令-2-gt-gt-文件" class="headerlink" title="命令 2&gt;&gt; 文件"></a>命令 2&gt;&gt; 文件</h2><p>将错误输出重定向到文件中（在原有内容后面追加）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里使用错误命令 -2</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source1.txt</span></span><br><span class="line">456</span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># xargs -n -2 &lt;source.txt 2&gt;&gt; source1.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source1.txt</span></span><br><span class="line">456</span><br><span class="line">xargs: 选项 -n 的值必须 &gt;= 1</span><br></pre></td></tr></table></figure>

<h2 id="命令-amp-gt-gt-文件"><a href="#命令-amp-gt-gt-文件" class="headerlink" title="命令 &amp;&gt;&gt; 文件"></a>命令 &amp;&gt;&gt; 文件</h2><p>等同于：命令 &gt;&gt; 文件 2&gt;&amp;1</p>
<p>将标准输出和错误输出共同写入文件（在原有内容后追加）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># echo &#x27;1123&#x27; &gt; source.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">1123</span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># ls dd &gt;&gt; source.txt 2&gt;&amp;1</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">1123</span><br><span class="line">ls: 无法访问dd: 没有那个文件或目录</span><br><span class="line"></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># ls dd &amp;&gt;&gt; source.txt</span></span><br><span class="line">[root@host-192-125-30-82 <span class="built_in">test</span>]<span class="comment"># cat source.txt</span></span><br><span class="line">1123</span><br><span class="line">ls: 无法访问dd: 没有那个文件或目录</span><br><span class="line">ls: 无法访问dd: 没有那个文件或目录</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/walkwaters/p/12459727.html">linux重定向符——“&lt;”、”&lt;&lt;”、”&gt;”和”&gt;&gt;”</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014360942/article/details/72630322">Linux中的特殊符号-重定向符号</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-tail%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-tail%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux tail命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 15:45:29" itemprop="dateCreated datePublished" datetime="2021-03-29T15:45:29+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>tail 命令和 head 命令正好相反，用来查看文件末尾的数据。</p>
<p>基本格式如下：<code>tail [选项] 文件名</code></p>
<ul>
<li>-n 行数K：该选项表示输出最后 K 行，在此基础上，如果使用 <code>-n +K</code>，则表示从文件的第 K 行开始输出。</li>
<li>-c 行数K: 该选项表示输出文件最后 K 个字节的内容，在此基础上，使用 <code>-c +K</code> 则表示从文件第 K 个字节开始输出。</li>
<li>-f :输出文件变化后新增加的数据。</li>
</ul>
<p>实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 /etc/passwd 文件最后 3 行的数据内容</span></span><br><span class="line">tail -n 3 /etc/passwd</span><br><span class="line">tail -3 /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 /etc/passwd 文件末尾 100 个字节的数据内容</span></span><br><span class="line">tail -c 100 /etc/passwd</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/737.html">Linux tail命令：显示文件结尾的内容</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/CentOS7%E6%8E%92%E6%9F%A5CLOSE-WAIT%E8%BF%87%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/CentOS7%E6%8E%92%E6%9F%A5CLOSE-WAIT%E8%BF%87%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">CentOS7排查CLOSE_WAIT过多异常原因</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 15:33:01" itemprop="dateCreated datePublished" datetime="2021-03-29T15:33:01+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查看系统连接数"><a href="#查看系统连接数" class="headerlink" title="查看系统连接数"></a>查看系统连接数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前socket连接状态统计信息</span></span><br><span class="line">cat /proc/net/sockstat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计当前各种状态的连接的数量的命令</span></span><br><span class="line">netstat -n | awk <span class="string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="查看端口范围"><a href="#查看端口范围" class="headerlink" title="查看端口范围"></a>查看端口范围</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许系统打开的端口范围，用于向外链接的端口范围</span></span><br><span class="line">cat /proc/sys/net/ipv4/ip_local_port_range</span><br><span class="line">1024	65000</span><br></pre></td></tr></table></figure>

<h2 id="查看文件打开数"><a href="#查看文件打开数" class="headerlink" title="查看文件打开数"></a>查看文件打开数</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前打开文件数 </span></span><br><span class="line"><span class="comment"># 如果执行缓慢，那么执行结果显示系统当前打开文件数500w</span></span><br><span class="line">lsof | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把当前打开文件列表保存</span></span><br><span class="line">lsof&gt;&gt;/tmp/lsof.log  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 5-6万 行之间的数据</span></span><br><span class="line">sed -n <span class="string">&#x27;50000,60000p&#x27;</span> /tmp/lsof.log</span><br></pre></td></tr></table></figure>

<p>结果，应用大量调用redis，且没有关闭：</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210329155921.png" alt="微信截图_20210329155921.png"></p>
<h2 id="排查代码"><a href="#排查代码" class="headerlink" title="排查代码"></a>排查代码</h2><p>找到如下问题：每次调用工具类，都 new 一个 csredis 客户端，导致连接数过多。</p>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210329160151.png" alt="微信截图_20210329160151.png"></p>
<p>修复：删除工具类，使用csredis静态类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-ss%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-ss%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux ss命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 15:04:56" itemprop="dateCreated datePublished" datetime="2021-03-29T15:04:56+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ss命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。ss命令是Linux CentOS 7中iproute软件包的一部分，默认已经安装。</p>
<p>当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。</p>
<p>ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iproute</span><br><span class="line">yum info iproute</span><br></pre></td></tr></table></figure>

<p>语法</p>
<p><code>ss(选项)</code></p>
<p>选项</p>
<ul>
<li>-h：显示帮助信息；</li>
<li>-V：显示指令版本信息；</li>
<li>-n：不解析服务名称，以数字方式显示；</li>
<li>-a：显示所有的套接字；</li>
<li>-l：显示处于监听状态的套接字；</li>
<li>-o：显示计时器信息；</li>
<li>-m：显示套接字的内存使用情况；</li>
<li>-p：显示使用套接字的进程信息；</li>
<li>-i：显示内部的TCP信息；</li>
<li>-4：只显示ipv4的套接字；</li>
<li>-6：只显示ipv6的套接字；</li>
<li>-t：只显示tcp套接字；</li>
<li>-u：只显示udp套接字；</li>
<li>-d：只显示DCCP套接字；</li>
<li>-w：仅显示RAW套接字；</li>
<li>-x：仅显示UNIX域套接字。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示ICP连接</span></span><br><span class="line">ss -t -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 Sockets 摘要</span></span><br><span class="line">ss -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有打开的网络连接端口</span></span><br><span class="line">ss -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程使用的socket</span></span><br><span class="line">ss -pl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有UDP Sockets</span></span><br><span class="line">ss -u -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看6379端口</span></span><br><span class="line">ss -ta sport = :6379 | head</span><br><span class="line">ss -pl | grep 3306</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有状态为established的SMTP连接</span></span><br><span class="line">ss -o state established <span class="string">&#x27;( dport = :smtp or sport = :smtp )&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有状态为Established的HTTP连接</span></span><br><span class="line">ss -o state established <span class="string">&#x27;( dport = :http or sport = :http )&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字</span></span><br><span class="line">ss -o state fin-wait-1 <span class="string">&#x27;( sport = :http or sport = :https )&#x27;</span> dst 193.233.7/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用TCP 状态过滤Sockets</span></span><br><span class="line">ss -4 state closing </span><br><span class="line">ss -4 state FILTER-NAME</span><br><span class="line">ss -6 state FILTER-NAME</span><br><span class="line"></span><br><span class="line"><span class="comment"># FILTER-NAME-HERE 可以代表以下任何一个：</span></span><br><span class="line"></span><br><span class="line">established</span><br><span class="line">syn-sent</span><br><span class="line">syn-recv</span><br><span class="line">fin-wait-1</span><br><span class="line">fin-wait-2</span><br><span class="line">time-wait</span><br><span class="line">closed</span><br><span class="line">close-wait</span><br><span class="line">last-ack</span><br><span class="line">listen</span><br><span class="line">closing</span><br><span class="line">all : 所有以上状态</span><br><span class="line">connected : 除了listen and closed的所有状态</span><br><span class="line">synchronized :所有已连接的状态除了syn-sent</span><br><span class="line">bucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.</span><br><span class="line">big : 和bucket相反.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配远程地址和端口号</span></span><br><span class="line">ss dst ADDRESS_PATTERN</span><br><span class="line">ss dst 192.168.1.5</span><br><span class="line">ss dst 192.168.119.113:http </span><br><span class="line">ss dst 192.168.119.113:smtp </span><br><span class="line">ss dst 192.168.119.113:443</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配本地地址和端口号</span></span><br><span class="line">ss src ADDRESS_PATTERN</span><br><span class="line">ss src 192.168.119.103</span><br><span class="line">ss src 192.168.119.103:http</span><br><span class="line">ss src 192.168.119.103:80</span><br><span class="line">ss src 192.168.119.103:smtp</span><br><span class="line">ss src 192.168.119.103:25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地或者远程端口和一个数比较</span></span><br><span class="line">ss dport OP PORT </span><br><span class="line">ss sport OP PORT</span><br><span class="line"></span><br><span class="line"><span class="comment"># ss dport OP PORT 远程端口和一个数比较；</span></span><br><span class="line"><span class="comment"># ss sport OP PORT 本地端口和一个数比较。</span></span><br><span class="line">OP 可以代表以下任意一个: </span><br><span class="line">&lt;= or le : 小于或等于端口号</span><br><span class="line">&gt;= or ge : 大于或等于端口号</span><br><span class="line">== or eq : 等于端口号</span><br><span class="line">!= or ne : 不等于端口号</span><br><span class="line">&lt; or gt : 小于端口号</span><br><span class="line">&gt; or lt : 大于端口号</span><br><span class="line"></span><br><span class="line"><span class="comment"># ss 和 netstat 效率对比</span></span><br><span class="line">time netstat -at</span><br><span class="line">time ss</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://man.linuxde.net/ss">ss命令</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/03/11/2953420.html">每天一个linux命令（57）：ss命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-sed%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-sed%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux sed命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 10:18:17" itemprop="dateCreated datePublished" datetime="2021-03-29T10:18:17+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux 三剑客，它们是 grep、awk、sed。</p>
<p>sed 全名叫 <code>stream editor</code>，流编辑器，用程序的方式来编辑文本，与 vim 的交互式编辑方式截然不同。它的功能十分强大，加上正则表达式的支持，可以进行大量的复杂文本的编辑操作。</p>
<p>使用场景：</p>
<ul>
<li>自动化程序中，不适合交互方式编辑的；</li>
<li>大批量重复性的编辑需求；</li>
<li>编辑命令太过复杂，在交互文本编辑器难以输入的情况；</li>
</ul>
<p>Linux sed 命令是利用脚本来处理文本文件。sed 命令采用的是流编辑模式，最明显的特点是，在 sed 处理数据之前，需要预先提供一组规则，sed 会按照此规则来编辑数据。默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</p>
<p>默认情况下 sed 并不会修改原始文件，这里被删除的行只是从 sed 的输出中消失了，原始文件没做任何改变。</p>
<p>sed 会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下：</p>
<ul>
<li>1，每次仅读取一行内容；</li>
<li>2，根据提供的规则命令匹配并修改数据。注意，sed 默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；</li>
<li>3，将执行结果输出。</li>
</ul>
<p><strong>工作原理</strong></p>
<p>sed 作为一种非交互式编辑器，它使用预先设定好的编辑指令对输入的文本进行编辑，完成之后输出编辑结果。</p>
<p>简单描述 sed 工作原理：</p>
<ul>
<li>sed 从输入文件中读取内容，每次处理一行内容，并把当前的一行内容存储在临时的缓冲区中，称为 模式空间。</li>
<li>接着用 sed 命令处理缓存区中的内容；</li>
<li>处理完毕后，把缓存区的内容送往屏幕；</li>
<li>接着处理下一行；</li>
</ul>
<p>这样不断重复，直到文件末尾，文件内容并没有改变，除非你使用重定向输出或指定了 i 参数</p>
<p>当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。</p>
<p>语法 <code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code></p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-e 脚本命令</td>
<td align="left">该选项会将其后跟的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td align="center">-f 脚本命令文件</td>
<td align="left">该选项会将其后文件中的脚本命令添加到已有的命令中。</td>
</tr>
<tr>
<td align="center">-n或–quiet或–silent</td>
<td align="left">仅显示script处理后的结果，默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</td>
</tr>
<tr>
<td align="center">-h或–help</td>
<td align="left">显示帮助。</td>
</tr>
<tr>
<td align="center">-V或–version</td>
<td align="left">显示版本信息。</td>
</tr>
</tbody></table>
<p>动作说明</p>
<p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除， d 后面通常不接任何字符；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：打印， 将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行<br>s ：取代， 通常搭配正规表示法，例如 1,20s/old/new/g</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>sed 基本上就是用正则表达式模式匹配。</p>
<h3 id="基本正则表达式"><a href="#基本正则表达式" class="headerlink" title="基本正则表达式"></a>基本正则表达式</h3><ul>
<li><code>.</code> 表示匹配任意一个字符，除了换行符，类似 Shell 通配符中的 ?；</li>
<li><code>*</code> 表示前边字符有 0 个或多个；</li>
<li><code>.*</code> 表示任意一个字符有 0 个或多个，也就是能匹配任意的字符；</li>
<li><code>^</code> 表示行首，也就是每一行的开始位置，^abc 匹配以 abc 开头的字符串；</li>
<li><code>$</code> 表示行尾，也就是每一行的结尾位置，}$ 匹配以大括号结尾的字符串；</li>
<li><code>&#123;&#125;</code> 表示前边字符的数量范围，{2}，表示重复 2 次，{2,}重复至少 2次，{2,4} 重复 2-4 次；</li>
<li><code>[]</code> 括号中可以包含表示字符集的表达式，使用方法大概如下几种</li>
</ul>
<p><img src="/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20210330113252.png" alt="微信截图_20210330113252.png"></p>
<h3 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h3><p>扩展正则表达式使用频率上没有基本表达式那么高，但依然很重要，很多情况下没有扩展正则是搞不定的，sed 命令使用扩展正则时需要加上选项 <code>-r</code>。</p>
<ul>
<li><code>?</code>：表示前置字符有 0 个或 1 个；</li>
<li><code>+</code>：表示前置字符有 1 个或多个；</li>
<li><code>|</code>：表示匹配其中的一项即可；</li>
<li><code>()</code>：表示分组，(a|b)b 表示可以匹配 ab 或 bb 子串，且命令表达式中可以通过 \1、\2 来表示匹配的变量</li>
<li><code>&#123;&#125;</code>：和基本正则中的大括号中意义相同，只不过使用时不用加 转义符号；</li>
</ul>
<h2 id="数字定址和正则定址"><a href="#数字定址和正则定址" class="headerlink" title="数字定址和正则定址"></a>数字定址和正则定址</h2><p>默认情况下 sed 会对每一行内容进行匹配、处理、输出，有时候我们不需要对所有内容进行操作，只需要修改一种一部分，比如 1-10 行，偶数行，或包括 hello 字符串的行。</p>
<p>这种情况下，就需要我们去定位特定的行来进行处理，而不是全部内容，这里把定位指定的行叫做 定址。</p>
<h3 id="数字定址"><a href="#数字定址" class="headerlink" title="数字定址"></a>数字定址</h3><p>数字定址其实就是通过数字去指定要操作的行，有几种方式，每种方式都有不同的应用场景。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只将第4行中hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;4s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将第2-4行中hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;2,4s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第2行开始，往下数4行，也就是2-6行</span></span><br><span class="line">$ sed <span class="string">&#x27;2,+4s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将最后1行中hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;$s/hello/A/g&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了第1行，其它行将hello替换为A</span></span><br><span class="line">$ sed <span class="string">&#x27;1!s/hello/A/g&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h3 id="正则定址"><a href="#正则定址" class="headerlink" title="正则定址"></a>正则定址</h3><p>正则定址，是通过正则表达式的匹配来确定需要处理编辑哪些行，其它行就不需要处理</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将匹配到hello的行执行删除操作，d 表示删除</span></span><br><span class="line">$ sed <span class="string">&#x27;/hello/d&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空行，&quot;^$&quot; 表示空行</span></span><br><span class="line">$ sed <span class="string">&#x27;/^$/d&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将匹配到以ts开头的行到以te开头的行之间所有行进行删除</span></span><br><span class="line">$ sed <span class="string">&#x27;/^ts/,/^te/d&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h3 id="数字定址和正则定址混用"><a href="#数字定址和正则定址混用" class="headerlink" title="数字定址和正则定址混用"></a>数字定址和正则定址混用</h3><p>数字定址和正则定址可以配合使用</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配从第1行到ts开头的行，把匹配的行执行删除</span></span><br><span class="line">$ sed <span class="string">&#x27;1,/^ts/d&#x27;</span> file.txt</span><br></pre></td></tr></table></figure>

<h2 id="sed脚本命令"><a href="#sed脚本命令" class="headerlink" title="sed脚本命令"></a>sed脚本命令</h2><h3 id="sed-s-替换脚本命令"><a href="#sed-s-替换脚本命令" class="headerlink" title="sed s 替换脚本命令"></a>sed s 替换脚本命令</h3><p>此命令的基本格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[address]s/pattern/replacement/flags</span><br></pre></td></tr></table></figure>
<p>address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。</p>
<p>sed s命令flags标记及功能:</p>
<table>
<thead>
<tr>
<th align="center">flags 标记</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">n</td>
<td align="left">1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td>
</tr>
<tr>
<td align="center">g</td>
<td align="left">对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td>
</tr>
<tr>
<td align="center">p</td>
<td align="left">会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td>
</tr>
<tr>
<td align="center">w file</td>
<td align="left">将缓冲区中的内容写到指定的 file 文件中；</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="left">用正则表达式匹配的内容进行替换；</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配第 n 个子串，该子串之前在 pattern 中用 <code>\(\)</code> 指定。</td>
</tr>
<tr>
<td align="center">\</td>
<td align="left">转义（转义替换部分包含：&amp; ，\ 等）。</td>
</tr>
</tbody></table>
<p><strong>实例</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed 编辑器只替换每行中第 2 次出现的匹配模式</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/2&#x27;</span> data4.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 g 标记，在新文件替换所有匹配的字符串</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/g&#x27;</span> data4.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n 选项会禁止 sed 输出，p 标记会输出修改过的行，</span></span><br><span class="line"><span class="comment"># 二者匹配使用的效果就是只输出被替换命令修改过的行</span></span><br><span class="line">sed -n <span class="string">&#x27;s/test/trial/p&#x27;</span> data5.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># w 标记会将匹配后的结果保存到指定文件中</span></span><br><span class="line">sed <span class="string">&#x27;s/test/trial/w test.txt&#x27;</span> data5.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换类似文件路径的字符串，需要将路径中的正斜线进行转义</span></span><br><span class="line">sed <span class="string">&#x27;s/\/bin\/bash/\/bin\/csh/&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="sed-d-替换脚本命令"><a href="#sed-d-替换脚本命令" class="headerlink" title="sed d 替换脚本命令"></a>sed d 替换脚本命令</h3><p>基本格式为：<code>[address]d</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有内容</span></span><br><span class="line">sed <span class="string">&#x27;d&#x27;</span> data1.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过行号指定，比如删除 data6.txt 文件内容中的第 3 行：</span></span><br><span class="line">sed <span class="string">&#x27;3d&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过特定行区间指定，比如删除 data6.txt 文件内容中的第 2、3行</span></span><br><span class="line">sed <span class="string">&#x27;2,3d&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用两个文本模式来删除某个区间内的行</span></span><br><span class="line"><span class="comment"># 指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，</span></span><br><span class="line"><span class="comment"># 因此，sed 会删除两个指定行之间的所有行（包括指定的行）</span></span><br><span class="line"><span class="comment"># 删除第 1~3 行的文本数据</span></span><br><span class="line">sed <span class="string">&#x27;/1/,/3/d&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过特殊的文件结尾字符，比如删除 data6.txt 文件内容中第 3 行开始的所有的内容</span></span><br><span class="line">sed <span class="string">&#x27;3,$d&#x27;</span> data6.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-a-和-i-脚本命令"><a href="#sed-a-和-i-脚本命令" class="headerlink" title="sed a 和 i 脚本命令"></a>sed a 和 i 脚本命令</h3><p>a 命令表示在指定行的后面附加一行，i 命令表示在指定行的前面插入一行</p>
<p>基本格式：<code>[address]a（或 i）\新文本内容</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将一个新行插入到数据流第三行前</span></span><br><span class="line">sed <span class="string">&#x27;3i\</span></span><br><span class="line"><span class="string">&gt; This is an inserted line.&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个新行附加到数据流中第三行后</span></span><br><span class="line">sed <span class="string">&#x27;3a\</span></span><br><span class="line"><span class="string">&gt; This is an appended line.&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可</span></span><br><span class="line"> sed <span class="string">&#x27;1i\</span></span><br><span class="line"><span class="string">&gt; This is one line of new text.\</span></span><br><span class="line"><span class="string">&gt; This is another line of new text.&#x27;</span> data6.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-c-替换脚本命令"><a href="#sed-c-替换脚本命令" class="headerlink" title="sed c 替换脚本命令"></a>sed c 替换脚本命令</h3><p>c 命令表示将指定行中的所有内容，替换成该选项后面的字符串。</p>
<p>基本格式为：<code>[address]c\用于替换的新文本</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;3c\</span></span><br><span class="line"><span class="string">&gt; This is a changed line of text.&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">sed <span class="string">&#x27;/number 3/c\</span></span><br><span class="line"><span class="string">&gt; This is a changed line of text.&#x27;</span> data6.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-y-转换脚本命令"><a href="#sed-y-转换脚本命令" class="headerlink" title="sed y 转换脚本命令"></a>sed y 转换脚本命令</h3><p>y 转换命令是唯一可以处理单个字符的 sed 脚本命令</p>
<p>基本格式：<code>[address]y/inchars/outchars/</code></p>
<p>转换命令会对 inchars 和 outchars 值进行一对一的映射，即 inchars 中的第一个字符会被转换为 outchars 中的第一个字符，第二个字符会被转换成 outchars 中的第二个字符…这个映射过程会一直持续到处理完指定字符。</p>
<p>如果 inchars 和 outchars 的长度不同，则 sed 会产生一条错误消息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;y/123/789/&#x27;</span> data8.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换命令是一个全局命令，它会文本行中找到的所有指定字符自动进行转换，</span></span><br><span class="line"><span class="comment"># 而不会考虑它们出现的位置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This 1 is a test of 1 try.&quot;</span> | sed <span class="string">&#x27;y/123/456/&#x27;</span></span><br><span class="line">This 4 is a <span class="built_in">test</span> of 4 try.</span><br></pre></td></tr></table></figure>

<h3 id="sed-p-打印脚本命令"><a href="#sed-p-打印脚本命令" class="headerlink" title="sed p 打印脚本命令"></a>sed p 打印脚本命令</h3><p>p 命令表示搜索符号条件的行，并输出该行的内容</p>
<p>基本格式为：<code>[address]p</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p 命令常见的用法是打印包含匹配文本模式的行</span></span><br><span class="line">sed -n <span class="string">&#x27;/number 3/p&#x27;</span> data6.txt</span><br><span class="line">This is line number 3.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找包含数字 3 的行，然后执行两条命令。</span></span><br><span class="line"><span class="comment"># 首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。</span></span><br><span class="line"><span class="comment"># 输出同时显示了原来的行文本和新的行文本。</span></span><br><span class="line">sed -n <span class="string">&#x27;/3/&#123;</span></span><br><span class="line"><span class="string">&gt; p</span></span><br><span class="line"><span class="string">&gt; s/line/test/p</span></span><br><span class="line"><span class="string">&gt; &#125;&#x27;</span> data6.txt</span><br><span class="line">This is line number 3.</span><br><span class="line">This is <span class="built_in">test</span> number 3.</span><br></pre></td></tr></table></figure>

<h3 id="sed-w-脚本命令"><a href="#sed-w-脚本命令" class="headerlink" title="sed w 脚本命令"></a>sed w 脚本命令</h3><p>w 命令用来将文本中指定行的内容写入文件中</p>
<p>基本格式如下：<code>[address]w filename</code></p>
<p>filename 表示文件名，可以使用相对路径或绝对路径，运行 sed 命令的用户都必须有文件的写权限。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 data6.txt 1，2行打印到 test.txt</span></span><br><span class="line">sed <span class="string">&#x27;1,2w test.txt&#x27;</span> data6.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不想让行直接输出，可以用 -n 选项</span></span><br><span class="line">sed -n <span class="string">&#x27;/Browncoat/w Browncoats.txt&#x27;</span> data11.txt</span><br></pre></td></tr></table></figure>

<h3 id="sed-r-脚本命令"><a href="#sed-r-脚本命令" class="headerlink" title="sed r 脚本命令"></a>sed r 脚本命令</h3><p>r 命令用于将一个独立文件的数据插入到当前数据流的指定位置，</p>
<p>基本格式为：<code>[address]r filename</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sed 命令会将 filename 文件中的内容插入到 address 指定行的后面</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat data12.txt</span></span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;3r data12.txt&#x27; data6.txt</span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br><span class="line">This is line number 4.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定文件中的数据插入到数据流的末尾，可以使用 $ 地址符</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;$r data12.txt&#x27; data6.txt</span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line">This is line number 3.</span><br><span class="line">This is line number 4.</span><br><span class="line">This is an added line.</span><br><span class="line">This is the second added line.</span><br></pre></td></tr></table></figure>

<h3 id="sed-q-退出脚本命令"><a href="#sed-q-退出脚本命令" class="headerlink" title="sed q 退出脚本命令"></a>sed q 退出脚本命令</h3><p>q 命令的作用是使 sed 命令在第一次匹配任务结束后，退出 sed 程序，不再进行对后续数据的处理。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sed 命令在打印输出第 2 行之后，就停止</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;2q&#x27; test.txt</span></span><br><span class="line">This is line number 1.</span><br><span class="line">This is line number 2.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 q 命令之后，sed 命令会在匹配到 number 1 时，将其替换成 number 0，然后直接退出。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;/number 1/&#123; s/number 1/number 0/;q; &#125;&#x27; test.txt</span></span><br><span class="line">This is line number 0.</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4028.html">Linux sed命令完全攻略</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/4056.html">Linux sed命令高级用法精讲</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-wc%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-wc%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux wc命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 10:01:16" itemprop="dateCreated datePublished" datetime="2021-03-29T10:01:16+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux wc 命令用于计算字数。利用 <code>wc</code> 指令可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则 <code>wc</code> 指令会从标准输入设备读取数据。</p>
<p>语法 <code>wc [-clw][--help][--version][文件...]</code></p>
<p>参数：</p>
<ul>
<li>-c或–bytes或–chars 只显示Bytes数。</li>
<li>-l或–lines 显示行数。</li>
<li>-w或–words 只显示字数。</li>
<li>–help 在线帮助。</li>
<li>–version 显示版本信息。</li>
</ul>
<p>实例</p>
<p>在默认的情况下，wc将计算指定文件的 行数、字数，以及字节数。使用的命令为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testfile文件的统计信息</span></span><br><span class="line">wc testfile</span><br><span class="line">3 92 598 testfile  <span class="comment"># testfile文件的行数为3、单词数92、字节数598 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#统计三个文件的信息</span></span><br><span class="line">wc testfile testfile_1 testfile_2</span><br><span class="line">3 92 598 testfile                    <span class="comment">#第一个文件行数为3、单词数92、字节数598  </span></span><br><span class="line">9 18 78 testfile_1                   <span class="comment">#第二个文件的行数为9、单词数18、字节数78  </span></span><br><span class="line">3 6 32 testfile_2                    <span class="comment">#第三个文件的行数为3、单词数6、字节数32  </span></span><br><span class="line">15 116 708 总用量                    <span class="comment">#三个文件总共的行数为15、单词数116、字节数708 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示行数</span></span><br><span class="line">wc -l</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/29/Linux-Head%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/29/Linux-Head%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux Head命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-29 09:56:55" itemprop="dateCreated datePublished" datetime="2021-03-29T09:56:55+00:00">2021-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>head</code> 命令可用于查看文件的开头部分的内容，有一个常用的参数 <code>-n</code> 用于显示行数，默认为 <code>10</code>，即显示 <code>10</code> 行的内容。</p>
<p>命令格式：<code>head [参数] [文件]</code></p>
<p>参数：</p>
<ul>
<li>-q 隐藏文件名</li>
<li>-v 显示文件名</li>
<li>-c&lt;数目&gt; 显示的字节数。</li>
<li>-n&lt;行数&gt; 显示的行数。</li>
</ul>
<p>实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 15 1.log</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/25/Linux-rlogin%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/Linux-rlogin%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux rlogin命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 13:33:02" itemprop="dateCreated datePublished" datetime="2021-03-25T13:33:02+00:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux rlogin命令用于远端登入。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>rlogin [-8EL][-e &lt;脱离字符&gt;][-l &lt;用户名称&gt;][主机名称或IP地址]</p>
<p><strong>必要参数：</strong></p>
<ul>
<li>-E 忽略escape字符</li>
<li>-8 只识别8位字的字符</li>
<li>-L 允许rlogin会话运行在litout模式</li>
<li>-ec 设置escape字符为c</li>
<li>-c 断开连接前要求确认</li>
<li>-a 强制要求远程主机在发送完一个空的本地用户名之后请求一个密码</li>
<li>-f 向远端主机发送一个本地认证</li>
<li>-F 向远程主机发送一个可转寄的本地认证</li>
<li>-7 强制执行7为的传输</li>
<li>-d 打开用于远端主机通信的TCP套接口的调试</li>
<li>-k 要求包含远端主机的tisckets</li>
<li>-x 启动数据传输的DES加密</li>
<li>-4 只使用 kerkberos的版本4的认证</li>
</ul>
<p><strong>选择参数：</strong></p>
<ul>
<li>-e&lt;字符&gt;  设置退出字符</li>
<li>-l&lt;用户&gt;  指定登陆的用户</li>
<li>-t&lt;终端类型&gt; 设置终端类型</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>显示rlogin服务是否开启</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list //检测rlogin服务是否开启</span><br></pre></td></tr></table></figure>

<p>开启rlogin服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rlogin on //开启rlogin服务</span><br></pre></td></tr></table></figure>

<p>登陆远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rlogin 192.168.1.88</span><br><span class="line">Password：</span><br><span class="line">Password：</span><br><span class="line">Login incorrect (不准确)</span><br></pre></td></tr></table></figure>

<p>指定用户名登陆远程主机</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rlogin 192.125.30.112 -l root</span><br><span class="line"></span><br><span class="line">Passord:</span><br><span class="line">Last login：Mon May 25 13：40:25 from 192.125.30.112</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-rlogin.html">Linux rlogin命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/25/Linux-ar%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/Linux-ar%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux ar命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-25 09:37:23" itemprop="dateCreated datePublished" datetime="2021-03-25T09:37:23+00:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">Linux基础命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Linux ar命令用于建立或修改备存文件，或是从备存文件中抽取文件。</p>
<p>ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>ar[-dmpqrtx][cfosSuvV][a&lt;成员文件&gt;][b&lt;成员文件&gt;][i&lt;成员文件&gt;][备存文件][成员文件]</p>
<p>参数：</p>
<p>必要参数：</p>
<ul>
<li>-d 　删除备存文件中的成员文件。</li>
<li>-m 　变更成员文件在备存文件中的次序。</li>
<li>-p 　显示备存文件中的成员文件内容。</li>
<li>-q 　将文件附加在备存文件末端。</li>
<li>-r 　将文件插入备存文件中。</li>
<li>-t 　显示备存文件中所包含的文件。</li>
<li>-x 　自备存文件中取出成员文件。</li>
</ul>
<p>选项参数：</p>
<ul>
<li>a&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之后。</li>
<li>b&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</li>
<li>c 　建立备存文件。</li>
<li>f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。</li>
<li>i&lt;成员文件&gt; 　将文件插入备存文件中指定的成员文件之前。</li>
<li>o 　保留备存文件中文件的日期。</li>
<li>s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。</li>
<li>S 　不产生符号表。</li>
<li>u 　只将日期较新文件插入备存文件中。</li>
<li>v 　程序执行时显示详细的信息。</li>
<li>V 　显示版本信息。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>打包文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls   //显示当前目录文件   </span></span><br><span class="line">a.c    b.c d.c   install.log      qte</span><br><span class="line">anaconda-ks.cfg c.c Desktop </span><br><span class="line"></span><br><span class="line"><span class="comment"># ar rv one.bak a.c b.c //打包 a.c b.c文件 </span></span><br><span class="line">ar: 正在创建 one.bak</span><br><span class="line">a - a.c</span><br><span class="line">a - b.c</span><br></pre></td></tr></table></figure>

<ul>
<li>打包多个文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar rv two.bak *.c  //打包以.c结尾的文件  </span></span><br><span class="line">ar: 正在创建 two.bak</span><br><span class="line">a - a.c</span><br><span class="line">a - b.c</span><br><span class="line">a - c.c</span><br><span class="line">a - d.c</span><br></pre></td></tr></table></figure>

<ul>
<li>显示打包文件的内容</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar t two.bak    </span></span><br><span class="line">a.c</span><br><span class="line">b.c</span><br><span class="line">c.c</span><br><span class="line">d.c</span><br></pre></td></tr></table></figure>

<ul>
<li>删除打包文件的成员文件</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ar d two.bak a.c b.c c.c  </span></span><br><span class="line"><span class="comment"># ar t two.bak       </span></span><br><span class="line">d.c</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-ar.html">Linux ar命令</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/24/ELF-%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/ELF-%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">ELF格式文件解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 15:13:06" itemprop="dateCreated datePublished" datetime="2021-03-24T15:13:06+00:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 02:08:26" itemprop="dateModified" datetime="2021-04-02T02:08:26+00:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ELF/" itemprop="url" rel="index"><span itemprop="name">ELF</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象文件-Object-files-分类"><a href="#对象文件-Object-files-分类" class="headerlink" title="对象文件(Object files)分类"></a>对象文件(Object files)分类</h2><h3 id="一，可重定位的对象文件-Relocatable-file"><a href="#一，可重定位的对象文件-Relocatable-file" class="headerlink" title="一，可重定位的对象文件(Relocatable file)"></a>一，可重定位的对象文件(Relocatable file)</h3><p>&emsp;&emsp;由汇编器汇编生成的 <code>.o</code> 文件。后面的链接器(link editor)拿一个或一些 Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。可以使用 <code>ar</code> 工具将众多的 <code>.o</code> (Relocatable object files) 归档(archive)成 <code>.a</code> 静态库文件。内核可加载模块 <code>.ko</code> 文件也是 Relocatable object file。</p>
<h3 id="二，可执行的对象文件-Executable-file"><a href="#二，可执行的对象文件-Executable-file" class="headerlink" title="二，可执行的对象文件(Executable file)"></a>二，可执行的对象文件(Executable file)</h3><p>&emsp;&emsp;文本编辑器vi、调式用的工具gdb、播放mp3歌曲的软件mplayer等等都是 Executable object file。在 Linux 系统里面，存在两种可执行的东西。除了 Executable object file，另外一种就是可执行的脚本(如shell脚本)。注意这些脚本不是 Executable object file，它们只是文本文件，但是执行这些脚本所用的解释器就是 Executable object file，比如 bash shell 程序。</p>
<h3 id="三，可被共享的对象文件-Shared-object-file"><a href="#三，可被共享的对象文件-Shared-object-file" class="headerlink" title="三，可被共享的对象文件(Shared object file)"></a>三，可被共享的对象文件(Shared object file)</h3><p>&emsp;&emsp;可被共享的对象文件，即 动态库文件，也即 <code>.so</code> 文件。</p>
<p>动态库在发挥作用的过程中，必须经过两个步骤：</p>
<ul>
<li>a) 链接编辑器(link editor)拿它和其他 Relocatable object file 以及其他 shared object file 作为输入，经链接处理后，生存另外的 shared object file 或者 executable file。</li>
<li>b) 在运行时，动态链接器(dynamic linker)拿它和一个 Executable file 以及另外一些 Shared object file 来一起处理，在 Linux 系统里面创建一个进程映像。</li>
</ul>
<h2 id="gcc翻译过程"><a href="#gcc翻译过程" class="headerlink" title="gcc翻译过程"></a>gcc翻译过程</h2><p><img src="/img/20170611205306090.png" alt="20170611205306090.png"></p>
<p>在Unix系统中，从源文件到可执行目标文件是由编译驱动程序完成的，如大名鼎鼎的gcc，翻译过程包括图中的是个阶段；</p>
<p><strong>一，预处理阶段</strong></p>
<p>预处理器（cpp）根据以字符#开头的命令修给原始的C程序，结果得到另一个C程序，通常以.i作为文件扩展名。主要是进行文本替换、宏展开、删除注释这类简单工作。</p>
<p>对应的命令：<code>linux&gt; gcc -E hello.c hello.i</code></p>
<p><strong>二，编译阶段</strong></p>
<p>编译器将文本文件hello.i翻译成hello.s，包含相应的汇编语言程序</p>
<p>对应的命令：<code>linux&gt; gcc -S hello.c hello.s</code></p>
<p><strong>三，汇编阶段</strong></p>
<p>将.s文件翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果保存在目标文件.o中(把汇编语言翻译成机器语言的过程)。</p>
<p>把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。</p>
<p>对应的命令：<code>linux&gt; gcc -c hello.c hello.o</code></p>
<p><strong>四，链接阶段</strong></p>
<p>&emsp;&emsp;此时hello程序调用了 printf 函数。 printf 函数存在于一个名为printf.o的单独的预编译目标文件中。 链接器（ld）就负责处理把这个文件并入到 hello.o 程序中，结果得到 hell.o 文件，一个可执行文件。最后可执行文件加载到储存器后由系统负责执行。</p>
<p>函数库一般分为静态库和动态库两种。</p>
<ul>
<li>静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为 <code>.a</code>。</li>
<li>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为 <code>.so</code>，gcc 在编译时默认使用动态库。</li>
</ul>
<h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><p>&emsp;&emsp;ELF 全称 <code>Executable and Linkable Format</code>，可执行可链接文件格式，目前常见的 Linux、 Android 可执行文件、共享库（<code>.so</code>）、目标文件（<code>.o</code>）以及Core 文件（吐核）均为此格式。</p>
<p>&emsp;&emsp;ELF 文件由4部分组成，分别是 ELF 头（ELF header）、程序头表（Program header table）、节（Section）和节区头部表（Section header table）。ELF 头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。</p>
<p><img src="/img/20160521110158483.png" alt="20160521110158483.png"></p>
<ul>
<li>ELF header： 描述整个文件的组织。</li>
<li>Program Header Table: 描述文件中的各种 segments，用来告诉系统如何创建进程映像的。</li>
<li>sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出，segments与sections是包含的关系，一个segment包含若干个section。</li>
<li>Section Header Table: 包含了文件各个segction的属性信息。</li>
</ul>
<p>&emsp;&emsp;ELF 文件格式提供了两种视图，分别是链接视图和执行视图，链接视图是以节（section）为单位，执行视图是以段（segment）为单位。</p>
<p>&emsp;&emsp;在汇编器和链接器看来，ELF 文件是由 Section Header Table 描述的一系列 Section 的集合，而执行一个 ELF 文件时，在加载器（Loader）看来它是由 Program Header Table 描述的一系列Segment的集合。</p>
<p><img src="/img/elf.png" alt="elf.png"></p>
<p><strong>程序头部表</strong>（Program Header Table），如果存在的话，告诉系统如何创建进程映像。<br><strong>节区头部表</strong>（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。</p>
<p>执行命令 <code>readelf -S android_server</code> 来查看该可执行文件中有哪些section。</p>
<p><img src="/img/20160521110452230.png" alt="20160521110452230.png"></p>
<p>行命令 <code>readelf –segments android_server</code>，可以查看该文件的执行视图。</p>
<p><img src="/img/20160521110508766.png" alt="20160521110508766.png"></p>
<p><strong>segment是section的一个集合，sections按照一定规则映射到segment。为什么需要区分两种不同视图？</strong></p>
<p>&emsp;&emsp;当ELF文件被加载到内存中后，系统会将多个具有相同权限（flg值）section合并一个segment。操作系统往往以页为基本单位来管理内存分配，一般页的大小为4096B，即4KB的大小。同时，内存的权限管理的粒度也是以页为单位，页内的内存是具有同样的权限等属性，并且操作系统对内存的管理往往追求高效和高利用率这样的目标。ELF文件在被映射时，是以系统的页长度为单位的，那么每个section在映射时的长度都是系统页长度的整数倍，如果section的长度不是其整数倍，则导致多余部分也将占用一个页。而我们从上面的例子中知道，一个ELF文件具有很多的section，那么会导致内存浪费严重。这样可以减少页面内部的碎片，节省了空间，显著提高内存利用率。</p>
<h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>转载自：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feglass/article/details/51469511?spm=1001.2014.3001.5501">ELF文件格式解析</a></p>
<p>32位ELF文件中常用的数据格式：</p>
<p><img src="/img/20160521110646983.png" alt="20160521110646983.png"></p>
<p><code>readelf -h android_server</code> 命令，可以看到 ELF Header 结构的内容:</p>
<p><img src="/img/20160521110756954.png" alt="20160521110756954.png"></p>
<p>对比以下三类ELF文件，我们得到了以下结论：<br>（1）e_type标识了文件类型<br>（2）Relocatable File（.o文件）不需要执行，因此e_entry字段为0，且没有Program Header Table等执行视图<br>（3）不同类型的ELF文件的Section也有较大区别，比如只有Relocatable File有.strtab节。 </p>
<p>(1) Shared Object File（.so文件）:<br><img src="/img/20160521110949018.png" alt="20160521110949018.png"></p>
<p>(2) Executable File（可执行文件android_server）:</p>
<p><img src="/img/20160521111008408.png" alt="20160521111008408.png"></p>
<p>(3) Relocatable File（.o文件）:</p>
<p><img src="/img/20160521111020956.png" alt="20160521111020956.png"></p>
<p>在 ELF Header 中需要重点关注以下几个字段：</p>
<ul>
<li>1，e_entry：程序入口地址<br>这个 sum.o 的进入点是 0x0(e_entry)，这表面Relocatable objects不会有程序进入点。所谓程序进入点是指当程序真正执行起来的时候，其第一条要运行的指令的运行时地址。因为Relocatable objects file只是供再链接而已，所以它不存在进入点。而可执行文件test和动态库.so都存在所谓的进入点，且可执行文件的 e_entry 指向C库中的_start，而动态库.so中的进入点指向 call_gmon_start。<br>如上图中 e_entry = 0xD8B0 (Executable File 文件)，我们用ida打开该文件看到确实是 _start() 函数的地址。</li>
</ul>
<p><img src="/img/20160521111227521.png" alt="20160521111227521.png"></p>
<ul>
<li>2，e_ehsize：ELF Header结构大小</li>
<li>3，e_phoff、e_phentsize、e_phnum：描述Program Header Table的偏移、大小、结构。</li>
<li>4，e_shoff、e_shentsize、e_shnum：描述Section Header Table的偏移、大小、结构。</li>
<li>5，e_shstrndx：这一项描述的是字符串表在 Section Header Table 中的索引，值25表示的是 Section Header Table 中第25项是字符串表（String Table）。</li>
</ul>
<h3 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h3><p>&emsp;&emsp;一个ELF文件中到底有哪些具体的 sections，由包含在这个ELF文件中的 section head table(SHT) 决定。在SHT中，针对每一个section，都设置有一个条目（entry），用来描述对应的这个section，其内容主要包括该 section 的名称、类型、大小以及在整个ELF文件中的字节偏移位置等等。我们也可以在TISCv1.2规范中找到SHT表中条目的C结构定义：</p>
<p><img src="/img/20160521111301410.png" alt="20160521111301410.png"></p>
<p>解析 android_server 可执行ELF文件，我们可以看到 Section Header Table 中确实有23（17h (16进制表示)）个条目，且索引为22（16h(16进制表示)）确实为 section header section string table。</p>
<p><img src="/img/20160521111322394.png" alt="20160521111322394.png"></p>
<p>打开条目，我们可以看到每个 entry 的具体字段，与上图的 Elf32_Shdr 结构一致。</p>
<p><img src="/img/20160521111341347.png" alt="20160521111341347.png"></p>
<p>&emsp;&emsp;需要注意的是，sh_name 值实际上是 .shstrtab 中的索引，该string table中存储着所有section的名字。下图中蓝色部分是.shstrtab的数据，我们可以看到，sh_name实际上是从索引1开始的”.shstrtab”字符串，因此这里的sh_name值为1h。</p>
<p><img src="/img/20160521111400597.png" alt="20160521111400597.png"></p>
<h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>下面我们分析一些so文件中重要的Section，包括符号表、重定位表、GOT表等。</p>
<p><strong>-符号表(.dynsym)</strong></p>
<p>&emsp;&emsp;符号表包含用来定位、重定位程序中符号定义和引用的信息，简单的理解就是符号表记录了该文件中的所有符号，所谓的符号就是经过修饰了的函数名或者变量名，不同的编译器有不同的修饰规则。例如符号_ZL15global_static_a，就是由global_static_a变量名经过修饰而来。</p>
<p>符号表项的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">     Elf32_Word st_name;        <span class="comment">//符号表项名称。如果该值非0，则表示符号名的字</span></span><br><span class="line">                                   <span class="comment">//符串表索引(offset)，否则符号表项没有名称。</span></span><br><span class="line">     Elf32_Addr st_value;       <span class="comment">//符号的取值。依赖于具体的上下文，可能是一个绝对值、一个地址等等。</span></span><br><span class="line">     Elf32_Word st_size;        <span class="comment">//符号的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;     <span class="comment">//符号的类型和绑定属性。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;    <span class="comment">//未定义。</span></span><br><span class="line">     Elf32_Half st_shndx;        <span class="comment">//每个符号表项都以和其他节区的关系的方式给出定义。</span></span><br><span class="line">　　　　　　　　　　　　　         <span class="comment">//此成员给出相关的节区头部表索引。</span></span><br><span class="line">&#125; Elf32_sym;</span><br></pre></td></tr></table></figure>

<p>通过 010Editor 解析出的符号表 .dynsym 的 section header 表项：</p>
<p><img src="/img/20160521111537942.png" alt="20160521111537942.png"></p>
<p>符号表的具体内容：</p>
<p><img src="/img/20160521111608073.png" alt="20160521111608073.png"></p>
<p><strong>-字符串表（.dynstr）</strong></p>
<p>字符串表中存放着所有符号的名称字符串。</p>
<p>字符串表的section header表项：</p>
<p><img src="/img/20160521111628840.png" alt="20160521111628840.png"></p>
<p>再看一下下图中字符串表的具体内容，我们可以看出，.dynstr和.shstrtab 结构完全相同，不过一个存储的是符号名称的字符串，而另一个是Section 名称的字符串。</p>
<p><img src="/img/20160521111652559.png" alt="20160521111652559.png"></p>
<p><strong>-重定位表</strong></p>
<p>&emsp;&emsp;重定位表在ELF文件中扮演很重要的角色，首先我们得理解重定位的概念，程序从代码到可执行文件这个过程中，要经历编译器，汇编器和链接器对代码的处理。然而编译器和汇编器通常为每个文件创建程序地址从0开始的目标代码，但是几乎没有计算机会允许从地址0加载你的程序。如果一个程序是由多个子程序组成的，那么所有的子程序必需要加载到互不重叠的地址上。重定位就是为程序不同部分分配加载地址，调整程序中的数据和代码以反映所分配地址的过程。简单的言之，则是将程序中的各个部分映射到合理的地址上来。</p>
<p>&emsp;&emsp;换句话来说，重定位是将符号引用与符号定义进行连接的过程。例如，当程序调用了一个函数时，相关的调用指令必须把控制传输到适当的目标执行地址。<br>具体来说，就是把符号的value进行重新定位。</p>
<p>可重定位文件必须包含如何修改其节区内容的信息，从而允许可执行文件和共享目标文件保存进程的程序映象的正确信息。这就是重定位表项做的工作。重定位表项的格式如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    Elf32_Addr r_offset;     <span class="comment">//重定位动作所适用的位置（受影响的存储单位的第一个字节的偏移或者虚拟地址）</span></span><br><span class="line">    Elf32_Word r_info;       <span class="comment">//要进行重定位的符号表索引，以及将实施的重定位类型（哪些位需要修改，以及如何计算它们的取值）</span></span><br><span class="line">                                         <span class="comment">//其中 .rel.dyn 重定位类型一般为R_386_GLOB_DAT和R_386_COPY；.rel.plt为R_386_JUMP_SLOT</span></span><br><span class="line">&#125; Elf32_Rel; </span><br></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    Elf32_Addr r_offset;  </span><br><span class="line">    Elf32_Word r_info;  </span><br><span class="line">    Elf32_Word r_addend;</span><br><span class="line"> &#125; Elf32_Rela; </span><br></pre></td></tr></table></figure>

<p>对 r_info 成员使用 ELF32_R_TYPE 宏运算可得到重定位类型，使用 ELF32_R_SYM 宏运算可得到符号在符号表里的索引值。 三种宏的具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(i) ((i)&gt;&gt;8) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_TYPE(i) ((unsigned char)(i)) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_INFO(s, t) (((s)</span></span><br></pre></td></tr></table></figure>

<p>重定位表中的内容:</p>
<p><img src="/img/20160521111838248.png" alt="20160521111838248.png"></p>
<p>以下是.rel.plt表的具体内容：</p>
<p><img src="/img/20160521111856928.png" alt="20160521111856928.png"></p>
<p>我们可以看到，每8个字节(s_entsize)一个表项。第一个表项中的r_offset值为0xc7660，r_info为0xa16。其中r_offset指向下图中GOT表中第一项__imp_clock_gettime外部函数地址。那么我们如何利用r_offset值来找到其对应的符号呢？如上所述，进行 ELF32_R_SYM宏运算实际上就是将r_info右移8位，0xa16右移8位得到0xa，因此这就是其在符号表中的索引。 </p>
<p><img src="/img/20160521111921663.png" alt="20160521111921663.png"></p>
<p>从下图中可以看见符号表的s_entsize值为10h，即16个字节每条目。因此我们可以找到其索引为0xa的条目的st_name值为0x9ea。那么怎么证明我们确实找到的是clock_gettime函数的符号呢？我们再来看一下st_name值是不是正确的。</p>
<p><img src="/img/20160521111941390.png" alt="20160521111941390.png"></p>
<p>st_name值表示的是符号名字符串中的第一个字符在字符串表中的偏移量，因此我们用0x9ea加上符号表的起始位置(0x7548)就能得到该字符串在‭0x7F32位置。如下图所示:</p>
<p><img src="/img/20160521112219618.png" alt="20160521112219618.png"></p>
<p><strong>-常见的重定位表类型：</strong></p>
<ul>
<li><p>.rel.text：重定位的地方在.text段内，以offset指定具体要定位位置。在链接时候由链接器完成。.rel.text属于普通重定位辅助段 ,他由编译器编译产生，存在于obj文件内。连接器连接时，他用于最终可执行文件或者动态库的重定位。通过它修改原obj文件的.text段后，合并到最终可执行文件或者动态文件的.text段。其类型一般为R_386_32和R_386_PC32。</p>
</li>
<li><p>.rel.dyn：重定位的地方在.got段内。主要是针对外部数据变量符号。例如全局数据。重定位在程序运行时定位，一般是在.init段内。定位过程：获得符号对应value后，根据rel.dyn表中对应的offset，修改.got表对应位置的value。另外，.rel.dyn 含义是指和dyn有关，一般是指在程序运行时候，动态加载。区别于rel.plt，rel.plt是指和plt相关，具体是指在某个函数被调用时候加载。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。</p>
</li>
<li><p>.rel.dyn和.rel.plt是动态定位辅助段。由连接器产生，存在于可执行文件或者动态库文件内。借助这两个辅助段可以动态修改对应.got和.got.plt段，从而实现运行时重定位。</p>
</li>
<li><p>.rel.plt：重定位的地方在.got.plt段内（注意也是.got内,具体区分而已）。 主要是针对外部函数符号。一般是函数首次被调用时候重定位。首次调用时会重定位函数地址，把最终函数地址放到.got内，以后读取该.got就直接得到最终函数地址。我个人理解这个Section的作用是，在重定位过程中，动态链接器根据r_offset找到.got对应表项，来完成对.got表项值的修改。</p>
</li>
<li><p>.plt段（过程链接表）：所有外部函数调用都是经过一个对应桩函数，这些桩函数都在.plt段内。具体调用外部函数过程是：<br>调用对应桩函数—&gt;桩函数取出.got表表内地址—&gt;然后跳转到这个地址.如果是第一次,这个跳转地址默认是桩函数本身跳转处地址的下一个指令地址(目的是通过桩函数统一集中取地址和加载地址),后续接着把对应函数的真实地址加载进来放到.got表对应处,同时跳转执行该地址指令.以后桩函数从.got取得地址都是真实函数地址了。<br>下图是.plt某表项，它包含了取.got表地址和跳转执行两条指令。</p>
</li>
</ul>
<p><img src="/img/20160521112646041.png" alt="20160521112646041.png"></p>
<ul>
<li>.got（全局偏移表）</li>
</ul>
<h3 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h3><p>&emsp;&emsp;程序头部（Program Header）描述与程序执行直接相关的目标文件结构信息。用来在文件中定位各个段的映像。同时包含其他一些用来为程序创建映像所必须的信息。<br>可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段或者系统准备程序执行所必须的其他信息。目标文件的 “段” 包含一个或者多个 “节区”，也就是 “段内容（Segment Contents）”。程序头部仅对可执行文件和共享目标文件有意义。</p>
<p>程序头部的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    Elf32_Word p_type;           <span class="comment">//此数组元素描述的段的类型，或者如何解释此数组元素的信息。 </span></span><br><span class="line">    Elf32_Off  p_offset;           <span class="comment">//此成员给出从文件头到该段第一个字节的偏移</span></span><br><span class="line">    Elf32_Addr p_vaddr;         <span class="comment">//此成员给出段的第一个字节将被放到内存中的虚拟地址</span></span><br><span class="line">    Elf32_Addr p_paddr;        <span class="comment">//此成员仅用于与物理地址相关的系统中。System V忽略所有应用程序的物理地址信息。</span></span><br><span class="line">    Elf32_Word p_filesz;         <span class="comment">//此成员给出段在文件映像中所占的字节数。可以为0。</span></span><br><span class="line">    Elf32_Word p_memsz;     <span class="comment">//此成员给出段在内存映像中占用的字节数。可以为0。</span></span><br><span class="line">    Elf32_Word p_flags;         <span class="comment">//此成员给出与段相关的标志。</span></span><br><span class="line">    Elf32_Word p_align;        <span class="comment">//此成员给出段在文件中和内存中如何对齐。</span></span><br><span class="line">&#125; Elf32_phdr;</span><br></pre></td></tr></table></figure>

<p>我们看到，以下两个工具确实是照此格式解析的:</p>
<p><img src="/img/20160521112705213.png" alt="20160521112705213.png"></p>
<p><img src="/img/20160521112720713.png" alt="20160521112720713.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mergerly/article/details/94585901">ELF文件格式解析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/daide2012/article/details/73065204">ELF文件详解—初步认识</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.virbox.com/?p=119">ELF 格式详解（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/feglass/article/details/51469511?spm=1001.2014.3001.5501">ELF文件格式解析</a></p>
<p><a target="_blank" rel="noopener" href="http://www.choudan.net/2013/10/25/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%AD%A6%E4%B9%A0%28%E4%BA%8C%29.html">Linux进程地址空间学习(二)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">376</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">119</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">168</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
