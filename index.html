<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"syxdevcode.github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="syxdevcode博客">
<meta property="og:url" content="https://syxdevcode.github.com/index.html">
<meta property="og:site_name" content="syxdevcode博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="syxdevcode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://syxdevcode.github.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>syxdevcode博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">syxdevcode博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/syxdevcode" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/Linux%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D/" class="post-title-link" itemprop="url">Linux下网络丢包故障定位</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 11:34:08" itemprop="dateCreated datePublished" datetime="2021-03-01T11:34:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DP0F3Q7TnOixxWZ9-_KA4A">云网络丢包故障定位全景指南</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">网络数据包发送和接收过程解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 10:34:08" itemprop="dateCreated datePublished" datetime="2021-03-01T10:34:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h2><p><img src="/img/651016-20190403213253371-112748496.png" alt="651016-20190403213253371-112748496.png"></p>
<h2 id="数据包名称简介"><a href="#数据包名称简介" class="headerlink" title="数据包名称简介"></a>数据包名称简介</h2><ul>
<li>包：可以说是全能性术语；</li>
<li>帧：用于表示数据链路层中包的单位；</li>
<li>数据包：是 IP 和 UDP 等网络层以上的分层中包的单位；</li>
<li>段：则表示 TCP 数据流中的信息；</li>
<li>消息：是指应用协议中数据的单位。</li>
</ul>
<p>&emsp;&emsp;每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="/img/651016-20190403213115559-1163198356.jpg" alt="651016-20190403213115559-1163198356.jpg"></p>
<h2 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h2><p>用户 a 向用户 b 发送邮件为例子：</p>
<p><img src="/img/1c7ddca5e0e0415c8b4c69047e680fc7.jpeg" alt="1c7ddca5e0e0415c8b4c69047e680fc7.jpeg"></p>
<p><strong>1，应用程序处理</strong></p>
<p>&emsp;&emsp;首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</p>
<p><strong>2，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</p>
<p><strong>3，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</p>
<p><strong>4，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</p>
<p><strong>5，网络接口（以太网驱动）的处理</strong></p>
<p>&emsp;&emsp;主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</p>
<p><strong>6，IP 模块的处理</strong></p>
<p>&emsp;&emsp;IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</p>
<p><strong>7，TCP 模块的处理</strong></p>
<p>&emsp;&emsp;在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<p><strong>8，应用程序的处理</strong></p>
<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</p>
<h2 id="传输层中的-TCP-和-UDP"><a href="#传输层中的-TCP-和-UDP" class="headerlink" title="传输层中的 TCP 和 UDP"></a>传输层中的 TCP 和 UDP</h2><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。</p>
<p><strong>(1) TCP</strong> 是面向连接的、可靠的流协议。流就是指不间断的数据结构，当应用程序采用 TCP 发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP 为提供可靠性传输，实行“顺序控制”或“重发控制”机制。此外还具备“流控制（流量控制）”、“拥塞控制”、提高网络利用率等众多功能。</p>
<p><strong>(2) UDP</strong> 是不具有可靠性的数据报协议。细微的处理它会交给上层的应用去完成。在 UDP 的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。</p>
<p>TCP 和 UDP 的优缺点无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>&emsp;&emsp;数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。</p>
<p>一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p><img src="/img/3f35fe4b91bb4a27b4ab30f84639d32a.jpeg" alt="3f35fe4b91bb4a27b4ab30f84639d32a.jpeg"><br><img src="/img/65b24665096545c089a7a18300218c6d.jpeg" alt="65b24665096545c089a7a18300218c6d.jpeg"></p>
<ul>
<li>(1) 和 (2) 的通信是在两台计算机上进行的。它们的目标端口号相同，都是80。这里可以根据源端口号加以区分。</li>
<li>(3) 和 (1) 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li>
<li>当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li>
</ul>
<h4 id="端口号的确定"><a href="#端口号的确定" class="headerlink" title="端口号的确定"></a>端口号的确定</h4><ul>
<li>标准既定的端口号：这种方法也叫静态方法。它是指每个应用程序都有其指定的端口号。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为知名端口号，分布在 <code>0~1023</code> 之间；除知名端口号之外，还有一些端口号被正式注册，它们分布在 <code>1024~49151</code> 之间，不过这些端口号可用于任何通信用途。</li>
<li>时序分配法：服务器有必要确定监听端口号，但是接受服务的客户端没必要确定端口号。在这种方法下，客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配。动态分配的端口号范围在 <code>49152~65535</code> 之间。</li>
</ul>
<h4 id="端口号与协议"><a href="#端口号与协议" class="headerlink" title="端口号与协议"></a>端口号与协议</h4><p>&emsp;&emsp;端口号由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。此外，那些知名端口号与传输层协议并无关系。只要端口一致都将分配同一种应用程序进行处理。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。</li>
<li>UDP 将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。</li>
<li>传输途中出现丢包，UDP 也不负责重发。</li>
<li>当包的到达顺序出现乱序时也没有纠正的功能。</li>
<li>如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。</li>
</ul>
<p>UDP 常用于一下几个方面：</p>
<ul>
<li>1.包总量较少的通信（DNS、SNMP等）；</li>
<li>2.视频、音频等多媒体通信（即时通信）；</li>
<li>3.限定于 LAN 等特定网络中的应用通信；</li>
<li>4.广播通信（广播、多播）。</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>&emsp;&emsp;TCP 与 UDP 的区别相当大。它充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</p>
<p>&emsp;&emsp;根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>&emsp;&emsp;TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。三次握手是指建立一个 TCP 连接时,需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。</p>
<p><img src="/img/3148139034514574a74a055e2a35b6fd.jpeg" alt="3148139034514574a74a055e2a35b6fd.jpeg"></p>
<ul>
<li><strong>第一次握手</strong>：客户端将标志位 <code>SYN</code> 置为1，随机产生一个值 <code>seq=J</code>，并将该数据包发送给服务器端，客户端进入 <code>SYN_SENT</code> 状态，等待服务器端确认。</li>
<li><strong>第二次握手</strong>：服务器端收到数据包后由标志位 <code>SYN=1</code>,知道客户端请求建立连接，服务器端将标志位 <code>SYN</code> 和 <code>ACK</code> 都置为1，<code>ack=J+1</code>，随机产生一个值 <code>seq=K</code> ，并将该数据包发送给客户端以确认连接请求，服务器端进入 <code>SYN_RCVD</code> 状态。</li>
<li><strong>第三次握手</strong>：客户端收到确认后，检查 <code>ack</code> 是否为 <code>J+1</code>，<code>ACK</code> 是否为1，如果正确,则将标志位 <code>ACK</code>置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查 <code>ack</code> 是否为 <code>K+1</code>， <code>ACK</code> 是否为1，如果正确则连接建立成功，客户端和服务器端进入 <code>ESTABLISHED</code> 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>&emsp;&emsp;四次挥手即终止 TCP 连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在 <code>socket</code> 编程中，这一过程由 客户端 或 服务端 任一方执行 <code>close</code> 来触发。</p>
<p>&emsp;&emsp;由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 <code>FIN</code> 来终止这一方向的连接，收到一个 <code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了 <code>FIN</code>。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><img src="/img/3e49dad546ba48eca6777783a8456a97.jpeg" alt="3e49dad546ba48eca6777783a8456a97.jpeg"></p>
<p>中断连接端可以是客户端，也可以是服务器端。</p>
<ul>
<li><strong>第一次挥手</strong>：客户端发送一个 <code>FIN=M</code>，用来关闭客户端到服务器端的数据传送，客户端进入 <code>FIN_WAIT_1</code> 状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</li>
<li><strong>第二次挥手</strong>：服务器端收到 <code>FIN</code> 后，先发送 <code>ack=M+1</code>，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入 <code>FIN_WAIT_2</code> 状态，继续等待服务器端的 <code>FIN</code> 报文。</li>
<li><em>第三次挥手*</em>：当服务器端确定数据已发送完成，则向客户端发送 <code>FIN=N</code> 报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 <code>LAST_ACK</code> 状态。</li>
<li><em>第四次挥手*</em>：客户端收到 <code>FIN=N</code> 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 <code>ack=N+1</code> 后进入 <code>TIME_WAIT</code> 状态，如果 <code>Server</code> 端没有收到 <code>ACK</code> 则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了 <code>2MSL</code> 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。</li>
</ul>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况，</p>
<p><img src="/img/4c5ab6ed942c431bbed30009959783c0.jpeg" alt="4c5ab6ed942c431bbed30009959783c0.jpeg"></p>
<h4 id="通过序列号与确认应答提高可靠性"><a href="#通过序列号与确认应答提高可靠性" class="headerlink" title="通过序列号与确认应答提高可靠性"></a>通过序列号与确认应答提高可靠性</h4><p>&emsp;&emsp;在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。 反之，则数据丢失的可能性很大。</p>
<p>&emsp;&emsp;在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。</p>
<p>&emsp;&emsp;未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p>
<p>&emsp;&emsp;此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p>
<p>&emsp;&emsp;对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此引入了序列号。</p>
<p>&emsp;&emsp;序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p>
<h4 id="重发超时的确定"><a href="#重发超时的确定" class="headerlink" title="重发超时的确定"></a>重发超时的确定</h4><p>&emsp;&emsp;重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过这个时间仍未收到确认应答，发送端将进行数据重发。最理想的是，找到一个最小时间，它能保证 “确认应答一定能在这个时间内返回”。</p>
<p>&emsp;&emsp;TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。为此，它在每次发包时都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时的时间就是比这个总和要稍大一点的值。</p>
<p>&emsp;&emsp;在 BSD 的 Unix 以及 Windows 系统中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍。不过，最初其重发超时的默认值一般设置为6秒左右。数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。</p>
<p>&emsp;&emsp;此外， 数据也不会被无限、反复地重发。达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</p>
<h4 id="以段为单位发送数据"><a href="#以段为单位发送数据" class="headerlink" title="以段为单位发送数据"></a>以段为单位发送数据</h4><p>&emsp;&emsp;在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为“最大消息长度”（MSS）。最理想的情况是，<font color=#ff0000 size=4 face="黑体">最大消息长度正好是 IP 中不会被分片处理的最大数据长度</font>。</p>
<p>&emsp;&emsp;TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</p>
<p>&emsp;&emsp;MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</p>
<h4 id="利用窗口控制提高速度"><a href="#利用窗口控制提高速度" class="headerlink" title="利用窗口控制提高速度"></a>利用窗口控制提高速度</h4><p>&emsp;&emsp;TCP 以 1 个段为单位，每发送一个段进行一次确认应答的处理。这样的传输方式有一个缺点，就是包的往返时间越长,通信性能就越低。</p>
<p>&emsp;&emsp;为解决这个问题，TCP 引入了窗口这个概念。确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送。如下图所示：</p>
<p><img src="/img/8c6eab31573940a5bc369ea648d45591.jpeg" alt="8c6eab31573940a5bc369ea648d45591.jpeg"></p>
<p>&emsp;&emsp;窗口大小就是指：无需等待确认应答，而可以继续发送数据的最大值。上图中窗口大小为4个段。这个机制实现了使用大量的缓冲区，通过对多个段，同时进行确认应答的功能。</p>
<h4 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h4><p><img src="/img/0f015679fbef46deb30d6669d5e28ddf.jpeg" alt="0f015679fbef46deb30d6669d5e28ddf.jpeg"></p>
<p>&emsp;&emsp;上图中的窗口内的数据，即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。</p>
<p>&emsp;&emsp;在滑动窗口以外的部分，包括未发送的数据，以及已经确认对端已收到的数据。当数据发出后，若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。</p>
<p>&emsp;&emsp;收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为 <code>滑动窗口控制</code>。</p>
<h4 id="窗口控制中的重发控制"><a href="#窗口控制中的重发控制" class="headerlink" title="窗口控制中的重发控制"></a>窗口控制中的重发控制</h4><p>&emsp;&emsp;在使用窗口控制中， 出现丢包一般分为两种情况：</p>
<p>① 确认应答未能返回的情况。在这种情况下，数据已经到达对端，是不需要再进行重发的，如下图：</p>
<p><img src="/img/f665dba5def44bb8a9ae13848602442c.jpeg" alt="f665dba5def44bb8a9ae13848602442c.jpeg"></p>
<p>② 某个报文段丢失的情况。接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答。如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回。而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发。这种机制比之前提到的超时管理更加高效，因此也被称为 <code>高速重发控制</code>。</p>
<p><img src="/img/1a1667fade0340998a1879a9f06d8511.jpeg" alt="1a1667fade0340998a1879a9f06d8511.jpeg"></p>
<h2 id="网络层中的-IP-协议"><a href="#网络层中的-IP-协议" class="headerlink" title="网络层中的 IP 协议"></a>网络层中的 IP 协议</h2><p>&emsp;&emsp;IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层。网络层的主要作用是 “实现终端节点之间的通信”。这种终端节点之间的通信也叫 “点对点通信”。</p>
<p>&emsp;&emsp;网络的下一层—数据链路层 的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上，也能实现两端节点之间的数据包传输。</p>
<p>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）、IP 分包与组包。</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>&emsp;&emsp;在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</p>
<p>&emsp;&emsp;作为网络层的 IP,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在 “连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</p>
<p>&emsp;&emsp;不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</p>
<p>&emsp;&emsp;IP 地址（IPv4 地址）由32位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将32位的 IP 地址以每8位为一组，分成4组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</p>
<p><img src="/img/902f8a4e03a242ecb6e16e3f718371e6.jpeg" alt="902f8a4e03a242ecb6e16e3f718371e6.jpeg"></p>
<h4 id="IP-地址由网络和主机两部分标识组成"><a href="#IP-地址由网络和主机两部分标识组成" class="headerlink" title="IP 地址由网络和主机两部分标识组成"></a>IP 地址由网络和主机两部分标识组成</h4><p><strong>IP地址的主机标识</strong></p>
<p>&emsp;&emsp;如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的 “主机标识” 则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠，即 IP 地址具有了唯一性。</p>
<p><img src="/img/060f69b3e2e74ddcb60af173c98b8423.jpeg" alt="060f69b3e2e74ddcb60af173c98b8423.jpeg"></p>
<p><strong>IP地址的网络标识</strong></p>
<p>&emsp;&emsp;如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</p>
<p><img src="/img/e0a9ddf22b5c4f1ca49e1a1ddd2c14be.jpeg" alt="e0a9ddf22b5c4f1ca49e1a1ddd2c14be.jpeg"></p>
<h4 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h4><p>&emsp;&emsp;IP 地址分为四个级别，分别为A类、B类、C类、D类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</p>
<ul>
<li>A 类 IP 地址是首位以 <code>0</code> 开头的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 8 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>0.0.0.0~127.0.0.0</code> 是 A 类的网络地址。<font color=#ff0000 size=4 face="黑体">A 类地址的后 24 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为 <code>16,777,214</code> 个。</li>
<li>B 类 IP 地址是前两位 <code>10</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 16 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>128.0.0.0~191.255.0.0</code> 是 B 类的网络地址。<font color=#ff0000 size=4 face="黑体">B 类地址的后 16 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为65,534个。</li>
<li>C 类 IP 地址是前三位为 <code>110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 24 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>192.0.0.0~223.255.255.0</code> 是 C 类的网络地址。<font color=#ff0000 size=4 face="黑体">C 类地址的后 8 位相当于主机标识。</font>因此，一个网段内可容纳的主机地址上限为254个。</li>
<li>D 类 IP 地址是前四位为 <code>1110</code> 的地址。<font color=#ff0000 size=4 face="黑体">从第 1 位到第 32 位是它的网络标识(网络号)。</font>用十进制表示的话，<code>224.0.0.0~239.255.255.255</code> 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li>
</ul>
<p>127.x.x.x段地址空间是被保留的回环地址。</p>
<p>&emsp;&emsp;在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 2的8次方- 2 = 254）个主机地址的原因。</p>
<h4 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h4><p>&emsp;&emsp;广播地址(<code>Broadcast Address</code>) 是专门用于同时向网络中所有工作站进行发送的一个地址。在使用 <code>TCP/IP</code> 协议的网络中，主机标识段 <code>host ID</code>为全1 (11111111，即十进制的255) 的IP 地址为广播地址，广播的分组传送给<code>host ID</code>段所涉及的所有计算机。例如，对于 <code>10.1.1.0</code> （255.0.0.0 ）网段，其直播广播地址为 <code>10.255.255.255</code> （255 即为 2 进制的11111111），当发出一个目的地址为 <code>10.255.255.255</code> 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<p>广播地址应用于网络内的所有主机,广播分为受限广播(本地广播)和直接广播两种。在本网络内的广播叫做受限广播(本地广播)；在不同网络之间的广播叫做直接广播。</p>
<ul>
<li>（1）受限广播(本地广播)<br>它不被路由发送，但会被送到相同物理网络段上的所有主机<br>IP地址的网络字段和主机字段全为1就是地址 <code>255.255.255.255</code></li>
<li>（2）直接广播<br>网络广播会被路由，并会发送到专门网络上的每台主机<br>IP地址的网络字段定义这个网络，主机字段通常全为1，如 <code>192.168.10.255</code></li>
</ul>
<p><strong>受限地址</strong></p>
<p>&emsp;&emsp;受限的广播地址是 <code>255.255.255.255</code>。该地址用于主机配置过程中IP数据包的目的地址，此时，主机可能还不知道它所在网络的网络掩码，甚至连它的IP地址也不知道。在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出本地网络中。</p>
<p><strong>指向网络</strong></p>
<p>&emsp;&emsp;指向网络的广播地址是主机号为全1(11111111)的地址。A类网络广播地址为 netid.255.255.255，其中netid为A类网络的网络号。一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p>
<p><strong>指向子网</strong></p>
<p>&emsp;&emsp;指向子网的广播地址为主机号为全1(11111111)且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。例如，如果路由器收到发往 <code>128.1.2.255</code> 的数据报，当B类网络 <code>128.1</code> 的子网掩码为 <code>255.255.255.0</code>时，该地址就是指向子网的广播地址；但如果该子网的掩码为 <code>255.255.254.0</code>，该地址就不是指向子网的广播地址。</p>
<p><strong>指向所有子网</strong></p>
<p>&emsp;&emsp;指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。指向所有子网的广播地址的子网号及主机号为全1。例如，如果目的子网掩码为 <code>255.255.255.0</code> ，那么IP地址 <code>128.1.255.255</code> 是一个指向所有子网的广播地址。然而，如果网络没有划分子网，这就是一个指向网络的广播。</p>
<h4 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h4><p>&emsp;&emsp;<code>IP多播</code>（也称 <code>多址广播</code> 或 <code>组播</code>）技术，是一种允许一台或多台主机（多播源）发送单一数据包到多台主机（一次的，同时的）的TCP/IP网络技术。多播作为一点对多点的通信，是节省网络带宽的有效方法之一。在网络音频/视频广播的应用中，当需要将一个节点的信号传送到多个节点时，无论是采用重复点对点通信方式，还是采用广播方式，都会严重浪费网络带宽，只有多播才是最好的选择。多播能使一个或多个多播源只把数据包发送给特定的多播组，而只有加入该多播组的主机才能接收到数据包。目前，IP多播技术被广泛应用在 网络音频/视频广播、AOD/VOD、网络视频会议、多媒体远程教育、”push”技术（如股票行情等）和虚拟现实游戏等方面。</p>
<p>&emsp;&emsp;有些应用会有这样的要求：一些分布在各处的进程需要以组的方式协同工作，组中的进程通常要给其他所有的成员发送消息。即有这样的一种方法能够给一些明确定义的组发送消息，这些组的成员数量虽然很多，但是与整个网络规模相比却很小。给这样一个组发送消息称为多点点播送，简称多播。需要注意的是多播数据包的目的ip地址实际上不可能对应某一台真实存在的主机的ip地址，也就是说该目的ip地址永远不可能作为源地址，即多播ip地址只能用于目的ip地址，不能用于源ip地址。</p>
<h5 id="1．IP多播地址和多播组"><a href="#1．IP多播地址和多播组" class="headerlink" title="1．IP多播地址和多播组"></a>1．IP多播地址和多播组</h5><p>&emsp;&emsp;IP多播通信必须依赖于IP多播地址，在 IPv4 中它是一个D类IP地址，并且ip首部中的协议字段为2，表明采用的是IGMP网际组管理协议。范围从 <code>224.0.0.0</code> 到 <code>239.255.255.255</code>，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类。因此，如果从首位开始到第 4 位是 <code>1110</code> ，就可以认为是多播地址，而剩下的 28 位可以成为多播的组编号。所有的主机（路由器以外的主机和终端主机）必须属于 <code>224.0.0.1</code> 的组，所有的路由器必须属于 <code>224.0.0.2</code> 的组。</p>
<ul>
<li>局部链接多播地址范围在 <code>224.0.0.0~224.0.0.255</code>，这是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包；</li>
<li>预留多播地址为 <code>224.0.1.0~238.255.255.255</code>，可用于全球范围（如Internet）或网络协议；</li>
<li>管理权限多播地址为 <code>239.0.0.0~239.255.255.255</code>，可供组织内部使用，类似于私有IP地址，不能用于 Internet，可限制多播范围。</li>
</ul>
<p>&emsp;&emsp;使用同一个IP多播地址接收多播数据包的所有主机构成了一个主机组，也称为多播组。一个多播组的成员是随时变动的，一台主机可以随时加入或离开多播组，多播组成员的数目和所在的地理位置也不受限制，一台主机也可以属于几个多播组。此外，不属于某一个多播组的主机也可以向该多播组发送数据包。</p>
<h5 id="2-IP多播技术的硬件支持"><a href="#2-IP多播技术的硬件支持" class="headerlink" title="2. IP多播技术的硬件支持"></a>2. IP多播技术的硬件支持</h5><p>要实现IP多播通信，要求介于多播源和接收者之间的路由器、集线器、交换机以及主机均需支持IP多播。目前，IP多播技术已得到硬件、软件厂商的广泛支持。</p>
<ul>
<li>（1）主机<br>支持IP多播通信的平台包括 Windows CE 2.1、Windows 95、Windows 98、Windows NT 4 和 Windows 2000 等，运行这些操作系统的主机都可以进行IP多播通信。此外，新生产的网卡也几乎都提供了对IP多播的支持。</li>
<li>（2）集线器和交换机<br>目前大多数集线器、交换机只是简单地把多播数据当成广播来发送接收，但一些中、高档交换机提供了对IP多播的支持。例如，在 3COM SuperStack 3 Swith 3300 交换机上可启用 802.1p 或 IGMP 多播过滤功能，只为已侦测到IGMP 数据包的端口转发多播数据包。</li>
<li>（3）路由器<br>多播通信要求多播源节点和目的节点之间的所有路由器必须提供对 Internet组管理协议（IGMP）、多播路由协议（如PIM、DVMRP等）的支持。</li>
</ul>
<p>&emsp;&emsp;多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p>
<p><img src="/img/71e3a03024f04d32954f591d6e1edb43.jpeg" alt="71e3a03024f04d32954f591d6e1edb43.jpeg"></p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码是在IPv4地址资源紧缺的背景下为了解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面。如果是都是使用的IPV6的话是没有子网掩码的概念。IPV6是端到端的连接通信，不需要子网了。</p>
<p>详情参考：<a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" title="IP4-子网掩码">IP4-子网掩码</a></p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">特征</th>
<th align="left">网络范围</th>
<th align="left">默认掩码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类地址</td>
<td align="left">第1个8位中的第1位始终为0</td>
<td align="left">0-127.x.x.x</td>
<td align="left">255.0.0.0/8</td>
</tr>
<tr>
<td align="left">B类地址</td>
<td align="left">第1个8位中的第1、2位始终为10</td>
<td align="left">128-191.x.x.x</td>
<td align="left">255.255.0.0/16</td>
</tr>
<tr>
<td align="left">C类地址</td>
<td align="left">第1个8位中的第1、2、3位始终为110</td>
<td align="left">192-y.x.x.x</td>
<td align="left">255.255.255.0/24</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</p>
<p><img src="/img/bb3cd3458dc94871a4a68f3fdd4897eb.jpeg" alt="bb3cd3458dc94871a4a68f3fdd4897eb.jpeg"></p>
<p>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</p>
<p><img src="/img/050f0e2d38554dd89fdc4427226cc688.jpeg" alt="050f0e2d38554dd89fdc4427226cc688.jpeg"></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>&emsp;&emsp;发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于 <code>指明路由器或主机</code> 的信息，以便真正发往目标地址。保存这种信息的就是 <code>路由控制表</code>。</p>
<p>&emsp;&emsp;该路由控制表的形成方式有两种：一种是管理员手动设置，也叫做静态路由控制；另一种是路由器与其他路由器相互交换信息时自动刷新，叫做动态路由控制。</p>
<p>&emsp;&emsp;IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做 <code>路由协议</code> 的协议制作而成。</p>
<h4 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h4><p>IP 地址的网络地址部分用于进行路由控制。路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</p>
<p>&emsp;&emsp;在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</p>
<p><img src="/img/97e1e1332e5445c5b3da354f7cf407f9.jpeg" alt="97e1e1332e5445c5b3da354f7cf407f9.jpeg"></p>
<h3 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h3><p>&emsp;&emsp;每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</p>
<p>&emsp;&emsp;任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</p>
<h3 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h3><p>&emsp;&emsp;分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</p>
<p>&emsp;&emsp;为了应对分片机制的不足，<code>路径MTU发现</code> 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>&emsp;&emsp;IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节</p>
<h4 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h4><ul>
<li>IP 地址的扩大与路由控制表的聚合。</li>
<li>性能提升。包首部长度采用固定的值（40字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li>
<li>支持即插即用功能。即使没有 <code>DHCP服务器</code> 也可以实现自动分配 IP 地址。</li>
<li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li>
<li>多播、Mobile IP 成为扩展功能。</li>
</ul>
<h4 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h4><p>&emsp;&emsp;一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（ <code>:</code> ）隔开进行标记。而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（<code>::</code>）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
<h4 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h4><p>&emsp;&emsp;IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</p>
<p><img src="/img/be1bff3dd05c4f999c7836ca26598c7d.jpeg" alt="be1bff3dd05c4f999c7836ca26598c7d.jpeg"></p>
<h4 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h4><p>&emsp;&emsp;全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</p>
<p>&emsp;&emsp;格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</p>
<p><img src="/img/478cf4cd8c2b43339b80d7b667a6520a.jpeg" alt="478cf4cd8c2b43339b80d7b667a6520a.jpeg"></p>
<h4 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h4><p>&emsp;&emsp;链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p>
<p><img src="/img/d9e6580e7ce245aa9116004055f69b8b.jpeg" alt="d9e6580e7ce245aa9116004055f69b8b.jpeg"></p>
<h4 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h4><p>&emsp;&emsp;唯一本地地址是不进行互联网通信时所用的地址。唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</p>
<ul>
<li>L 通常被置为 1</li>
<li>全局 ID 的值随机决定</li>
<li>子网 ID 是指该域子网地址</li>
<li>接口 ID 即为接口的 ID</li>
</ul>
<p><img src="/img/8efd0df062b049978546f10dc3895af5.jpeg" alt="8efd0df062b049978546f10dc3895af5.jpeg"></p>
<h4 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h4><p>&emsp;&emsp;IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</p>
<p>&emsp;&emsp;IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行 <code>路径MTU发现</code>，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</p>
<h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><p>&emsp;&emsp;IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>&emsp;&emsp;我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</p>
<p>&emsp;&emsp;这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>&emsp;&emsp;地址解析协议，即 <code>ARP（Address Resolution Protocol）</code>，是根据IP地址获取物理地址的一个 <code>TCP/IP</code> 协议。主机发送信息时将包含目标IP地址的 <code>ARP</code> 请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机 <code>ARP缓存</code> 中，并保留一定时间，下次请求时直接查询 <code>ARP缓存</code> 以节约资源。</p>
<p>&emsp;&emsp;地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送 <code>ARP</code> 应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机 <code>ARP缓存</code>；由此攻击者就可以向某一主机发送伪 <code>ARP</code> 应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个 <code>ARP欺骗</code>。ARP命令可用于查询本机 <code>ARP缓存</code> 中 IP 地址和 MAC 地址的对应关系、添加或删除静态对应关系等。相关协议有 <code>RARP</code>、<code>代理ARP</code>。NDP用于在IPv6中代替地址解析协议。</p>
<p>&emsp;&emsp;只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</p>
<p>&emsp;&emsp;ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</p>
<p>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</p>
<h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>&emsp;&emsp;<code>ICMP（Internet Control Message Protocol）</code> Internet控制报文协议。它是 <code>TCP/IP</code> 协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>&emsp;&emsp;<code>ICMP</code> 使用 IP 的基本支持，就像它是一个更高级别的协议，但是，<code>ICMP</code> 实际上是IP的一个组成部分，必须由每个IP模块实现。</p>
<p>&emsp;&emsp;<code>ICMP</code> 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</p>
<p>&emsp;&emsp;IPv4 中 <code>ICMP</code> 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 <code>ICMP</code>，仍然可以实现 IP 通信。然而，在 IPv6 中，<code>ICMP</code> 的作用被扩大，如果没有 <code>ICMPv6</code>，IPv6 就无法进行正常通信。</p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>&emsp;&emsp;如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</p>
<p>&emsp;&emsp;于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</p>
<p>&emsp;&emsp;<code>DHCP</code> (Dynamic Host Configuration Protocol，动态主机配置协议) 是一个局域网的网络协议，使用UDP协议工作，指的是由服务器控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和子网掩码。默认情况下，DHCP作为 <code>Windows Server</code> 的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。</p>
<p>&emsp;&emsp;主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<p>&emsp;&emsp;在RFC 2131中有详细的描述，DHCP有3个端口，其中 <code>UDP67</code> 和 <code>UDP68</code> 为正常的 <code>DHCP</code> 服务端口，分别作为 <code>DHCP Server</code> 和 <code>DHCP Client</code> 的服务端口；546号端口用于 <code>DHCPv6 Client</code>，而不用于 <code>DHCPv4</code> ，是为 <code>DHCP failover</code> 服务，这是需要特别开启的服务，<code>DHCP failover</code> 是用来做双机热备的。</p>
<p>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>&emsp;&emsp;<code>NAT</code>（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</p>
<p>&emsp;&emsp;除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 <code>NAPT</code>（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</p>
<p>&emsp;&emsp;<code>NAT（NAPT）</code>实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 <code>NAT-PT</code>。</p>
<h4 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h4><p><img src="/img/e11421fc61d14423adab54661884f497.jpeg" alt="e11421fc61d14423adab54661884f497.jpeg"></p>
<p>夹着 IPv4 网络的两个 IPv6 网络</p>
<p>&emsp;&emsp;如上图的网络环境中，网络A 网络B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</p>
<p>&emsp;&emsp;IP 隧道可以将那网络A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发网络C。</p>
<p>&emsp;&emsp;一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中 “IP首部的后面还是 IP首部” 或者 “IP首部 的后面是 IPv6的首部” 等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做 “IP隧道”。</p>
<h2 id="扩展：运行在传输层中的-TCP-和-UDP-的协议"><a href="#扩展：运行在传输层中的-TCP-和-UDP-的协议" class="headerlink" title="扩展：运行在传输层中的 TCP 和 UDP 的协议"></a>扩展：运行在传输层中的 TCP 和 UDP 的协议</h2><p>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</p>
<p><strong>运行在 TCP协议上的协议：</strong></p>
<ul>
<li>HTTP（HypertextTransferProtocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）, HTTP协议的安全版本。</li>
<li>FTP（FileTransferProtocol，文件传输协议），用于文件传输。</li>
<li>POP3（PostOfficeProtocol,version3，邮局协议），收邮件用。</li>
<li>SMTP（SimpleMailTransferProtocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletypeover theNetwork，网络电传），通过一个 终端（terminal）登陆到网络。</li>
<li>SSH（SecureShell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p><strong>运行在 UDP协议上的协议：</strong></p>
<ul>
<li>BOOTP（BootProtocol，启动协议），应用于无盘设备。</li>
<li>NTP（NetworkTimeProtocol，网络时间协议），用于网络同步。</li>
<li>DHCP（DynamicHostConfigurationProtocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p><strong>运行在 TCP和 UDP协议上：</strong></p>
<ul>
<li>DNS（DomainNameService，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.sohu.com/a/339068354_774177">https://www.sohu.com/a/339068354_774177</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44630560/article/details/108100907">https://blog.csdn.net/weixin_44630560/article/details/108100907</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/IP4-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" class="post-title-link" itemprop="url">IP4-子网掩码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-01 10:33:08" itemprop="dateCreated datePublished" datetime="2021-03-01T10:33:08+00:00">2021-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">子网掩码</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网络掩码"><a href="#网络掩码" class="headerlink" title="网络掩码"></a>网络掩码</h2><p>&emsp;&emsp;子网掩码是在IPv4地址资源紧缺的背景下为了解决lP地址分配而产生的虚拟lP技术，通过子网掩码将A、B、C三类地址划分为若干子网，从而显著提高了IP地址的分配效率，有效解决了IP地址资源紧张的局面。如果是都是使用的IPV6的话是没有子网掩码的概念。IPV6是端到端的连接通信，不需要子网了。</p>
<p>&emsp;&emsp;网络掩码做为一个辅助工具，可以帮助主机区分以上三种情况，所以网络掩码是必不可少的，和IP地址如影相随。最初的网络掩码长度为8的整数倍，8、16、24、32，这里的长度为二进制的长度，即一个字节长度的整数倍。</p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">特征</th>
<th align="left">网络范围</th>
<th align="left">默认掩码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A类地址</td>
<td align="left">第1个8位中的第1位始终为0</td>
<td align="left">0-127.x.x.x</td>
<td align="left">255.0.0.0/8</td>
</tr>
<tr>
<td align="left">B类地址</td>
<td align="left">第1个8位中的第1、2位始终为10</td>
<td align="left">128-191.x.x.x</td>
<td align="left">255.255.0.0/16</td>
</tr>
<tr>
<td align="left">C类地址</td>
<td align="left">第1个8位中的第1、2、3位始终为110</td>
<td align="left">192-y.x.x.x</td>
<td align="left">255.255.255.0/24</td>
</tr>
</tbody></table>
<p><strong>1.1.1.1/8</strong><br>这个组合经常出现的路由器的配置里，其中 <code>1.1.1.1</code> 为IP地址。 <code>/8</code> 表示网络掩码的长度，8个二进制长度。</p>
<p><strong>172.16.1.1/16</strong><br><code>172.16.1.1</code> 为IP地址。<code>/16</code> 表示网络掩码的长度，16个二进制长度。</p>
<p><strong>192.168.1.1/24</strong><br><code>192.168.1.1</code> 为IP地址。<code>/24</code>表示网络掩码的长度，24个二进制长度。</p>
<p><strong>127.0.0.1/32</strong><br><code>127.0.0.1</code> 为IP地址。<code>/32</code> 表示网络掩码的长度，32个二进制长度。</p>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>如果不对掩码长度是8的整数倍做强制要求，那么就实现精细化的子网掩码。</p>
<p><code>CIDR</code> :( Classless Inter-Domain Routing，元类域间路由选择).我们需要了解这种网络表示法。形式如：192.168.10.32/28。前面的数字是我们的网络地址，后面的28表示用28位来表示网络位，用32-28=4位来表示主机位。通过这种记法，我们能明确两个信息：<br>网络地址：<code>192.168.10.32</code><br>子网掩码：<code>255.255.255.240</code></p>
<p>通过下表我们能明确 <code>子网掩码</code> 和 <code>斜杠表示法</code> 之间的关系:</p>
<p><img src="/img/1679092-20190709175902328-586874586.png" alt="1679092-20190709175902328-586874586.png"><br><img src="/img/1679092-20190709175913957-2145237488.png" alt="1679092-20190709175913957-2145237488.png"></p>
<p>其中 <code>/8-/15</code> 只能用于A类网络，<code>/16-/23</code> 可用于A类和B类网络，而 <code>/24-/30</code> 可用于A类、B类和C类网络。这就是大多数公司都使用A类网络地址的一大原因，因为它们可使用所有的子网掩码，进行网络设计时的灵活性最大。</p>
<p>假设现有一IP地址 <code>180.210.242.131</code>，即 <code>10110100.11010010.11110010.10000011</code><br>同时指定子网掩码为 <code>255.255.248.0</code>  即 <code>11111111.11111111.11111000.00000000</code>，则</p>
<p>网络号：两者进行与运算，即 <code>10110100.11010010.11110000.00000000（180.210.240.0）</code><br>主机号：子网掩码取反再和IP做与运算，即 <code>00000000.00000000.00000010.10000011（0.0.2.131）</code><br>子网号：这个IP本来是B类地址，默认的子网掩码是 <code>255.255.0.0</code>，所以本来的网络号是16位，但它实际网络号是21位，就是借了5位网络位，所以可以划分 <code>2^5</code> 个子网，即32个，实际使用30个，这个网段可以容纳主机 <code>2^11</code> 个，即2048个，有效2046个一头一尾分别做网络号和广播。</p>
<p>从前有一个地主，有256间房子，地主家的门牌号码是 <code>192.168.1</code>，那么他家第一间房子的门牌号码是 <code>192.168.1.0</code> ，第二间是 <code>192.168.1.1</code>,……第256间的编号是 <code>192.168.1.255</code>。</p>
<p>地主老了，需要把256间房子分给4个儿子，平均分配，每个儿子可以分64间。</p>
<p>请来一位先生主持公道，先生这么来操作：</p>
<p><code>192.168.1.0-192.168.1.63</code> 分给大儿子<br><code>192.168.1.64-192.168.1.127</code> 分给二儿子<br><code>192.168.1.128 -192.168.1.191</code> 分给三儿子<br><code>192.168.1.192-192.168.1.255</code> 分给四儿子</p>
<p>如何来描述四个儿子的子网网段呢?</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.0/26</span><br><span class="line">192.168.1.64/26</span><br><span class="line">192.168.1.128/26</span><br><span class="line">192.168.1.192/26</span><br></pre></td></tr></table></figure>

<p><strong>/26 解析</strong></p>
<p><code>255.255.255.192</code> 的二进制是：<code>11111111-11111111-11111111-11</code> 总共是26个1，为了简化子网掩码的表示，用 <code>/26</code> 代替 <code>255.255.255.192</code>。</p>
<p>按位与运算我们来看大儿子的网段 <code>192.168.1.0/26</code> 是如何得到的？</p>
<p>以大儿子的房间为例：<code>192.168.1.0-192.168.1.63</code></p>
<p>二进制表示：</p>
<p><code>192.168.1.0</code> 对于二进制：<code>11000000.10101000.00000001.00000000</code></p>
<p><code>192.168.1.63</code> 对于二进制：<code>11000000.10101000.00000001.00111111</code></p>
<p>首尾地址完全相同的是: <code>11000000.10101000.00000001.00</code>，总共26位！那么用这个 <code>192.168.1.0/26</code> 就可以表示大儿子所有房间。</p>
<p>对照房间的门牌号码 <code>192.168.1.199</code>，很显然属于四儿子的。</p>
<p>Q1：一个主机 <code>192.168.1.199/26</code> 能否和直连主机 <code>192.168.1.200/24</code> 通信？</p>
<p>可以的，因为都是四儿子的房间。</p>
<p>Q2：一个主机 <code>192.168.1.199/26</code> 能否和直连主机 <code>192.168.1.1/24</code> 通信？</p>
<p>不可以，因为一个是大儿子的房间，一个是四儿子的房间，无法直连通信！</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jAITB4o1nnO5M2wt0hDqjw">子网掩码有那么难吗？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/02/28/MSS-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E9%95%BF%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/MSS-%E6%9C%80%E5%A4%A7%E6%8A%A5%E6%96%87%E6%AE%B5%E9%95%BF%E5%BA%A6/" class="post-title-link" itemprop="url">MSS-最大报文段长度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 17:40:07" itemprop="dateCreated datePublished" datetime="2021-02-28T17:40:07+00:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最大报文段长度（MSS）是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）。</p>
<h2 id="开放式互联网模型"><a href="#开放式互联网模型" class="headerlink" title="开放式互联网模型"></a>开放式互联网模型</h2><p>开放式系统互联模型（OpenSystemInterconnection Model，简称为OSI模型）是一种互联网概念化模型，由国际标准化组织(InternationalOrganization forStandardization，简称为ISO)提出，定义于ISO/IEC 7498-1。OSI模型将互联网分为七层，由最高层（用户端）到最底层（物理层面）排列为：第7层 应用层（Application Layer）;第6层 表达层（Presentation Layer）；第5层 会话层（Session Layer）；第4层 传输层（Transport Layer）；第3层 网络层（Network Layer）；第2层 数据链接层（Data Link Layer）第1层 物理层（Physical Layer）；本词条MSS是第四层传输层中的一种协议（TCP）的选项之一。</p>
<p><img src="/img/503d269759ee3d6d55fbf8fa925e7a224f4a20a470e3.png" alt="503d269759ee3d6d55fbf8fa925e7a224f4a20a470e3.png"></p>
<h2 id="区分MSS与MTU"><a href="#区分MSS与MTU" class="headerlink" title="区分MSS与MTU"></a>区分MSS与MTU</h2><p>最大报文段长度（MSS）与最大传输单元（Maximum Transmission Unit, MTU）均是协议用来定义最大长度的。不同的是，MTU应用于OSI模型的第二层数据链接层，并无具体针对的协议。MTU限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小。例如，如果已知某局域网的MTU为1500字节，则在网络层的因特网协议（Internet Protocol, IP）里，最大的数据包大小为1500字节（包含IP协议头）。MSS针对的是OSI模型里第四层传输层的TCP协议。因为MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制。</p>
<p><img src="/img/d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png" alt="d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/02/28/IP%20Header%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/IP%20Header%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">IP Header结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 15:57:12" itemprop="dateCreated datePublished" datetime="2021-02-28T15:57:12+00:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IP-Header结构"><a href="#IP-Header结构" class="headerlink" title="IP Header结构"></a>IP Header结构</h2><p><img src="/img/2015-04-14-3.jpg" alt="2015-04-14-3.jpg"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://abcdxyzk.github.io/blog/2015/04/14/kernel-net-sock-raw/">https://abcdxyzk.github.io/blog/2015/04/14/kernel-net-sock-raw/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7-Ethernet-Frame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7-Ethernet-Frame/" class="post-title-link" itemprop="url">以太网帧-Ethernet Frame</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 17:10:06" itemprop="dateCreated datePublished" datetime="2021-01-29T17:10:06+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/img/ethernet-frame.gif" alt="ethernet-frame.gif"></p>
<p>octets：（Bytes）字节<br>Frame：帧</p>
<p><img src="/img/d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png" alt="d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png"></p>
<p><img src="/img/20210127194819642.png" alt="20210127194819642.png"></p>
<h2 id="Ethernet帧格式历史"><a href="#Ethernet帧格式历史" class="headerlink" title="Ethernet帧格式历史"></a>Ethernet帧格式历史</h2><p>1980 DEC,Intel,Xerox 制订了 Ethernet I 的标准</p>
<p>1982 DEC,Intel,Xerox 又制订了 Ehternet II 的标准</p>
<p>1982 IEEE 开始研究 Ethernet 的国际标准 802.3</p>
<p>1983 迫不及待的 Novell 基于 IEEE 802.3 的原始版开发了专用的 Ethernet 帧格式 (因此 802.3 Raw 先于 IEEE 802.3 出台.)</p>
<p>1985 IEEE 推出 IEEE 802.3 规范,</p>
<p>后来为解决 Ethernet II 与 802.3 帧格式 的兼容问题,推出折衷的 Ethernet SNAP 格式</p>
<p>(其中早期的 Ethernet I 已经完全被其他帧格式取代了 ,所以现在 Ethernet 只能见到后面几种 Ethernet的帧格式,现在大部分的网络设备都支持这几种 Ethernet 的帧格式,如:cisco 的路由器再设定 Ethernet 接口时可以指定不同的以太网的帧格式:arpa,sap,snap,novell-ether)</p>
<p>今天的实际环境中大多数TCP/IP设备都使用Ethernet V2格式的帧。<br>这是因为第一种大规模使用的TCP/IP系统(4.2/3 BSD UNIX)的出现时间介于RFC 894和RFC 1042之间，<br>它为了避免不能和别的主机互操作的风险而采用了RFC 894的实现；<br>也由于大家都抱着这种想法，所以 802.3 标准并没有如预期那样得到普及；</p>
<p>CISCO设备的Ethernet Interface默认封装格式是ARPA(Ethernet V2)</p>
<p><strong>不同厂商对这几种帧格式不同的叫法</strong></p>
<table>
<thead>
<tr>
<th align="left">Frame Type</th>
<th align="left">Novell公司</th>
<th align="left">Cisco 公司</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ethernet Version 2</td>
<td align="left">Ethernet_II</td>
<td align="left">arpa</td>
</tr>
<tr>
<td align="left">802.3 Raw</td>
<td align="left">Ethernet_802.3</td>
<td align="left">novell_ether</td>
</tr>
<tr>
<td align="left">IEEE 802.3/802.2</td>
<td align="left">Ethernet_802.2</td>
<td align="left">sap</td>
</tr>
<tr>
<td align="left">IEEE 802.3/802.2 SNAP</td>
<td align="left">ETHERNET_SNAP</td>
<td align="left">snap</td>
</tr>
</tbody></table>
<h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><h3 id="Ethernet-I-V1"><a href="#Ethernet-I-V1" class="headerlink" title="Ethernet I (V1)"></a>Ethernet I (V1)</h3><p>这是最原始的一种格式，是由 Xerox PARC 提出的 3Mbps CSMA/CD 以太网标准的封装格式，<br>后来在1980年由 DEC，Intel 和 Xerox 标准化形成 Ethernet V1 标准；</p>
<h3 id="Ethernet-II-V2-ARPA"><a href="#Ethernet-II-V2-ARPA" class="headerlink" title="Ethernet II (V2) (ARPA)"></a>Ethernet II (V2) (ARPA)</h3><p>这是最常见的一种以太网帧格式，也是今天以太网的事实标准，由DEC，Intel 和Xerox [简称 DIX以太网联盟] 在1982年公布其标准，主要更改了Ethernet V1 的电气特性和物理接口， 在帧格式上并无变化；Ethernet V2 出现后迅速取代 Ethernet V1 成为以太网事实标准；</p>
<p>Ethernet V2 帧头（Frame Header）结构为： 6bytes的源地址（源MAC） + 6bytes的目标地址（目标MAC） + 2Bytes协议类型字段（用于标示封装在这个 Frame 里面数据的类型)，<br>数据长度 46–1500 Bytes，4Bytes的帧校验。</p>
<p>Ethernet V2 类型以太网帧的最小长度为64字节（6＋6＋2＋46＋4），最大长度为1518字节（6＋6＋2＋1500＋4）。</p>
<p>常见协议类型如下：</p>
<p>0x0800 　　IP协议数据，<br>0x86dd 　　IPv6协议数据，<br>0x809B 　　AppleTalk协议数据，<br>0x8138 　　Novell类型协议数据等。<br>0x0806 　　ARP<br>0x0600 　　XNS (Xerox)<br>0x6003 　　DECNET</p>
<p>如果协议类型字段取值为0000-05dc(十进制的0-1500)，则该帧就不是 Ethernet V2(ARPA) 类型了，而是下面的三种 802.3帧 类型之一；</p>
<p>Ethernet V2 可以支持 TCP/IP，Novell IPX/SPX，Apple Talk Phase I 等协议；RFC 894 定义了IP报文在Ethernet V2 上的封装格式；</p>
<h3 id="Novell-Ethernet-（802-3-Raw）-novell-ether"><a href="#Novell-Ethernet-（802-3-Raw）-novell-ether" class="headerlink" title="Novell Ethernet （802.3 Raw） novell_ether"></a>Novell Ethernet （802.3 Raw） novell_ether</h3><p>这是1983年 Novell 发布其划时代的 Netware/86 网络套件时，采用的私有以太网帧格式，该格式以当时尚未正式发布的 802.3 标准为基础；</p>
<p>但是当两年以后 IEEE正式发布 802.3 标准时情况发生了变化 — IEEE 在802.3帧头中又加入了802.2 LLC(Logical Link Control)头，这使得 Novell 的 802.3 RAW 格式跟正式的 IEEE 802.3 标准互不兼容；可以看到在 Novell 的 RAW 802.3 帧结构中并没有标志协议类型的字段，而只有 Length 字段(2bytes,取值为0000-05dc，即十进制的0-1500)，因为 RAW 802.3帧 只支持 IPX/SPX 一种协议；</p>
<p>802.3 Raw 帧头与 Ethernet 帧头有所不同，其中 Ethernet II 帧头中的类型域变成了长度域，后面接着的两个字节为 0xFFFF,用于标示这个帧是 Novell Ether 类型的 Frame,由于前面的 0xFFFF 站掉了两个字节所以数据域缩小为 44-1498 个字节,帧校验不变。</p>
<p><img src="/img/802.3_Raw.png" alt="802.3Raw.png"></p>
<ul>
<li>目标地址：此数据包的目标MAC地址。</li>
<li>源地址：此数据包的源MAC地址。</li>
<li>长度：帧包含的数量必须或等于 1500。(在 Ethernet 802.3 raw 类型以太网帧中，原来 Ethernet II 类型以太网帧中的类型字段被”总长度”字段所取代，它指明其后数据域的长度，其取值范围为：46-1500。)</li>
<li>数据：高层协议（IPX/SPX）、数据和填充符，范围在46～1500字节。(长度紧跟着的接下来的2个字节是固定不变的16进制数 0xFFFF，它标识此帧为 Novell 以太类型数据帧。)</li>
<li>FCS：数据帧校验序列，用于确定数据包在传输过程中是否损坏。</li>
</ul>
<h3 id="IEEE-802-3-802-2-LLC-Logical-Link-Control-sap"><a href="#IEEE-802-3-802-2-LLC-Logical-Link-Control-sap" class="headerlink" title="IEEE 802.3/802.2 LLC (Logical Link Control),sap"></a>IEEE 802.3/802.2 LLC (Logical Link Control),sap</h3><p>这是IEEE 正式的 802.3 标准，它由 Ethernet V2 发展而来。</p>
<p>IEEE 802.3 的 Frame Header 和 Ethernet II 的帧头有所不同,IEEE 802.3 将 Ethernet V2 帧头的协议类型字段替换为帧长度字段(取值为0000-05dc;十进制的1500)。</p>
<p>其中又引入 802.2 协议(LLC,Logical Link Control) 在 802.3 帧头后面添加了一个 LLC 首部,LLC头包含目的 服务访问点(DSAP,Destination Service Access Point)、源服务访问点（SSAP,Source Service Access Point）和 控制（Control）字段。</p>
<p>IEEE 802.3 把 DLC (数据链路控制，Digital Loop Carrier) 层分隔成明显的两个子层：MAC 层和 LLC 层，其中 MAC 层主要是指示硬件目的地址和源地址，LLC层用来提供一些服务：</p>
<ul>
<li>通过SAP地址来辨别接收和发送方法</li>
<li>兼容无连接和面向连接服务</li>
<li>提供子网访问协议（Sub-network Access Protocol，SNAP），类型字段即由它的首部给出。</li>
</ul>
<p>MAC层要保证最小帧长度不小于64字节，如果数据不满足64字节长度就必须进行填充。</p>
<p>利用 Sniffer 等协议分析工具去捕获的 IEEE 802.3 帧的解码，可以看到在 DLC 层源地址后紧跟着就是 802.3 的长度（Length）字段 0026，它小于 05FF（二进制1535），可以肯定它不是 Ethernet V2 的帧，而接下来的 Offset 0E 处的值 4242 （代表DSAP和SSAP），既不是 Novell 802.3 Raw 的特征值 FFFF ，也不是 IEEE 802.3 SNAP 的特征值 AAAA ，因此它肯定是一个 IEEE 802.3 的帧。</p>
<p>以太网类型码：</p>
<p><img src="/img/ETHERNET_type_code.png" alt="ETHERNET_type_code.png"></p>
<p>decimal：十进制<br>octal：八进制</p>
<p><strong>802.2 SAP (Service Access Point) 介绍</strong></p>
<p>为了区别 802.3 数据帧中所封装的数据类型，IEEE 引入了 802.2 SAP 和 SNAP 的标准。它们工作在数据链路层的 LLC（逻辑链路控制）子层。</p>
<p>通过在802.3帧的数据字段中划分出被称为服务访问点（SAP）的新区域来解决识别上层协议的问题，这就是 802.2 SAP。</p>
<p><strong>LLC标准 介绍</strong></p>
<p>LLC 标准包括两个服务访问点，源服务访问点（SSAP）和目标服务访问点（DSAP）。每个SAP只有1字节长，而其中仅保留了6比特用于标识上层协议，所能标识的协议数有限。</p>
<p>因此，又开发出另外一种解决方案，在 802.2 SAP 的基础上又新添加了一个 2字节长的类型域（同时将SAP的值置为AA），使其可以标识更多的上层协议类型，这就是 802.2 SNAP。</p>
<p>常见SAP值：</p>
<ul>
<li>0：Null LSAP[IEEE] </li>
<li>4：SNA Path Control[IEEE] </li>
<li>6：DOD IP[79,JBP] </li>
<li>AA：SNAP[IEEE] </li>
<li>FE：ISO DIS 8473[52,JXJ] </li>
<li>FF：Global DSAP[IEEE]</li>
</ul>
<p><img src="/img/IEEE_802.3.png" alt="IEEE_802.3.png"></p>
<ul>
<li>目标地址：此数据包的目标mac地址；</li>
<li>源地址：此数据包的源mac地址；</li>
<li>长度：帧包含的数据量必须小于或等于1500（16进制的05DC）；</li>
<li>DSAP：目标服务存取点（Destination  Service Access Point）；</li>
<li>SSAP：源服务存取点（Source Service Access  Point）；</li>
<li>控制：无连接或面向连接的C；</li>
<li>数据：高层协议、数据和填充符;</li>
<li>FCS：数据帧校验序列，用于确定数据包在传输过程中是否损坏。</li>
</ul>
<h3 id="Ethernet-SNAP-IEEE-802-3-802-2-SNAP-ETHERNET-SNAP-snap"><a href="#Ethernet-SNAP-IEEE-802-3-802-2-SNAP-ETHERNET-SNAP-snap" class="headerlink" title="Ethernet SNAP (IEEE 802.3/802.2 SNAP, ETHERNET_SNAP, snap)"></a>Ethernet SNAP (IEEE 802.3/802.2 SNAP, ETHERNET_SNAP, snap)</h3><p>SNAP (Sub-Network Access Protocol)子网访问协议，是逻辑链路控制（Logical Link Control）的一个子集，它允许协议不用通过 服务访问点（SAP）即可实现 IEEE 兼容的 MAC 层功能，因此它在 DSAP 和 SSAP域里的值是固定的 （AAAA）。也正源于此，它需要额外提供5个字节的头来指定接收方法，3个字节标识厂商代码，2个字节标识上层协议。</p>
<p>其 MAC 层保证数据帧长度不小于64字节，不足的话需要进行数据填充。</p>
<p>Sniffer 捕获的 IEEE 802.3 SNAP 帧的解码，可以看到在 DLC 层源地址后紧跟着就是 802.3 的长度（Length）字段 0175，它小于 05FF，可以肯定它不是 Ethernet V2 的帧，而接下来的 Offset 0E 处的值 AAAA （代表DSAP和SSAP），这是 IEEE 802.3 SNAP 的特征值 AAAA ，因此可以断定它是一个 IEEE 802.3 SNAP 的帧。</p>
<p>SNAP Frame 与 802.3/802.2 Frame 的最大区别是增加了一个 5 Bytes 的 SNAP ID，其中前面3个byte通常与源mac地址的前三个bytes相同为厂商代码，有时也可设为0,后2 bytes 与 Ethernet II 的类型域相同。</p>
<p><img src="/img/ETHERNET_SNAP.png" alt="ETHERNET_SNAP.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th align="left">Frame Type</th>
<th align="left">Header &amp; CRC</th>
<th align="left">Data Min</th>
<th align="left">Data Max</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ethernet II (DIX)</td>
<td align="left">18</td>
<td align="left">46</td>
<td align="left">1500</td>
</tr>
<tr>
<td align="left">802.3 (IEEE)</td>
<td align="left">21</td>
<td align="left">43</td>
<td align="left">1497</td>
</tr>
<tr>
<td align="left">SNAP</td>
<td align="left">26</td>
<td align="left">38</td>
<td align="left">1492</td>
</tr>
</tbody></table>
<ul>
<li>Ethernet II 和 IEEE 802.3 是局域网里最常见的帧</li>
<li>Ethernet II 可以装载的数据长度是46—1500;  </li>
<li>IEEE802.3 SAP 可以装装的数据长度是43—1497; </li>
<li>IEEE 802.3 SNAP 可以装载的数据长度是38—1492；</li>
<li>Ethernet II 不提供 MAC 层的数据填充功能;</li>
<li>IEEE802.3 SAP 和 SNAP 都提供数据填充功能.</li>
</ul>
<p><strong>Ethernet V2 帧与IEEE 802.3 帧的比较</strong></p>
<p>Ethernet V2 可以装载的最大数据长度是1500字节，而 IEEE 802.3 可以装载的最大数据是1492字节（SNAP）或是1497字节; Ethernet V2 不提供 MAC层 的数据填充功能，而 IEEE 802.3 不仅提供该功能，还具备服务访问点（SAP）和 SNAP 层，能够提供更有效的数据链路层控制和更好的传输保证。那么我们可以得出这样的结 论：Ethernet V2 比 IEEE 802.3 更适合于传输大量的数据，但 Ethernet V2 缺乏数据链路层的控制，不利于传输需要严格传输控制的数据，这也正是 IEEE 802.3 的优势所在，越需要严格传输控制的应用，越需要用 IEEE 802.3或 SNAP 来封装，但 IEEE 802.3 也不可避免的带来数据装载量的损失，因此该格式的封装往往用在较少数据量承载但又需要严格控制 传输的应用中。</p>
<p>在实际应用中，我们会发现，大多数应用的以太网数据包是 Ethernet V2 的帧（如HTTP、FTP、SMTP、POP3等应用），而交换机之间的BPDU（桥协议数据单元）数据包则是IEEE 802.3的帧，VLAN Trunk 协议如 802.1Q 和Cisco的CDP（思科发现协议）等则是采用 IEEE 802.3 SNAP 的帧。可以利用Sniffer等协议分析工具去捕捉数据包。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guoshaobei/article/details/4768514">以太网帧与ieee 802.3帧</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yshe_xun/article/details/7636078">以太网类型码(Ethernet type codes)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xlmeng1988/articles/2445619.html">Ethernet frame</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mylinux/p/5553242.html">ETHERNET帧结构</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21318925">车小胖谈网络：Ethernet Frame</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%EF%BC%88CRC%EF%BC%89%E4%B8%8E%E5%B8%A7%E6%A3%80%E9%AA%8C%E5%BA%8F%E5%88%97-FCS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%EF%BC%88CRC%EF%BC%89%E4%B8%8E%E5%B8%A7%E6%A3%80%E9%AA%8C%E5%BA%8F%E5%88%97-FCS/" class="post-title-link" itemprop="url">循环冗余检验算法（CRC）与帧检验序列(FCS)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 16:38:55" itemprop="dateCreated datePublished" datetime="2021-01-29T16:38:55+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>循环冗余检验CRC是一种检验方法，而FCS是添加在数据后面的帧检验序列。CRC 检验只能保证接收端接收到的帧没有差错，至于有没有出现帧丢失，帧重复，帧失序，是无法判断的。</p>
<h2 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h2><p>循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术（算法），主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p>
<h2 id="FCS"><a href="#FCS" class="headerlink" title="FCS"></a>FCS</h2><p>帧校验序列码 FCS ( Frame Check Sequences) 是为提高通信的可靠性设置的。将每一帧中的第一个字符@到该帧中正文的最后一个ASCII 字符作“异或”运算, 并将异或的结果转换为两个ASCII码, 便得到了FCS , 它作为帧的一部分发送到接收端。接收端计算出收到的帧的FCS , 如果与发送端传送过来的FCS 不同, 可以判定通信有误。</p>
<p>帧校验序列（FCS）是指特别的检测码字符被添加到在一个通信协议中的帧中进行检错和纠错。发送主机在整个帧中有一个检测码随着发送。接收主机在整个帧中的检测码使用相同的运算法则，并将它与接收到的 FCS 相比较。这样，它能够探测是否任何数据在运输中丢失或被改变。它可能当时丢失这个数据，和请求错误帧的重传。一个循环冗余码校验常被用来估算 FCS。</p>
<p>FCS 字段：包含帧的 32 位循环冗余校验 (CRC), 数据链路层帧方式接入协议（LAPF）中的字段，是一个16比特的序列。它具有很强的检错能力，它能检测出在任何位置上的 3 个以内的错误、所有的奇数个错误、16个比特之内的连续错误以及大部分的大量突发错误。</p>
<p><img src="/img/ethernet-frame.gif" alt="ethernet-frame.gif"></p>
<p>octets：（Bytes）字节<br>Frame：帧</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/loveCC_orange/article/details/79127809">循环冗余检验算法（CRC）与帧检验序列(FCS)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lxm920714/article/details/103274092">帧检验序列(FCS)</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/MTU-%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/MTU-%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83/" class="post-title-link" itemprop="url">MTU-最大传输单元</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 14:24:29" itemprop="dateCreated datePublished" datetime="2021-01-29T14:24:29+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ethernet/" itemprop="url" rel="index"><span itemprop="name">Ethernet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>最大传输单元</strong>（Maximum Transmission Unit，MTU）用来通知对方所能接受数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小。<br>是包或帧的最大长度，一般以字节记。如果MTU过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包(或帧)上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以太网和802.3对数据帧的长度都有一个限制，其最大值分别是1500字节和1492字节。链路层的这个特性称为MTU，即最大传输单元。不同类型网络的数帧长度大多数都有一个上限。如果IP层有一个数据报要传，而且数据帧的长度比链路层的MTU还大，那么IP层就需要进行分片( fragmentation)，即把数据报分成干片，这样每一片就都小于MTU。 </p>
<p>当同一个网络上的两台主机互相进行通信时，该网络的MTU是非常重要。但是如果两台主机之间的通信要通过多个网络，每个网络的链路层可能有不同的MTU，那么这时重要的不是两台主机所在网络的MTU的值，而是两台主机通信路径中的最小MTU，称为 路径 MTU( Path mtu，PMTU)。</p>
<p>两台主机之间的PMTU不一定是个常数，它取决于当时所选择的路径，而且路由选择也不一定是对称的(从A到B的路由可能与从B到A的路由不同)，因此，PMTU在两个方向上不一定是一致的。<br>RFC1191描述了PMTU的发现机制，即确定路径MTU的方法。ICMP的不可到达错误采用的就是这种方法， traceroute程序也是用这种方法来确定到达目的节点的PMT的。</p>
<h2 id="MTU字节"><a href="#MTU字节" class="headerlink" title="MTU字节"></a>MTU字节</h2><p>在远端节点的配置响应中将包含在该信道使用的实际的MTU大小，信道的方向是流向本地节点，MTU值取在configReq中的MTU和远端节点的输出MTU能力中最小值。该MTU只能用于这个信道，不能用于相反方向的信道。<br>MTU字段：2个字节。</p>
<p>MTU字段表示发起请求方可以接受的最大的L2CAP分组净荷(按字节计)。MTU是非对称的，请求的发送方指定在该信道上它可以接收的MTU值。L2CAP的实现必须支持最小的48字节的MTU值。缺省值是672字节。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>MTU是网络调节的重要因素，因为包中的额外开销量相当高。高的MTU减少了头信息浪费的字节数。对大量数据传输尤其重要，而对小于MTU的传输没有影响。因此，注意配置传输大量数据流的服务器(如文件服务器和FTPH&amp;．务器)上的MTU。</p>
<p>选择MTU时，规则是选择传输中不需分段的最大MTU。如果网络使用一种媒体类型，缺省的设置就可以。选择比媒体最大值更小的MTU并没有好处，整个数据报会因为每个包的错误而重发。换言之，不能重发单个段。</p>
<h2 id="IP分片与重组"><a href="#IP分片与重组" class="headerlink" title="IP分片与重组"></a>IP分片与重组</h2><p>数据链路不同，最大传输单元( Maximum transmission Unit，MTU)也不同，由于IP协议是数据链路的上一层，所以它必须不受数据链路的MTU大小的影响能够加以利用。当IP数据报太大时，就要采用分片技术，以保证数据帧不大于要过的网络的MTU。</p>
<p>IP协议除了具有路由寻址功能外，另一个重要的功能就是IP数据报的分片处理。每个数据链路层能够确定发送的一个帧的最大长度称为最大传输单元。在Ethernet中，MTU为1500字节;在FDDI中，MTU为4352字节;在 IP over ATM中，MTU为9180字节。</p>
<p>如果要发送的IP数据报比数据链路层的MTU大，则无法发送该数据报。对于来自于上一层的IP协议，当要求发送的IP数据报比数据链路层的MTU大时，必把该数据报分割成多个IP数据报才能发送。另外，在进行通信的各台主机之间，存在着MTU不同的数据链路;在发送的过程中，也有MTU缩小的情况发生。当出现上述情况时，在发送过程中必须有一台能够进行分片处理的路由器。</p>
<p>接收端主机必须对经过分片处理后的IP数据报进行还原处理。在中继路由器中，虽然路由器进行了分片处理，但并不进行还原处理。另外，经分片处理的IP数据报只有经过还原处理后才能还原成原来的IP数据报，才可以向上一层的模块传递数据。</p>
<p><img src="/img/d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png" alt="d009b3de9c82d158ccbfd28051420ed8bc3eb135e4e3.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83/9730690?fromtitle=mtu&fromid=508920">最大传输单元</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/29/%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/29/%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/" class="post-title-link" itemprop="url">查看Linux系统版本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-29 13:57:29" itemprop="dateCreated datePublished" datetime="2021-01-29T13:57:29+00:00">2021-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查看Linux内核版本"><a href="#查看Linux内核版本" class="headerlink" title="查看Linux内核版本"></a>查看Linux内核版本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>

<h2 id="查看Linux系统版本"><a href="#查看Linux系统版本" class="headerlink" title="查看Linux系统版本"></a>查看Linux系统版本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版。</span></span><br><span class="line"><span class="comment"># 如果未安装，需要命令：yum install redhat-lsb -y</span></span><br><span class="line">lsb_release -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只适合Redhat系的Linux</span></span><br><span class="line">cat /etc/redhat-release</span><br><span class="line">file /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 适用于所有的Linux发行版</span></span><br><span class="line">cat /etc/issue</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/18/Git%E5%8F%96%E6%B6%88%E6%96%87%E4%BB%B6%E8%B7%9F%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/Git%E5%8F%96%E6%B6%88%E6%96%87%E4%BB%B6%E8%B7%9F%E8%B8%AA/" class="post-title-link" itemprop="url">Git取消文件跟踪</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-18 10:05:02" itemprop="dateCreated datePublished" datetime="2021-01-18T10:05:02+00:00">2021-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index"><span itemprop="name">Git</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .  <span class="comment"># 不删除本地文件</span></span><br><span class="line">git rm -r --f . 　　  <span class="comment"># 删除本地文件</span></span><br><span class="line">git rm --cached 1.txt  <span class="comment"># 删除readme1.txt的跟踪，并保留在本地。</span></span><br><span class="line">git rm --f 1.txt    <span class="comment"># 删除readme1.txt的跟踪，并且删除本地文件。</span></span><br></pre></td></tr></table></figure>

<p>已经被纳入了版本管理中，则修改 <code>.gitignore</code> 是无效的。</p>
<p>解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区到本地仓库中</span></span><br><span class="line">git commit -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Python3学习-函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-16 15:22:55" itemprop="dateCreated datePublished" datetime="2021-01-16T15:22:55+00:00">2021-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python3/" itemprop="url" rel="index"><span itemprop="name">Python3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>自定义函数规则：</p>
<ul>
<li>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号 : 起始，并且缩进。</li>
<li>return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数</span>):</span></span><br><span class="line">	函数体</span><br><span class="line">	<span class="keyword">return</span> 返回值</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名():</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不确定参数的个数,使用不定长参数，在参数名前加 * 进行声明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">*参数名</span>):</span></span><br><span class="line">	函数体</span><br><span class="line"></span><br><span class="line"><span class="comment"># lambda 定义匿名函数</span></span><br><span class="line"><span class="keyword">lambda</span> 参数 : 表达式</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_empty</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testprint</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;Hello&#x27;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    s = x + y</span><br><span class="line">    print(<span class="string">&#x27;s--&gt;&#x27;</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 不定长参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_variable</span>(<span class="params">*params</span>):</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> params:</span><br><span class="line">        print(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line">test_sub = <span class="keyword">lambda</span> x, y: x - y</span><br></pre></td></tr></table></figure>

<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testprint</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="comment"># 打印任何传入的字符串</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">testprint(<span class="string">&quot;调用自定义函数!&quot;</span>)</span><br><span class="line">testprint(<span class="string">&quot;再次调用同一函数&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>在 python 中，类型属于对象，变量是没有类型的</p>
<p><strong>可更改(mutable)与不可更改(immutable)对象</strong></p>
<p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li>不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li>
<li>可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递：</p>
<ul>
<li>不可变类型：类似 C++ 的值传递，如 整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a)）内部修改 a 的值，则是新生成来一个 a。</li>
<li>可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li>
</ul>
<p><strong>函数调用可以使用关键字参数来确定传入的参数值，并且不需要使用指定顺序：</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testprint</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用testprint函数</span></span><br><span class="line">testprint( <span class="built_in">str</span> = <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要使用指定顺序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testprint</span>(<span class="params"> name, age</span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用testprint函数</span></span><br><span class="line">testprint( age=<span class="number">20</span>, name=<span class="string">&quot;jun&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数:"></a>默认参数:</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testprint</span>(<span class="params">name, age = <span class="number">35</span></span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">testprint(name=<span class="string">&quot;jun&quot;</span> )</span><br></pre></td></tr></table></figure>

<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>如果在函数调用时没有指定参数，它就是一个空元组,可以不向函数传递未命名的变量。</p>
<p>加星号 <code>*</code> 的参数会以元组(tuple)的形式导入:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testprint</span>(<span class="params">arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用testprint 函数</span></span><br><span class="line">testprint(<span class="number">10</span>)</span><br><span class="line">testprint(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明函数时，参数中星号 * 可以单独出现，</span></span><br><span class="line"><span class="comment"># 如果单独出现星号 * 后的参数必须用关键字传入。</span></span><br><span class="line"><span class="comment"># 例如:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,*,c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment"># 报错</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment"># 正常</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>语法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> ))</span><br></pre></td></tr></table></figure>

<h3 id="强制位置参数"><a href="#强制位置参数" class="headerlink" title="强制位置参数"></a>强制位置参数</h3><p>Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</p>
<p>在以下的例子中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 或 f 要求为关键字形参:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span></span><br><span class="line">    print(a, b, c, d, e, f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 正确使用方法:</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误使用方法:</span></span><br><span class="line">f(<span class="number">10</span>, b=<span class="number">20</span>, c=<span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)   <span class="comment"># b 不能使用关键字参数的形式</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, f=<span class="number">60</span>)           <span class="comment"># e 必须使用关键字参数的形式</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/16/Python3%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">Python3学习-基本语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-16 11:35:24" itemprop="dateCreated datePublished" datetime="2021-01-16T11:35:24+00:00">2021-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python3/" itemprop="url" rel="index"><span itemprop="name">Python3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>if、elif、else 来进行逻辑判断</p>
<p>格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2.</span>..</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    执行语句<span class="number">3.</span>..</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    执行语句<span class="number">4.</span>..</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>for 循环可以遍历任何序列</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">str</span>:</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">9</span>) :</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P</span><br><span class="line">y</span><br><span class="line">t</span><br><span class="line">h</span><br><span class="line">o</span><br><span class="line">n</span><br></pre></td></tr></table></figure>

<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">m = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> m &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + m</span><br><span class="line">    m = m - <span class="number">1</span></span><br><span class="line">print(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<p><strong>while 循环使用 else 语句</strong></p>
<p>在 while … else 在条件语句为 false 时执行 else 的语句块。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break 用在 for 循环和 while 循环语句中，用来终止整个循环。</p>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue 用在 for 循环和 while 循环语句中，用来终止本次循环。</p>
<h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h3><p>pass 是空语句，它不做任何事情，一般用做占位语句，作用是保持程序结构的完整性。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/13/MySQL-GRANT%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/MySQL-GRANT%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83/" class="post-title-link" itemprop="url">MySQL GRANT命令-用户授权</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-13 15:20:34" itemprop="dateCreated datePublished" datetime="2021-01-13T15:20:34+00:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySql/" itemprop="url" rel="index"><span itemprop="name">MySql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="GRANT语法"><a href="#GRANT语法" class="headerlink" title="GRANT语法"></a>GRANT语法</h2><p>在 MySQL 中，拥有 GRANT 权限的用户才可以执行 GRANT 语句，其语法格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT priv_type [(column_list)] ON database.table</span><br><span class="line">TO user [IDENTIFIED BY [PASSWORD] <span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">[, user[IDENTIFIED BY [PASSWORD] <span class="string">&#x27;password&#x27;</span>]] ...</span><br><span class="line">[WITH with_option [with_option]...]</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT,INSERT,DELETE,UPDATE ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;192.125.30.123&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>取消权限：</p>
<p><code>revoke all on *.* from root@localhost;</code></p>
<ul>
<li>priv_type 参数表示权限类型；</li>
<li>columns_list 参数表示权限作用于哪些列上，省略该参数时，表示作用于整个表；</li>
<li>database.table 用于指定权限的级别；</li>
<li>user 参数表示用户账户，由用户名和主机名构成，格式是“‘username’@’hostname’”；</li>
<li>IDENTIFIED BY 参数用来为用户设置密码；</li>
<li>password 参数是用户的新密码。</li>
</ul>
<p>WITH 关键字后面带有一个或多个 with_option 参数。这个参数有 5 个选项，详细介绍如下：</p>
<ul>
<li>GRANT OPTION：被授权的用户可以将这些权限赋予给别的用户；</li>
<li>MAX_QUERIES_PER_HOUR count：设置每个小时可以允许执行 count 次查询；</li>
<li>MAX_UPDATES_PER_HOUR count：设置每个小时可以允许执行 count 次更新；</li>
<li>MAX_CONNECTIONS_PER_HOUR count：设置每小时可以建立 count 个连接;</li>
<li>MAX_USER_CONNECTIONS count：设置单个用户可以同时具有的 count 个连接。</li>
</ul>
<p>GRANT 语句中可用于指定权限级别的值有以下几类格式：</p>
<ul>
<li>*：表示当前数据库中的所有表。</li>
<li><em>.</em>：表示所有数据库中的所有表。</li>
<li>db_name.*：表示某个数据库中的所有表，db_name 指定数据库名。</li>
<li>db_name.tbl_name：表示某个数据库中的某个表或视图，db_name 指定数据库名，tbl_name 指定表名或视图名。</li>
<li>db_name.routine_name：表示某个数据库中的某个存储过程或函数，routine_name 指定存储过程名或函数名。</li>
<li>TO 子句：如果权限被授予给一个不存在的用户，MySQL 会自动执行一条 CREATE USER 语句来创建这个用户，但同时必须为该用户设置密码。</li>
</ul>
<h2 id="数据库权限的权限类型"><a href="#数据库权限的权限类型" class="headerlink" title="数据库权限的权限类型"></a>数据库权限的权限类型</h2><table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="center">对应user表中的字段</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SELECT</td>
<td align="center">Select_priv</td>
<td align="center">表示授予用户可以使用 SELECT 语句访问特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td align="left">INSERT</td>
<td align="center">Insert_priv</td>
<td align="center">表示授予用户可以使用 INSERT 语句向特定数据库中所有表添加数据行的权限。</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="center">Delete_priv</td>
<td align="center">表示授予用户可以使用 DELETE 语句删除特定数据库中所有表的数据行的权限。</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="center">Update_priv</td>
<td align="center">表示授予用户可以使用 UPDATE 语句更新特定数据库中所有数据表的值的权限。</td>
</tr>
<tr>
<td align="left">REFERENCES</td>
<td align="center">References_priv</td>
<td align="center">表示授予用户可以创建指向特定的数据库中的表外键的权限。</td>
</tr>
<tr>
<td align="left">CREATE</td>
<td align="center">Create_priv</td>
<td align="center">表示授权用户可以使用 CREATE TABLE 语句在特定数据库中创建新表的权限。</td>
</tr>
<tr>
<td align="left">ALTER</td>
<td align="center">Alter_priv</td>
<td align="center">表示授予用户可以使用 ALTER TABLE 语句修改特定数据库中所有数据表的权限。</td>
</tr>
<tr>
<td align="left">SHOW VIEW</td>
<td align="center">Show_view_priv</td>
<td align="center">表示授予用户可以查看特定数据库中已有视图的视图定义的权限。</td>
</tr>
<tr>
<td align="left">CREATE ROUTINE</td>
<td align="center">Create_routine_priv</td>
<td align="center">表示授予用户可以为特定的数据库创建存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="left">ALTER ROUTINE</td>
<td align="center">Alter_routine_priv</td>
<td align="center">表示授予用户可以更新和删除数据库中已有的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="left">INDEX</td>
<td align="center">Index_priv</td>
<td align="center">表示授予用户可以在特定数据库中的所有数据表上定义和删除索引的权限。</td>
</tr>
<tr>
<td align="left">DROP</td>
<td align="center">Drop_priv</td>
<td align="center">表示授予用户可以删除特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td align="left">CREATE TEMPORARY TABLES</td>
<td align="center">Create_tmp_table_priv</td>
<td align="center">表示授予用户可以在特定数据库中创建临时表的权限。</td>
</tr>
<tr>
<td align="left">CREATE VIEW</td>
<td align="center">Create_view_priv</td>
<td align="center">表示授予用户可以在特定数据库中创建新的视图的权限。</td>
</tr>
<tr>
<td align="left">EXECUTE ROUTINE</td>
<td align="center">Execute_priv</td>
<td align="center">表示授予用户可以调用特定数据库的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td align="left">LOCK TABLES</td>
<td align="center">Lock_tables_priv</td>
<td align="center">表示授予用户可以锁定特定数据库的已有数据表的权限。</td>
</tr>
<tr>
<td align="left">ALL 或 ALL PRIVILEGES 或 SUPER</td>
<td align="center">Super_priv</td>
<td align="center">表示以上所有权限/超级权限</td>
</tr>
</tbody></table>
<h2 id="表权限的权限类型"><a href="#表权限的权限类型" class="headerlink" title="表权限的权限类型"></a>表权限的权限类型</h2><table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="center">对应user表中的字段</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SELECT</td>
<td align="center">Select_priv</td>
<td align="center">授予用户可以使用 SELECT 语句进行访问特定表的权限</td>
</tr>
<tr>
<td align="left">INSERT</td>
<td align="center">Insert_priv</td>
<td align="center">授予用户可以使用 INSERT 语句向一个特定表中添加数据行的权限</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="center">Delete_priv</td>
<td align="center">授予用户可以使用 DELETE 语句从一个特定表中删除数据行的权限</td>
</tr>
<tr>
<td align="left">DROP</td>
<td align="center">Drop_priv</td>
<td align="center">授予用户可以删除数据表的权限</td>
</tr>
<tr>
<td align="left">UPDATE</td>
<td align="center">Update_priv</td>
<td align="center">授予用户可以使用 UPDATE 语句更新特定数据表的权限</td>
</tr>
<tr>
<td align="left">ALTER</td>
<td align="center">Alter_priv</td>
<td align="center">授予用户可以使用 ALTER TABLE 语句修改数据表的权限</td>
</tr>
<tr>
<td align="left">REFERENCES</td>
<td align="center">References_priv</td>
<td align="center">授予用户可以创建一个外键来参照特定数据表的权限</td>
</tr>
<tr>
<td align="left">CREATE</td>
<td align="center">Create_priv</td>
<td align="center">授予用户可以使用特定的名字创建一个数据表的权限</td>
</tr>
<tr>
<td align="left">INDEX</td>
<td align="center">Index_priv</td>
<td align="center">授予用户可以在表上定义索引的权限</td>
</tr>
<tr>
<td align="left">ALL 或 ALL PRIVILEGES 或 SUPER</td>
<td align="center">Super_priv</td>
<td align="center">所有的权限名</td>
</tr>
</tbody></table>
<h2 id="列权限的权限类型"><a href="#列权限的权限类型" class="headerlink" title="列权限的权限类型"></a>列权限的权限类型</h2><p>值只能指定为 SELECT、INSERT 和 UPDATE，同时权限的后面需要加上 列名 列表 column-list</p>
<h2 id="用户权限类型"><a href="#用户权限类型" class="headerlink" title="用户权限类型"></a>用户权限类型</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的用户，并授予 数据有查询、插入权限，并授予 GRANT 权限</span></span><br><span class="line">GRANT SELECT,INSERT SLAVE ON *.*  TO  <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询用户权限</span></span><br><span class="line">SHOW GRANTS FOR <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/13/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%ADsocket%E7%8A%B6%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%ADsocket%E7%8A%B6%E6%80%81/" class="post-title-link" itemprop="url">Linux查看系统中socket状态</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-13 11:03:05" itemprop="dateCreated datePublished" datetime="2021-01-13T11:03:05+00:00">2021-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="IPv4查看"><a href="#IPv4查看" class="headerlink" title="IPv4查看"></a>IPv4查看</h2><p><code>cat /proc/net/sockstat</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockets: used 230</span><br><span class="line">TCP: inuse 30 orphan 0 tw 2 alloc 36 mem 2</span><br><span class="line">UDP: inuse 3 mem 0</span><br><span class="line">UDPLITE: inuse 0</span><br><span class="line">RAW: inuse 0</span><br><span class="line">FRAG: inuse 0 memory 0</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>sockets: used：已使用的所有协议套接字总量</li>
<li>TCP: inuse：正在使用（正在侦听）的TCP套接字数量。其值≤ netstat –lnt | grep ^tcp | wc –l</li>
<li>TCP: orphan：无主（不属于任何进程）的TCP连接数（无用、待销毁的TCP socket数）</li>
<li>TCP: tw：等待关闭的TCP连接数。其值等于netstat –ant | grep TIME_WAIT | wc –l</li>
<li>TCP：alloc(allocated)：已分配（已建立、已申请到sk_buff）的TCP套接字数量。其值等于netstat –ant | grep ^tcp | wc –l</li>
<li>TCP：mem：套接字缓冲区使用量（单位不详。用scp实测，速度在4803.9kB/s时：其值=11，netstat –ant 中相应的22端口的Recv-Q＝0，Send-Q≈400）</li>
<li>UDP：inuse：正在使用的UDP套接字数量</li>
<li>RAW：</li>
<li>FRAG：使用的IP段数量</li>
</ul>
<h2 id="IPv6查看"><a href="#IPv6查看" class="headerlink" title="IPv6查看"></a>IPv6查看</h2><p><code>cat /proc/net/sockstat6</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://syxdevcode.github.com/2021/01/11/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="syxdevcode">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="syxdevcode博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">TCP传输控制协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-11 15:05:11" itemprop="dateCreated datePublished" datetime="2021-01-11T15:05:11+00:00">2021-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-08 01:12:02" itemprop="dateModified" datetime="2021-03-08T01:12:02+00:00">2021-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TCP%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">TCP协议</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP-报文格式简介"><a href="#TCP-报文格式简介" class="headerlink" title="TCP 报文格式简介"></a>TCP 报文格式简介</h2><ul>
<li>TCP 报文由 <code>TCP Header</code> 和 <code>TCP</code> 数据组成。</li>
<li><strong>TCP Header 的最大长度为 60 字节(byte)</strong>，而<strong>必须要有的固定长度</strong>也就是图一的前5层的<strong>20字节(byte)</strong>，每层占有 <code>32bit</code>，也就是 <code>32/8=4</code> 字节，5层，<code>5*4 = 20</code> 字节，那么第六层的可选项和填充也就是<strong>Tcp Options字段最大为60-20=40字节(byte)</strong>。填充是为了使TCP首部为4字节（32bit）的整数倍。</li>
</ul>
<h2 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h2><p><img src="/img/tcp2.png" alt="tcp2.png"></p>
<p><strong>Source Port</strong>：源端口，16位(bit)，2个字节(byte)。<br><strong>Destination Port</strong>：目的端口，16位，2个字节。<br><strong>Sequence Number</strong>：序号，发送数据包中的第一个字节的序列号，32位。<br><strong>Acknowledgment Number</strong>：确认序列号，32位。<br><strong>Data Offset</strong>：数据偏移，4位，该字段的值是TCP首部（包括选项）长度除以4。<br><strong>标志位</strong>：6位，URG 表示 <code>Urgent Pointer</code> 字段有意义：<br><code>ACK</code> 表示 <code>Acknowledgment Number</code> 字段有意义<br><code>PSH</code> 表示 <code>Push</code> 功能，RST 表示复位 TCP 连接<br><code>SYN</code> 表示 <code>SYN</code> 报文（在建立 TCP 连接的时候使用）<br><code>FIN</code> 表示没有数据需要发送了（在关闭 TCP 连接的时候使用）<br><strong>Window</strong>：窗口，表示接收缓冲区的空闲空间，16位，2个字节，用来告诉TCP连接对端自己能够接收的最大数据长度。<br><strong>Checksum</strong>：校验和，16位，2个字节。<br><strong>Urgent Pointers</strong>：紧急指针，16位,2个字节，只有 URG 标志位被设置时该字段才有意义，表示紧急数据相对序列号（Sequence Number字段的值）的偏移。<br><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为 MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。<br><strong>数据</strong>：TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p>
<h2 id="TCP-Options字段"><a href="#TCP-Options字段" class="headerlink" title="TCP Options字段"></a>TCP Options字段</h2><p>Tcp Options 字段的最大长度为40字节。Tcp Options 字段的一般数据结构如图所示：</p>
<ul>
<li>Kind(1字节)</li>
<li>Length(1字节)</li>
<li>Info(n字节)</li>
</ul>
<p>选项的第一个字段 kind 说明选项的类型。有的 TCP 选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段 info（如果有的话）是选项的具体信息。</p>
<p><img src="/img/tcpoptions.png" alt="tcpoptions.png"></p>
<ul>
<li>第一个kind= 2，表示最大报文段长度（Max Segment Size，MSS），TCP 模块通常将 MSS 设置为（MTU-40, MTU[Maximum Transmission Unit，缩写 MTU，中文名是：最大传输单元]）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带 TCP 报文段的IP数据报的长度就不会超过 MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS 值是1460（1500-40）字节。</li>
<li>kind= 4，表示支持 SACK，SACK Block（收到乱序数据）。</li>
<li>kind = 8，代表 Timestamps，即时间戳，启用 Timestamp Option 后，每个 TCP Segment 中都会带有 Timestamp Option，其中包含了两个 32bit 的 Timestamp 也就是各四个字节的 Timestamp Value（TSval）和 Timestamp Echo Reply（TSecr）。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确计算出RTT。</li>
</ul>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p><img src="/img/tcp1.gif" alt="tcp1"></p>
<p>TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出 <code>SYN</code> 连接请求后，等待对方回答 <code>SYN+ACK</code>，并最终对对方的 <code>SYN</code> 执行 <code>ACK</code> 确认。</p>
<p>TCP三次握手的过程如下：</p>
<ul>
<li>客户端发送 <code>SYN（SEQ=x）</code> 报文给服务器端，进入 <code>SYN_SEND</code> 状态。</li>
<li>服务器端收到 <code>SYN</code> 报文，回应一个 <code>SYN （SEQ=y）ACK（ACK=x+1）</code> 报文，进入 <code>SYN_RECV</code> 状态。</li>
<li>客户端收到服务器端的 <code>SYN</code> 报文，回应一个 <code>ACK（ACK=y+1）</code> 报文，进入 <code>Established(已获确认的)</code> 状态。</li>
</ul>
<p>三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。</p>
<h3 id="连接终止"><a href="#连接终止" class="headerlink" title="连接终止"></a>连接终止</h3><p><img src="/img/tcp3.gif" alt="tcp3.gif"></p>
<p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的 <code>半关闭</code>（<code>half-close</code>）造成的。</p>
<ul>
<li>（1）某个应用进程首先调用 <code>close</code>，称该端执行 <code>主动关闭（active close）</code>。该端的TCP于是发送一个 <code>FIN</code> 分节，表示数据发送完毕。</li>
<li>（2） 接收到这个 <code>FIN</code> 的对端执行 <code>被动关闭（passive close）</code>，这个 <code>FIN</code> 由TCP确认。</li>
</ul>
<p>注意：<code>FIN</code> 的接收也作为一个文件结束符（<code>end-of-file</code>）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，<code>FIN</code> 的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</p>
<ul>
<li>（3） 一段时间后，接收到这个文件结束符的应用进程将调用 <code>close</code> 关闭它的套接字。这导致它的 <code>TCP</code> 也发送一个 <code>FIN</code>。</li>
<li>（4） 接收这个最终 <code>FIN</code> 的原发送端TCP（即执行主动关闭的那一端）确认这个 <code>FIN</code>。</li>
</ul>
<p>既然每个方向都需要一个<code>FIN</code>和一个 <code>ACK</code> ，因此通常需要4个分节。</p>
<p>注意：<br>（1） <code>通常</code> 是指，某些情况下，步骤1的 <code>FIN</code> 随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。<br>（2） 在 步骤2 与 步骤3 之间，从执行 被动关闭一端 到 执行主动关闭一端 流动数据是可能的，这称为 <code>半关闭</code>（half-close）。<br>（3） 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个<code>FIN</code>。<br>无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。</p>
<h2 id="TCP重连"><a href="#TCP重连" class="headerlink" title="TCP重连"></a>TCP重连</h2><p><img src="/img/tcp%E9%87%8D%E8%BF%9E.png" alt="tcp重连.png"></p>
<p>四元组：源IP地址、目的IP地址、源端口、目的端口<br>五元组：源IP地址、目的IP地址、协议号、源端口、目的端口<br>七元组：源IP地址、目的IP地址、协议号、源端口、目的端口、服务类型、接口索引</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Hollake/article/details/89327474">Tcp报文简介以及头部选项字段(Tcp Options字段)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/blakegao/article/details/19419237">常用的TCP Option</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mary19920410/article/details/77255967">浅析TCP中时间戳选项timestamp</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">syxdevcode</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">355</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/syxdevcode" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;syxdevcode" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">syxdevcode</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
