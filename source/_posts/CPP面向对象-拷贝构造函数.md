---
title: CPP面向对象-拷贝构造函数
date: 2021-07-01 14:21:30
tags:
- CPP
- CPP面向对象
- VSCode
- MingGW64
categories: CPP
---

拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。

**原则：**

拷贝构造函数是一种特殊的构造函数，具有单个形参，该形参（常用`const`修饰）是对该类类型的引用。
当定义一个新对象并用一个同类型的对象对它进行初始化时，将显示使用拷贝构造函数。
当该类型的对象传递给函数或从函数返回该类型的对象时，将隐式调用拷贝构造函数。

**C++支持两种初始化形式：**

拷贝初始化 `int a = 5;` 和直接初始化 `int a(5);` 对于其他类型没有什么区别，对于类类型直接初始化直接调用实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数，也就是说：

```cpp
A x(2);　　//直接初始化，调用构造函数
A y = x;　　//拷贝初始化，调用拷贝构造函数
```

**必须定义拷贝构造函数的情况：**

只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝；
有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源，这两种情况下都必须定义拷贝构造函数。

**什么情况使用拷贝构造函数：**

类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：

* （1）一个对象以值传递的方式传入函数体
* （2）一个对象以值传递的方式从函数返回
* （3）一个对象需要通过另外一个对象进行初始化。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。
<!--more-->
**为什么当类成员中含有指针类型成员且需要对其分配内存时，一定要有总定义拷贝构造函数？？**

默认的拷贝构造函数实现的只能是浅拷贝，即直接将原对象的数据成员值依次复制给新对象中对应的数据成员，并没有为新对象另外分配内存资源。

这样，如果对象的数据成员是指针，两个指针对象实际上指向的是同一块内存空间。

在某些情况下，浅拷贝回带来数据安全方面的隐患。

当类的数据成员中有指针类型时，我们就必须定义一个特定的拷贝构造函数，该拷贝构造函数不仅可以实现原对象和新对象之间数据成员的拷贝，而且可以为新的对象分配单独的内存资源，这就是深拷贝构造函数。

**如何防止默认拷贝发生**

声明一个私有的拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类的对象，编译器会报告错误，从而可以避免按值传递或返回对象。

**总结：**

当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。
当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以，这时，必须采用深拷贝。

深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

拷贝构造函数的最常见形式如下：

```cpp
classname (const classname &obj) {
   // 构造函数的主体
}
```

`obj` 是一个对象引用，该对象是用于初始化另一个对象的。

实例：

```cpp
#include <iostream>

using namespace std;

class Line
{
public:
    int getLength(void);
    Line(int len);         // 简单的构造函数
    Line(const Line &obj); // 拷贝构造函数
    ~Line();               // 析构函数

private:
    int *ptr;
};

// 成员函数定义，包括构造函数
Line::Line(int len)
{
    cout << "调用构造函数" << endl;
    // 为指针分配内存
    ptr = new int;
    *ptr = len;
}

Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    ptr = new int;
    *ptr = *obj.ptr; // 拷贝值
}

Line::~Line(void)
{
    cout << "释放内存" << endl;
    delete ptr;
}
int Line::getLength(void)
{
    return *ptr;
}

void display(Line obj)
{
    cout << "line 大小 : " << obj.getLength() << endl;
}

// 程序的主函数
int main()
{
    Line line(10);

    /*
    (1).display对象传入形参时，会先会产生一个临时变量，暂定为 C 。
    (2).然后调用拷贝构造函数把line的值给C。 整个这两个步骤有点像：Line C(line);
    (3).等display()执行完后, 析构掉 C 对象。
    */
    display(line);

    return 0;
}
```

结果：

```cpp
调用构造函数
调用拷贝构造函数并为指针 ptr 分配内存
line 大小 : 10
释放内存
释放内存
```

[C++ 拷贝构造函数](https://www.runoob.com/cplusplus/cpp-copy-constructor.html)