---
title: DotNet面试题解析07-GC与内存管理
date: 2018-12-20 11:28:04
tags:
- DotNet
- CSharp
- CSharp基础
- DotNet面试题解析
categories: 
- DotNet面试题解析
---
## 面试题解析

### 1. 简述一下一个引用对象的生命周期？

* new创建对象并分配内存
* 对象初始化
* 对象操作、使用
* 资源清理（非托管资源）
* GC垃圾回收

### 2. 创建下面对象实例，需要申请多少内存空间？

```csharp
public class User
{
    public int Age { get; set; }
    public string Name { get; set; }

    public string _Name = "123" + "abc";
    public List<string> _Names;
}
```

40字节内存空间。

### 3. 什么是垃圾？

一个变量如果在其生存期内的某一时刻已经不再被引用，那么，这个对象就有可能成为垃圾

### 4. GC是什么，简述一下GC的工作方式？

GC是** 垃圾回收（Garbage Collect）**的缩写，是.NET核心机制的重要部分。她的基本工作原理就是遍历托管堆中的对象，标记哪些被使用对象（哪些没人使用的就是所谓的垃圾），然后把可达对象转移到一个连续的地址空间（也叫压缩），其余的所有没用的对象内存被回收掉。

### 5. GC进行垃圾回收时的主要流程是？

** (1)标记：**先假设所有对象都是垃圾，根据应用程序根Root遍历堆上的每一个引用对象，生成可达对象图，对于还在使用的对象（可达对象）进行标记（其实就是在对象同步索引块中开启一个标示位）。

** (2)清除**：针对所有不可达对象进行清除操作，针对普通对象直接回收内存，而对于实现了终结器的对象（实现了析构函数的对象）需要单独回收处理。清除之后，内存就会变得不连续了，就是步骤3的工作了。

** (3)压缩**：把剩下的对象转移到一个连续的内存，因为这些对象地址变了，还需要把那些Root跟指针的地址修改为移动后的新地址。

### 6. GC在哪些情况下回进行回收工作？

* 内存不足溢出时（0代对象充满时）
* Windwos报告内存不足时，CLR会强制执行垃圾回收
* CLR卸载AppDomian，GC回收所有
* 调用GC.Collect
* 其他情况，如主机拒绝分配内存，物理内存不足，超出短期存活代的存段门限

### 7. using() 语法是如何确保对象资源被释放的？如果内部出现异常依然会释放资源吗？

using() 只是一种语法形式，其本质还是try…finally的结构，可以保证Dispose始终会被执行。

### 8. 解释一下C#里的析构函数？为什么有些编程建议里不推荐使用析构函数呢？

C#里的析构函数其实就是终结器Finalize，因为长得像C++里的析构函数而已。

有些编程建议里不推荐使用析构函数要原因在于：第一是Finalize本身性能并不好；其次很多人搞不清楚Finalize的原理，可能会滥用，导致内存泄露，因此就干脆别用了

### 9. Finalize() 和 Dispose() 之间的区别？

Finalize() 和 Dispose()都是.NET中提供释放非托管资源的方式，他们的主要区别在于执行者和执行时间不同：

* finalize由垃圾回收器调用；dispose由对象调用。
* finalize无需担心因为没有调用finalize而使非托管资源得不到释放，而dispose必须手动调用。
* finalize不能保证立即释放非托管资源，Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间；而dispose一调用便释放非托管资源。
* 只有class类型才能重写finalize，而结构不能；类和结构都能实现IDispose。

另外一个重点区别就是终结器会导致对象复活一次，也就说会被GC回收两次才最终完成回收工作，这也是有些人不建议开发人员使用终结器的主要原因。

### 10. Dispose和Finalize方法在何时被调用？

* Dispose一调用便释放非托管资源；
* Finalize不能保证立即释放非托管资源，Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间；

### 11. .NET中的托管堆中是否可能出现内存泄露的现象？

是的，可能会。比如：

* 不正确的使用静态字段，导致大量数据无法被GC释放；
* 没有正确执行Dispose()，非托管资源没有得到释放；
* 不正确的使用终结器Finalize()，导致无法正常释放资源；
* 其他不正确的引用，导致大量托管对象无法被GC释放；

### 12. 在托管堆上创建新对象有哪几种常见方式？

* new一个对象；
* 字符串赋值，如string s1=”abc”；
* 值类型装箱；

参考：

[.NET面试题解析(06)-GC与内存管理](http://www.cnblogs.com/anding/p/5260319.html)