---
title: 缓存在分布式系统中的应用
date: 2018-06-12 09:10:31
tags:
- 分布式
- 缓存
categories: 
- 缓存
---
# 缓存在分布式系统中的应用

## 一、缓存概述

缓存是分布式系统中的重要组件，主要解决高并发，大数据场景下，热点数据访问的性能问题。提供高性能的数据快速访问。

### 1.1缓存的原理

（1）将数据写入/读取速度更快的存储（设备）

（2）将数据缓存到离应用最近的位置；

（3）将数据缓存到离用户最近的位置。

### 1.2缓存分类

（1）CDN缓存；

（2）反向代理缓存；

（3）分布式Cache；

（4）本地应用缓存；

### 1.3缓存媒介

常用中间件：Redis，Memcache，Ngnix，Varnish，Squid，Ehcache等；

缓存的内容：文件，数据，对象；

缓存的介质：CPU，内存（本地，分布式），磁盘（本地，分布式）

### 1.4缓存设计

缓存设计需要解决以下几个问题：

（1）缓存什么？

哪些数据需要缓存：1.热点数据；2.静态资源；

（2）缓存的位置？

CDN，反向代理，分布式缓存服务器，本机（内存，硬盘）

（3）如何缓存的问题？

过期策略

1.固定时间：比如指定缓存的时间是30分钟；
2.相对时间：比如最近10分钟内没有访问的数据；

同步机制

实时写入；（推）
异步刷新；（推拉）

## 二、CDN缓存

CDN主要解决将数据缓存到离用户最近的位置，一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署CDN应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

### 2.1 CND原理

CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。

（1）未部署CDN应用前

网络请求路径：

请求：本机网络（局域网）——》运营商网络——》应用服务器机房

响应：应用服务器机房——》运营商网络——》本机网络（局域网）

在不考虑复杂网络的情况下，从请求到响应需要经过3个节点，6个步骤完成一次用户访问操作。

（2）部署CDN应用后

网络路径：

请求：本机网络（局域网）——》运营商网络

响应：运营商网络——》本机网络（局域网）

在不考虑复杂网络的情况下，从请求到响应需要经过2个节点，2个步骤完成一次用户访问操作。

与不部署CDN服务相比，减少了1个节点，4个步骤的访问。极大的提高的系统的响应速度。

### 2.2 CDN优缺点

（1）优点（摘自百度百科）

1、本地Cache加速：提升访问速度，尤其含有大量图片和静态页面站点；

2、镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；

3、远程加速：远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度；

4、带宽优化：自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。

5、集群抗攻击：广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量。

（2）缺点

1.动态资源缓存，需要注意实时性；

解决：主要缓存静态资源，动态资源建立多级缓存或准实时同步；

2.如何保证数据的一致性和实时性需要权衡考虑；

解决：

1.设置缓存失效时间（1个小时，最终一致性）；
2.数据版本号；

## 三、反向代理缓存

反向代理是指在网站服务器机房部署代理服务器，实现负载均衡，数据缓存，安全控制等功能。

### 3.1缓存原理

反向代理位于应用服务器机房，处理所有对WEB服务器的请求。如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向WEB服务器的请求数，从而降低了WEB服务器的负载。

反向代理一般缓存静态资源，动态资源转发到应用服务器处理。常用的缓存应用服务器有Varnish，Ngnix，Squid。

### 3.2 代理缓存比较

常用的代理缓存有Varnish，Squid，Ngnix，简单比较如下：

（1）varnish和squid是专业的cache服务，nginx需要第三方模块支持；

（2）Varnish采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比Squid高；

（3）Varnish由于是内存cache，所以对小文件如css,js,小图片啥的支持很棒，后端的持久化缓存可以采用的是Squid或ATS；

（4）Squid功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个HAProxy或nginx做负载均衡跑多个实例；

（5）Nginx采用第三方模块ncache做的缓冲，性能基本达到varnish，一般作为反向代理使用，可以实现简单的缓存。

## 四、分布式缓存

CDN,反向代理缓存，主要解决静态文件，或用户请求资源的缓存，数据源一般为静态文件或动态生成的文件（有缓存头标识）。

分布式缓存，主要指缓存用户经常访问数据的缓存，数据源为数据库。一般起到热点数据访问和减轻数据库压力的作用。

目前分布式缓存设计，在大型网站架构中是必备的架构要素。常用的中间件有Memcache，Redis。

### Memcache

（1）使用物理内存作为缓存区，可独立运行在服务器上。每个进程最大2G，如果想缓存更多的数据，可以开辟更多的memcache进程（不同端口）或者使用分布式memcache进行缓存，将数据缓存到不同的物理机或者虚拟机上。

（2）使用key-value的方式来存储数据，这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为O(1)。

（3）协议简单：基于文本行的协议，直接通过telnet在memcached服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；

（4）基于libevent高性能通信：Libevent是一套利用C开发的程序库，它将BSD系统的kqueue,Linux系统的epoll等事件处理功能封装成一个接口，与传统的select相比，提高了性能。

（5）内置的内存管理方式：所有数据都保存在内存中，存取数据比硬盘快，当内存满后，通过LRU算法自动删除不使用的缓存，但没有考虑数据的容灾问题，重启服务，所有数据会丢失。

（6）分布式：各个memcached服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于memcache客户端。

（7）缓存策略：Memcached的缓存策略是LRU（最近最少使用）到期失效策略。在memcached内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当memcached服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在LRU中，memcached使用的是一种Lazy Expiration策略，自己不会监控存入的key/vlue对是否过期，而是在获取key值时查看记录的时间戳，检查key/value对空间是否过期，这样可减轻服务器的负载。

### Redis

Redis 是一个开源（BSD许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。 支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。

内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。

### Memcache与Redis的比较

（1）数据结构：Memcache只支持key value存储方式，Redis支持更多的数据类型，比如Key value，hash，list，set，zset；

（2）多线程：Memcache支持多线程，redis支持单线程；CPU利用方面Memcache优于redis；

（3）持久化：Memcache不支持持久化，Redis支持持久化；

（4）内存利用率：memcache高，redis低（采用压缩的情况下比memcache高）；

（5）过期策略：memcache过期后，不删除缓存，会导致下次取数据数据的问题，Redis有专门线程，清除缓存数据；

## 缓存穿透

缓存穿透是说收到了一个请求，但是该请求缓存里没有，只能去数据库里查询，然后放进缓存。这里面有两个风险，一个是同时有好多请求访问同一个数据，然后业务系统把这些请求全发到了数据库；第二个是有人恶意构造一个逻辑上不存在的数据，然后大量发送这个请求，这样每次请求都会被发送到数据库，可能导致数据挂掉。

怎么应对这种情况呢？对于恶意访问，一个思路是事先做校验，对恶意数据直接过滤掉，不要发到数据库层；第二个思路是缓存空结果，就是对查询不存在的数据仍然记录一条该数据不存在在缓存里，这样能有效的减少查询数据库的次数。

## 缓存击穿

缓存一般是Key，value方式存在，当某一个Key不存在时会查询数据库，假如这个Key，一直不存在，则会频繁的请求数据库，对数据库造成访问压力。

解决方法：

（1）对结果为空的数据也进行缓存，当此key有数据后，清理缓存；

（2）一定不存在的key，采用布隆过滤器，建立一个大的Bitmap中，查询时通过该bitmap过滤；

一个思路是全局锁，就是所有访问某个数据的请求都共享一个锁，获得锁的那个才有资格去访问数据库，其他线程必须等待。但是现在的业务都是分布式的，本地锁没法控制其他服务器也等待，所以要用到全局锁，比如用redis的setnx实现全局锁。

另一个思路是对即将过期的数据主动刷新，做法可以有很多，比如起一个线程轮询数据，比如把所有数据划分为不同的缓存区间，定期分区间刷新数据等等。

## 四、缓存雪崩

雪崩是指当大量缓存失效时，导致大量的请求访问数据库，导致数据库服务器，无法抗住请求或挂掉的情况。

解决方法：

（1）合理规划缓存的失效时间；

（2）合理评估数据库的负载压力；

（3）对数据库进行过载保护或应用层限流；

（4）多级缓存设计，缓存高可用；

参考：

[大型网站架构系列：缓存在分布式系统中的应用（一）](http://www.cnblogs.com/itfly8/p/5562610.html)

[大型网站架构系列：缓存在分布式系统中的应用（二）](http://www.cnblogs.com/itfly8/p/5562615.html)

[大型网站架构系列：缓存在分布式系统中的应用（三）](http://www.cnblogs.com/itfly8/p/5597639.html)

[高并发请求的缓存设计策略](https://www.cnblogs.com/bethunebtj/p/9159914.html)