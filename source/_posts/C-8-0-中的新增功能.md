---
title: C# 8.0 中的新增功能
date: 2020-10-16 14:30:28
tags:
- DotNet
- CSharp
- CSharp新增功能
- CSharp基础
categories: 
- CSharp新增功能
---

“.NET Core 3.x”和“.NET Standard 2.1”支持 C# 8.0 。有关详细信息，请参阅[C# 语言版本控制](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/configure-language-version)

## Readonly 成员

可将 readonly 修饰符应用于结构的成员。 它指示该成员不会修改状态。 这比将 readonly 修饰符应用于 struct 声明更精细。

```c#
public struct Point
{
    public double X { get; set; }
    public double Y { get; set; }
    public readonly  double Distance => Math.Sqrt(X * X + Y * Y);

    public readonly override string ToString() =>
        $"({X}, {Y}) is {Distance} from the origin";
}
```

readonly 修饰符对于只读属性是必需的。 编译器会假设 get 访问器可以修改状态；必须显式声明 readonly。 自动实现的属性是一个例外；编译器会将所有自动实现的 Getter 视为 readonly，因此，此处无需向 X 和 Y 属性添加 readonly 修饰符。

## 默认接口方法

现在可以将成员添加到接口，并为这些成员提供实现。 借助此语言功能，API 作者可以将方法添加到以后版本的接口中，而不会破坏与该接口当前实现的源或二进制文件兼容性。 现有的实现继承默认实现。

参考：

[https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/starter/customer-relationship](https://github.com/dotnet/samples/tree/master/csharp/tutorials/default-interface-members-versions/starter/customer-relationship)

[教程：在 C# 8.0 中使用默认接口方法更新接口](https://docs.microsoft.com/zh-cn/dotnet/csharp/tutorials/default-interface-methods-versions

## switch 表达式

```c#
public static RGBColor FromRainbow(Rainbow colorBand) =>
    colorBand switch
    {
        Rainbow.Red    => new RGBColor(0xFF, 0x00, 0x00),
        Rainbow.Orange => new RGBColor(0xFF, 0x7F, 0x00),
        Rainbow.Yellow => new RGBColor(0xFF, 0xFF, 0x00),
        Rainbow.Green  => new RGBColor(0x00, 0xFF, 0x00),
        Rainbow.Blue   => new RGBColor(0x00, 0x00, 0xFF),
        Rainbow.Indigo => new RGBColor(0x4B, 0x00, 0x82),
        Rainbow.Violet => new RGBColor(0x94, 0x00, 0xD3),
        _              => throw new ArgumentException(message: "invalid enum value", paramName: nameof(colorBand)),
    };
```

* 变量位于 switch 关键字之前。 不同的顺序使得在视觉上可以很轻松地区分 switch 表达式和 switch 语句。
* 将 case 和 : 元素替换为 =>。 它更简洁，更直观。
* 将 default 事例替换为 _ 弃元。
* 正文是表达式，不是语句。

## 属性模式

```c#
public static decimal ComputeSalesTax(Address location, decimal salePrice) =>
    location switch
    {
        { State: "WA" } => salePrice * 0.06M,
        { State: "MN" } => salePrice * 0.075M,
        { State: "MI" } => salePrice * 0.05M,
        // other cases removed for brevity...
        _ => 0M
    };
```

## 元组模式

```c#
public static string RockPaperScissors(string first, string second)
    => (first, second) switch
    {
        ("rock", "paper") => "rock is covered by paper. Paper wins.",
        ("rock", "scissors") => "rock breaks scissors. Rock wins.",
        ("paper", "rock") => "paper covers rock. Paper wins.",
        ("paper", "scissors") => "paper is cut by scissors. Scissors wins.",
        ("scissors", "rock") => "scissors is broken by rock. Rock wins.",
        ("scissors", "paper") => "scissors cuts paper. Scissors wins.",
        (_, _) => "tie"
    };
```

## 位置模式

```C#
public class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) => (X, Y) = (x, y);

    public void Deconstruct(out int x, out int y) =>
        (x, y) = (X, Y);
}

public enum Quadrant
{
    Unknown,
    Origin,
    One,
    Two,
    Three,
    Four,
    OnBorder
}

static Quadrant GetQuadrant(Point point) => point switch
{
    (0, 0) => Quadrant.Origin,
    var (x, y) when x > 0 && y > 0 => Quadrant.One,
    var (x, y) when x < 0 && y > 0 => Quadrant.Two,
    var (x, y) when x < 0 && y < 0 => Quadrant.Three,
    var (x, y) when x > 0 && y < 0 => Quadrant.Four,
    var (_, _) => Quadrant.OnBorder,
    _ => Quadrant.Unknown
};
```

## using 声明

using 声明是前面带 using 关键字的变量声明。它指示编译器声明的变量应在封闭范围的末尾进行处理。

```c#
static int WriteLinesToFile(IEnumerable<string> lines)
{
    // 当到达方法的右括号时，将对该文件进行处理。
    using var file = new System.IO.StreamWriter("WriteLines2.txt");
    // Notice how we declare skippedLines after the using statement.
    int skippedLines = 0;
    foreach (string line in lines)
    {
        if (!line.Contains("Second"))
        {
            file.WriteLine(line);
        }
        else
        {
            skippedLines++;
        }
    }
    // Notice how skippedLines is in scope here.
    return skippedLines;
    // file is disposed here
}
```

## 静态本地函数

```c#
int M()
{
    int y = 5;
    int x = 7;
    return Add(x, y);

    static int Add(int left, int right) => left + right;
}
```

## 可处置的 ref 结构

用 ref 修饰符声明的 struct 可能无法实现任何接口，因此无法实现 IDisposable。 因此，要能够处理 ref struct，它必须有一个可访问的 void Dispose() 方法。 此功能同样适用于 readonly ref struct 声明。

## 可为空引用类型


## 异步流

从 C# 8.0 开始，可以创建并以异步方式使用流。 返回异步流的方法有三个属性：

* 它是用 async 修饰符声明的。
* 它将返回 IAsyncEnumerable<T>。
* 该方法包含用于在异步流中返回连续元素的 yield return 语句。

使用异步流需要在枚举流元素时在 foreach 关键字前面添加 await 关键字。 添加 await 关键字需要枚举异步流的方法，以使用 async 修饰符进行声明并返回 async 方法允许的类型。 通常这意味着返回 Task 或 Task<TResult>。 也可以为 ValueTask 或 ValueTask<TResult>。 方法既可以使用异步流，也可以生成异步流，这意味着它将返回 IAsyncEnumerable<T>。

```c#
await foreach (var number in GenerateSequence())
{
    Console.WriteLine(number);
}
```

## 异步可释放

从 C# 8.0 开始，语言支持实现 System.IAsyncDisposable 接口的异步可释放类型。 可使用 await using 语句来处理异步可释放对象。

## 索引和范围

索引和范围为访问序列中的单个元素或范围提供了简洁的语法。

此语言支持依赖于两个新类型和两个新运算符：

* System.Index 表示一个序列索引。
* 来自末尾运算符 ^ 的索引，指定一个索引与序列末尾相关。
* System.Range 表示序列的子范围。
* 范围运算符 ..，用于指定范围的开始和末尾，就像操作数一样。

0 索引与 sequence[0] 相同。 ^0 索引与 sequence[sequence.Length] 相同。 请注意，sequence[^0] 不会引发异常，就像 sequence[sequence.Length] 一样。 对于任何数字 n，索引 ^n 与 sequence.Length - n 相同。

范围指定范围的开始和末尾 。 包括此范围的开始，但不包括此范围的末尾，这表示此范围包含开始但不包含末尾 。 范围 [0..^0] 表示整个范围，就像 [0..sequence.Length] 表示整个范围。

```c#
var words = new string[]
{
                // index from start    index from end
    "The",      // 0                   ^9
    "quick",    // 1                   ^8
    "brown",    // 2                   ^7
    "fox",      // 3                   ^6
    "jumped",   // 4                   ^5
    "over",     // 5                   ^4
    "the",      // 6                   ^3
    "lazy",     // 7                   ^2
    "dog"       // 8                   ^1
};              // 9 (or words.Length) ^0

// 使用 ^1 索引检索最后一个词
Console.WriteLine($"The last word is {words[^1]}");
// writes "dog"

// 包括 words[1] 到 words[3]
var quickBrownFox = words[1..4];

// 包括 words[^2] 和 words[^1]
var lazyDog = words[^2..^0];

var allWords = words[..]; // contains "The" through "dog".
var firstPhrase = words[..4]; // contains "The" through "fox"
var lastPhrase = words[6..]; // contains "the", "lazy" and "dog"

Range phrase = 1..4;
var text = words[phrase];
```

## Null 合并赋值

C# 8.0 引入了 null 合并赋值运算符 ??=。 仅当左操作数计算为 null 时，才能使用运算符 ??= 将其右操作数的值分配给左操作数。

```C#
List<int> numbers = null;
int? i = null;

numbers ??= new List<int>();
numbers.Add(i ??= 17);
numbers.Add(i ??= 20);

Console.WriteLine(string.Join(" ", numbers));  // output: 17 17
Console.WriteLine(i);  // output: 17
```

## 非托管构造类型

在 C# 7.3 及更低版本中，构造类型（包含至少一个类型参数的类型）不能为非托管类型。 从 C# 8.0 开始，如果构造的值类型仅包含非托管类型的字段，则该类型不受管理。

```c#
public struct Coords<T>
{
    public T X;
    public T Y;
}
```

Coords<int> 类型为 C# 8.0 及更高版本中的非托管类型。 与任何非托管类型一样，可以创建指向此类型的变量的指针，或针对此类型的实例在堆栈上分配内存块：

```C#
Span<Coords<int>> coordinates = stackalloc[]
{
    new Coords<int> { X = 0, Y = 0 },
    new Coords<int> { X = 0, Y = 3 },
    new Coords<int> { X = 4, Y = 0 }
};
```

## 嵌套表达式中的 stackalloc

stackalloc 表达式在堆栈上分配内存块。该方法返回时，将自动丢弃在方法执行期间创建的堆栈中分配的内存块。 不能显式释放使用 stackalloc 分配的内存。 堆栈中分配的内存块不受垃圾回收的影响，也不必通过 fixed 语句固定。

```c#
Span<int> numbers = stackalloc[] { 1, 2, 3, 4, 5, 6 };
var ind = numbers.IndexOfAny(stackalloc[] { 2, 4, 6, 8 });
Console.WriteLine(ind);  // output: 1
```

[stackalloc 表达式（C# 参考）](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/stackalloc)

## 内插逐字字符串的增强功能

内插逐字字符串中 $ 和 @ 标记的顺序可以任意安排：$@"..." 和 @$"..." 均为有效的内插逐字字符串。 在早期 C# 版本中，$ 标记必须出现在 @ 标记之前。

参考：

[C# 8.0 中的新增功能](https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-8)