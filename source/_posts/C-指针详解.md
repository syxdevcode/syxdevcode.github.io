---
title: C-指针详解
date: 2021-05-28 15:32:02
tags:
- C语言
- VSCode
- MingGW64
categories: C语言
---

## 一，常见指针

`&` 是取地址运算符，`*` 是间接运算符。

### 1，int p;

整型变量，32位CPU的话，占有32个bite。

### 2，int *p;

整型指针变量，用于存放一个整型变量的地址。

解析：

从 p 处开始，先与 `*` 结合，所以说明 p 是一个指针, 然后再与 `int` 结合, 说明指针所指向的内容的类型为 `int` 型。

### 3，int p[3];

整型数据组成的数组。

解析：

首先从 p 处开始，先与 `[]` 结合，说明 p 是一个数组, 然后与 `int` 结合, 说明数组里的元素是整型的, 所以 p 是一个由整型数据组成的数组。

<!--more-->
### 4，int *p[3];

这是一个数组，该数组里面的成员是整型的指针，分别指向 `int` 型的内存。

解析：

首先从 p 处开始, 先与 `[]` 结合，因为其优先级比 `*` 高，所以 p 是一个数组, 然后再与 `*` 结合, 说明数组里的元素是指针类型, 然后再与 `int` 结合, 说明指针所指向的内容的类型是整型。

![微信截图_20210528161733.png](/img/微信截图_20210528161733.png)

### 5，int (*p)[3];

这是一个指针，指向一个 `int` 型数组，地址类型是`int [3]`型。

解析：

首先从 p 处开始, 先与 `*` 结合,说明 p 是一个指针然后，再与 `[]` 结合(与 `()` 这步可以忽略,只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与 `int` 结合, 说明数组里的元素是整型的。

![微信截图_20210528162431.png](/img/微信截图_20210528162431.png)

### 6，int **p;

这是一个整型指针变量，用于存放一个整型变量的地址，

解析：

首先从 p 开始, 先与 `*` 结合, 说是 p 是一个指针, 然后再与 `*` 结合, 说明指针所指向的元素是指针, 然后再与 `int` 结合, 说明该指针所指向的元素是整型数据。

### 7，int p(int);

这是一个函数，函数的返回值是一个整型数据。

解析：

从 p 处起,先与 `()` 结合, 说明 p 是一个函数, 然后进入 `()` 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 `int` 结合, 说明函数的返回值是一个整型数据。

### 8，void *p(int);

这是一个函数，函数的参数是 `int`，返回值是 `void *`。

### 9，int (*p)(int);

这是一个指针，指向一个函数，该函数形参是 `int`，返回值是 `int`。

解析：

从 p 处开始, 先与指针结合, 说明 p 是一个指针, 然后与 `()` 结合, 说明指针指向的是一个函数, 然后再与 `()` 里的 `int` 结合, 说明函数有一个 `int` 型的参数, 再与最外层的 `int` 结合, 说明函数的返回类型是整型。

### 10，int (*p[3])(int);

解析：

* p 先和`[3]`结合，说明 p 是一个数组；
* `p[3]` 外面 `*` 结合，所以数组元素是一个指针；
* 假定 `（*p[3]）` 是 `X`,外面是 `int （X）（int）`，所以指针是指向函数，函数的形参是 `int` 型，返回值是 `int` 型。

![微信截图_20210528165552.png](/img/微信截图_20210528165552.png)

### 11，`int *(*p(int))[3]`;

解析：

从 p 开始，先与 `()` 结合, 说明 p 是一个函数, 然后进入 `()` 里面，与 `int` 结合, 说明函数有一个整型变量参数, 然后再与外面的 `*` 结合, 说明函数返回的是一个指针, 然后到最外面一层, 先与 `[]` 结合, 说明返回的指针指向的是一个数组, 然后再与 `*` 结合, 说明数组里的元素是指针, 然后再与 `int` 结合, 说明指针指向的内容是整型数据。

所以 p 是一个参数为一个整数，且返回一个指向由整型指针变量组成的数组的指针变量的函数。

## 二，指针详解

指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。

要搞清一个指针需要搞清指针的四方面的内容：指针的类型、指针所指向的类型、指针的值或者叫指针所指向的内存区、指针本身所占据的内存区。

实例：

```c
int *ptr;
char *ptr;
int **ptr;
int (*ptr)[3];
int *(*ptr)[4];
```

### 1，指针的类型

<font color=#ff0000 size=4 face="黑体">从语法上看，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。</font>这是指针本身所具有的类型。

* 1、`int *ptr;` : 指针的类型是 `int*`
* 2、`char *ptr; `: 指针的类型是 `char*`
* 3、`int **ptr;` : 指针的类型是 `int**`
* 4、`int (*ptr)[3]; `: 指针的类型是 `int(*)[3]`
* 5、`int *(*ptr)[4];` : 指针的类型是 `int*(*)[4]`

### 2，指针所指向的类型

通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

<font color=#ff0000 size=4 face="黑体">从语法上看，只须把指针声明语句中的 指针名字和名字左边的指针声明符 `*` 去掉，剩下的就是指针所指向的类型。</font>

* 1、`int*ptr;` : 指针所指向的类型是 `int`
* 2、`char*ptr;` : 指针所指向的的类型是 `char`
* 3、`int**ptr;` : 指针所指向的的类型是 `int*`
* 4、`int(*ptr)[3];` : 指针所指向的的类型是 `int()[3]`
* 5、`int*(*ptr)[4];` : 指针所指向的的类型是 `int*()[4]`

在指针的算术运算中，指针所指向的类型有很大的作用。

指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。

### 3，指针的值----或者叫指针所指向的内存区或地址

指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为32 位程序里内存地址全都是32位的长度。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 `sizeof(指针所指向的类型)` 的一片内存区。

一个指针的值是 `XX`，就相当于说该指针指向了以 `XX` 为首地址的一片内存区域；一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。

指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？（重点注意）

### 4，指针本身所占据的内存区

指针本身占了多大的内存？只要用函数 `sizeof(指针的类型)` 测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。

## 三，指针的算术运算

指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：

**实例1：**

```c
char a[20];
int *ptr=(int *)a; //强制类型转换并不会改变 a 的类型
ptr++;
```

解析：指针 `ptr` 的类型是 `int*`，它指向的类型是 `int`，它被初始化为指向整型变量 `a`。
接下来的第 3 句中，指针 `ptr` 被加了 1，编译器是这样处理的：它把指针 `ptr` 的值加上了 `sizeof(int)`，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。
由于地址是用字节做单位的，故 `ptr` 所指向的地址由原来的变量 `a` 的地址向高地址方向增加了 4 个字节。
由于 `char` 类型的长度是一个字节，所以，原来 `ptr` 是指向数组 `a` 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。

**实例2：**

将整型数组中各个单元的值加 1。由于每次循环都将指针 ptr 加 1 个单元，所以每次循环都能访问数组的下一个单元。

```c
#include <stdio.h>

int main()
{
    int array[20] = {0};
    int *ptr = array;
    for (int i = 0; i < 20; i++)
    {
        int p = (*ptr)++;
        printf("p: %d\n", (*ptr));
        ptr++;
    }

    return 0;
}
```

**实例2：**

```c
char a[20]="You_are_a_girl";
int *ptr=(int *)a;
ptr+=5;
```

`ptr` 被加上了 5，编译器是这样处理的：将指针 `ptr` 的值加上 5 乘 `sizeof(int)`，在 32 位程序中就是加上了 5 乘 `4=20`。由于地址的单位是字节，故现在的 `ptr` 所指向的地址比起加 5 后的 `ptr` 所指向的地址来说，向高地址方向移动了 `20` 个字节。

没加 5 前的 `ptr` 指向数组 a 的第 0 号单元开始的四个字节，加 5 后，`ptr` 已经指向了数组 a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。

如果 `ptr` 是被减去 5，那么处理过程大同小异，只不过 `ptr` 的值是被减去 5 乘 `sizeof(int)`，新的 `ptr` 指向的地址将比原来的 `ptr` 所指向的地址向低地址方向移动了 20 个字节。


### 总结

一个指针 `ptrold` 加(减)一个整数 `n` 后，结果是一个新的指针 `ptrnew`，`ptrnew` 的类型和 `ptrold` 的类型相同，`ptrnew` 所指向的类型和 `ptrold` 所指向的类型也相同。`ptrnew` 的值将比 `ptrold` 的值增加(减少)了 `n` 乘 `sizeof(ptrold 所指向的类型)` 个字节。就是说，`ptrnew` 所指向的内存区将比 `ptrold` 所指向的内存区向高(低)地址方向移动了 `n` 乘 `sizeof(ptrold所指向的类型)` 个字节。

指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组。

## 四，指针表达式

一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。

```c
int a,b;
int array[10];
int *pa;
pa=&a; //&a 是一个指针表达式。
Int **ptr=&pa; //&pa 也是一个指针表达式。
*ptr=&b; //*ptr 和&b 都是指针表达式。
pa=array;
pa++; //这也是指针表达式。

char *arr[20];
char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式
char *str;
str=*parr; //*parr 是指针表达式
str=*(parr+1); //*(parr+1)是指针表达式
str=*(parr+2); //*(parr+2)是指针表达式
```

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在实例中，`&a` 不是一个左值，因为它还没有占据明确的内存。`*ptr` 是一个左值，因为 `*ptr` 这个指针已经占据了内存，其实 `*ptr` 就是指针 `pa`，既然 `pa` 已经在内存中有了自己的位置，那么 `*ptr` 当然也有了自己的位置。

## 五，数组和指针的关系

数组的数组名其实可以看作一个指针。

```c
int array[10]={0,1,2,3,4,5,6,7,8,9},value;
value=array[0]; //也可写成：value=*array;
value=array[3]; //也可写成：value=*(array+3);
value=array[4]; //也可写成：value=*(array+4);
```

一般而言数组名 `array` 代表数组本身，类型是 `int[10]`，但如果把 `array` 看做指针的话，它指向数组的第 0 个单元，类型是 `int *`，所指向的类型是数组单元的类型即 `int`。同理，`array+3` 是一个指向数组第 3 个单元的指针，所以 `*(array+3)` 等于 3。

**实例：**

```c
char *str[3]={
    "Hello,thisisasample!",
    "Hi,goodmorning.",
    "Helloworld"
};
char s[80];
strcpy(s,str[0]); //也可写成strcpy(s,*str);
printf("s=%s\n", s);
// 输出 ：Hello,thisisasample!

strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));
printf("s=%s\n", s);
// 输出 ：Hi,goodmorning.

strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));
printf("s=%s\n", s);
// 输出 ：Helloworld
```

C 库函数 `char *strcpy(char *dest, const char *src)` 把 `src` 所指向的字符串复制到 `dest`。
需要注意的是如果目标数组 `dest` 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。

`str` 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 `str` 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 `char **`，它指向的类型是 `char *`。

`*str` 也是一个指针，它的类型是 `char *`，它所指向的类型是 `char`，它指向的地址是字符串 `Hello,thisisasample!` 的第一个字符的地址，即 `H` 的地址。

注意:字符串相当于是一个数组, 在内存中以数组的形式储存, 只不过字符串是一个数组常量, 内容不可改变,且只能是右值，如果看成指针的话, 他即是常量指针, 也是指针常量。

`str+1` 也是一个指针，它指向数组的第 1 号单元，它的类型是 `char**`，它指向的类型是 `char*`。
`*(str+1)` 也是一个指针，它的类型是 `char*`，它所指向的类型是 `char`，它指向 `Hi,goodmorning.` 的第一个字符 `H`。

**数组**

声明了一个数组 `TYPE array[n]`，则数组名称 `array` 就有了两重含义：

* 第一，它代表整个数组，它的类型是 `TYPE[n]`；
* 第二，它是一个常量指针，该指针的类型是 `TYPE*`，该指针指向的类型是 `TYPE`，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 `array++` 的表达式是错误的。

在不同的表达式中数组名 `array` 可以扮演不同的角色。在表达式 `sizeof(array)` 中，数组名 `array` 代表数组本身，故这时 `sizeof` 函数测出的是整个数组的大小。

在表达式 `*array` 中，`array` 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。`sizeof(*array)` 测出的是数组单元的大小。

表达式 `array+n`（其中n=0，1，2，.....）中，`array` 扮演的是指针，故 `array+n` 的结果是一个指针，它的类型是 `TYPE *`，它指向的类型是 `TYPE`，它指向数组第 n 号单元。故 `sizeof(array+n)`测出的是指针类型的大小。在 32 位程序中结果是 4。

实例：

```
int array[10];
int (*ptr)[10];
ptr=&array;：
```

`ptr` 是一个指针，它的类型是 `int(*)[10]`，他指向的类型是 `int[10]` ，我们用整个数组的首地址来初始化它。在语句 `ptr=&array`中，`array` 代表数组本身。

函数 `sizeof(指针名称)` 测出的是指针自身类型的大小。

```c
int(*ptr)[10];
```

则在 32 位程序中，有：

```c
sizeof(int(*)[10])==4
sizeof(int[10])==40
sizeof(ptr)==4
```

实际上，`sizeof(对象)` 测出的都是对象自身的类型的大小，而不是别的什么类型的大小。

## 六，指针和结构类型的关系

实例：

声明一个指向结构类型对象的指针。

```c
struct MyStruct
{
    int a;
    int b;
    int c;
};
struct MyStruct ss={20,30,40};
//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。
struct MyStruct *ptr=&ss;

//声明了一个指向结构对象ss 的指针。它的类型是
//MyStruct *,它指向的类型是MyStruct。

int *pstr=(int*)&ss;
//声明了一个指向结构对象ss 的指针。但是pstr 和
//它被指向的类型ptr 是不同的。
```

通过指针 `ptr` 来访问 `ss` 的三个成员变量：（推荐）

```c
ptr->a; //指向运算符，或者 (*ptr).a ,建议使用前者
ptr->b;
ptr->c;
```

通过指针 `pstr` 来访问 `ss` 的三个成员变量：（不推荐）

```c
*pstr； //访问了ss 的成员a。
*(pstr+1); //访问了ss 的成员b。
*(pstr+2) //访问了ss 的成员c。
```

**验证不正规**

将结构体换成数组

```c
int array[3]={35,56,37};
int *pa=array;
//通过指针pa 访问数组array 的三个单元的方法是：
*pa; //访问了第0 号单元
*(pa+1); //访问了第1 号单元
*(pa+2); //访问了第2 号单元
```

所有的 `C/C++` 编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个 `填充字节`，这就导致各个成员之间可能会有若干个字节的空隙。

所以，即使 `*pstr` 访问到了结构对象 `ss` 的第一个成员变量 `a`，也不能保证 `*(pstr+1)` 就一定能访问到结构成员 `b`。因为成员 `a` 和成员 `b` 之间可能会有若干填充字节，可能 `*(pstr+1)` 就正好访问到了这些填充字节。

## 七，指针和函数的关系

可以把一个指针声明成为一个指向函数的指针。

```c
int fun1(char *,int);
int (*pfun1)(char *,int);
pfun1=fun1;
int a=(*pfun1)("abcdefg",7); //通过函数指针调用函数。
```

可以把指针作为函数的形参。在函数调用语句中，可以用指针表达式来作为实参。

```c
int fun(char *);
inta;
char str[]="abcdefghijklmn";
a=fun(str);
int fun(char *s)
{
    int num=0;
    for(int i=0;;)
    {
        num+=*s;s++;
    }
    return num;
}
```

这个例子中的函数 `fun` 统计一个字符串中各个字符的 `ASCII` 码值之和。数组的名字也是一个指针。在函数调用中，当把 `str` 作为实参传递给形参 s 后，实际是把 `str` 的值传递给了 s，s 所指向的地址就和 `str` 所指向的地址一致，但是 `str` 和 s 各自占用各自的存储空间。在函数体内对 s 进行自加 1 运算，并不意味着同时对 `str` 进行了自加 1 运算。

## 八，指针类型转换

当初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。

```c
float f=12.3;
float *fptr=&f;
int *p;
```

**指针p指向实数f**

```c
//强制类型转换
p=(int*)&f;
```

如果有一个指针 `p`，我们需要把它的类型和所指向的类型改为 `TYPE *TYPE`， 那么语法格式是：`(TYPE *)p`

这样强制类型转换的结果是一个新指针，该新指针的类型是 `TYPE *`，它指向的类型是 `TYPE`，它指向的地址就是原指针指向的地址。 而原来的指针 `p` 的一切属性都没有被修改。（切记）

一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换:

函数 fun 的作用是把一个整数的四个字节的顺序来个颠倒:
注意这是一个 32 位程序，故 `int` 类型占了四个字节，`char` 类型占一个字节。

```c
void fun(char*);

int a=125,b;
fun((char*)&a);

void fun(char*s)
{
    char c;
    c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;
    c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;
}
```











[C 指针详解](https://www.runoob.com/w3cnote/c-pointer-detail.html)