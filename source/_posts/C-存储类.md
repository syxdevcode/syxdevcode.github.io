---
title: C-存储类
date: 2021-05-19 08:52:20
tags:
- C语言
- VSCode
- MingGW64
categories: C语言
---

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：

* **auto** 是局部变量的默认存储类, 限定变量只能在函数内部使用；
* **register** 代表了寄存器变量，不在内存中使用；
* **static** 是全局变量的默认存储类，表示变量在程序生命周期内可见；
* **extern** 表示全局变量，即对程序内所有文件可见，类似于Java中的public关键字；

<!--more-->
## auto存储类

auto 存储类是所有局部变量默认的存储类。auto 只能用在函数内，只能修饰局部变量。

定义两个带有相同存储类的变量:

```c
{
   int mount;
   auto int month;
}
```

## register存储类

`register` 存储类用于定义存储在寄存器中而不是 `RAM` 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 `&` 运算符（因为它没有内存位置）。

`Register` 变量：动态和静态变量都是存放在内存中，程序中遇到该值时用控制器发指令将变量的值送到运算器中，需要存数再保存到内存中。如果频繁使用一个变量，比如一个函数体内的多次循环每次都引用该局部变量，我们则可以把局部变量的值放到CPU的寄存器中，叫寄存器变量。不需要多次到内存中存取提高效率。但是，只能局部自动变量和形参可以做寄存器变量。在函数调用时占用一些寄存器，函数结束时释放。不同系统对`register`要求也不一样，比如对定义`register`变量个数，数据类型等限制，有的默认为自动变量处理。所以在程序一般也不用。

```c
{
   register int  miles;
}
```

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 `register` 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

实例 register.c

```c
#include <stdio.h>
#include <time.h>

#define TIME 1000000000
int m, n = TIME; /* 全局变量 */

int main(void)
{   
    time_t start, stop;
    register int a, b = TIME; /* 寄存器变量 */
    int x, y = TIME;          /* 一般变量   */

    time(&start);
    for (a = 0; a < b; a++);
    time(&stop);
    printf("寄存器变量用时: %ld 秒\n", stop - start);
    
    time(&start);
    for (x = 0; x < y; x++);
    time(&stop);
    printf("一般变量用时: %ld 秒\n", stop - start);
    
    time(&start);
    for (m = 0; m < n; m++);
    time(&stop);
    printf("全局变量用时: %ld 秒\n", stop - start);

    return 0;
}
```

## static存储类

`static` 存储类指示编译器，在程序的生命周期内保持局部变量的存在，不需要在每次进入和离开作用域时进行创建和销毁。因此，使用 `static` 修饰局部变量可以在函数调用之前，保持局部变量的值。

`static` 修饰符也可以应用于全局变量。当 `static` 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 `static` 变量或方法，可以被任何在**同一个文件**中函数或方法调用。

以下实例演示了 `static` 修饰全局变量和局部变量的应用：

```c
#include <stdio.h>
 
/* 函数声明 */
void func1(void);
 
static int count=10;        /* 全局变量 - static 是默认的 */
 
int main()
{
  while (count--) {
      func1();
  }
  return 0;
}
 
void func1(void)
{
 /* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
 * 每次调用函数 'func1' 'thingy' 值不会被重置。
 */
  static int thingy=5;
  thingy++;
  printf(" thingy 为 %d ， count 为 %d\n", thingy, count);
}
```

结果：

```c
 thingy 为 6 ， count 为 9
 thingy 为 7 ， count 为 8
 thingy 为 8 ， count 为 7
 thingy 为 9 ， count 为 6
 thingy 为 10 ， count 为 5
 thingy 为 11 ， count 为 4
 thingy 为 12 ， count 为 3
 thingy 为 13 ， count 为 2
 thingy 为 14 ， count 为 1
 thingy 为 15 ， count 为 0
```

## extern存储类

`extern` 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当使用 `extern` 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 `extern` 来得到已定义的变量或函数的引用。可以理解成，`extern` 是用来在另一个文件中声明一个全局变量或函数。

`extern` 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

第一个文件：main.c

实例

```c
#include <stdio.h>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
```

第二个文件：support.c

实例

```c
#include <stdio.h>
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
```

在这里，第二个文件中的 `extern` 关键字用于声明已经在第一个文件 main.c 中定义的 count。

编译，执行：

```c
PS E:\git\C> gcc main.c support.c
PS E:\git\C> ./a
count is 5
```

## C中全局变量、局部变量、静态全局变量、静态局部变量

**从作用域看：**

* 1、全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件，使用时，需要用`extern` 关键字再次声明这个全局变量。
* 2、静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
* 3、局部变量也只有局部作用域，它是自动对象（`auto`），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
* 4、静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被`static`关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

**从分配内存空间看：**

* 1、全局变量，静态局部变量，静态全局变量都在`静态存储区`分配空间，而局部变量在栈里分配空间
* 2、全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。
 **(1)**静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。
 **(2)**变量用`static`告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。
从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此 `static` 这个说明符在不同的地方所起的作用是不同的。应予以注意。

**Tips:**

* A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；
* B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；
* C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；
* D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用`static`变量(这样的函数被称为：带 `内部存储器` 功能的的函数)
* E.函数中必须要使用`static`变量情况:比如当某函数的返回值为指针类型时，则必须是`static`的局部变量的地址作为返回值，若为`auto`类型，则返回为错指针。

[C 存储类](https://www.runoob.com/cprogramming/c-storage-classes.html)