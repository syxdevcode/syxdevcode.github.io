---
title: TCP传输控制协议
date: 2020-09-15 15:05:11
tags:
- TCP协议
- 计算机基础
categories:
- TCP协议
---

## TCP首部格式

![tcp2.png](/img/tcp2.png)

**Source Port** ：源端口，16位。
**Destination Port**：目的端口，16位。
**Sequence Number**：发送数据包中的第一个字节的序列号，32位。
**Acknowledgment Number**:确认序列号，32位。
**Data Offset**：是数据偏移，4位，该字段的值是TCP首部（包括选项）长度除以4。
**标志位**：6位，URG表示 `Urgent Pointer` 字段有意义：
`ACK` 表示 `Acknowledgment Number` 字段有意义
`PSH` 表示 `Push` 功能，RST表示复位TCP连接
`SYN` 表示 `SYN` 报文（在建立TCP连接的时候使用）
`FIN` 表示没有数据需要发送了（在关闭TCP连接的时候使用）
`Window` 表示接收缓冲区的空闲空间，16位，用来告诉TCP连接对端自己能够接收的最大数据长度。
**Checksum**：校验和，16位。
**Urgent Pointers**：紧急指针，16位，只有URG标志位被设置时该字段才有意义，表示紧急数据相对序列号（Sequence Number字段的值）的偏移。

## 工作方式

## 建立连接

![tcp1](/img/tcp1.gif)

TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出 `SYN` 连接请求后，等待对方回答 `SYN+ACK`，并最终对对方的 `SYN` 执行 `ACK` 确认。

TCP三次握手的过程如下：

* 客户端发送 `SYN（SEQ=x）` 报文给服务器端，进入 `SYN_SEND` 状态。
* 服务器端收到 `SYN` 报文，回应一个 `SYN （SEQ=y）ACK（ACK=x+1）` 报文，进入 `SYN_RECV` 状态。
* 客户端收到服务器端的 `SYN` 报文，回应一个 `ACK（ACK=y+1）` 报文，进入 `Established(已获确认的)` 状态。

三次握手完成，TCP客户端和服务器端成功地建立连接，可以开始传输数据了。

### 连接终止

![tcp3.gif](/img/tcp3.gif)

建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的 `半关闭`（`half-close`）造成的。

* （1）某个应用进程首先调用 `close`，称该端执行 `主动关闭（active close）`。该端的TCP于是发送一个 `FIN` 分节，表示数据发送完毕。
* （2） 接收到这个 `FIN` 的对端执行 `被动关闭（passive close）`，这个 `FIN` 由TCP确认。

注意：`FIN` 的接收也作为一个文件结束符（`end-of-file`）传递给接收端应用进程，放在已排队等候该应用进程接收的任何其他数据之后，因为，`FIN` 的接收意味着接收端应用进程在相应连接上再无额外数据可接收。
* （3） 一段时间后，接收到这个文件结束符的应用进程将调用 `close` 关闭它的套接字。这导致它的 `TCP` 也发送一个 `FIN`。
* （4） 接收这个最终 `FIN` 的原发送端TCP（即执行主动关闭的那一端）确认这个 `FIN`。

既然每个方向都需要一个`FIN`和一个 `ACK` ，因此通常需要4个分节。

注意：
（1） `通常` 是指，某些情况下，步骤1的 `FIN` 随数据一起发送，另外，步骤2和步骤3发送的分节都出自执行被动关闭那一端，有可能被合并成一个分节。
（2） 在 步骤2 与 步骤3 之间，从执行 被动关闭一端 到 执行主动关闭一端 流动数据是可能的，这称为 `半关闭`（half-close）。
（3） 当一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止时，所有打开的描述符都被关闭，这也导致仍然打开的任何TCP连接上也发出一个`FIN`。
无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0却由服务器执行主动关闭。

## TCP重连

![tcp重连.png](/img/tcp重连.png)

四元组：源IP地址、目的IP地址、源端口、目的端口
五元组：源IP地址、目的IP地址、协议号、源端口、目的端口
七元组：源IP地址、目的IP地址、协议号、源端口、目的端口、服务类型、接口索引