---
title: Socket网络编程
date: 2021-09-13 17:26:39
tags:
- TCP协议
- UDP协议
- 计算机基础
- 网络基础
- 网络编程
- IP网络
- Socket
- Ethernet
categories:
- Socket
---

## SOCKET简介

Socket英文原义是 孔 或 插座。作为进程通信机制，取后一种意思。通常也称作 `套接字`，用于描述IP地址和端口，是一个通信链的句柄（其实就是两个程序通信用的）。

以一个电话网为例：

* (1)， 电话的通话双方相当于相互通信的2个程序，电话号码就是ip地址。
* (2)，任何用户在通话之前，首先要占有一部电话机，相当于申请一个Socket；同时要知道对方的号码，相当于对方有一个固定的Socket。
* (3)，然后向对方拨号呼叫，相当于发出连接请求。对方假如在场并空闲，拿起电话话筒，双方就可以正式通话，相当于连接成功。
* (4)，双方通话的过程，是一方向电话机发出信号和对方从电话机接收信号的过程，相当于向Socket发送数据和从Socket接收数据。
* (5)，通话结束后，一方挂起电话机相当于关闭Socket，撤销连接。

## 套接字分类

为了满足不同程序对通信质量和性能的要求，一般的网络系统都提供了以下3种不同类型的套接字，以供用户在设计程序时根据不同需要来选择：

* **流式套接字（SOCK_STREAM）**：提供了一种可靠的、面向连接的双向数据传输服务。实现了数据无差错，无重复的发送，内设流量控制，被传输的数据被看做无记录边界的字节流。在TCP/IP协议簇中，使用TCP实现字节流的传输，当用户要发送大批量数据，或对数据传输的可靠性有较高要求时使用流式套接字。
* **数据报套接字（SOCK_DGRAM）**：提供了一种无连接、不可靠的双向数据传输服务。数据以独立的包形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端数据按发送顺序接收。在TCP/IP协议簇中，使用UDP实现数据报套接字。
* **原始套接字（SOCK_RAW）**：该套接字允许对较低层协议（如IP或ICMP）进行直接访问。一般用于对TCP/IP核心协议的网络编程。

## SOCKET概念

### 端口

&emsp;&emsp;在Internet上有很多这样的主机，这些主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务（应用程序），因此，在网络协议中使用端口号识别主机上不同的进程。

例如：http使用80端口，FTP使用21端口，SSH 使用 22 端口，DNS 使用 53端口，TelNet使用23端口。

### 协议

#### TCP

&emsp;&emsp;TCP 是一种面向连接的、可靠的，基于字节流的传输层通信协议。为两台主机提供高可靠性的数据通信服务。它可以将源主机的数据无差错地传输到目标主机。当有数据要发送时，对应用进程送来的数据进行分片，以适合于在网络层中传输；当接收到网络层传来的分组时，它要对收到的分组进行确认，还要对丢失的分组设置超时重发等。为此TCP需要增加额外的许多开销，以便在数据传输过程中进行一些必要的控制，确保数据的可靠传输。因此，TCP传输的效率比较低。

**TCP的工作过程：**

![1033738-20161224160027854-1956600516.png](/img/1033738-20161224160027854-1956600516.png)

* **第一次握手**：建立连接时，客户端发送SYN包（SEQ=x）到服务器，并进入SYN_SEND状态，等待服务器确认。
* **第二次握手**：服务器收到SYN包，必须确认客户的SYN（ACK=x+1），同时自己也发送一个SYN包（SEQ=y），即 `SYN+ACK` 包，此时服务器进入 `SYN_RECV` 状态。
* **第三次握手**：客户端收到服务器的 `SYN+ACK` 包，向服务器发送确认包 `ACK(ACK=y+1)`，此包发送完毕，客户端和服务器进入 `Established` 状态，完成三次握手。

**传输数据:**

&emsp;&emsp;一旦通信双方建立了TCP连接，连接中的任何一方都能向对方发送数据和接收对方发来的数据。TCP协议负责把用户数据（字节流）按一定的格式和长度组成多个数据报进行发送，并在接收到数据报之后按分解顺序重新组装和恢复用户数据。
利用TCP传输数据时，数据是以字节流的形式进行传输的。

**连接的终止:**

建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（`half-close`）造成的。具体过程如图所示：

![1033738-20161224161001261-2026303529.png](/img/1033738-20161224161001261-2026303529.png)

**TCP的主要特点:**

* (1) 是面向连接的协议。
* (2) 端到端的通信。每个TCP连接只能有两个端点，而且只能一对一通信，不能一点对多点直接通信。
* (3) 高可靠性。通过TCP连接传送的数据，能保证数据无差错、不丢失、不重复地准确到达接收方，并且保证各数据到达的顺序与其发出的顺序相同。
* (4) 全双工方式传输。
* (5) 数据以字节流的方式传输。
* (6) 传输的数据无消息边界。

**同步与异步:**

&emsp;&emsp;同步工作方式是指利用TCP编写的程序执行到监听或接收语句时，在未完成工作（侦听到连接请求或收到对方发来的数据）前不再继续往下执行，线程处于阻塞状态，直到该语句完成相应的工作后才继续执行下一条语句。
异步工作方式是指程序执行到监听或接收语句时，不论工作是否完成，都会继续往下执行。

#### UDP

&emsp;&emsp;UDP是一种简单的、面向数据报的无连接的协议，提供的是不一定可靠的传输服务。所谓 `无连接` 是指在正式通信前不必与对方先建立连接，不管对方状态如何都直接发送过去。这与发手机短信非常相似，只要知道对方的手机号就可以了，不要考虑对方手机处于什么状态。UDP虽然不能保证数据传输的可靠性，但数据传输的效率较高。

**UDP与TCP的区别:**

* **(1) UDP可靠性不如TCP**

&emsp;&emsp;TCP包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其他信息，否则将一直等待直到收到确认信息为止。与TCP不同，UDP并不提供数据传送的保证机制。如果在从发送方到接收方的传递过程中出现数据报的丢失，协议本身并不能做出任何检测或提示。因此，通常人们把UDP称为不可靠的传输协议。

* **(2) UDP不能保证有序传输**

UDP不能确保数据的发送和接收顺序。对于突发性的数据报，有可能会乱序。

**UDP的优势:**

* **(1) UDP速度比TCP快**

&emsp;&emsp;由于UDP不需要先与对方建立连接，也不需要传输确认，因此其数据传输速度比TCP快得多。对于强调传输性能而不是传输完整性的应用（比如网络音频播放、视频点播和网络会议等），使用UDP比较合适，因为它的传输速度快，使通过网络播放的视频音质好、画面清晰。

* **(2) UDP有消息边界**

&emsp;&emsp;发送方UDP对应用程序交下来的报文，在添加首部后就向下直接交付给IP层。既不拆分，也不合并，而是保留这些报文的边界。使用UDP不需要考虑消息边界问题，这样使得UDP编程相比TCP，在对接收到的数据的处理方面要方便的多。在程序员看来，UDP套接字使用比TCP简单。UDP的这一特征也说明了它是一种面向报文的传输协议。

* **(3) UDP可以一对多传输**

&emsp;&emsp;由于传输数据不建立连接，也就不需要维护连接状态（包括收发状态等），因此一台服务器可以同时向多个客户端传输相同的消息。利用UDP可以使用广播或组播的方式同时向子网上的所有客户进程发送消息，这一点也比TCP方便。

其中，速度快是UDP的首要优势。

&emsp;&emsp;由于TCP协议中植入了各种安全保障功能，在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重影响。反观UDP，由于抛弃了信息可靠传输机制，将安全和排序等功能移交给上层应用完成，极大地降低了执行时间，使速度得到了保证。简而言之，UDP的 `理念` 就是 `不顾一切，只为更快地发送数据`。

![1033738-20161224175130214-655760387.png](/img/1033738-20161224175130214-655760387.png)

## socket一般应用模式

![1033738-20161222105102807-1112314980.png](/img/1033738-20161222105102807-1112314980.png)

## SOCKET通信基本流程图

![1033738-20161222110415651-1974763936.png](/img/1033738-20161222110415651-1974763936.png)

根据socket通信基本流程图，总结通信的基本步骤：

**服务器端：**

* 第一步：创建一个用于监听连接的Socket对像；
* 第二步：用指定的端口号和服务器的ip建立一个EndPoint对像；
* 第三步：用socket对像的Bind()方法绑定EndPoint；
* 第四步：用socket对像的Listen()方法开始监听；
* 第五步：接收到客户端的连接，用socket对像的Accept()方法创建一个新的用于和客户端进行通信的socket对像;
* 第六步：通信结束后一定记得关闭socket;

**客户端：**

* 第一步：建立一个Socket对像；
* 第二步：用指定的端口号和服务器的ip建立一个EndPoint对像；
* 第三步：用socket对像的Connect()方法以上面建立的EndPoint对像做为参数，向服务器发出连接请求；
* 第四步：如果连接成功，就用socket对像的Send()方法向服务器发送信息；
* 第五步：用socket对像的Receive()方法接受服务器发来的信息 ;
* 第六步：通信结束后一定记得关闭socket；

参考：

[C#网络编程二：Socket编程](https://www.cnblogs.com/dotnet261010/p/6211900.html)
